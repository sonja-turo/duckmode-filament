var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/@kurkle/color/dist/color.esm.js
function round(v) {
  return v + 0.5 | 0;
}
var lim = (v, l2, h) => Math.max(Math.min(v, h), l2);
function p2b(v) {
  return lim(round(v * 2.55), 0, 255);
}
function n2b(v) {
  return lim(round(v * 255), 0, 255);
}
function b2n(v) {
  return lim(round(v / 2.55) / 100, 0, 1);
}
function n2p(v) {
  return lim(round(v * 100), 0, 100);
}
var map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
var hex = [..."0123456789ABCDEF"];
var h1 = (b) => hex[b & 15];
var h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
var eq = (b) => (b & 240) >> 4 === (b & 15);
var isShort = (v) => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
function hexParse(str) {
  var len = str.length;
  var ret;
  if (str[0] === "#") {
    if (len === 4 || len === 5) {
      ret = {
        r: 255 & map$1[str[1]] * 17,
        g: 255 & map$1[str[2]] * 17,
        b: 255 & map$1[str[3]] * 17,
        a: len === 5 ? map$1[str[4]] * 17 : 255
      };
    } else if (len === 7 || len === 9) {
      ret = {
        r: map$1[str[1]] << 4 | map$1[str[2]],
        g: map$1[str[3]] << 4 | map$1[str[4]],
        b: map$1[str[5]] << 4 | map$1[str[6]],
        a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
      };
    }
  }
  return ret;
}
var alpha = (a, f) => a < 255 ? f(a) : "";
function hexString(v) {
  var f = isShort(v) ? h1 : h2;
  return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
}
var HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h, s2, l2) {
  const a = s2 * Math.min(l2, 1 - l2);
  const f = (n2, k = (n2 + h / 30) % 12) => l2 - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  return [f(0), f(8), f(4)];
}
function hsv2rgbn(h, s2, v) {
  const f = (n2, k = (n2 + h / 60) % 6) => v - v * s2 * Math.max(Math.min(k, 4 - k, 1), 0);
  return [f(5), f(3), f(1)];
}
function hwb2rgbn(h, w, b) {
  const rgb = hsl2rgbn(h, 1, 0.5);
  let i;
  if (w + b > 1) {
    i = 1 / (w + b);
    w *= i;
    b *= i;
  }
  for (i = 0; i < 3; i++) {
    rgb[i] *= 1 - w - b;
    rgb[i] += w;
  }
  return rgb;
}
function hueValue(r, g, b, d, max) {
  if (r === max) {
    return (g - b) / d + (g < b ? 6 : 0);
  }
  if (g === max) {
    return (b - r) / d + 2;
  }
  return (r - g) / d + 4;
}
function rgb2hsl(v) {
  const range = 255;
  const r = v.r / range;
  const g = v.g / range;
  const b = v.b / range;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l2 = (max + min) / 2;
  let h, s2, d;
  if (max !== min) {
    d = max - min;
    s2 = l2 > 0.5 ? d / (2 - max - min) : d / (max + min);
    h = hueValue(r, g, b, d, max);
    h = h * 60 + 0.5;
  }
  return [h | 0, s2 || 0, l2];
}
function calln(f, a, b, c) {
  return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
}
function hsl2rgb(h, s2, l2) {
  return calln(hsl2rgbn, h, s2, l2);
}
function hwb2rgb(h, w, b) {
  return calln(hwb2rgbn, h, w, b);
}
function hsv2rgb(h, s2, v) {
  return calln(hsv2rgbn, h, s2, v);
}
function hue(h) {
  return (h % 360 + 360) % 360;
}
function hueParse(str) {
  const m = HUE_RE.exec(str);
  let a = 255;
  let v;
  if (!m) {
    return;
  }
  if (m[5] !== v) {
    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
  }
  const h = hue(+m[2]);
  const p1 = +m[3] / 100;
  const p2 = +m[4] / 100;
  if (m[1] === "hwb") {
    v = hwb2rgb(h, p1, p2);
  } else if (m[1] === "hsv") {
    v = hsv2rgb(h, p1, p2);
  } else {
    v = hsl2rgb(h, p1, p2);
  }
  return {
    r: v[0],
    g: v[1],
    b: v[2],
    a
  };
}
function rotate(v, deg) {
  var h = rgb2hsl(v);
  h[0] = hue(h[0] + deg);
  h = hsl2rgb(h);
  v.r = h[0];
  v.g = h[1];
  v.b = h[2];
}
function hslString(v) {
  if (!v) {
    return;
  }
  const a = rgb2hsl(v);
  const h = a[0];
  const s2 = n2p(a[1]);
  const l2 = n2p(a[2]);
  return v.a < 255 ? `hsla(${h}, ${s2}%, ${l2}%, ${b2n(v.a)})` : `hsl(${h}, ${s2}%, ${l2}%)`;
}
var map = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
};
var names$1 = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function unpack() {
  const unpacked = {};
  const keys = Object.keys(names$1);
  const tkeys = Object.keys(map);
  let i, j, k, ok, nk;
  for (i = 0; i < keys.length; i++) {
    ok = nk = keys[i];
    for (j = 0; j < tkeys.length; j++) {
      k = tkeys[j];
      nk = nk.replace(k, map[k]);
    }
    k = parseInt(names$1[ok], 16);
    unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
  }
  return unpacked;
}
var names;
function nameParse(str) {
  if (!names) {
    names = unpack();
    names.transparent = [0, 0, 0, 0];
  }
  const a = names[str.toLowerCase()];
  return a && {
    r: a[0],
    g: a[1],
    b: a[2],
    a: a.length === 4 ? a[3] : 255
  };
}
var RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
  const m = RGB_RE.exec(str);
  let a = 255;
  let r, g, b;
  if (!m) {
    return;
  }
  if (m[7] !== r) {
    const v = +m[7];
    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
  }
  r = +m[1];
  g = +m[3];
  b = +m[5];
  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
  return {
    r,
    g,
    b,
    a
  };
}
function rgbString(v) {
  return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
}
var to = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
var from = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
function interpolate(rgb1, rgb2, t) {
  const r = from(b2n(rgb1.r));
  const g = from(b2n(rgb1.g));
  const b = from(b2n(rgb1.b));
  return {
    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
    a: rgb1.a + t * (rgb2.a - rgb1.a)
  };
}
function modHSL(v, i, ratio) {
  if (v) {
    let tmp = rgb2hsl(v);
    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
    tmp = hsl2rgb(tmp);
    v.r = tmp[0];
    v.g = tmp[1];
    v.b = tmp[2];
  }
}
function clone(v, proto) {
  return v ? Object.assign(proto || {}, v) : v;
}
function fromObject(input) {
  var v = { r: 0, g: 0, b: 0, a: 255 };
  if (Array.isArray(input)) {
    if (input.length >= 3) {
      v = { r: input[0], g: input[1], b: input[2], a: 255 };
      if (input.length > 3) {
        v.a = n2b(input[3]);
      }
    }
  } else {
    v = clone(input, { r: 0, g: 0, b: 0, a: 1 });
    v.a = n2b(v.a);
  }
  return v;
}
function functionParse(str) {
  if (str.charAt(0) === "r") {
    return rgbParse(str);
  }
  return hueParse(str);
}
var Color = class {
  constructor(input) {
    if (input instanceof Color) {
      return input;
    }
    const type = typeof input;
    let v;
    if (type === "object") {
      v = fromObject(input);
    } else if (type === "string") {
      v = hexParse(input) || nameParse(input) || functionParse(input);
    }
    this._rgb = v;
    this._valid = !!v;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var v = clone(this._rgb);
    if (v) {
      v.a = b2n(v.a);
    }
    return v;
  }
  set rgb(obj) {
    this._rgb = fromObject(obj);
  }
  rgbString() {
    return this._valid ? rgbString(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? hexString(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? hslString(this._rgb) : void 0;
  }
  mix(color3, weight) {
    if (color3) {
      const c1 = this.rgb;
      const c2 = color3.rgb;
      let w2;
      const p = weight === w2 ? 0.5 : weight;
      const w = 2 * p - 1;
      const a = c1.a - c2.a;
      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
      w2 = 1 - w1;
      c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
      c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
      c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
      c1.a = p * c1.a + (1 - p) * c2.a;
      this.rgb = c1;
    }
    return this;
  }
  interpolate(color3, t) {
    if (color3) {
      this._rgb = interpolate(this._rgb, color3._rgb, t);
    }
    return this;
  }
  clone() {
    return new Color(this.rgb);
  }
  alpha(a) {
    this._rgb.a = n2b(a);
    return this;
  }
  clearer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 - ratio;
    return this;
  }
  greyscale() {
    const rgb = this._rgb;
    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
    rgb.r = rgb.g = rgb.b = val;
    return this;
  }
  opaquer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 + ratio;
    return this;
  }
  negate() {
    const v = this._rgb;
    v.r = 255 - v.r;
    v.g = 255 - v.g;
    v.b = 255 - v.b;
    return this;
  }
  lighten(ratio) {
    modHSL(this._rgb, 2, ratio);
    return this;
  }
  darken(ratio) {
    modHSL(this._rgb, 2, -ratio);
    return this;
  }
  saturate(ratio) {
    modHSL(this._rgb, 1, ratio);
    return this;
  }
  desaturate(ratio) {
    modHSL(this._rgb, 1, -ratio);
    return this;
  }
  rotate(deg) {
    rotate(this._rgb, deg);
    return this;
  }
};

// node_modules/chart.js/dist/chunks/helpers.segment.js
function noop() {
}
var uid = (() => {
  let id = 0;
  return () => id++;
})();
function isNullOrUndef(value) {
  return value === null || typeof value === "undefined";
}
function isArray(value) {
  if (Array.isArray && Array.isArray(value)) {
    return true;
  }
  const type = Object.prototype.toString.call(value);
  if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
    return true;
  }
  return false;
}
function isObject(value) {
  return value !== null && Object.prototype.toString.call(value) === "[object Object]";
}
function isNumberFinite(value) {
  return (typeof value === "number" || value instanceof Number) && isFinite(+value);
}
function finiteOrDefault(value, defaultValue) {
  return isNumberFinite(value) ? value : defaultValue;
}
function valueOrDefault(value, defaultValue) {
  return typeof value === "undefined" ? defaultValue : value;
}
var toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : +value / dimension;
var toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
function callback(fn, args, thisArg) {
  if (fn && typeof fn.call === "function") {
    return fn.apply(thisArg, args);
  }
}
function each(loopable, fn, thisArg, reverse) {
  let i, len, keys;
  if (isArray(loopable)) {
    len = loopable.length;
    if (reverse) {
      for (i = len - 1; i >= 0; i--) {
        fn.call(thisArg, loopable[i], i);
      }
    } else {
      for (i = 0; i < len; i++) {
        fn.call(thisArg, loopable[i], i);
      }
    }
  } else if (isObject(loopable)) {
    keys = Object.keys(loopable);
    len = keys.length;
    for (i = 0; i < len; i++) {
      fn.call(thisArg, loopable[keys[i]], keys[i]);
    }
  }
}
function _elementsEqual(a0, a1) {
  let i, ilen, v0, v1;
  if (!a0 || !a1 || a0.length !== a1.length) {
    return false;
  }
  for (i = 0, ilen = a0.length; i < ilen; ++i) {
    v0 = a0[i];
    v1 = a1[i];
    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
      return false;
    }
  }
  return true;
}
function clone2(source) {
  if (isArray(source)) {
    return source.map(clone2);
  }
  if (isObject(source)) {
    const target = /* @__PURE__ */ Object.create(null);
    const keys = Object.keys(source);
    const klen = keys.length;
    let k = 0;
    for (; k < klen; ++k) {
      target[keys[k]] = clone2(source[keys[k]]);
    }
    return target;
  }
  return source;
}
function isValidKey(key) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(key) === -1;
}
function _merger(key, target, source, options) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    merge(tval, sval, options);
  } else {
    target[key] = clone2(sval);
  }
}
function merge(target, source, options) {
  const sources = isArray(source) ? source : [
    source
  ];
  const ilen = sources.length;
  if (!isObject(target)) {
    return target;
  }
  options = options || {};
  const merger = options.merger || _merger;
  let current;
  for (let i = 0; i < ilen; ++i) {
    current = sources[i];
    if (!isObject(current)) {
      continue;
    }
    const keys = Object.keys(current);
    for (let k = 0, klen = keys.length; k < klen; ++k) {
      merger(keys[k], target, current, options);
    }
  }
  return target;
}
function mergeIf(target, source) {
  return merge(target, source, {
    merger: _mergerIf
  });
}
function _mergerIf(key, target, source) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    mergeIf(tval, sval);
  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
    target[key] = clone2(sval);
  }
}
var keyResolvers = {
  // Chart.helpers.core resolveObjectKey should resolve empty key to root object
  "": (v) => v,
  // default resolvers
  x: (o) => o.x,
  y: (o) => o.y
};
function _splitKey(key) {
  const parts = key.split(".");
  const keys = [];
  let tmp = "";
  for (const part of parts) {
    tmp += part;
    if (tmp.endsWith("\\")) {
      tmp = tmp.slice(0, -1) + ".";
    } else {
      keys.push(tmp);
      tmp = "";
    }
  }
  return keys;
}
function _getKeyResolver(key) {
  const keys = _splitKey(key);
  return (obj) => {
    for (const k of keys) {
      if (k === "") {
        break;
      }
      obj = obj && obj[k];
    }
    return obj;
  };
}
function resolveObjectKey(obj, key) {
  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
  return resolver(obj);
}
function _capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
var defined = (value) => typeof value !== "undefined";
var isFunction = (value) => typeof value === "function";
var setsEqual = (a, b) => {
  if (a.size !== b.size) {
    return false;
  }
  for (const item of a) {
    if (!b.has(item)) {
      return false;
    }
  }
  return true;
};
function _isClickEvent(e) {
  return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
}
var PI = Math.PI;
var TAU = 2 * PI;
var PITAU = TAU + PI;
var INFINITY = Number.POSITIVE_INFINITY;
var RAD_PER_DEG = PI / 180;
var HALF_PI = PI / 2;
var QUARTER_PI = PI / 4;
var TWO_THIRDS_PI = PI * 2 / 3;
var log10 = Math.log10;
var sign = Math.sign;
function almostEquals(x, y, epsilon) {
  return Math.abs(x - y) < epsilon;
}
function niceNum(range) {
  const roundedRange = Math.round(range);
  range = almostEquals(range, roundedRange, range / 1e3) ? roundedRange : range;
  const niceRange = Math.pow(10, Math.floor(log10(range)));
  const fraction = range / niceRange;
  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
  return niceFraction * niceRange;
}
function _factorize(value) {
  const result = [];
  const sqrt = Math.sqrt(value);
  let i;
  for (i = 1; i < sqrt; i++) {
    if (value % i === 0) {
      result.push(i);
      result.push(value / i);
    }
  }
  if (sqrt === (sqrt | 0)) {
    result.push(sqrt);
  }
  result.sort((a, b) => a - b).pop();
  return result;
}
function isNumber(n2) {
  return !isNaN(parseFloat(n2)) && isFinite(n2);
}
function almostWhole(x, epsilon) {
  const rounded = Math.round(x);
  return rounded - epsilon <= x && rounded + epsilon >= x;
}
function _setMinAndMaxByKey(array, target, property) {
  let i, ilen, value;
  for (i = 0, ilen = array.length; i < ilen; i++) {
    value = array[i][property];
    if (!isNaN(value)) {
      target.min = Math.min(target.min, value);
      target.max = Math.max(target.max, value);
    }
  }
}
function toRadians(degrees) {
  return degrees * (PI / 180);
}
function toDegrees(radians) {
  return radians * (180 / PI);
}
function _decimalPlaces(x) {
  if (!isNumberFinite(x)) {
    return;
  }
  let e = 1;
  let p = 0;
  while (Math.round(x * e) / e !== x) {
    e *= 10;
    p++;
  }
  return p;
}
function getAngleFromPoint(centrePoint, anglePoint) {
  const distanceFromXCenter = anglePoint.x - centrePoint.x;
  const distanceFromYCenter = anglePoint.y - centrePoint.y;
  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
  if (angle < -0.5 * PI) {
    angle += TAU;
  }
  return {
    angle,
    distance: radialDistanceFromCenter
  };
}
function distanceBetweenPoints(pt1, pt2) {
  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
function _normalizeAngle(a) {
  return (a % TAU + TAU) % TAU;
}
function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
  const a = _normalizeAngle(angle);
  const s2 = _normalizeAngle(start);
  const e = _normalizeAngle(end);
  const angleToStart = _normalizeAngle(s2 - a);
  const angleToEnd = _normalizeAngle(e - a);
  const startToAngle = _normalizeAngle(a - s2);
  const endToAngle = _normalizeAngle(a - e);
  return a === s2 || a === e || sameAngleIsFullCircle && s2 === e || angleToStart > angleToEnd && startToAngle < endToAngle;
}
function _limitValue(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function _int16Range(value) {
  return _limitValue(value, -32768, 32767);
}
function _isBetween(value, start, end, epsilon = 1e-6) {
  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
}
function _lookup(table, value, cmp) {
  cmp = cmp || ((index) => table[index] < value);
  let hi = table.length - 1;
  let lo = 0;
  let mid;
  while (hi - lo > 1) {
    mid = lo + hi >> 1;
    if (cmp(mid)) {
      lo = mid;
    } else {
      hi = mid;
    }
  }
  return {
    lo,
    hi
  };
}
var _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? (index) => {
  const ti = table[index][key];
  return ti < value || ti === value && table[index + 1][key] === value;
} : (index) => table[index][key] < value);
var _rlookupByKey = (table, key, value) => _lookup(table, value, (index) => table[index][key] >= value);
function _filterBetween(values, min, max) {
  let start = 0;
  let end = values.length;
  while (start < end && values[start] < min) {
    start++;
  }
  while (end > start && values[end - 1] > max) {
    end--;
  }
  return start > 0 || end < values.length ? values.slice(start, end) : values;
}
var arrayEvents = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function listenArrayEvents(array, listener) {
  if (array._chartjs) {
    array._chartjs.listeners.push(listener);
    return;
  }
  Object.defineProperty(array, "_chartjs", {
    configurable: true,
    enumerable: false,
    value: {
      listeners: [
        listener
      ]
    }
  });
  arrayEvents.forEach((key) => {
    const method = "_onData" + _capitalize(key);
    const base = array[key];
    Object.defineProperty(array, key, {
      configurable: true,
      enumerable: false,
      value(...args) {
        const res = base.apply(this, args);
        array._chartjs.listeners.forEach((object) => {
          if (typeof object[method] === "function") {
            object[method](...args);
          }
        });
        return res;
      }
    });
  });
}
function unlistenArrayEvents(array, listener) {
  const stub = array._chartjs;
  if (!stub) {
    return;
  }
  const listeners = stub.listeners;
  const index = listeners.indexOf(listener);
  if (index !== -1) {
    listeners.splice(index, 1);
  }
  if (listeners.length > 0) {
    return;
  }
  arrayEvents.forEach((key) => {
    delete array[key];
  });
  delete array._chartjs;
}
function _arrayUnique(items) {
  const set3 = new Set(items);
  if (set3.size === items.length) {
    return items;
  }
  return Array.from(set3);
}
var requestAnimFrame = function() {
  if (typeof window === "undefined") {
    return function(callback3) {
      return callback3();
    };
  }
  return window.requestAnimationFrame;
}();
function throttled(fn, thisArg) {
  let argsToUse = [];
  let ticking = false;
  return function(...args) {
    argsToUse = args;
    if (!ticking) {
      ticking = true;
      requestAnimFrame.call(window, () => {
        ticking = false;
        fn.apply(thisArg, argsToUse);
      });
    }
  };
}
function debounce(fn, delay) {
  let timeout;
  return function(...args) {
    if (delay) {
      clearTimeout(timeout);
      timeout = setTimeout(fn, delay, args);
    } else {
      fn.apply(this, args);
    }
    return delay;
  };
}
var _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
var _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
var _textX = (align, left, right, rtl) => {
  const check = rtl ? "left" : "right";
  return align === check ? right : align === "center" ? (left + right) / 2 : left;
};
var atEdge = (t) => t === 0 || t === 1;
var elasticIn = (t, s2, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s2) * TAU / p));
var elasticOut = (t, s2, p) => Math.pow(2, -10 * t) * Math.sin((t - s2) * TAU / p) + 1;
var effects = {
  linear: (t) => t,
  easeInQuad: (t) => t * t,
  easeOutQuad: (t) => -t * (t - 2),
  easeInOutQuad: (t) => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
  easeInCubic: (t) => t * t * t,
  easeOutCubic: (t) => (t -= 1) * t * t + 1,
  easeInOutCubic: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
  easeInQuart: (t) => t * t * t * t,
  easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
  easeInOutQuart: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
  easeInQuint: (t) => t * t * t * t * t,
  easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
  easeInOutQuint: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
  easeInSine: (t) => -Math.cos(t * HALF_PI) + 1,
  easeOutSine: (t) => Math.sin(t * HALF_PI),
  easeInOutSine: (t) => -0.5 * (Math.cos(PI * t) - 1),
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
  easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
  easeInOutExpo: (t) => atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
  easeInCirc: (t) => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
  easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
  easeInOutCirc: (t) => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
  easeInElastic: (t) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
  easeOutElastic: (t) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
  easeInOutElastic(t) {
    const s2 = 0.1125;
    const p = 0.45;
    return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s2, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s2, p);
  },
  easeInBack(t) {
    const s2 = 1.70158;
    return t * t * ((s2 + 1) * t - s2);
  },
  easeOutBack(t) {
    const s2 = 1.70158;
    return (t -= 1) * t * ((s2 + 1) * t + s2) + 1;
  },
  easeInOutBack(t) {
    let s2 = 1.70158;
    if ((t /= 0.5) < 1) {
      return 0.5 * (t * t * (((s2 *= 1.525) + 1) * t - s2));
    }
    return 0.5 * ((t -= 2) * t * (((s2 *= 1.525) + 1) * t + s2) + 2);
  },
  easeInBounce: (t) => 1 - effects.easeOutBounce(1 - t),
  easeOutBounce(t) {
    const m = 7.5625;
    const d = 2.75;
    if (t < 1 / d) {
      return m * t * t;
    }
    if (t < 2 / d) {
      return m * (t -= 1.5 / d) * t + 0.75;
    }
    if (t < 2.5 / d) {
      return m * (t -= 2.25 / d) * t + 0.9375;
    }
    return m * (t -= 2.625 / d) * t + 0.984375;
  },
  easeInOutBounce: (t) => t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
};
function isPatternOrGradient(value) {
  if (value && typeof value === "object") {
    const type = value.toString();
    return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
  }
  return false;
}
function color(value) {
  return isPatternOrGradient(value) ? value : new Color(value);
}
function getHoverColor(value) {
  return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();
}
var numbers = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
];
var colors = [
  "color",
  "borderColor",
  "backgroundColor"
];
function applyAnimationsDefaults(defaults3) {
  defaults3.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  });
  defaults3.describe("animation", {
    _fallback: false,
    _indexable: false,
    _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
  });
  defaults3.set("animations", {
    colors: {
      type: "color",
      properties: colors
    },
    numbers: {
      type: "number",
      properties: numbers
    }
  });
  defaults3.describe("animations", {
    _fallback: "animation"
  });
  defaults3.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (v) => v | 0
        }
      }
    }
  });
}
function applyLayoutsDefaults(defaults3) {
  defaults3.set("layout", {
    autoPadding: true,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
var intlCache = /* @__PURE__ */ new Map();
function getNumberFormat(locale, options) {
  options = options || {};
  const cacheKey = locale + JSON.stringify(options);
  let formatter = intlCache.get(cacheKey);
  if (!formatter) {
    formatter = new Intl.NumberFormat(locale, options);
    intlCache.set(cacheKey, formatter);
  }
  return formatter;
}
function formatNumber(num, locale, options) {
  return getNumberFormat(locale, options).format(num);
}
var formatters = {
  values(value) {
    return isArray(value) ? value : "" + value;
  },
  numeric(tickValue, index, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const locale = this.chart.options.locale;
    let notation;
    let delta = tickValue;
    if (ticks.length > 1) {
      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
      if (maxTick < 1e-4 || maxTick > 1e15) {
        notation = "scientific";
      }
      delta = calculateDelta(tickValue, ticks);
    }
    const logDelta = log10(Math.abs(delta));
    const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
    const options = {
      notation,
      minimumFractionDigits: numDecimal,
      maximumFractionDigits: numDecimal
    };
    Object.assign(options, this.options.ticks.format);
    return formatNumber(tickValue, locale, options);
  },
  logarithmic(tickValue, index, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const remain = ticks[index].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
    if ([
      1,
      2,
      3,
      5,
      10,
      15
    ].includes(remain) || index > 0.8 * ticks.length) {
      return formatters.numeric.call(this, tickValue, index, ticks);
    }
    return "";
  }
};
function calculateDelta(tickValue, ticks) {
  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
    delta = tickValue - Math.floor(tickValue);
  }
  return delta;
}
var Ticks = {
  formatters
};
function applyScaleDefaults(defaults3) {
  defaults3.set("scale", {
    display: true,
    offset: false,
    reverse: false,
    beginAtZero: false,
    bounds: "ticks",
    clip: true,
    grace: 0,
    grid: {
      display: true,
      lineWidth: 1,
      drawOnChartArea: true,
      drawTicks: true,
      tickLength: 8,
      tickWidth: (_ctx, options) => options.lineWidth,
      tickColor: (_ctx, options) => options.color,
      offset: false
    },
    border: {
      display: true,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: false,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: false,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: true,
      autoSkip: true,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Ticks.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: false,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  });
  defaults3.route("scale.ticks", "color", "", "color");
  defaults3.route("scale.grid", "color", "", "borderColor");
  defaults3.route("scale.border", "color", "", "borderColor");
  defaults3.route("scale.title", "color", "", "color");
  defaults3.describe("scale", {
    _fallback: false,
    _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
    _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash" && name !== "dash"
  });
  defaults3.describe("scales", {
    _fallback: "scale"
  });
  defaults3.describe("scale.ticks", {
    _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
    _indexable: (name) => name !== "backdropPadding"
  });
}
var overrides = /* @__PURE__ */ Object.create(null);
var descriptors = /* @__PURE__ */ Object.create(null);
function getScope$1(node, key) {
  if (!key) {
    return node;
  }
  const keys = key.split(".");
  for (let i = 0, n2 = keys.length; i < n2; ++i) {
    const k = keys[i];
    node = node[k] || (node[k] = /* @__PURE__ */ Object.create(null));
  }
  return node;
}
function set(root, scope, values) {
  if (typeof scope === "string") {
    return merge(getScope$1(root, scope), values);
  }
  return merge(getScope$1(root, ""), scope);
}
var Defaults = class {
  constructor(_descriptors3, _appliers) {
    this.animation = void 0;
    this.backgroundColor = "rgba(0,0,0,0.1)";
    this.borderColor = "rgba(0,0,0,0.1)";
    this.color = "#666";
    this.datasets = {};
    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
    this.elements = {};
    this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ];
    this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    };
    this.hover = {};
    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
    this.hoverColor = (ctx, options) => getHoverColor(options.color);
    this.indexAxis = "x";
    this.interaction = {
      mode: "nearest",
      intersect: true,
      includeInvisible: false
    };
    this.maintainAspectRatio = true;
    this.onHover = null;
    this.onClick = null;
    this.parsing = true;
    this.plugins = {};
    this.responsive = true;
    this.scale = void 0;
    this.scales = {};
    this.showLine = true;
    this.drawActiveElementsOnTop = true;
    this.describe(_descriptors3);
    this.apply(_appliers);
  }
  set(scope, values) {
    return set(this, scope, values);
  }
  get(scope) {
    return getScope$1(this, scope);
  }
  describe(scope, values) {
    return set(descriptors, scope, values);
  }
  override(scope, values) {
    return set(overrides, scope, values);
  }
  route(scope, name, targetScope, targetName) {
    const scopeObject = getScope$1(this, scope);
    const targetScopeObject = getScope$1(this, targetScope);
    const privateName = "_" + name;
    Object.defineProperties(scopeObject, {
      [privateName]: {
        value: scopeObject[name],
        writable: true
      },
      [name]: {
        enumerable: true,
        get() {
          const local = this[privateName];
          const target = targetScopeObject[targetName];
          if (isObject(local)) {
            return Object.assign({}, target, local);
          }
          return valueOrDefault(local, target);
        },
        set(value) {
          this[privateName] = value;
        }
      }
    });
  }
  apply(appliers) {
    appliers.forEach((apply) => apply(this));
  }
};
var defaults = /* @__PURE__ */ new Defaults({
  _scriptable: (name) => !name.startsWith("on"),
  _indexable: (name) => name !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: false,
    _indexable: false
  }
}, [
  applyAnimationsDefaults,
  applyLayoutsDefaults,
  applyScaleDefaults
]);
function toFontString(font) {
  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
    return null;
  }
  return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
}
function _measureText(ctx, data, gc, longest, string) {
  let textWidth = data[string];
  if (!textWidth) {
    textWidth = data[string] = ctx.measureText(string).width;
    gc.push(string);
  }
  if (textWidth > longest) {
    longest = textWidth;
  }
  return longest;
}
function _longestText(ctx, font, arrayOfThings, cache) {
  cache = cache || {};
  let data = cache.data = cache.data || {};
  let gc = cache.garbageCollect = cache.garbageCollect || [];
  if (cache.font !== font) {
    data = cache.data = {};
    gc = cache.garbageCollect = [];
    cache.font = font;
  }
  ctx.save();
  ctx.font = font;
  let longest = 0;
  const ilen = arrayOfThings.length;
  let i, j, jlen, thing, nestedThing;
  for (i = 0; i < ilen; i++) {
    thing = arrayOfThings[i];
    if (thing !== void 0 && thing !== null && !isArray(thing)) {
      longest = _measureText(ctx, data, gc, longest, thing);
    } else if (isArray(thing)) {
      for (j = 0, jlen = thing.length; j < jlen; j++) {
        nestedThing = thing[j];
        if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
          longest = _measureText(ctx, data, gc, longest, nestedThing);
        }
      }
    }
  }
  ctx.restore();
  const gcLen = gc.length / 2;
  if (gcLen > arrayOfThings.length) {
    for (i = 0; i < gcLen; i++) {
      delete data[gc[i]];
    }
    gc.splice(0, gcLen);
  }
  return longest;
}
function _alignPixel(chart, pixel, width) {
  const devicePixelRatio = chart.currentDevicePixelRatio;
  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
function clearCanvas(canvas, ctx) {
  ctx = ctx || canvas.getContext("2d");
  ctx.save();
  ctx.resetTransform();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}
function drawPoint(ctx, options, x, y) {
  drawPointLegend(ctx, options, x, y, null);
}
function drawPointLegend(ctx, options, x, y, w) {
  let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;
  const style = options.pointStyle;
  const rotation = options.rotation;
  const radius = options.radius;
  let rad = (rotation || 0) * RAD_PER_DEG;
  if (style && typeof style === "object") {
    type = style.toString();
    if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rad);
      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
      ctx.restore();
      return;
    }
  }
  if (isNaN(radius) || radius <= 0) {
    return;
  }
  ctx.beginPath();
  switch (style) {
    default:
      if (w) {
        ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
      } else {
        ctx.arc(x, y, radius, 0, TAU);
      }
      ctx.closePath();
      break;
    case "triangle":
      width = w ? w / 2 : radius;
      ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
      ctx.closePath();
      break;
    case "rectRounded":
      cornerRadius = radius * 0.516;
      size = radius - cornerRadius;
      xOffset = Math.cos(rad + QUARTER_PI) * size;
      xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
      yOffset = Math.sin(rad + QUARTER_PI) * size;
      yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
      ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
      ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);
      ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);
      ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
      ctx.closePath();
      break;
    case "rect":
      if (!rotation) {
        size = Math.SQRT1_2 * radius;
        width = w ? w / 2 : size;
        ctx.rect(x - width, y - size, 2 * width, 2 * size);
        break;
      }
      rad += QUARTER_PI;
    case "rectRot":
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      ctx.closePath();
      break;
    case "crossRot":
      rad += QUARTER_PI;
    case "cross":
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      break;
    case "star":
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      rad += QUARTER_PI;
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      break;
    case "line":
      xOffset = w ? w / 2 : Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      break;
    case "dash":
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);
      break;
    case false:
      ctx.closePath();
      break;
  }
  ctx.fill();
  if (options.borderWidth > 0) {
    ctx.stroke();
  }
}
function _isPointInArea(point, area, margin) {
  margin = margin || 0.5;
  return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
}
function clipArea(ctx, area) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
  ctx.clip();
}
function unclipArea(ctx) {
  ctx.restore();
}
function setRenderOpts(ctx, opts) {
  if (opts.translation) {
    ctx.translate(opts.translation[0], opts.translation[1]);
  }
  if (!isNullOrUndef(opts.rotation)) {
    ctx.rotate(opts.rotation);
  }
  if (opts.color) {
    ctx.fillStyle = opts.color;
  }
  if (opts.textAlign) {
    ctx.textAlign = opts.textAlign;
  }
  if (opts.textBaseline) {
    ctx.textBaseline = opts.textBaseline;
  }
}
function decorateText(ctx, x, y, line, opts) {
  if (opts.strikethrough || opts.underline) {
    const metrics = ctx.measureText(line);
    const left = x - metrics.actualBoundingBoxLeft;
    const right = x + metrics.actualBoundingBoxRight;
    const top = y - metrics.actualBoundingBoxAscent;
    const bottom = y + metrics.actualBoundingBoxDescent;
    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
    ctx.strokeStyle = ctx.fillStyle;
    ctx.beginPath();
    ctx.lineWidth = opts.decorationWidth || 2;
    ctx.moveTo(left, yDecoration);
    ctx.lineTo(right, yDecoration);
    ctx.stroke();
  }
}
function drawBackdrop(ctx, opts) {
  const oldColor = ctx.fillStyle;
  ctx.fillStyle = opts.color;
  ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
  ctx.fillStyle = oldColor;
}
function renderText(ctx, text, x, y, font, opts = {}) {
  const lines = isArray(text) ? text : [
    text
  ];
  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
  let i, line;
  ctx.save();
  ctx.font = font.string;
  setRenderOpts(ctx, opts);
  for (i = 0; i < lines.length; ++i) {
    line = lines[i];
    if (opts.backdrop) {
      drawBackdrop(ctx, opts.backdrop);
    }
    if (stroke) {
      if (opts.strokeColor) {
        ctx.strokeStyle = opts.strokeColor;
      }
      if (!isNullOrUndef(opts.strokeWidth)) {
        ctx.lineWidth = opts.strokeWidth;
      }
      ctx.strokeText(line, x, y, opts.maxWidth);
    }
    ctx.fillText(line, x, y, opts.maxWidth);
    decorateText(ctx, x, y, line, opts);
    y += Number(font.lineHeight);
  }
  ctx.restore();
}
function addRoundedRectPath(ctx, rect) {
  const { x, y, w, h, radius } = rect;
  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);
  ctx.lineTo(x, y + h - radius.bottomLeft);
  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
  ctx.lineTo(x + w - radius.bottomRight, y + h);
  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
  ctx.lineTo(x + w, y + radius.topRight);
  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
  ctx.lineTo(x + radius.topLeft, y);
}
var LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
var FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function toLineHeight(value, size) {
  const matches = ("" + value).match(LINE_HEIGHT);
  if (!matches || matches[1] === "normal") {
    return size * 1.2;
  }
  value = +matches[2];
  switch (matches[3]) {
    case "px":
      return value;
    case "%":
      value /= 100;
      break;
  }
  return size * value;
}
var numberOrZero = (v) => +v || 0;
function _readValueToProps(value, props) {
  const ret = {};
  const objProps = isObject(props);
  const keys = objProps ? Object.keys(props) : props;
  const read = isObject(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
  for (const prop of keys) {
    ret[prop] = numberOrZero(read(prop));
  }
  return ret;
}
function toTRBL(value) {
  return _readValueToProps(value, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function toTRBLCorners(value) {
  return _readValueToProps(value, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function toPadding(value) {
  const obj = toTRBL(value);
  obj.width = obj.left + obj.right;
  obj.height = obj.top + obj.bottom;
  return obj;
}
function toFont(options, fallback) {
  options = options || {};
  fallback = fallback || defaults.font;
  let size = valueOrDefault(options.size, fallback.size);
  if (typeof size === "string") {
    size = parseInt(size, 10);
  }
  let style = valueOrDefault(options.style, fallback.style);
  if (style && !("" + style).match(FONT_STYLE)) {
    console.warn('Invalid font style specified: "' + style + '"');
    style = void 0;
  }
  const font = {
    family: valueOrDefault(options.family, fallback.family),
    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
    size,
    style,
    weight: valueOrDefault(options.weight, fallback.weight),
    string: ""
  };
  font.string = toFontString(font);
  return font;
}
function resolve(inputs, context, index, info) {
  let cacheable = true;
  let i, ilen, value;
  for (i = 0, ilen = inputs.length; i < ilen; ++i) {
    value = inputs[i];
    if (value === void 0) {
      continue;
    }
    if (context !== void 0 && typeof value === "function") {
      value = value(context);
      cacheable = false;
    }
    if (index !== void 0 && isArray(value)) {
      value = value[index % value.length];
      cacheable = false;
    }
    if (value !== void 0) {
      if (info && !cacheable) {
        info.cacheable = false;
      }
      return value;
    }
  }
}
function _addGrace(minmax, grace, beginAtZero) {
  const { min, max } = minmax;
  const change = toDimension(grace, (max - min) / 2);
  const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
  return {
    min: keepZero(min, -Math.abs(change)),
    max: keepZero(max, change)
  };
}
function createContext(parentContext, context) {
  return Object.assign(Object.create(parentContext), context);
}
function _createResolver(scopes, prefixes = [
  ""
], rootScopes, fallback, getTarget = () => scopes[0]) {
  const finalRootScopes = rootScopes || scopes;
  if (typeof fallback === "undefined") {
    fallback = _resolve("_fallback", scopes);
  }
  const cache = {
    [Symbol.toStringTag]: "Object",
    _cacheable: true,
    _scopes: scopes,
    _rootScopes: finalRootScopes,
    _fallback: fallback,
    _getTarget: getTarget,
    override: (scope) => _createResolver([
      scope,
      ...scopes
    ], prefixes, finalRootScopes, fallback)
  };
  return new Proxy(cache, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(target, prop) {
      delete target[prop];
      delete target._keys;
      delete scopes[0][prop];
      return true;
    },
    /**
    * A trap for getting property values.
    */
    get(target, prop) {
      return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(target, prop) {
      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(scopes[0]);
    },
    /**
    * A trap for the in operator.
    */
    has(target, prop) {
      return getKeysFromAllScopes(target).includes(prop);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys(target) {
      return getKeysFromAllScopes(target);
    },
    /**
    * A trap for setting property values.
    */
    set(target, prop, value) {
      const storage = target._storage || (target._storage = getTarget());
      target[prop] = storage[prop] = value;
      delete target._keys;
      return true;
    }
  });
}
function _attachContext(proxy, context, subProxy, descriptorDefaults) {
  const cache = {
    _cacheable: false,
    _proxy: proxy,
    _context: context,
    _subProxy: subProxy,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: _descriptors(proxy, descriptorDefaults),
    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
  };
  return new Proxy(cache, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(target, prop) {
      delete target[prop];
      delete proxy[prop];
      return true;
    },
    /**
    * A trap for getting property values.
    */
    get(target, prop, receiver) {
      return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(target, prop) {
      return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
        enumerable: true,
        configurable: true
      } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(proxy);
    },
    /**
    * A trap for the in operator.
    */
    has(target, prop) {
      return Reflect.has(proxy, prop);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys() {
      return Reflect.ownKeys(proxy);
    },
    /**
    * A trap for setting property values.
    */
    set(target, prop, value) {
      proxy[prop] = value;
      delete target[prop];
      return true;
    }
  });
}
function _descriptors(proxy, defaults3 = {
  scriptable: true,
  indexable: true
}) {
  const { _scriptable = defaults3.scriptable, _indexable = defaults3.indexable, _allKeys = defaults3.allKeys } = proxy;
  return {
    allKeys: _allKeys,
    scriptable: _scriptable,
    indexable: _indexable,
    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
  };
}
var readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
var needsSubResolver = (prop, value) => isObject(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
function _cached(target, prop, resolve3) {
  if (Object.prototype.hasOwnProperty.call(target, prop)) {
    return target[prop];
  }
  const value = resolve3();
  target[prop] = value;
  return value;
}
function _resolveWithContext(target, prop, receiver) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors3 } = target;
  let value = _proxy[prop];
  if (isFunction(value) && descriptors3.isScriptable(prop)) {
    value = _resolveScriptable(prop, value, target, receiver);
  }
  if (isArray(value) && value.length) {
    value = _resolveArray(prop, value, target, descriptors3.isIndexable);
  }
  if (needsSubResolver(prop, value)) {
    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors3);
  }
  return value;
}
function _resolveScriptable(prop, getValue, target, receiver) {
  const { _proxy, _context, _subProxy, _stack } = target;
  if (_stack.has(prop)) {
    throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
  }
  _stack.add(prop);
  let value = getValue(_context, _subProxy || receiver);
  _stack.delete(prop);
  if (needsSubResolver(prop, value)) {
    value = createSubResolver(_proxy._scopes, _proxy, prop, value);
  }
  return value;
}
function _resolveArray(prop, value, target, isIndexable) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors3 } = target;
  if (typeof _context.index !== "undefined" && isIndexable(prop)) {
    return value[_context.index % value.length];
  } else if (isObject(value[0])) {
    const arr = value;
    const scopes = _proxy._scopes.filter((s2) => s2 !== arr);
    value = [];
    for (const item of arr) {
      const resolver = createSubResolver(scopes, _proxy, prop, item);
      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors3));
    }
  }
  return value;
}
function resolveFallback(fallback, prop, value) {
  return isFunction(fallback) ? fallback(prop, value) : fallback;
}
var getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
function addScopes(set3, parentScopes, key, parentFallback, value) {
  for (const parent of parentScopes) {
    const scope = getScope(key, parent);
    if (scope) {
      set3.add(scope);
      const fallback = resolveFallback(scope._fallback, key, value);
      if (typeof fallback !== "undefined" && fallback !== key && fallback !== parentFallback) {
        return fallback;
      }
    } else if (scope === false && typeof parentFallback !== "undefined" && key !== parentFallback) {
      return null;
    }
  }
  return false;
}
function createSubResolver(parentScopes, resolver, prop, value) {
  const rootScopes = resolver._rootScopes;
  const fallback = resolveFallback(resolver._fallback, prop, value);
  const allScopes = [
    ...parentScopes,
    ...rootScopes
  ];
  const set3 = /* @__PURE__ */ new Set();
  set3.add(value);
  let key = addScopesFromKey(set3, allScopes, prop, fallback || prop, value);
  if (key === null) {
    return false;
  }
  if (typeof fallback !== "undefined" && fallback !== prop) {
    key = addScopesFromKey(set3, allScopes, fallback, key, value);
    if (key === null) {
      return false;
    }
  }
  return _createResolver(Array.from(set3), [
    ""
  ], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
}
function addScopesFromKey(set3, allScopes, key, fallback, item) {
  while (key) {
    key = addScopes(set3, allScopes, key, fallback, item);
  }
  return key;
}
function subGetTarget(resolver, prop, value) {
  const parent = resolver._getTarget();
  if (!(prop in parent)) {
    parent[prop] = {};
  }
  const target = parent[prop];
  if (isArray(target) && isObject(value)) {
    return value;
  }
  return target || {};
}
function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
  let value;
  for (const prefix of prefixes) {
    value = _resolve(readKey(prefix, prop), scopes);
    if (typeof value !== "undefined") {
      return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
    }
  }
}
function _resolve(key, scopes) {
  for (const scope of scopes) {
    if (!scope) {
      continue;
    }
    const value = scope[key];
    if (typeof value !== "undefined") {
      return value;
    }
  }
}
function getKeysFromAllScopes(target) {
  let keys = target._keys;
  if (!keys) {
    keys = target._keys = resolveKeysFromAllScopes(target._scopes);
  }
  return keys;
}
function resolveKeysFromAllScopes(scopes) {
  const set3 = /* @__PURE__ */ new Set();
  for (const scope of scopes) {
    for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
      set3.add(key);
    }
  }
  return Array.from(set3);
}
var EPSILON = Number.EPSILON || 1e-14;
function _isDomSupported() {
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function _getParentNode(domNode) {
  let parent = domNode.parentNode;
  if (parent && parent.toString() === "[object ShadowRoot]") {
    parent = parent.host;
  }
  return parent;
}
function parseMaxStyle(styleValue, node, parentProperty) {
  let valueInPixels;
  if (typeof styleValue === "string") {
    valueInPixels = parseInt(styleValue, 10);
    if (styleValue.indexOf("%") !== -1) {
      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
    }
  } else {
    valueInPixels = styleValue;
  }
  return valueInPixels;
}
var getComputedStyle = (element) => element.ownerDocument.defaultView.getComputedStyle(element, null);
function getStyle(el, property) {
  return getComputedStyle(el).getPropertyValue(property);
}
var positions = [
  "top",
  "right",
  "bottom",
  "left"
];
function getPositionedStyle(styles, style, suffix) {
  const result = {};
  suffix = suffix ? "-" + suffix : "";
  for (let i = 0; i < 4; i++) {
    const pos = positions[i];
    result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
  }
  result.width = result.left + result.right;
  result.height = result.top + result.bottom;
  return result;
}
var useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
function getCanvasPosition(e, canvas) {
  const touches = e.touches;
  const source = touches && touches.length ? touches[0] : e;
  const { offsetX, offsetY } = source;
  let box = false;
  let x, y;
  if (useOffsetPos(offsetX, offsetY, e.target)) {
    x = offsetX;
    y = offsetY;
  } else {
    const rect = canvas.getBoundingClientRect();
    x = source.clientX - rect.left;
    y = source.clientY - rect.top;
    box = true;
  }
  return {
    x,
    y,
    box
  };
}
function getRelativePosition(event, chart) {
  if ("native" in event) {
    return event;
  }
  const { canvas, currentDevicePixelRatio } = chart;
  const style = getComputedStyle(canvas);
  const borderBox = style.boxSizing === "border-box";
  const paddings = getPositionedStyle(style, "padding");
  const borders = getPositionedStyle(style, "border", "width");
  const { x, y, box } = getCanvasPosition(event, canvas);
  const xOffset = paddings.left + (box && borders.left);
  const yOffset = paddings.top + (box && borders.top);
  let { width, height } = chart;
  if (borderBox) {
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  return {
    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
  };
}
function getContainerSize(canvas, width, height) {
  let maxWidth, maxHeight;
  if (width === void 0 || height === void 0) {
    const container = _getParentNode(canvas);
    if (!container) {
      width = canvas.clientWidth;
      height = canvas.clientHeight;
    } else {
      const rect = container.getBoundingClientRect();
      const containerStyle = getComputedStyle(container);
      const containerBorder = getPositionedStyle(containerStyle, "border", "width");
      const containerPadding = getPositionedStyle(containerStyle, "padding");
      width = rect.width - containerPadding.width - containerBorder.width;
      height = rect.height - containerPadding.height - containerBorder.height;
      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
    }
  }
  return {
    width,
    height,
    maxWidth: maxWidth || INFINITY,
    maxHeight: maxHeight || INFINITY
  };
}
var round1 = (v) => Math.round(v * 10) / 10;
function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
  const style = getComputedStyle(canvas);
  const margins = getPositionedStyle(style, "margin");
  const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
  const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
  let { width, height } = containerSize;
  if (style.boxSizing === "content-box") {
    const borders = getPositionedStyle(style, "border", "width");
    const paddings = getPositionedStyle(style, "padding");
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  width = Math.max(0, width - margins.width);
  height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
  if (width && !height) {
    height = round1(width / 2);
  }
  const maintainHeight = bbWidth !== void 0 || bbHeight !== void 0;
  if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
    height = containerSize.height;
    width = round1(Math.floor(height * aspectRatio));
  }
  return {
    width,
    height
  };
}
function retinaScale(chart, forceRatio, forceStyle) {
  const pixelRatio = forceRatio || 1;
  const deviceHeight = Math.floor(chart.height * pixelRatio);
  const deviceWidth = Math.floor(chart.width * pixelRatio);
  chart.height = Math.floor(chart.height);
  chart.width = Math.floor(chart.width);
  const canvas = chart.canvas;
  if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
    canvas.style.height = `${chart.height}px`;
    canvas.style.width = `${chart.width}px`;
  }
  if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
    chart.currentDevicePixelRatio = pixelRatio;
    canvas.height = deviceHeight;
    canvas.width = deviceWidth;
    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    return true;
  }
  return false;
}
var supportsEventListenerOptions = function() {
  let passiveSupported = false;
  try {
    const options = {
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    if (_isDomSupported()) {
      window.addEventListener("test", null, options);
      window.removeEventListener("test", null, options);
    }
  } catch (e) {
  }
  return passiveSupported;
}();
function readUsedSize(element, property) {
  const value = getStyle(element, property);
  const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
  return matches ? +matches[1] : void 0;
}
var getRightToLeftAdapter = function(rectX, width) {
  return {
    x(x) {
      return rectX + rectX + width - x;
    },
    setWidth(w) {
      width = w;
    },
    textAlign(align) {
      if (align === "center") {
        return align;
      }
      return align === "right" ? "left" : "right";
    },
    xPlus(x, value) {
      return x - value;
    },
    leftForLtr(x, itemWidth) {
      return x - itemWidth;
    }
  };
};
var getLeftToRightAdapter = function() {
  return {
    x(x) {
      return x;
    },
    setWidth(w) {
    },
    textAlign(align) {
      return align;
    },
    xPlus(x, value) {
      return x + value;
    },
    leftForLtr(x, _itemWidth) {
      return x;
    }
  };
};
function getRtlAdapter(rtl, rectX, width) {
  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx, direction) {
  let style, original;
  if (direction === "ltr" || direction === "rtl") {
    style = ctx.canvas.style;
    original = [
      style.getPropertyValue("direction"),
      style.getPropertyPriority("direction")
    ];
    style.setProperty("direction", direction, "important");
    ctx.prevTextDirection = original;
  }
}
function restoreTextDirection(ctx, original) {
  if (original !== void 0) {
    delete ctx.prevTextDirection;
    ctx.canvas.style.setProperty("direction", original[0], original[1]);
  }
}

// node_modules/chart.js/dist/chart.js
var Animator = class {
  constructor() {
    this._request = null;
    this._charts = /* @__PURE__ */ new Map();
    this._running = false;
    this._lastDate = void 0;
  }
  _notify(chart, anims, date, type) {
    const callbacks = anims.listeners[type];
    const numSteps = anims.duration;
    callbacks.forEach((fn) => fn({
      chart,
      initial: anims.initial,
      numSteps,
      currentStep: Math.min(date - anims.start, numSteps)
    }));
  }
  _refresh() {
    if (this._request) {
      return;
    }
    this._running = true;
    this._request = requestAnimFrame.call(window, () => {
      this._update();
      this._request = null;
      if (this._running) {
        this._refresh();
      }
    });
  }
  _update(date = Date.now()) {
    let remaining = 0;
    this._charts.forEach((anims, chart) => {
      if (!anims.running || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i = items.length - 1;
      let draw = false;
      let item;
      for (; i >= 0; --i) {
        item = items[i];
        if (item._active) {
          if (item._total > anims.duration) {
            anims.duration = item._total;
          }
          item.tick(date);
          draw = true;
        } else {
          items[i] = items[items.length - 1];
          items.pop();
        }
      }
      if (draw) {
        chart.draw();
        this._notify(chart, anims, date, "progress");
      }
      if (!items.length) {
        anims.running = false;
        this._notify(chart, anims, date, "complete");
        anims.initial = false;
      }
      remaining += items.length;
    });
    this._lastDate = date;
    if (remaining === 0) {
      this._running = false;
    }
  }
  _getAnims(chart) {
    const charts = this._charts;
    let anims = charts.get(chart);
    if (!anims) {
      anims = {
        running: false,
        initial: true,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      };
      charts.set(chart, anims);
    }
    return anims;
  }
  listen(chart, event, cb) {
    this._getAnims(chart).listeners[event].push(cb);
  }
  add(chart, items) {
    if (!items || !items.length) {
      return;
    }
    this._getAnims(chart).items.push(...items);
  }
  has(chart) {
    return this._getAnims(chart).items.length > 0;
  }
  start(chart) {
    const anims = this._charts.get(chart);
    if (!anims) {
      return;
    }
    anims.running = true;
    anims.start = Date.now();
    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
    this._refresh();
  }
  running(chart) {
    if (!this._running) {
      return false;
    }
    const anims = this._charts.get(chart);
    if (!anims || !anims.running || !anims.items.length) {
      return false;
    }
    return true;
  }
  stop(chart) {
    const anims = this._charts.get(chart);
    if (!anims || !anims.items.length) {
      return;
    }
    const items = anims.items;
    let i = items.length - 1;
    for (; i >= 0; --i) {
      items[i].cancel();
    }
    anims.items = [];
    this._notify(chart, anims, Date.now(), "complete");
  }
  remove(chart) {
    return this._charts.delete(chart);
  }
};
var animator = /* @__PURE__ */ new Animator();
var transparent = "transparent";
var interpolators = {
  boolean(from3, to3, factor) {
    return factor > 0.5 ? to3 : from3;
  },
  color(from3, to3, factor) {
    const c0 = color(from3 || transparent);
    const c1 = c0.valid && color(to3 || transparent);
    return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to3;
  },
  number(from3, to3, factor) {
    return from3 + (to3 - from3) * factor;
  }
};
var Animation = class {
  constructor(cfg, target, prop, to3) {
    const currentValue = target[prop];
    to3 = resolve([
      cfg.to,
      to3,
      currentValue,
      cfg.from
    ]);
    const from3 = resolve([
      cfg.from,
      currentValue,
      to3
    ]);
    this._active = true;
    this._fn = cfg.fn || interpolators[cfg.type || typeof from3];
    this._easing = effects[cfg.easing] || effects.linear;
    this._start = Math.floor(Date.now() + (cfg.delay || 0));
    this._duration = this._total = Math.floor(cfg.duration);
    this._loop = !!cfg.loop;
    this._target = target;
    this._prop = prop;
    this._from = from3;
    this._to = to3;
    this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(cfg, to3, date) {
    if (this._active) {
      this._notify(false);
      const currentValue = this._target[this._prop];
      const elapsed = date - this._start;
      const remain = this._duration - elapsed;
      this._start = date;
      this._duration = Math.floor(Math.max(remain, cfg.duration));
      this._total += elapsed;
      this._loop = !!cfg.loop;
      this._to = resolve([
        cfg.to,
        to3,
        currentValue,
        cfg.from
      ]);
      this._from = resolve([
        cfg.from,
        currentValue,
        to3
      ]);
    }
  }
  cancel() {
    if (this._active) {
      this.tick(Date.now());
      this._active = false;
      this._notify(false);
    }
  }
  tick(date) {
    const elapsed = date - this._start;
    const duration = this._duration;
    const prop = this._prop;
    const from3 = this._from;
    const loop = this._loop;
    const to3 = this._to;
    let factor;
    this._active = from3 !== to3 && (loop || elapsed < duration);
    if (!this._active) {
      this._target[prop] = to3;
      this._notify(true);
      return;
    }
    if (elapsed < 0) {
      this._target[prop] = from3;
      return;
    }
    factor = elapsed / duration % 2;
    factor = loop && factor > 1 ? 2 - factor : factor;
    factor = this._easing(Math.min(1, Math.max(0, factor)));
    this._target[prop] = this._fn(from3, to3, factor);
  }
  wait() {
    const promises = this._promises || (this._promises = []);
    return new Promise((res, rej) => {
      promises.push({
        res,
        rej
      });
    });
  }
  _notify(resolved) {
    const method = resolved ? "res" : "rej";
    const promises = this._promises || [];
    for (let i = 0; i < promises.length; i++) {
      promises[i][method]();
    }
  }
};
var Animations = class {
  constructor(chart, config) {
    this._chart = chart;
    this._properties = /* @__PURE__ */ new Map();
    this.configure(config);
  }
  configure(config) {
    if (!isObject(config)) {
      return;
    }
    const animationOptions = Object.keys(defaults.animation);
    const animatedProps = this._properties;
    Object.getOwnPropertyNames(config).forEach((key) => {
      const cfg = config[key];
      if (!isObject(cfg)) {
        return;
      }
      const resolved = {};
      for (const option of animationOptions) {
        resolved[option] = cfg[option];
      }
      (isArray(cfg.properties) && cfg.properties || [
        key
      ]).forEach((prop) => {
        if (prop === key || !animatedProps.has(prop)) {
          animatedProps.set(prop, resolved);
        }
      });
    });
  }
  _animateOptions(target, values) {
    const newOptions = values.options;
    const options = resolveTargetOptions(target, newOptions);
    if (!options) {
      return [];
    }
    const animations = this._createAnimations(options, newOptions);
    if (newOptions.$shared) {
      awaitAll(target.options.$animations, newOptions).then(() => {
        target.options = newOptions;
      }, () => {
      });
    }
    return animations;
  }
  _createAnimations(target, values) {
    const animatedProps = this._properties;
    const animations = [];
    const running = target.$animations || (target.$animations = {});
    const props = Object.keys(values);
    const date = Date.now();
    let i;
    for (i = props.length - 1; i >= 0; --i) {
      const prop = props[i];
      if (prop.charAt(0) === "$") {
        continue;
      }
      if (prop === "options") {
        animations.push(...this._animateOptions(target, values));
        continue;
      }
      const value = values[prop];
      let animation = running[prop];
      const cfg = animatedProps.get(prop);
      if (animation) {
        if (cfg && animation.active()) {
          animation.update(cfg, value, date);
          continue;
        } else {
          animation.cancel();
        }
      }
      if (!cfg || !cfg.duration) {
        target[prop] = value;
        continue;
      }
      running[prop] = animation = new Animation(cfg, target, prop, value);
      animations.push(animation);
    }
    return animations;
  }
  update(target, values) {
    if (this._properties.size === 0) {
      Object.assign(target, values);
      return;
    }
    const animations = this._createAnimations(target, values);
    if (animations.length) {
      animator.add(this._chart, animations);
      return true;
    }
  }
};
function awaitAll(animations, properties) {
  const running = [];
  const keys = Object.keys(properties);
  for (let i = 0; i < keys.length; i++) {
    const anim = animations[keys[i]];
    if (anim && anim.active()) {
      running.push(anim.wait());
    }
  }
  return Promise.all(running);
}
function resolveTargetOptions(target, newOptions) {
  if (!newOptions) {
    return;
  }
  let options = target.options;
  if (!options) {
    target.options = newOptions;
    return;
  }
  if (options.$shared) {
    target.options = options = Object.assign({}, options, {
      $shared: false,
      $animations: {}
    });
  }
  return options;
}
function scaleClip(scale, allowedOverflow) {
  const opts = scale && scale.options || {};
  const reverse = opts.reverse;
  const min = opts.min === void 0 ? allowedOverflow : 0;
  const max = opts.max === void 0 ? allowedOverflow : 0;
  return {
    start: reverse ? max : min,
    end: reverse ? min : max
  };
}
function defaultClip(xScale, yScale, allowedOverflow) {
  if (allowedOverflow === false) {
    return false;
  }
  const x = scaleClip(xScale, allowedOverflow);
  const y = scaleClip(yScale, allowedOverflow);
  return {
    top: y.end,
    right: x.end,
    bottom: y.start,
    left: x.start
  };
}
function toClip(value) {
  let t, r, b, l2;
  if (isObject(value)) {
    t = value.top;
    r = value.right;
    b = value.bottom;
    l2 = value.left;
  } else {
    t = r = b = l2 = value;
  }
  return {
    top: t,
    right: r,
    bottom: b,
    left: l2,
    disabled: value === false
  };
}
function getSortedDatasetIndices(chart, filterVisible) {
  const keys = [];
  const metasets = chart._getSortedDatasetMetas(filterVisible);
  let i, ilen;
  for (i = 0, ilen = metasets.length; i < ilen; ++i) {
    keys.push(metasets[i].index);
  }
  return keys;
}
function applyStack(stack, value, dsIndex, options = {}) {
  const keys = stack.keys;
  const singleMode = options.mode === "single";
  let i, ilen, datasetIndex, otherValue;
  if (value === null) {
    return;
  }
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    datasetIndex = +keys[i];
    if (datasetIndex === dsIndex) {
      if (options.all) {
        continue;
      }
      break;
    }
    otherValue = stack.values[datasetIndex];
    if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {
      value += otherValue;
    }
  }
  return value;
}
function convertObjectDataToArray(data) {
  const keys = Object.keys(data);
  const adata = new Array(keys.length);
  let i, ilen, key;
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    key = keys[i];
    adata[i] = {
      x: key,
      y: data[key]
    };
  }
  return adata;
}
function isStacked(scale, meta) {
  const stacked = scale && scale.options.stacked;
  return stacked || stacked === void 0 && meta.stack !== void 0;
}
function getStackKey(indexScale, valueScale, meta) {
  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
}
function getUserBounds(scale) {
  const { min, max, minDefined, maxDefined } = scale.getUserBounds();
  return {
    min: minDefined ? min : Number.NEGATIVE_INFINITY,
    max: maxDefined ? max : Number.POSITIVE_INFINITY
  };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
  const subStack = stacks[stackKey] || (stacks[stackKey] = {});
  return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack, vScale, positive, type) {
  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
    const value = stack[meta.index];
    if (positive && value > 0 || !positive && value < 0) {
      return meta.index;
    }
  }
  return null;
}
function updateStacks(controller, parsed) {
  const { chart, _cachedMeta: meta } = controller;
  const stacks = chart._stacks || (chart._stacks = {});
  const { iScale, vScale, index: datasetIndex } = meta;
  const iAxis = iScale.axis;
  const vAxis = vScale.axis;
  const key = getStackKey(iScale, vScale, meta);
  const ilen = parsed.length;
  let stack;
  for (let i = 0; i < ilen; ++i) {
    const item = parsed[i];
    const { [iAxis]: index, [vAxis]: value } = item;
    const itemStacks = item._stacks || (item._stacks = {});
    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);
    stack[datasetIndex] = value;
    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
    const visualValues = stack._visualValues || (stack._visualValues = {});
    visualValues[datasetIndex] = value;
  }
}
function getFirstScaleId(chart, axis) {
  const scales = chart.scales;
  return Object.keys(scales).filter((key) => scales[key].axis === axis).shift();
}
function createDatasetContext(parent, index) {
  return createContext(parent, {
    active: false,
    dataset: void 0,
    datasetIndex: index,
    index,
    mode: "default",
    type: "dataset"
  });
}
function createDataContext(parent, index, element) {
  return createContext(parent, {
    active: false,
    dataIndex: index,
    parsed: void 0,
    raw: void 0,
    element,
    index,
    mode: "default",
    type: "data"
  });
}
function clearStacks(meta, items) {
  const datasetIndex = meta.controller.index;
  const axis = meta.vScale && meta.vScale.axis;
  if (!axis) {
    return;
  }
  items = items || meta._parsed;
  for (const parsed of items) {
    const stacks = parsed._stacks;
    if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
      return;
    }
    delete stacks[axis][datasetIndex];
    if (stacks[axis]._visualValues !== void 0 && stacks[axis]._visualValues[datasetIndex] !== void 0) {
      delete stacks[axis]._visualValues[datasetIndex];
    }
  }
}
var isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
var cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
var createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && {
  keys: getSortedDatasetIndices(chart, true),
  values: null
};
var DatasetController = class {
  constructor(chart, datasetIndex) {
    this.chart = chart;
    this._ctx = chart.ctx;
    this.index = datasetIndex;
    this._cachedDataOpts = {};
    this._cachedMeta = this.getMeta();
    this._type = this._cachedMeta.type;
    this.options = void 0;
    this._parsing = false;
    this._data = void 0;
    this._objectData = void 0;
    this._sharedOptions = void 0;
    this._drawStart = void 0;
    this._drawCount = void 0;
    this.enableOptionSharing = false;
    this.supportsDecimation = false;
    this.$context = void 0;
    this._syncList = [];
    this.datasetElementType = new.target.datasetElementType;
    this.dataElementType = new.target.dataElementType;
    this.initialize();
  }
  initialize() {
    const meta = this._cachedMeta;
    this.configure();
    this.linkScales();
    meta._stacked = isStacked(meta.vScale, meta);
    this.addElements();
    if (this.options.fill && !this.chart.isPluginEnabled("filler")) {
      console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
    }
  }
  updateIndex(datasetIndex) {
    if (this.index !== datasetIndex) {
      clearStacks(this._cachedMeta);
    }
    this.index = datasetIndex;
  }
  linkScales() {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    const chooseId = (axis, x, y, r) => axis === "x" ? x : axis === "r" ? r : y;
    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
    const indexAxis = meta.indexAxis;
    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
    meta.xScale = this.getScaleForId(xid);
    meta.yScale = this.getScaleForId(yid);
    meta.rScale = this.getScaleForId(rid);
    meta.iScale = this.getScaleForId(iid);
    meta.vScale = this.getScaleForId(vid);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(scaleID) {
    return this.chart.scales[scaleID];
  }
  _getOtherScale(scale) {
    const meta = this._cachedMeta;
    return scale === meta.iScale ? meta.vScale : meta.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const meta = this._cachedMeta;
    if (this._data) {
      unlistenArrayEvents(this._data, this);
    }
    if (meta._stacked) {
      clearStacks(meta);
    }
  }
  _dataCheck() {
    const dataset = this.getDataset();
    const data = dataset.data || (dataset.data = []);
    const _data = this._data;
    if (isObject(data)) {
      this._data = convertObjectDataToArray(data);
    } else if (_data !== data) {
      if (_data) {
        unlistenArrayEvents(_data, this);
        const meta = this._cachedMeta;
        clearStacks(meta);
        meta._parsed = [];
      }
      if (data && Object.isExtensible(data)) {
        listenArrayEvents(data, this);
      }
      this._syncList = [];
      this._data = data;
    }
  }
  addElements() {
    const meta = this._cachedMeta;
    this._dataCheck();
    if (this.datasetElementType) {
      meta.dataset = new this.datasetElementType();
    }
  }
  buildOrUpdateElements(resetNewElements) {
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    let stackChanged = false;
    this._dataCheck();
    const oldStacked = meta._stacked;
    meta._stacked = isStacked(meta.vScale, meta);
    if (meta.stack !== dataset.stack) {
      stackChanged = true;
      clearStacks(meta);
      meta.stack = dataset.stack;
    }
    this._resyncElements(resetNewElements);
    if (stackChanged || oldStacked !== meta._stacked) {
      updateStacks(this, meta._parsed);
    }
  }
  configure() {
    const config = this.chart.config;
    const scopeKeys = config.datasetScopeKeys(this._type);
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
    this.options = config.createResolver(scopes, this.getContext());
    this._parsing = this.options.parsing;
    this._cachedDataOpts = {};
  }
  parse(start, count) {
    const { _cachedMeta: meta, _data: data } = this;
    const { iScale, _stacked } = meta;
    const iAxis = iScale.axis;
    let sorted = start === 0 && count === data.length ? true : meta._sorted;
    let prev = start > 0 && meta._parsed[start - 1];
    let i, cur, parsed;
    if (this._parsing === false) {
      meta._parsed = data;
      meta._sorted = true;
      parsed = data;
    } else {
      if (isArray(data[start])) {
        parsed = this.parseArrayData(meta, data, start, count);
      } else if (isObject(data[start])) {
        parsed = this.parseObjectData(meta, data, start, count);
      } else {
        parsed = this.parsePrimitiveData(meta, data, start, count);
      }
      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
      for (i = 0; i < count; ++i) {
        meta._parsed[i + start] = cur = parsed[i];
        if (sorted) {
          if (isNotInOrderComparedToPrev()) {
            sorted = false;
          }
          prev = cur;
        }
      }
      meta._sorted = sorted;
    }
    if (_stacked) {
      updateStacks(this, parsed);
    }
  }
  parsePrimitiveData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = new Array(count);
    let i, ilen, index;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      parsed[i] = {
        [iAxis]: singleScale || iScale.parse(labels[index], index),
        [vAxis]: vScale.parse(data[index], index)
      };
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const parsed = new Array(count);
    let i, ilen, index, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      item = data[index];
      parsed[i] = {
        x: xScale.parse(item[0], index),
        y: yScale.parse(item[1], index)
      };
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const parsed = new Array(count);
    let i, ilen, index, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      item = data[index];
      parsed[i] = {
        x: xScale.parse(resolveObjectKey(item, xAxisKey), index),
        y: yScale.parse(resolveObjectKey(item, yAxisKey), index)
      };
    }
    return parsed;
  }
  getParsed(index) {
    return this._cachedMeta._parsed[index];
  }
  getDataElement(index) {
    return this._cachedMeta.data[index];
  }
  applyStack(scale, parsed, mode) {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const value = parsed[scale.axis];
    const stack = {
      keys: getSortedDatasetIndices(chart, true),
      values: parsed._stacks[scale.axis]._visualValues
    };
    return applyStack(stack, value, meta.index, {
      mode
    });
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    const parsedValue = parsed[scale.axis];
    let value = parsedValue === null ? NaN : parsedValue;
    const values = stack && parsed._stacks[scale.axis];
    if (stack && values) {
      stack.values = values;
      value = applyStack(stack, parsedValue, this._cachedMeta.index);
    }
    range.min = Math.min(range.min, value);
    range.max = Math.max(range.max, value);
  }
  getMinMax(scale, canStack) {
    const meta = this._cachedMeta;
    const _parsed = meta._parsed;
    const sorted = meta._sorted && scale === meta.iScale;
    const ilen = _parsed.length;
    const otherScale = this._getOtherScale(scale);
    const stack = createStack(canStack, meta, this.chart);
    const range = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
    let i, parsed;
    function _skip() {
      parsed = _parsed[i];
      const otherValue = parsed[otherScale.axis];
      return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
    }
    for (i = 0; i < ilen; ++i) {
      if (_skip()) {
        continue;
      }
      this.updateRangeFromParsed(range, scale, parsed, stack);
      if (sorted) {
        break;
      }
    }
    if (sorted) {
      for (i = ilen - 1; i >= 0; --i) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range, scale, parsed, stack);
        break;
      }
    }
    return range;
  }
  getAllParsedValues(scale) {
    const parsed = this._cachedMeta._parsed;
    const values = [];
    let i, ilen, value;
    for (i = 0, ilen = parsed.length; i < ilen; ++i) {
      value = parsed[i][scale.axis];
      if (isNumberFinite(value)) {
        values.push(value);
      }
    }
    return values;
  }
  getMaxOverflow() {
    return false;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const parsed = this.getParsed(index);
    return {
      label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
      value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
    };
  }
  _update(mode) {
    const meta = this._cachedMeta;
    this.update(mode || "default");
    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
  }
  update(mode) {
  }
  draw() {
    const ctx = this._ctx;
    const chart = this.chart;
    const meta = this._cachedMeta;
    const elements = meta.data || [];
    const area = chart.chartArea;
    const active = [];
    const start = this._drawStart || 0;
    const count = this._drawCount || elements.length - start;
    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
    let i;
    if (meta.dataset) {
      meta.dataset.draw(ctx, area, start, count);
    }
    for (i = start; i < start + count; ++i) {
      const element = elements[i];
      if (element.hidden) {
        continue;
      }
      if (element.active && drawActiveElementsOnTop) {
        active.push(element);
      } else {
        element.draw(ctx, area);
      }
    }
    for (i = 0; i < active.length; ++i) {
      active[i].draw(ctx, area);
    }
  }
  getStyle(index, active) {
    const mode = active ? "active" : "default";
    return index === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);
  }
  getContext(index, active, mode) {
    const dataset = this.getDataset();
    let context;
    if (index >= 0 && index < this._cachedMeta.data.length) {
      const element = this._cachedMeta.data[index];
      context = element.$context || (element.$context = createDataContext(this.getContext(), index, element));
      context.parsed = this.getParsed(index);
      context.raw = dataset.data[index];
      context.index = context.dataIndex = index;
    } else {
      context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
      context.dataset = dataset;
      context.index = context.datasetIndex = this.index;
    }
    context.active = !!active;
    context.mode = mode;
    return context;
  }
  resolveDatasetElementOptions(mode) {
    return this._resolveElementOptions(this.datasetElementType.id, mode);
  }
  resolveDataElementOptions(index, mode) {
    return this._resolveElementOptions(this.dataElementType.id, mode, index);
  }
  _resolveElementOptions(elementType, mode = "default", index) {
    const active = mode === "active";
    const cache = this._cachedDataOpts;
    const cacheKey = elementType + "-" + mode;
    const cached = cache[cacheKey];
    const sharing = this.enableOptionSharing && defined(index);
    if (cached) {
      return cloneIfNotShared(cached, sharing);
    }
    const config = this.chart.config;
    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
    const prefixes = active ? [
      `${elementType}Hover`,
      "hover",
      elementType,
      ""
    ] : [
      elementType,
      ""
    ];
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
    const names3 = Object.keys(defaults.elements[elementType]);
    const context = () => this.getContext(index, active, mode);
    const values = config.resolveNamedOptions(scopes, names3, context, prefixes);
    if (values.$shared) {
      values.$shared = sharing;
      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
    }
    return values;
  }
  _resolveAnimations(index, transition, active) {
    const chart = this.chart;
    const cache = this._cachedDataOpts;
    const cacheKey = `animation-${transition}`;
    const cached = cache[cacheKey];
    if (cached) {
      return cached;
    }
    let options;
    if (chart.options.animation !== false) {
      const config = this.chart.config;
      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      options = config.createResolver(scopes, this.getContext(index, active, transition));
    }
    const animations = new Animations(chart, options && options.animations);
    if (options && options._cacheable) {
      cache[cacheKey] = Object.freeze(animations);
    }
    return animations;
  }
  getSharedOptions(options) {
    if (!options.$shared) {
      return;
    }
    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
  }
  includeOptions(mode, sharedOptions) {
    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
  }
  _getSharedOptions(start, mode) {
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const previouslySharedOptions = this._sharedOptions;
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
    return {
      sharedOptions,
      includeOptions
    };
  }
  updateElement(element, index, properties, mode) {
    if (isDirectUpdateMode(mode)) {
      Object.assign(element, properties);
    } else {
      this._resolveAnimations(index, mode).update(element, properties);
    }
  }
  updateSharedOptions(sharedOptions, mode, newOptions) {
    if (sharedOptions && !isDirectUpdateMode(mode)) {
      this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
    }
  }
  _setStyle(element, index, mode, active) {
    element.active = active;
    const options = this.getStyle(index, active);
    this._resolveAnimations(index, mode, active).update(element, {
      options: !active && this.getSharedOptions(options) || options
    });
  }
  removeHoverStyle(element, datasetIndex, index) {
    this._setStyle(element, index, "active", false);
  }
  setHoverStyle(element, datasetIndex, index) {
    this._setStyle(element, index, "active", true);
  }
  _removeDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", false);
    }
  }
  _setDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", true);
    }
  }
  _resyncElements(resetNewElements) {
    const data = this._data;
    const elements = this._cachedMeta.data;
    for (const [method, arg1, arg2] of this._syncList) {
      this[method](arg1, arg2);
    }
    this._syncList = [];
    const numMeta = elements.length;
    const numData = data.length;
    const count = Math.min(numData, numMeta);
    if (count) {
      this.parse(0, count);
    }
    if (numData > numMeta) {
      this._insertElements(numMeta, numData - numMeta, resetNewElements);
    } else if (numData < numMeta) {
      this._removeElements(numData, numMeta - numData);
    }
  }
  _insertElements(start, count, resetNewElements = true) {
    const meta = this._cachedMeta;
    const data = meta.data;
    const end = start + count;
    let i;
    const move = (arr) => {
      arr.length += count;
      for (i = arr.length - 1; i >= end; i--) {
        arr[i] = arr[i - count];
      }
    };
    move(data);
    for (i = start; i < end; ++i) {
      data[i] = new this.dataElementType();
    }
    if (this._parsing) {
      move(meta._parsed);
    }
    this.parse(start, count);
    if (resetNewElements) {
      this.updateElements(data, start, count, "reset");
    }
  }
  updateElements(element, start, count, mode) {
  }
  _removeElements(start, count) {
    const meta = this._cachedMeta;
    if (this._parsing) {
      const removed = meta._parsed.splice(start, count);
      if (meta._stacked) {
        clearStacks(meta, removed);
      }
    }
    meta.data.splice(start, count);
  }
  _sync(args) {
    if (this._parsing) {
      this._syncList.push(args);
    } else {
      const [method, arg1, arg2] = args;
      this[method](arg1, arg2);
    }
    this.chart._dataChanges.push([
      this.index,
      ...args
    ]);
  }
  _onDataPush() {
    const count = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - count,
      count
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(start, count) {
    if (count) {
      this._sync([
        "_removeElements",
        start,
        count
      ]);
    }
    const newCount = arguments.length - 2;
    if (newCount) {
      this._sync([
        "_insertElements",
        start,
        newCount
      ]);
    }
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
};
__publicField(DatasetController, "defaults", {});
__publicField(DatasetController, "datasetElementType", null);
__publicField(DatasetController, "dataElementType", null);
function getRatioAndOffset(rotation, circumference, cutout) {
  let ratioX = 1;
  let ratioY = 1;
  let offsetX = 0;
  let offsetY = 0;
  if (circumference < TAU) {
    const startAngle = rotation;
    const endAngle = startAngle + circumference;
    const startX = Math.cos(startAngle);
    const startY = Math.sin(startAngle);
    const endX = Math.cos(endAngle);
    const endY = Math.sin(endAngle);
    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
    const maxX = calcMax(0, startX, endX);
    const maxY = calcMax(HALF_PI, startY, endY);
    const minX = calcMin(PI, startX, endX);
    const minY = calcMin(PI + HALF_PI, startY, endY);
    ratioX = (maxX - minX) / 2;
    ratioY = (maxY - minY) / 2;
    offsetX = -(maxX + minX) / 2;
    offsetY = -(maxY + minY) / 2;
  }
  return {
    ratioX,
    ratioY,
    offsetX,
    offsetY
  };
}
var DoughnutController = class extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.enableOptionSharing = true;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.offsetX = void 0;
    this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(start, count) {
    const data = this.getDataset().data;
    const meta = this._cachedMeta;
    if (this._parsing === false) {
      meta._parsed = data;
    } else {
      let getter = (i2) => +data[i2];
      if (isObject(data[start])) {
        const { key = "value" } = this._parsing;
        getter = (i2) => +resolveObjectKey(data[i2], key);
      }
      let i, ilen;
      for (i = start, ilen = start + count; i < ilen; ++i) {
        meta._parsed[i] = getter(i);
      }
    }
  }
  _getRotation() {
    return toRadians(this.options.rotation - 90);
  }
  _getCircumference() {
    return toRadians(this.options.circumference);
  }
  _getRotationExtents() {
    let min = TAU;
    let max = -TAU;
    for (let i = 0; i < this.chart.data.datasets.length; ++i) {
      if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {
        const controller = this.chart.getDatasetMeta(i).controller;
        const rotation = controller._getRotation();
        const circumference = controller._getCircumference();
        min = Math.min(min, rotation);
        max = Math.max(max, rotation + circumference);
      }
    }
    return {
      rotation: min,
      circumference: max - min
    };
  }
  update(mode) {
    const chart = this.chart;
    const { chartArea } = chart;
    const meta = this._cachedMeta;
    const arcs = meta.data;
    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
    const chartWeight = this._getRingWeight(this.index);
    const { circumference, rotation } = this._getRotationExtents();
    const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
    const maxWidth = (chartArea.width - spacing) / ratioX;
    const maxHeight = (chartArea.height - spacing) / ratioY;
    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
    const outerRadius = toDimension(this.options.radius, maxRadius);
    const innerRadius = Math.max(outerRadius * cutout, 0);
    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
    this.offsetX = offsetX * outerRadius;
    this.offsetY = offsetY * outerRadius;
    meta.total = this.calculateTotal();
    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  _circumference(i, reset) {
    const opts = this.options;
    const meta = this._cachedMeta;
    const circumference = this._getCircumference();
    if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
      return 0;
    }
    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const centerX = (chartArea.left + chartArea.right) / 2;
    const centerY = (chartArea.top + chartArea.bottom) / 2;
    const animateScale = reset && animationOpts.animateScale;
    const innerRadius = animateScale ? 0 : this.innerRadius;
    const outerRadius = animateScale ? 0 : this.outerRadius;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    let startAngle = this._getRotation();
    let i;
    for (i = 0; i < start; ++i) {
      startAngle += this._circumference(i, reset);
    }
    for (i = start; i < start + count; ++i) {
      const circumference = this._circumference(i, reset);
      const arc = arcs[i];
      const properties = {
        x: centerX + this.offsetX,
        y: centerY + this.offsetY,
        startAngle,
        endAngle: startAngle + circumference,
        circumference,
        outerRadius,
        innerRadius
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? "active" : mode);
      }
      startAngle += circumference;
      this.updateElement(arc, i, properties, mode);
    }
  }
  calculateTotal() {
    const meta = this._cachedMeta;
    const metaData = meta.data;
    let total = 0;
    let i;
    for (i = 0; i < metaData.length; i++) {
      const value = meta._parsed[i];
      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
        total += Math.abs(value);
      }
    }
    return total;
  }
  calculateCircumference(value) {
    const total = this._cachedMeta.total;
    if (total > 0 && !isNaN(value)) {
      return TAU * (Math.abs(value) / total);
    }
    return 0;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index], chart.options.locale);
    return {
      label: labels[index] || "",
      value
    };
  }
  getMaxBorderWidth(arcs) {
    let max = 0;
    const chart = this.chart;
    let i, ilen, meta, controller, options;
    if (!arcs) {
      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
        if (chart.isDatasetVisible(i)) {
          meta = chart.getDatasetMeta(i);
          arcs = meta.data;
          controller = meta.controller;
          break;
        }
      }
    }
    if (!arcs) {
      return 0;
    }
    for (i = 0, ilen = arcs.length; i < ilen; ++i) {
      options = controller.resolveDataElementOptions(i);
      if (options.borderAlign !== "inner") {
        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
      }
    }
    return max;
  }
  getMaxOffset(arcs) {
    let max = 0;
    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
      const options = this.resolveDataElementOptions(i);
      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
    }
    return max;
  }
  _getRingWeightOffset(datasetIndex) {
    let ringWeightOffset = 0;
    for (let i = 0; i < datasetIndex; ++i) {
      if (this.chart.isDatasetVisible(i)) {
        ringWeightOffset += this._getRingWeight(i);
      }
    }
    return ringWeightOffset;
  }
  _getRingWeight(datasetIndex) {
    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
};
__publicField(DoughnutController, "id", "doughnut");
__publicField(DoughnutController, "defaults", {
  datasetElementType: false,
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: false
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "circumference",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "startAngle",
        "x",
        "y",
        "offset",
        "borderWidth",
        "spacing"
      ]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
});
__publicField(DoughnutController, "descriptors", {
  _scriptable: (name) => name !== "spacing",
  _indexable: (name) => name !== "spacing" && !name.startsWith("borderDash") && !name.startsWith("hoverBorderDash")
});
__publicField(DoughnutController, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle, color: color3 } } = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                fontColor: color3,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    }
  }
});
function abstract() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
var DateAdapterBase = class {
  constructor(options) {
    __publicField(this, "options");
    this.options = options || {};
  }
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(members) {
    Object.assign(DateAdapterBase.prototype, members);
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  init() {
  }
  formats() {
    return abstract();
  }
  parse() {
    return abstract();
  }
  format() {
    return abstract();
  }
  add() {
    return abstract();
  }
  diff() {
    return abstract();
  }
  startOf() {
    return abstract();
  }
  endOf() {
    return abstract();
  }
};
var adapters = {
  _date: DateAdapterBase
};
function binarySearch(metaset, axis, value, intersect) {
  const { controller, data, _sorted } = metaset;
  const iScale = controller._cachedMeta.iScale;
  if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
    if (!intersect) {
      return lookupMethod(data, axis, value);
    } else if (controller._sharedOptions) {
      const el = data[0];
      const range = typeof el.getRange === "function" && el.getRange(axis);
      if (range) {
        const start = lookupMethod(data, axis, value - range);
        const end = lookupMethod(data, axis, value + range);
        return {
          lo: start.lo,
          hi: end.hi
        };
      }
    }
  }
  return {
    lo: 0,
    hi: data.length - 1
  };
}
function evaluateInteractionItems(chart, axis, position, handler, intersect) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  const value = position[axis];
  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
    const { index, data } = metasets[i];
    const { lo, hi } = binarySearch(metasets[i], axis, value, intersect);
    for (let j = lo; j <= hi; ++j) {
      const element = data[j];
      if (!element.skip) {
        handler(element, index, j);
      }
    }
  }
}
function getDistanceMetricForAxis(axis) {
  const useX = axis.indexOf("x") !== -1;
  const useY = axis.indexOf("y") !== -1;
  return function(pt1, pt2) {
    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
  };
}
function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
  const items = [];
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return items;
  }
  const evaluationFunc = function(element, datasetIndex, index) {
    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
      return;
    }
    if (element.inRange(position.x, position.y, useFinalPosition)) {
      items.push({
        element,
        datasetIndex,
        index
      });
    }
  };
  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
  return items;
}
function getNearestRadialItems(chart, position, axis, useFinalPosition) {
  let items = [];
  function evaluationFunc(element, datasetIndex, index) {
    const { startAngle, endAngle } = element.getProps([
      "startAngle",
      "endAngle"
    ], useFinalPosition);
    const { angle } = getAngleFromPoint(element, {
      x: position.x,
      y: position.y
    });
    if (_angleBetween(angle, startAngle, endAngle)) {
      items.push({
        element,
        datasetIndex,
        index
      });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  let items = [];
  const distanceMetric = getDistanceMetricForAxis(axis);
  let minDistance = Number.POSITIVE_INFINITY;
  function evaluationFunc(element, datasetIndex, index) {
    const inRange = element.inRange(position.x, position.y, useFinalPosition);
    if (intersect && !inRange) {
      return;
    }
    const center = element.getCenterPoint(useFinalPosition);
    const pointInArea = !!includeInvisible || chart.isPointInArea(center);
    if (!pointInArea && !inRange) {
      return;
    }
    const distance = distanceMetric(position, center);
    if (distance < minDistance) {
      items = [
        {
          element,
          datasetIndex,
          index
        }
      ];
      minDistance = distance;
    } else if (distance === minDistance) {
      items.push({
        element,
        datasetIndex,
        index
      });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return [];
  }
  return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
}
function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
  const items = [];
  const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
  let intersectsItem = false;
  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index) => {
    if (element[rangeMethod](position[axis], useFinalPosition)) {
      items.push({
        element,
        datasetIndex,
        index
      });
      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
    }
  });
  if (intersect && !intersectsItem) {
    return [];
  }
  return items;
}
var Interaction = {
  evaluateInteractionItems,
  modes: {
    index(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "x";
      const includeInvisible = options.includeInvisible || false;
      const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      const elements = [];
      if (!items.length) {
        return [];
      }
      chart.getSortedVisibleDatasetMetas().forEach((meta) => {
        const index = items[0].index;
        const element = meta.data[index];
        if (element && !element.skip) {
          elements.push({
            element,
            datasetIndex: meta.index,
            index
          });
        }
      });
      return elements;
    },
    dataset(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      if (items.length > 0) {
        const datasetIndex = items[0].datasetIndex;
        const data = chart.getDatasetMeta(datasetIndex).data;
        items = [];
        for (let i = 0; i < data.length; ++i) {
          items.push({
            element: data[i],
            datasetIndex,
            index: i
          });
        }
      }
      return items;
    },
    point(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
    },
    nearest(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
    },
    x(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
    },
    y(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
    }
  }
};
var STATIC_POSITIONS = [
  "left",
  "top",
  "right",
  "bottom"
];
function filterByPosition(array, position) {
  return array.filter((v) => v.pos === position);
}
function filterDynamicPositionByAxis(array, axis) {
  return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
}
function sortByWeight(array, reverse) {
  return array.sort((a, b) => {
    const v0 = reverse ? b : a;
    const v1 = reverse ? a : b;
    return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
  });
}
function wrapBoxes(boxes) {
  const layoutBoxes = [];
  let i, ilen, box, pos, stack, stackWeight;
  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
    box = boxes[i];
    ({ position: pos, options: { stack, stackWeight = 1 } } = box);
    layoutBoxes.push({
      index: i,
      box,
      pos,
      horizontal: box.isHorizontal(),
      weight: box.weight,
      stack: stack && pos + stack,
      stackWeight
    });
  }
  return layoutBoxes;
}
function buildStacks(layouts2) {
  const stacks = {};
  for (const wrap of layouts2) {
    const { stack, pos, stackWeight } = wrap;
    if (!stack || !STATIC_POSITIONS.includes(pos)) {
      continue;
    }
    const _stack = stacks[stack] || (stacks[stack] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    _stack.count++;
    _stack.weight += stackWeight;
  }
  return stacks;
}
function setLayoutDims(layouts2, params) {
  const stacks = buildStacks(layouts2);
  const { vBoxMaxWidth, hBoxMaxHeight } = params;
  let i, ilen, layout;
  for (i = 0, ilen = layouts2.length; i < ilen; ++i) {
    layout = layouts2[i];
    const { fullSize } = layout.box;
    const stack = stacks[layout.stack];
    const factor = stack && layout.stackWeight / stack.weight;
    if (layout.horizontal) {
      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
      layout.height = hBoxMaxHeight;
    } else {
      layout.width = vBoxMaxWidth;
      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
    }
  }
  return stacks;
}
function buildLayoutBoxes(boxes) {
  const layoutBoxes = wrapBoxes(boxes);
  const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
  const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
  const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
  const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
  const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
  return {
    fullSize,
    leftAndTop: left.concat(top),
    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
    chartArea: filterByPosition(layoutBoxes, "chartArea"),
    vertical: left.concat(right).concat(centerVertical),
    horizontal: top.concat(bottom).concat(centerHorizontal)
  };
}
function getCombinedMax(maxPadding, chartArea, a, b) {
  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
}
function updateMaxPadding(maxPadding, boxPadding) {
  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
  const { pos, box } = layout;
  const maxPadding = chartArea.maxPadding;
  if (!isObject(pos)) {
    if (layout.size) {
      chartArea[pos] -= layout.size;
    }
    const stack = stacks[layout.stack] || {
      size: 0,
      count: 1
    };
    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
    layout.size = stack.size / stack.count;
    chartArea[pos] += layout.size;
  }
  if (box.getPadding) {
    updateMaxPadding(maxPadding, box.getPadding());
  }
  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
  const widthChanged = newWidth !== chartArea.w;
  const heightChanged = newHeight !== chartArea.h;
  chartArea.w = newWidth;
  chartArea.h = newHeight;
  return layout.horizontal ? {
    same: widthChanged,
    other: heightChanged
  } : {
    same: heightChanged,
    other: widthChanged
  };
}
function handleMaxPadding(chartArea) {
  const maxPadding = chartArea.maxPadding;
  function updatePos(pos) {
    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
    chartArea[pos] += change;
    return change;
  }
  chartArea.y += updatePos("top");
  chartArea.x += updatePos("left");
  updatePos("right");
  updatePos("bottom");
}
function getMargins(horizontal, chartArea) {
  const maxPadding = chartArea.maxPadding;
  function marginForPositions(positions2) {
    const margin = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    positions2.forEach((pos) => {
      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
    });
    return margin;
  }
  return horizontal ? marginForPositions([
    "left",
    "right"
  ]) : marginForPositions([
    "top",
    "bottom"
  ]);
}
function fitBoxes(boxes, chartArea, params, stacks) {
  const refitBoxes = [];
  let i, ilen, layout, box, refit, changed;
  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
    layout = boxes[i];
    box = layout.box;
    box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
    const { same, other } = updateDims(chartArea, params, layout, stacks);
    refit |= same && refitBoxes.length;
    changed = changed || other;
    if (!box.fullSize) {
      refitBoxes.push(layout);
    }
  }
  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
function setBoxDims(box, left, top, width, height) {
  box.top = top;
  box.left = left;
  box.right = left + width;
  box.bottom = top + height;
  box.width = width;
  box.height = height;
}
function placeBoxes(boxes, chartArea, params, stacks) {
  const userPadding = params.padding;
  let { x, y } = chartArea;
  for (const layout of boxes) {
    const box = layout.box;
    const stack = stacks[layout.stack] || {
      count: 1,
      placed: 0,
      weight: 1
    };
    const weight = layout.stackWeight / stack.weight || 1;
    if (layout.horizontal) {
      const width = chartArea.w * weight;
      const height = stack.size || box.height;
      if (defined(stack.start)) {
        y = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
      } else {
        setBoxDims(box, chartArea.left + stack.placed, y, width, height);
      }
      stack.start = y;
      stack.placed += width;
      y = box.bottom;
    } else {
      const height = chartArea.h * weight;
      const width = stack.size || box.width;
      if (defined(stack.start)) {
        x = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
      } else {
        setBoxDims(box, x, chartArea.top + stack.placed, width, height);
      }
      stack.start = x;
      stack.placed += height;
      x = box.right;
    }
  }
  chartArea.x = x;
  chartArea.y = y;
}
var layouts = {
  addBox(chart, item) {
    if (!chart.boxes) {
      chart.boxes = [];
    }
    item.fullSize = item.fullSize || false;
    item.position = item.position || "top";
    item.weight = item.weight || 0;
    item._layers = item._layers || function() {
      return [
        {
          z: 0,
          draw(chartArea) {
            item.draw(chartArea);
          }
        }
      ];
    };
    chart.boxes.push(item);
  },
  removeBox(chart, layoutItem) {
    const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
    if (index !== -1) {
      chart.boxes.splice(index, 1);
    }
  },
  configure(chart, item, options) {
    item.fullSize = options.fullSize;
    item.position = options.position;
    item.weight = options.weight;
  },
  update(chart, width, height, minPadding) {
    if (!chart) {
      return;
    }
    const padding = toPadding(chart.options.layout.padding);
    const availableWidth = Math.max(width - padding.width, 0);
    const availableHeight = Math.max(height - padding.height, 0);
    const boxes = buildLayoutBoxes(chart.boxes);
    const verticalBoxes = boxes.vertical;
    const horizontalBoxes = boxes.horizontal;
    each(chart.boxes, (box) => {
      if (typeof box.beforeLayout === "function") {
        box.beforeLayout();
      }
    });
    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
    const params = Object.freeze({
      outerWidth: width,
      outerHeight: height,
      padding,
      availableWidth,
      availableHeight,
      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
      hBoxMaxHeight: availableHeight / 2
    });
    const maxPadding = Object.assign({}, padding);
    updateMaxPadding(maxPadding, toPadding(minPadding));
    const chartArea = Object.assign({
      maxPadding,
      w: availableWidth,
      h: availableHeight,
      x: padding.left,
      y: padding.top
    }, padding);
    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
    fitBoxes(boxes.fullSize, chartArea, params, stacks);
    fitBoxes(verticalBoxes, chartArea, params, stacks);
    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
      fitBoxes(verticalBoxes, chartArea, params, stacks);
    }
    handleMaxPadding(chartArea);
    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
    chartArea.x += chartArea.w;
    chartArea.y += chartArea.h;
    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
    chart.chartArea = {
      left: chartArea.left,
      top: chartArea.top,
      right: chartArea.left + chartArea.w,
      bottom: chartArea.top + chartArea.h,
      height: chartArea.h,
      width: chartArea.w
    };
    each(boxes.chartArea, (layout) => {
      const box = layout.box;
      Object.assign(box, chart.chartArea);
      box.update(chartArea.w, chartArea.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
var BasePlatform = class {
  acquireContext(canvas, aspectRatio) {
  }
  releaseContext(context) {
    return false;
  }
  addEventListener(chart, type, listener) {
  }
  removeEventListener(chart, type, listener) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(element, width, height, aspectRatio) {
    width = Math.max(0, width || element.width);
    height = height || element.height;
    return {
      width,
      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
    };
  }
  isAttached(canvas) {
    return true;
  }
  updateConfig(config) {
  }
};
var BasicPlatform = class extends BasePlatform {
  acquireContext(item) {
    return item && item.getContext && item.getContext("2d") || null;
  }
  updateConfig(config) {
    config.options.animation = false;
  }
};
var EXPANDO_KEY = "$chartjs";
var EVENT_TYPES = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
};
var isNullOrEmpty = (value) => value === null || value === "";
function initCanvas(canvas, aspectRatio) {
  const style = canvas.style;
  const renderHeight = canvas.getAttribute("height");
  const renderWidth = canvas.getAttribute("width");
  canvas[EXPANDO_KEY] = {
    initial: {
      height: renderHeight,
      width: renderWidth,
      style: {
        display: style.display,
        height: style.height,
        width: style.width
      }
    }
  };
  style.display = style.display || "block";
  style.boxSizing = style.boxSizing || "border-box";
  if (isNullOrEmpty(renderWidth)) {
    const displayWidth = readUsedSize(canvas, "width");
    if (displayWidth !== void 0) {
      canvas.width = displayWidth;
    }
  }
  if (isNullOrEmpty(renderHeight)) {
    if (canvas.style.height === "") {
      canvas.height = canvas.width / (aspectRatio || 2);
    } else {
      const displayHeight = readUsedSize(canvas, "height");
      if (displayHeight !== void 0) {
        canvas.height = displayHeight;
      }
    }
  }
  return canvas;
}
var eventListenerOptions = supportsEventListenerOptions ? {
  passive: true
} : false;
function addListener(node, type, listener) {
  if (node) {
    node.addEventListener(type, listener, eventListenerOptions);
  }
}
function removeListener(chart, type, listener) {
  if (chart && chart.canvas) {
    chart.canvas.removeEventListener(type, listener, eventListenerOptions);
  }
}
function fromNativeEvent(event, chart) {
  const type = EVENT_TYPES[event.type] || event.type;
  const { x, y } = getRelativePosition(event, chart);
  return {
    type,
    chart,
    native: event,
    x: x !== void 0 ? x : null,
    y: y !== void 0 ? y : null
  };
}
function nodeListContains(nodeList, canvas) {
  for (const node of nodeList) {
    if (node === canvas || node.contains(canvas)) {
      return true;
    }
  }
}
function createAttachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.addedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
function createDetachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.removedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
var drpListeningCharts = /* @__PURE__ */ new Map();
var oldDevicePixelRatio = 0;
function onWindowResize() {
  const dpr = window.devicePixelRatio;
  if (dpr === oldDevicePixelRatio) {
    return;
  }
  oldDevicePixelRatio = dpr;
  drpListeningCharts.forEach((resize, chart) => {
    if (chart.currentDevicePixelRatio !== dpr) {
      resize();
    }
  });
}
function listenDevicePixelRatioChanges(chart, resize) {
  if (!drpListeningCharts.size) {
    window.addEventListener("resize", onWindowResize);
  }
  drpListeningCharts.set(chart, resize);
}
function unlistenDevicePixelRatioChanges(chart) {
  drpListeningCharts.delete(chart);
  if (!drpListeningCharts.size) {
    window.removeEventListener("resize", onWindowResize);
  }
}
function createResizeObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const container = canvas && _getParentNode(canvas);
  if (!container) {
    return;
  }
  const resize = throttled((width, height) => {
    const w = container.clientWidth;
    listener(width, height);
    if (w < container.clientWidth) {
      listener();
    }
  }, window);
  const observer = new ResizeObserver((entries) => {
    const entry = entries[0];
    const width = entry.contentRect.width;
    const height = entry.contentRect.height;
    if (width === 0 && height === 0) {
      return;
    }
    resize(width, height);
  });
  observer.observe(container);
  listenDevicePixelRatioChanges(chart, resize);
  return observer;
}
function releaseObserver(chart, type, observer) {
  if (observer) {
    observer.disconnect();
  }
  if (type === "resize") {
    unlistenDevicePixelRatioChanges(chart);
  }
}
function createProxyAndListen(chart, type, listener) {
  const canvas = chart.canvas;
  const proxy = throttled((event) => {
    if (chart.ctx !== null) {
      listener(fromNativeEvent(event, chart));
    }
  }, chart);
  addListener(canvas, type, proxy);
  return proxy;
}
var DomPlatform = class extends BasePlatform {
  acquireContext(canvas, aspectRatio) {
    const context = canvas && canvas.getContext && canvas.getContext("2d");
    if (context && context.canvas === canvas) {
      initCanvas(canvas, aspectRatio);
      return context;
    }
    return null;
  }
  releaseContext(context) {
    const canvas = context.canvas;
    if (!canvas[EXPANDO_KEY]) {
      return false;
    }
    const initial = canvas[EXPANDO_KEY].initial;
    [
      "height",
      "width"
    ].forEach((prop) => {
      const value = initial[prop];
      if (isNullOrUndef(value)) {
        canvas.removeAttribute(prop);
      } else {
        canvas.setAttribute(prop, value);
      }
    });
    const style = initial.style || {};
    Object.keys(style).forEach((key) => {
      canvas.style[key] = style[key];
    });
    canvas.width = canvas.width;
    delete canvas[EXPANDO_KEY];
    return true;
  }
  addEventListener(chart, type, listener) {
    this.removeEventListener(chart, type);
    const proxies = chart.$proxies || (chart.$proxies = {});
    const handlers = {
      attach: createAttachObserver,
      detach: createDetachObserver,
      resize: createResizeObserver
    };
    const handler = handlers[type] || createProxyAndListen;
    proxies[type] = handler(chart, type, listener);
  }
  removeEventListener(chart, type) {
    const proxies = chart.$proxies || (chart.$proxies = {});
    const proxy = proxies[type];
    if (!proxy) {
      return;
    }
    const handlers = {
      attach: releaseObserver,
      detach: releaseObserver,
      resize: releaseObserver
    };
    const handler = handlers[type] || removeListener;
    handler(chart, type, proxy);
    proxies[type] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(canvas, width, height, aspectRatio) {
    return getMaximumSize(canvas, width, height, aspectRatio);
  }
  isAttached(canvas) {
    const container = _getParentNode(canvas);
    return !!(container && container.isConnected);
  }
};
function _detectPlatform(canvas) {
  if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
    return BasicPlatform;
  }
  return DomPlatform;
}
var Element = class {
  constructor() {
    __publicField(this, "x");
    __publicField(this, "y");
    __publicField(this, "active", false);
    __publicField(this, "options");
    __publicField(this, "$animations");
  }
  tooltipPosition(useFinalPosition) {
    const { x, y } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return {
      x,
      y
    };
  }
  hasValue() {
    return isNumber(this.x) && isNumber(this.y);
  }
  getProps(props, final) {
    const anims = this.$animations;
    if (!final || !anims) {
      return this;
    }
    const ret = {};
    props.forEach((prop) => {
      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
    });
    return ret;
  }
};
__publicField(Element, "defaults", {});
__publicField(Element, "defaultRoutes");
function autoSkip(scale, ticks) {
  const tickOpts = scale.options.ticks;
  const determinedMaxTicks = determineMaxTicks(scale);
  const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
  const numMajorIndices = majorIndices.length;
  const first = majorIndices[0];
  const last = majorIndices[numMajorIndices - 1];
  const newTicks = [];
  if (numMajorIndices > ticksLimit) {
    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
    return newTicks;
  }
  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
  if (numMajorIndices > 0) {
    let i, ilen;
    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
    }
    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
    return newTicks;
  }
  skip(ticks, newTicks, spacing);
  return newTicks;
}
function determineMaxTicks(scale) {
  const offset2 = scale.options.offset;
  const tickLength = scale._tickSize();
  const maxScale = scale._length / tickLength + (offset2 ? 0 : 1);
  const maxChart = scale._maxLength / tickLength;
  return Math.floor(Math.min(maxScale, maxChart));
}
function calculateSpacing(majorIndices, ticks, ticksLimit) {
  const evenMajorSpacing = getEvenSpacing(majorIndices);
  const spacing = ticks.length / ticksLimit;
  if (!evenMajorSpacing) {
    return Math.max(spacing, 1);
  }
  const factors = _factorize(evenMajorSpacing);
  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
    const factor = factors[i];
    if (factor > spacing) {
      return factor;
    }
  }
  return Math.max(spacing, 1);
}
function getMajorIndices(ticks) {
  const result = [];
  let i, ilen;
  for (i = 0, ilen = ticks.length; i < ilen; i++) {
    if (ticks[i].major) {
      result.push(i);
    }
  }
  return result;
}
function skipMajors(ticks, newTicks, majorIndices, spacing) {
  let count = 0;
  let next = majorIndices[0];
  let i;
  spacing = Math.ceil(spacing);
  for (i = 0; i < ticks.length; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = majorIndices[count * spacing];
    }
  }
}
function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
  const start = valueOrDefault(majorStart, 0);
  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
  let count = 0;
  let length, i, next;
  spacing = Math.ceil(spacing);
  if (majorEnd) {
    length = majorEnd - majorStart;
    spacing = length / Math.floor(length / spacing);
  }
  next = start;
  while (next < 0) {
    count++;
    next = Math.round(start + count * spacing);
  }
  for (i = Math.max(start, 0); i < end; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = Math.round(start + count * spacing);
    }
  }
}
function getEvenSpacing(arr) {
  const len = arr.length;
  let i, diff;
  if (len < 2) {
    return false;
  }
  for (diff = arr[0], i = 1; i < len; ++i) {
    if (arr[i] - arr[i - 1] !== diff) {
      return false;
    }
  }
  return diff;
}
var reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
var offsetFromEdge = (scale, edge, offset2) => edge === "top" || edge === "left" ? scale[edge] + offset2 : scale[edge] - offset2;
var getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);
function sample(arr, numItems) {
  const result = [];
  const increment = arr.length / numItems;
  const len = arr.length;
  let i = 0;
  for (; i < len; i += increment) {
    result.push(arr[Math.floor(i)]);
  }
  return result;
}
function getPixelForGridLine(scale, index, offsetGridLines) {
  const length = scale.ticks.length;
  const validIndex = Math.min(index, length - 1);
  const start = scale._startPixel;
  const end = scale._endPixel;
  const epsilon = 1e-6;
  let lineValue = scale.getPixelForTick(validIndex);
  let offset2;
  if (offsetGridLines) {
    if (length === 1) {
      offset2 = Math.max(lineValue - start, end - lineValue);
    } else if (index === 0) {
      offset2 = (scale.getPixelForTick(1) - lineValue) / 2;
    } else {
      offset2 = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;
    }
    lineValue += validIndex < index ? offset2 : -offset2;
    if (lineValue < start - epsilon || lineValue > end + epsilon) {
      return;
    }
  }
  return lineValue;
}
function garbageCollect(caches, length) {
  each(caches, (cache) => {
    const gc = cache.gc;
    const gcLen = gc.length / 2;
    let i;
    if (gcLen > length) {
      for (i = 0; i < gcLen; ++i) {
        delete cache.data[gc[i]];
      }
      gc.splice(0, gcLen);
    }
  });
}
function getTickMarkLength(options) {
  return options.drawTicks ? options.tickLength : 0;
}
function getTitleHeight(options, fallback) {
  if (!options.display) {
    return 0;
  }
  const font = toFont(options.font, fallback);
  const padding = toPadding(options.padding);
  const lines = isArray(options.text) ? options.text.length : 1;
  return lines * font.lineHeight + padding.height;
}
function createScaleContext(parent, scale) {
  return createContext(parent, {
    scale,
    type: "scale"
  });
}
function createTickContext(parent, index, tick) {
  return createContext(parent, {
    tick,
    index,
    type: "tick"
  });
}
function titleAlign(align, position, reverse) {
  let ret = _toLeftRightCenter(align);
  if (reverse && position !== "right" || !reverse && position === "right") {
    ret = reverseAlign(ret);
  }
  return ret;
}
function titleArgs(scale, offset2, position, align) {
  const { top, left, bottom, right, chart } = scale;
  const { chartArea, scales } = chart;
  let rotation = 0;
  let maxWidth, titleX, titleY;
  const height = bottom - top;
  const width = right - left;
  if (scale.isHorizontal()) {
    titleX = _alignStartEnd(align, left, right);
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleY = scales[positionAxisID].getPixelForValue(value) + height - offset2;
    } else if (position === "center") {
      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset2;
    } else {
      titleY = offsetFromEdge(scale, position, offset2);
    }
    maxWidth = right - left;
  } else {
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleX = scales[positionAxisID].getPixelForValue(value) - width + offset2;
    } else if (position === "center") {
      titleX = (chartArea.left + chartArea.right) / 2 - width + offset2;
    } else {
      titleX = offsetFromEdge(scale, position, offset2);
    }
    titleY = _alignStartEnd(align, bottom, top);
    rotation = position === "left" ? -HALF_PI : HALF_PI;
  }
  return {
    titleX,
    titleY,
    maxWidth,
    rotation
  };
}
var Scale = class extends Element {
  constructor(cfg) {
    super();
    this.id = cfg.id;
    this.type = cfg.type;
    this.options = void 0;
    this.ctx = cfg.ctx;
    this.chart = cfg.chart;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.maxWidth = void 0;
    this.maxHeight = void 0;
    this.paddingTop = void 0;
    this.paddingBottom = void 0;
    this.paddingLeft = void 0;
    this.paddingRight = void 0;
    this.axis = void 0;
    this.labelRotation = void 0;
    this.min = void 0;
    this.max = void 0;
    this._range = void 0;
    this.ticks = [];
    this._gridLineItems = null;
    this._labelItems = null;
    this._labelSizes = null;
    this._length = 0;
    this._maxLength = 0;
    this._longestTextCache = {};
    this._startPixel = void 0;
    this._endPixel = void 0;
    this._reversePixels = false;
    this._userMax = void 0;
    this._userMin = void 0;
    this._suggestedMax = void 0;
    this._suggestedMin = void 0;
    this._ticksLength = 0;
    this._borderValue = 0;
    this._cache = {};
    this._dataLimitsCached = false;
    this.$context = void 0;
  }
  init(options) {
    this.options = options.setContext(this.getContext());
    this.axis = options.axis;
    this._userMin = this.parse(options.min);
    this._userMax = this.parse(options.max);
    this._suggestedMin = this.parse(options.suggestedMin);
    this._suggestedMax = this.parse(options.suggestedMax);
  }
  parse(raw, index) {
    return raw;
  }
  getUserBounds() {
    let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
    return {
      min: finiteOrDefault(_userMin, _suggestedMin),
      max: finiteOrDefault(_userMax, _suggestedMax),
      minDefined: isNumberFinite(_userMin),
      maxDefined: isNumberFinite(_userMax)
    };
  }
  getMinMax(canStack) {
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    let range;
    if (minDefined && maxDefined) {
      return {
        min,
        max
      };
    }
    const metas = this.getMatchingVisibleMetas();
    for (let i = 0, ilen = metas.length; i < ilen; ++i) {
      range = metas[i].controller.getMinMax(this, canStack);
      if (!minDefined) {
        min = Math.min(min, range.min);
      }
      if (!maxDefined) {
        max = Math.max(max, range.max);
      }
    }
    min = maxDefined && min > max ? max : min;
    max = minDefined && min > max ? min : max;
    return {
      min: finiteOrDefault(min, finiteOrDefault(max, min)),
      max: finiteOrDefault(max, finiteOrDefault(min, max))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const data = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
  }
  getLabelItems(chartArea = this.chart.chartArea) {
    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
    return items;
  }
  beforeLayout() {
    this._cache = {};
    this._dataLimitsCached = false;
  }
  beforeUpdate() {
    callback(this.options.beforeUpdate, [
      this
    ]);
  }
  update(maxWidth, maxHeight, margins) {
    const { beginAtZero, grace, ticks: tickOpts } = this.options;
    const sampleSize = tickOpts.sampleSize;
    this.beforeUpdate();
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, margins);
    this.ticks = null;
    this._labelSizes = null;
    this._gridLineItems = null;
    this._labelItems = null;
    this.beforeSetDimensions();
    this.setDimensions();
    this.afterSetDimensions();
    this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
    if (!this._dataLimitsCached) {
      this.beforeDataLimits();
      this.determineDataLimits();
      this.afterDataLimits();
      this._range = _addGrace(this, grace, beginAtZero);
      this._dataLimitsCached = true;
    }
    this.beforeBuildTicks();
    this.ticks = this.buildTicks() || [];
    this.afterBuildTicks();
    const samplingEnabled = sampleSize < this.ticks.length;
    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
    this.configure();
    this.beforeCalculateLabelRotation();
    this.calculateLabelRotation();
    this.afterCalculateLabelRotation();
    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
      this.ticks = autoSkip(this, this.ticks);
      this._labelSizes = null;
      this.afterAutoSkip();
    }
    if (samplingEnabled) {
      this._convertTicksToLabels(this.ticks);
    }
    this.beforeFit();
    this.fit();
    this.afterFit();
    this.afterUpdate();
  }
  configure() {
    let reversePixels = this.options.reverse;
    let startPixel, endPixel;
    if (this.isHorizontal()) {
      startPixel = this.left;
      endPixel = this.right;
    } else {
      startPixel = this.top;
      endPixel = this.bottom;
      reversePixels = !reversePixels;
    }
    this._startPixel = startPixel;
    this._endPixel = endPixel;
    this._reversePixels = reversePixels;
    this._length = endPixel - startPixel;
    this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    callback(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    callback(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = 0;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = 0;
      this.bottom = this.height;
    }
    this.paddingLeft = 0;
    this.paddingTop = 0;
    this.paddingRight = 0;
    this.paddingBottom = 0;
  }
  afterSetDimensions() {
    callback(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(name) {
    this.chart.notifyPlugins(name, this.getContext());
    callback(this.options[name], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    callback(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(ticks) {
    const tickOpts = this.options.ticks;
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      tick = ticks[i];
      tick.label = callback(tickOpts.callback, [
        tick.value,
        i,
        ticks
      ], this);
    }
  }
  afterTickToLabelConversion() {
    callback(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    callback(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const options = this.options;
    const tickOpts = options.ticks;
    const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);
    const minRotation = tickOpts.minRotation || 0;
    const maxRotation = tickOpts.maxRotation;
    let labelRotation = minRotation;
    let tickWidth, maxHeight, maxLabelDiagonal;
    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
      this.labelRotation = minRotation;
      return;
    }
    const labelSizes = this._getLabelSizes();
    const maxLabelWidth = labelSizes.widest.width;
    const maxLabelHeight = labelSizes.highest.height;
    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
    if (maxLabelWidth + 6 > tickWidth) {
      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
      maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
      labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
    }
    this.labelRotation = labelRotation;
  }
  afterCalculateLabelRotation() {
    callback(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    callback(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const minSize = {
      width: 0,
      height: 0
    };
    const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
    const display = this._isVisible();
    const isHorizontal = this.isHorizontal();
    if (display) {
      const titleHeight = getTitleHeight(titleOpts, chart.options.font);
      if (isHorizontal) {
        minSize.width = this.maxWidth;
        minSize.height = getTickMarkLength(gridOpts) + titleHeight;
      } else {
        minSize.height = this.maxHeight;
        minSize.width = getTickMarkLength(gridOpts) + titleHeight;
      }
      if (tickOpts.display && this.ticks.length) {
        const { first, last, widest, highest } = this._getLabelSizes();
        const tickPadding = tickOpts.padding * 2;
        const angleRadians = toRadians(this.labelRotation);
        const cos = Math.cos(angleRadians);
        const sin = Math.sin(angleRadians);
        if (isHorizontal) {
          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
        } else {
          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
        }
        this._calculatePadding(first, last, sin, cos);
      }
    }
    this._handleMargins();
    if (isHorizontal) {
      this.width = this._length = chart.width - this._margins.left - this._margins.right;
      this.height = minSize.height;
    } else {
      this.width = minSize.width;
      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
    }
  }
  _calculatePadding(first, last, sin, cos) {
    const { ticks: { align, padding }, position } = this.options;
    const isRotated = this.labelRotation !== 0;
    const labelsBelowTicks = position !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const offsetLeft = this.getPixelForTick(0) - this.left;
      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
      let paddingLeft = 0;
      let paddingRight = 0;
      if (isRotated) {
        if (labelsBelowTicks) {
          paddingLeft = cos * first.width;
          paddingRight = sin * last.height;
        } else {
          paddingLeft = sin * first.height;
          paddingRight = cos * last.width;
        }
      } else if (align === "start") {
        paddingRight = last.width;
      } else if (align === "end") {
        paddingLeft = first.width;
      } else if (align !== "inner") {
        paddingLeft = first.width / 2;
        paddingRight = last.width / 2;
      }
      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
    } else {
      let paddingTop = last.height / 2;
      let paddingBottom = first.height / 2;
      if (align === "start") {
        paddingTop = 0;
        paddingBottom = first.height;
      } else if (align === "end") {
        paddingTop = last.height;
        paddingBottom = 0;
      }
      this.paddingTop = paddingTop + padding;
      this.paddingBottom = paddingBottom + padding;
    }
  }
  _handleMargins() {
    if (this._margins) {
      this._margins.left = Math.max(this.paddingLeft, this._margins.left);
      this._margins.top = Math.max(this.paddingTop, this._margins.top);
      this._margins.right = Math.max(this.paddingRight, this._margins.right);
      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
    }
  }
  afterFit() {
    callback(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis, position } = this.options;
    return position === "top" || position === "bottom" || axis === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(ticks) {
    this.beforeTickToLabelConversion();
    this.generateTickLabels(ticks);
    let i, ilen;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      if (isNullOrUndef(ticks[i].label)) {
        ticks.splice(i, 1);
        ilen--;
        i--;
      }
    }
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let labelSizes = this._labelSizes;
    if (!labelSizes) {
      const sampleSize = this.options.ticks.sampleSize;
      let ticks = this.ticks;
      if (sampleSize < ticks.length) {
        ticks = sample(ticks, sampleSize);
      }
      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
    }
    return labelSizes;
  }
  _computeLabelSizes(ticks, length, maxTicksLimit) {
    const { ctx, _longestTextCache: caches } = this;
    const widths = [];
    const heights = [];
    const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));
    let widestLabelSize = 0;
    let highestLabelSize = 0;
    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
    for (i = 0; i < length; i += increment) {
      label = ticks[i].label;
      tickFont = this._resolveTickFontOptions(i);
      ctx.font = fontString = tickFont.string;
      cache = caches[fontString] = caches[fontString] || {
        data: {},
        gc: []
      };
      lineHeight = tickFont.lineHeight;
      width = height = 0;
      if (!isNullOrUndef(label) && !isArray(label)) {
        width = _measureText(ctx, cache.data, cache.gc, width, label);
        height = lineHeight;
      } else if (isArray(label)) {
        for (j = 0, jlen = label.length; j < jlen; ++j) {
          nestedLabel = label[j];
          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
            height += lineHeight;
          }
        }
      }
      widths.push(width);
      heights.push(height);
      widestLabelSize = Math.max(width, widestLabelSize);
      highestLabelSize = Math.max(height, highestLabelSize);
    }
    garbageCollect(caches, length);
    const widest = widths.indexOf(widestLabelSize);
    const highest = heights.indexOf(highestLabelSize);
    const valueAt = (idx) => ({
      width: widths[idx] || 0,
      height: heights[idx] || 0
    });
    return {
      first: valueAt(0),
      last: valueAt(length - 1),
      widest: valueAt(widest),
      highest: valueAt(highest),
      widths,
      heights
    };
  }
  getLabelForValue(value) {
    return value;
  }
  getPixelForValue(value, index) {
    return NaN;
  }
  getValueForPixel(pixel) {
  }
  getPixelForTick(index) {
    const ticks = this.ticks;
    if (index < 0 || index > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index].value);
  }
  getPixelForDecimal(decimal) {
    if (this._reversePixels) {
      decimal = 1 - decimal;
    }
    const pixel = this._startPixel + decimal * this._length;
    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
  }
  getDecimalForPixel(pixel) {
    const decimal = (pixel - this._startPixel) / this._length;
    return this._reversePixels ? 1 - decimal : decimal;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min, max } = this;
    return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
  }
  getContext(index) {
    const ticks = this.ticks || [];
    if (index >= 0 && index < ticks.length) {
      const tick = ticks[index];
      return tick.$context || (tick.$context = createTickContext(this.getContext(), index, tick));
    }
    return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
  }
  _tickSize() {
    const optionTicks = this.options.ticks;
    const rot = toRadians(this.labelRotation);
    const cos = Math.abs(Math.cos(rot));
    const sin = Math.abs(Math.sin(rot));
    const labelSizes = this._getLabelSizes();
    const padding = optionTicks.autoSkipPadding || 0;
    const w = labelSizes ? labelSizes.widest.width + padding : 0;
    const h = labelSizes ? labelSizes.highest.height + padding : 0;
    return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
  }
  _isVisible() {
    const display = this.options.display;
    if (display !== "auto") {
      return !!display;
    }
    return this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(chartArea) {
    const axis = this.axis;
    const chart = this.chart;
    const options = this.options;
    const { grid, position, border } = options;
    const offset2 = grid.offset;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const ticksLength = ticks.length + (offset2 ? 1 : 0);
    const tl = getTickMarkLength(grid);
    const items = [];
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = borderOpts.display ? borderOpts.width : 0;
    const axisHalfWidth = axisWidth / 2;
    const alignBorderValue = function(pixel) {
      return _alignPixel(chart, pixel, axisWidth);
    };
    let borderValue, i, lineValue, alignedLineValue;
    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
    if (position === "top") {
      borderValue = alignBorderValue(this.bottom);
      ty1 = this.bottom - tl;
      ty2 = borderValue - axisHalfWidth;
      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
      y2 = chartArea.bottom;
    } else if (position === "bottom") {
      borderValue = alignBorderValue(this.top);
      y1 = chartArea.top;
      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
      ty1 = borderValue + axisHalfWidth;
      ty2 = this.top + tl;
    } else if (position === "left") {
      borderValue = alignBorderValue(this.right);
      tx1 = this.right - tl;
      tx2 = borderValue - axisHalfWidth;
      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
      x2 = chartArea.right;
    } else if (position === "right") {
      borderValue = alignBorderValue(this.left);
      x1 = chartArea.left;
      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
      tx1 = borderValue + axisHalfWidth;
      tx2 = this.left + tl;
    } else if (axis === "x") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      y1 = chartArea.top;
      y2 = chartArea.bottom;
      ty1 = borderValue + axisHalfWidth;
      ty2 = ty1 + tl;
    } else if (axis === "y") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      tx1 = borderValue - axisHalfWidth;
      tx2 = tx1 - tl;
      x1 = chartArea.left;
      x2 = chartArea.right;
    }
    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
    const step = Math.max(1, Math.ceil(ticksLength / limit));
    for (i = 0; i < ticksLength; i += step) {
      const context = this.getContext(i);
      const optsAtIndex = grid.setContext(context);
      const optsAtIndexBorder = border.setContext(context);
      const lineWidth = optsAtIndex.lineWidth;
      const lineColor = optsAtIndex.color;
      const borderDash = optsAtIndexBorder.dash || [];
      const borderDashOffset = optsAtIndexBorder.dashOffset;
      const tickWidth = optsAtIndex.tickWidth;
      const tickColor = optsAtIndex.tickColor;
      const tickBorderDash = optsAtIndex.tickBorderDash || [];
      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
      lineValue = getPixelForGridLine(this, i, offset2);
      if (lineValue === void 0) {
        continue;
      }
      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
      if (isHorizontal) {
        tx1 = tx2 = x1 = x2 = alignedLineValue;
      } else {
        ty1 = ty2 = y1 = y2 = alignedLineValue;
      }
      items.push({
        tx1,
        ty1,
        tx2,
        ty2,
        x1,
        y1,
        x2,
        y2,
        width: lineWidth,
        color: lineColor,
        borderDash,
        borderDashOffset,
        tickWidth,
        tickColor,
        tickBorderDash,
        tickBorderDashOffset
      });
    }
    this._ticksLength = ticksLength;
    this._borderValue = borderValue;
    return items;
  }
  _computeLabelItems(chartArea) {
    const axis = this.axis;
    const options = this.options;
    const { position, ticks: optionTicks } = options;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const { align, crossAlign, padding, mirror } = optionTicks;
    const tl = getTickMarkLength(options.grid);
    const tickAndPadding = tl + padding;
    const hTickAndPadding = mirror ? -padding : tickAndPadding;
    const rotation = -toRadians(this.labelRotation);
    const items = [];
    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
    let textBaseline = "middle";
    if (position === "top") {
      y = this.bottom - hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "bottom") {
      y = this.top + hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "left") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (position === "right") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (axis === "x") {
      if (position === "center") {
        y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
      }
      textAlign = this._getXAxisLabelAlignment();
    } else if (axis === "y") {
      if (position === "center") {
        x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        x = this.chart.scales[positionAxisID].getPixelForValue(value);
      }
      textAlign = this._getYAxisLabelAlignment(tl).textAlign;
    }
    if (axis === "y") {
      if (align === "start") {
        textBaseline = "top";
      } else if (align === "end") {
        textBaseline = "bottom";
      }
    }
    const labelSizes = this._getLabelSizes();
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      label = tick.label;
      const optsAtIndex = optionTicks.setContext(this.getContext(i));
      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
      font = this._resolveTickFontOptions(i);
      lineHeight = font.lineHeight;
      lineCount = isArray(label) ? label.length : 1;
      const halfCount = lineCount / 2;
      const color3 = optsAtIndex.color;
      const strokeColor = optsAtIndex.textStrokeColor;
      const strokeWidth = optsAtIndex.textStrokeWidth;
      let tickTextAlign = textAlign;
      if (isHorizontal) {
        x = pixel;
        if (textAlign === "inner") {
          if (i === ilen - 1) {
            tickTextAlign = !this.options.reverse ? "right" : "left";
          } else if (i === 0) {
            tickTextAlign = !this.options.reverse ? "left" : "right";
          } else {
            tickTextAlign = "center";
          }
        }
        if (position === "top") {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = -lineCount * lineHeight + lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
          } else {
            textOffset = -labelSizes.highest.height + lineHeight / 2;
          }
        } else {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
          } else {
            textOffset = labelSizes.highest.height - lineCount * lineHeight;
          }
        }
        if (mirror) {
          textOffset *= -1;
        }
        if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
          x += lineHeight / 2 * Math.sin(rotation);
        }
      } else {
        y = pixel;
        textOffset = (1 - lineCount) * lineHeight / 2;
      }
      let backdrop;
      if (optsAtIndex.showLabelBackdrop) {
        const labelPadding = toPadding(optsAtIndex.backdropPadding);
        const height = labelSizes.heights[i];
        const width = labelSizes.widths[i];
        let top = textOffset - labelPadding.top;
        let left = 0 - labelPadding.left;
        switch (textBaseline) {
          case "middle":
            top -= height / 2;
            break;
          case "bottom":
            top -= height;
            break;
        }
        switch (textAlign) {
          case "center":
            left -= width / 2;
            break;
          case "right":
            left -= width;
            break;
          case "inner":
            if (i === ilen - 1) {
              left -= width;
            } else if (i > 0) {
              left -= width / 2;
            }
            break;
        }
        backdrop = {
          left,
          top,
          width: width + labelPadding.width,
          height: height + labelPadding.height,
          color: optsAtIndex.backdropColor
        };
      }
      items.push({
        label,
        font,
        textOffset,
        options: {
          rotation,
          color: color3,
          strokeColor,
          strokeWidth,
          textAlign: tickTextAlign,
          textBaseline,
          translation: [
            x,
            y
          ],
          backdrop
        }
      });
    }
    return items;
  }
  _getXAxisLabelAlignment() {
    const { position, ticks } = this.options;
    const rotation = -toRadians(this.labelRotation);
    if (rotation) {
      return position === "top" ? "left" : "right";
    }
    let align = "center";
    if (ticks.align === "start") {
      align = "left";
    } else if (ticks.align === "end") {
      align = "right";
    } else if (ticks.align === "inner") {
      align = "inner";
    }
    return align;
  }
  _getYAxisLabelAlignment(tl) {
    const { position, ticks: { crossAlign, mirror, padding } } = this.options;
    const labelSizes = this._getLabelSizes();
    const tickAndPadding = tl + padding;
    const widest = labelSizes.widest.width;
    let textAlign;
    let x;
    if (position === "left") {
      if (mirror) {
        x = this.right + padding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x += widest;
        }
      } else {
        x = this.right - tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x = this.left;
        }
      }
    } else if (position === "right") {
      if (mirror) {
        x = this.left + padding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x -= widest;
        }
      } else {
        x = this.left + tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x = this.right;
        }
      }
    } else {
      textAlign = "right";
    }
    return {
      textAlign,
      x
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror) {
      return;
    }
    const chart = this.chart;
    const position = this.options.position;
    if (position === "left" || position === "right") {
      return {
        top: 0,
        left: this.left,
        bottom: chart.height,
        right: this.right
      };
    }
    if (position === "top" || position === "bottom") {
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: chart.width
      };
    }
  }
  drawBackground() {
    const { ctx, options: { backgroundColor }, left, top, width, height } = this;
    if (backgroundColor) {
      ctx.save();
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(left, top, width, height);
      ctx.restore();
    }
  }
  getLineWidthForValue(value) {
    const grid = this.options.grid;
    if (!this._isVisible() || !grid.display) {
      return 0;
    }
    const ticks = this.ticks;
    const index = ticks.findIndex((t) => t.value === value);
    if (index >= 0) {
      const opts = grid.setContext(this.getContext(index));
      return opts.lineWidth;
    }
    return 0;
  }
  drawGrid(chartArea) {
    const grid = this.options.grid;
    const ctx = this.ctx;
    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
    let i, ilen;
    const drawLine = (p1, p2, style) => {
      if (!style.width || !style.color) {
        return;
      }
      ctx.save();
      ctx.lineWidth = style.width;
      ctx.strokeStyle = style.color;
      ctx.setLineDash(style.borderDash || []);
      ctx.lineDashOffset = style.borderDashOffset;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
      ctx.restore();
    };
    if (grid.display) {
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        const item = items[i];
        if (grid.drawOnChartArea) {
          drawLine({
            x: item.x1,
            y: item.y1
          }, {
            x: item.x2,
            y: item.y2
          }, item);
        }
        if (grid.drawTicks) {
          drawLine({
            x: item.tx1,
            y: item.ty1
          }, {
            x: item.tx2,
            y: item.ty2
          }, {
            color: item.tickColor,
            width: item.tickWidth,
            borderDash: item.tickBorderDash,
            borderDashOffset: item.tickBorderDashOffset
          });
        }
      }
    }
  }
  drawBorder() {
    const { chart, ctx, options: { border, grid } } = this;
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = border.display ? borderOpts.width : 0;
    if (!axisWidth) {
      return;
    }
    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
    const borderValue = this._borderValue;
    let x1, x2, y1, y2;
    if (this.isHorizontal()) {
      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
      y1 = y2 = borderValue;
    } else {
      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
      x1 = x2 = borderValue;
    }
    ctx.save();
    ctx.lineWidth = borderOpts.width;
    ctx.strokeStyle = borderOpts.color;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }
  drawLabels(chartArea) {
    const optionTicks = this.options.ticks;
    if (!optionTicks.display) {
      return;
    }
    const ctx = this.ctx;
    const area = this._computeLabelArea();
    if (area) {
      clipArea(ctx, area);
    }
    const items = this.getLabelItems(chartArea);
    for (const item of items) {
      const renderTextOptions = item.options;
      const tickFont = item.font;
      const label = item.label;
      const y = item.textOffset;
      renderText(ctx, label, 0, y, tickFont, renderTextOptions);
    }
    if (area) {
      unclipArea(ctx);
    }
  }
  drawTitle() {
    const { ctx, options: { position, title, reverse } } = this;
    if (!title.display) {
      return;
    }
    const font = toFont(title.font);
    const padding = toPadding(title.padding);
    const align = title.align;
    let offset2 = font.lineHeight / 2;
    if (position === "bottom" || position === "center" || isObject(position)) {
      offset2 += padding.bottom;
      if (isArray(title.text)) {
        offset2 += font.lineHeight * (title.text.length - 1);
      }
    } else {
      offset2 += padding.top;
    }
    const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset2, position, align);
    renderText(ctx, title.text, 0, 0, font, {
      color: title.color,
      maxWidth,
      rotation,
      textAlign: titleAlign(align, position, reverse),
      textBaseline: "middle",
      translation: [
        titleX,
        titleY
      ]
    });
  }
  draw(chartArea) {
    if (!this._isVisible()) {
      return;
    }
    this.drawBackground();
    this.drawGrid(chartArea);
    this.drawBorder();
    this.drawTitle();
    this.drawLabels(chartArea);
  }
  _layers() {
    const opts = this.options;
    const tz = opts.ticks && opts.ticks.z || 0;
    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
    const bz = valueOrDefault(opts.border && opts.border.z, 0);
    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
      return [
        {
          z: tz,
          draw: (chartArea) => {
            this.draw(chartArea);
          }
        }
      ];
    }
    return [
      {
        z: gz,
        draw: (chartArea) => {
          this.drawBackground();
          this.drawGrid(chartArea);
          this.drawTitle();
        }
      },
      {
        z: bz,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: tz,
        draw: (chartArea) => {
          this.drawLabels(chartArea);
        }
      }
    ];
  }
  getMatchingVisibleMetas(type) {
    const metas = this.chart.getSortedVisibleDatasetMetas();
    const axisID = this.axis + "AxisID";
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      const meta = metas[i];
      if (meta[axisID] === this.id && (!type || meta.type === type)) {
        result.push(meta);
      }
    }
    return result;
  }
  _resolveTickFontOptions(index) {
    const opts = this.options.ticks.setContext(this.getContext(index));
    return toFont(opts.font);
  }
  _maxDigits() {
    const fontSize = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / fontSize;
  }
};
var TypedRegistry = class {
  constructor(type, scope, override) {
    this.type = type;
    this.scope = scope;
    this.override = override;
    this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(type) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
  }
  register(item) {
    const proto = Object.getPrototypeOf(item);
    let parentScope;
    if (isIChartComponent(proto)) {
      parentScope = this.register(proto);
    }
    const items = this.items;
    const id = item.id;
    const scope = this.scope + "." + id;
    if (!id) {
      throw new Error("class does not have id: " + item);
    }
    if (id in items) {
      return scope;
    }
    items[id] = item;
    registerDefaults(item, scope, parentScope);
    if (this.override) {
      defaults.override(item.id, item.overrides);
    }
    return scope;
  }
  get(id) {
    return this.items[id];
  }
  unregister(item) {
    const items = this.items;
    const id = item.id;
    const scope = this.scope;
    if (id in items) {
      delete items[id];
    }
    if (scope && id in defaults[scope]) {
      delete defaults[scope][id];
      if (this.override) {
        delete overrides[id];
      }
    }
  }
};
function registerDefaults(item, scope, parentScope) {
  const itemDefaults = merge(/* @__PURE__ */ Object.create(null), [
    parentScope ? defaults.get(parentScope) : {},
    defaults.get(scope),
    item.defaults
  ]);
  defaults.set(scope, itemDefaults);
  if (item.defaultRoutes) {
    routeDefaults(scope, item.defaultRoutes);
  }
  if (item.descriptors) {
    defaults.describe(scope, item.descriptors);
  }
}
function routeDefaults(scope, routes) {
  Object.keys(routes).forEach((property) => {
    const propertyParts = property.split(".");
    const sourceName = propertyParts.pop();
    const sourceScope = [
      scope
    ].concat(propertyParts).join(".");
    const parts = routes[property].split(".");
    const targetName = parts.pop();
    const targetScope = parts.join(".");
    defaults.route(sourceScope, sourceName, targetScope, targetName);
  });
}
function isIChartComponent(proto) {
  return "id" in proto && "defaults" in proto;
}
var Registry = class {
  constructor() {
    this.controllers = new TypedRegistry(DatasetController, "datasets", true);
    this.elements = new TypedRegistry(Element, "elements");
    this.plugins = new TypedRegistry(Object, "plugins");
    this.scales = new TypedRegistry(Scale, "scales");
    this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...args) {
    this._each("register", args);
  }
  remove(...args) {
    this._each("unregister", args);
  }
  addControllers(...args) {
    this._each("register", args, this.controllers);
  }
  addElements(...args) {
    this._each("register", args, this.elements);
  }
  addPlugins(...args) {
    this._each("register", args, this.plugins);
  }
  addScales(...args) {
    this._each("register", args, this.scales);
  }
  getController(id) {
    return this._get(id, this.controllers, "controller");
  }
  getElement(id) {
    return this._get(id, this.elements, "element");
  }
  getPlugin(id) {
    return this._get(id, this.plugins, "plugin");
  }
  getScale(id) {
    return this._get(id, this.scales, "scale");
  }
  removeControllers(...args) {
    this._each("unregister", args, this.controllers);
  }
  removeElements(...args) {
    this._each("unregister", args, this.elements);
  }
  removePlugins(...args) {
    this._each("unregister", args, this.plugins);
  }
  removeScales(...args) {
    this._each("unregister", args, this.scales);
  }
  _each(method, args, typedRegistry) {
    [
      ...args
    ].forEach((arg) => {
      const reg = typedRegistry || this._getRegistryForType(arg);
      if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
        this._exec(method, reg, arg);
      } else {
        each(arg, (item) => {
          const itemReg = typedRegistry || this._getRegistryForType(item);
          this._exec(method, itemReg, item);
        });
      }
    });
  }
  _exec(method, registry2, component) {
    const camelMethod = _capitalize(method);
    callback(component["before" + camelMethod], [], component);
    registry2[method](component);
    callback(component["after" + camelMethod], [], component);
  }
  _getRegistryForType(type) {
    for (let i = 0; i < this._typedRegistries.length; i++) {
      const reg = this._typedRegistries[i];
      if (reg.isForType(type)) {
        return reg;
      }
    }
    return this.plugins;
  }
  _get(id, typedRegistry, type) {
    const item = typedRegistry.get(id);
    if (item === void 0) {
      throw new Error('"' + id + '" is not a registered ' + type + ".");
    }
    return item;
  }
};
var registry = /* @__PURE__ */ new Registry();
var PluginService = class {
  constructor() {
    this._init = [];
  }
  notify(chart, hook, args, filter) {
    if (hook === "beforeInit") {
      this._init = this._createDescriptors(chart, true);
      this._notify(this._init, chart, "install");
    }
    const descriptors3 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
    const result = this._notify(descriptors3, chart, hook, args);
    if (hook === "afterDestroy") {
      this._notify(descriptors3, chart, "stop");
      this._notify(this._init, chart, "uninstall");
    }
    return result;
  }
  _notify(descriptors3, chart, hook, args) {
    args = args || {};
    for (const descriptor of descriptors3) {
      const plugin = descriptor.plugin;
      const method = plugin[hook];
      const params = [
        chart,
        args,
        descriptor.options
      ];
      if (callback(method, params, plugin) === false && args.cancelable) {
        return false;
      }
    }
    return true;
  }
  invalidate() {
    if (!isNullOrUndef(this._cache)) {
      this._oldCache = this._cache;
      this._cache = void 0;
    }
  }
  _descriptors(chart) {
    if (this._cache) {
      return this._cache;
    }
    const descriptors3 = this._cache = this._createDescriptors(chart);
    this._notifyStateChanges(chart);
    return descriptors3;
  }
  _createDescriptors(chart, all) {
    const config = chart && chart.config;
    const options = valueOrDefault(config.options && config.options.plugins, {});
    const plugins = allPlugins(config);
    return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);
  }
  _notifyStateChanges(chart) {
    const previousDescriptors = this._oldCache || [];
    const descriptors3 = this._cache;
    const diff = (a, b) => a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
    this._notify(diff(previousDescriptors, descriptors3), chart, "stop");
    this._notify(diff(descriptors3, previousDescriptors), chart, "start");
  }
};
function allPlugins(config) {
  const localIds = {};
  const plugins = [];
  const keys = Object.keys(registry.plugins.items);
  for (let i = 0; i < keys.length; i++) {
    plugins.push(registry.getPlugin(keys[i]));
  }
  const local = config.plugins || [];
  for (let i = 0; i < local.length; i++) {
    const plugin = local[i];
    if (plugins.indexOf(plugin) === -1) {
      plugins.push(plugin);
      localIds[plugin.id] = true;
    }
  }
  return {
    plugins,
    localIds
  };
}
function getOpts(options, all) {
  if (!all && options === false) {
    return null;
  }
  if (options === true) {
    return {};
  }
  return options;
}
function createDescriptors(chart, { plugins, localIds }, options, all) {
  const result = [];
  const context = chart.getContext();
  for (const plugin of plugins) {
    const id = plugin.id;
    const opts = getOpts(options[id], all);
    if (opts === null) {
      continue;
    }
    result.push({
      plugin,
      options: pluginOpts(chart.config, {
        plugin,
        local: localIds[id]
      }, opts, context)
    });
  }
  return result;
}
function pluginOpts(config, { plugin, local }, opts, context) {
  const keys = config.pluginScopeKeys(plugin);
  const scopes = config.getOptionScopes(opts, keys);
  if (local && plugin.defaults) {
    scopes.push(plugin.defaults);
  }
  return config.createResolver(scopes, context, [
    ""
  ], {
    scriptable: false,
    indexable: false,
    allKeys: true
  });
}
function getIndexAxis(type, options) {
  const datasetDefaults = defaults.datasets[type] || {};
  const datasetOptions = (options.datasets || {})[type] || {};
  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
}
function getAxisFromDefaultScaleID(id, indexAxis) {
  let axis = id;
  if (id === "_index_") {
    axis = indexAxis;
  } else if (id === "_value_") {
    axis = indexAxis === "x" ? "y" : "x";
  }
  return axis;
}
function getDefaultScaleIDFromAxis(axis, indexAxis) {
  return axis === indexAxis ? "_index_" : "_value_";
}
function idMatchesAxis(id) {
  if (id === "x" || id === "y" || id === "r") {
    return id;
  }
}
function axisFromPosition(position) {
  if (position === "top" || position === "bottom") {
    return "x";
  }
  if (position === "left" || position === "right") {
    return "y";
  }
}
function determineAxis(id, ...scaleOptions) {
  if (idMatchesAxis(id)) {
    return id;
  }
  for (const opts of scaleOptions) {
    const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());
    if (axis) {
      return axis;
    }
  }
  throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);
}
function getAxisFromDataset(id, axis, dataset) {
  if (dataset[axis + "AxisID"] === id) {
    return {
      axis
    };
  }
}
function retrieveAxisFromDatasets(id, config) {
  if (config.data && config.data.datasets) {
    const boundDs = config.data.datasets.filter((d) => d.xAxisID === id || d.yAxisID === id);
    if (boundDs.length) {
      return getAxisFromDataset(id, "x", boundDs[0]) || getAxisFromDataset(id, "y", boundDs[0]);
    }
  }
  return {};
}
function mergeScaleConfig(config, options) {
  const chartDefaults = overrides[config.type] || {
    scales: {}
  };
  const configScales = options.scales || {};
  const chartIndexAxis = getIndexAxis(config.type, options);
  const scales = /* @__PURE__ */ Object.create(null);
  Object.keys(configScales).forEach((id) => {
    const scaleConf = configScales[id];
    if (!isObject(scaleConf)) {
      return console.error(`Invalid scale configuration for scale: ${id}`);
    }
    if (scaleConf._proxy) {
      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
    }
    const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);
    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
    const defaultScaleOptions = chartDefaults.scales || {};
    scales[id] = mergeIf(/* @__PURE__ */ Object.create(null), [
      {
        axis
      },
      scaleConf,
      defaultScaleOptions[axis],
      defaultScaleOptions[defaultId]
    ]);
  });
  config.data.datasets.forEach((dataset) => {
    const type = dataset.type || config.type;
    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
    const datasetDefaults = overrides[type] || {};
    const defaultScaleOptions = datasetDefaults.scales || {};
    Object.keys(defaultScaleOptions).forEach((defaultID) => {
      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
      const id = dataset[axis + "AxisID"] || axis;
      scales[id] = scales[id] || /* @__PURE__ */ Object.create(null);
      mergeIf(scales[id], [
        {
          axis
        },
        configScales[id],
        defaultScaleOptions[defaultID]
      ]);
    });
  });
  Object.keys(scales).forEach((key) => {
    const scale = scales[key];
    mergeIf(scale, [
      defaults.scales[scale.type],
      defaults.scale
    ]);
  });
  return scales;
}
function initOptions(config) {
  const options = config.options || (config.options = {});
  options.plugins = valueOrDefault(options.plugins, {});
  options.scales = mergeScaleConfig(config, options);
}
function initData(data) {
  data = data || {};
  data.datasets = data.datasets || [];
  data.labels = data.labels || [];
  return data;
}
function initConfig(config) {
  config = config || {};
  config.data = initData(config.data);
  initOptions(config);
  return config;
}
var keyCache = /* @__PURE__ */ new Map();
var keysCached = /* @__PURE__ */ new Set();
function cachedKeys(cacheKey, generate) {
  let keys = keyCache.get(cacheKey);
  if (!keys) {
    keys = generate();
    keyCache.set(cacheKey, keys);
    keysCached.add(keys);
  }
  return keys;
}
var addIfFound = (set3, obj, key) => {
  const opts = resolveObjectKey(obj, key);
  if (opts !== void 0) {
    set3.add(opts);
  }
};
var Config = class {
  constructor(config) {
    this._config = initConfig(config);
    this._scopeCache = /* @__PURE__ */ new Map();
    this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(type) {
    this._config.type = type;
  }
  get data() {
    return this._config.data;
  }
  set data(data) {
    this._config.data = initData(data);
  }
  get options() {
    return this._config.options;
  }
  set options(options) {
    this._config.options = options;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const config = this._config;
    this.clearCache();
    initOptions(config);
  }
  clearCache() {
    this._scopeCache.clear();
    this._resolverCache.clear();
  }
  datasetScopeKeys(datasetType) {
    return cachedKeys(datasetType, () => [
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(datasetType, transition) {
    return cachedKeys(`${datasetType}.transition.${transition}`, () => [
      [
        `datasets.${datasetType}.transitions.${transition}`,
        `transitions.${transition}`
      ],
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(datasetType, elementType) {
    return cachedKeys(`${datasetType}-${elementType}`, () => [
      [
        `datasets.${datasetType}.elements.${elementType}`,
        `datasets.${datasetType}`,
        `elements.${elementType}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(plugin) {
    const id = plugin.id;
    const type = this.type;
    return cachedKeys(`${type}-plugin-${id}`, () => [
      [
        `plugins.${id}`,
        ...plugin.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(mainScope, resetCache) {
    const _scopeCache = this._scopeCache;
    let cache = _scopeCache.get(mainScope);
    if (!cache || resetCache) {
      cache = /* @__PURE__ */ new Map();
      _scopeCache.set(mainScope, cache);
    }
    return cache;
  }
  getOptionScopes(mainScope, keyLists, resetCache) {
    const { options, type } = this;
    const cache = this._cachedScopes(mainScope, resetCache);
    const cached = cache.get(keyLists);
    if (cached) {
      return cached;
    }
    const scopes = /* @__PURE__ */ new Set();
    keyLists.forEach((keys) => {
      if (mainScope) {
        scopes.add(mainScope);
        keys.forEach((key) => addIfFound(scopes, mainScope, key));
      }
      keys.forEach((key) => addIfFound(scopes, options, key));
      keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
      keys.forEach((key) => addIfFound(scopes, defaults, key));
      keys.forEach((key) => addIfFound(scopes, descriptors, key));
    });
    const array = Array.from(scopes);
    if (array.length === 0) {
      array.push(/* @__PURE__ */ Object.create(null));
    }
    if (keysCached.has(keyLists)) {
      cache.set(keyLists, array);
    }
    return array;
  }
  chartOptionScopes() {
    const { options, type } = this;
    return [
      options,
      overrides[type] || {},
      defaults.datasets[type] || {},
      {
        type
      },
      defaults,
      descriptors
    ];
  }
  resolveNamedOptions(scopes, names3, context, prefixes = [
    ""
  ]) {
    const result = {
      $shared: true
    };
    const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
    let options = resolver;
    if (needContext(resolver, names3)) {
      result.$shared = false;
      context = isFunction(context) ? context() : context;
      const subResolver = this.createResolver(scopes, context, subPrefixes);
      options = _attachContext(resolver, context, subResolver);
    }
    for (const prop of names3) {
      result[prop] = options[prop];
    }
    return result;
  }
  createResolver(scopes, context, prefixes = [
    ""
  ], descriptorDefaults) {
    const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
    return isObject(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
  }
};
function getResolver(resolverCache, scopes, prefixes) {
  let cache = resolverCache.get(scopes);
  if (!cache) {
    cache = /* @__PURE__ */ new Map();
    resolverCache.set(scopes, cache);
  }
  const cacheKey = prefixes.join();
  let cached = cache.get(cacheKey);
  if (!cached) {
    const resolver = _createResolver(scopes, prefixes);
    cached = {
      resolver,
      subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
    };
    cache.set(cacheKey, cached);
  }
  return cached;
}
var hasFunction = (value) => isObject(value) && Object.getOwnPropertyNames(value).some((key) => isFunction(value[key]));
function needContext(proxy, names3) {
  const { isScriptable, isIndexable } = _descriptors(proxy);
  for (const prop of names3) {
    const scriptable = isScriptable(prop);
    const indexable = isIndexable(prop);
    const value = (indexable || scriptable) && proxy[prop];
    if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {
      return true;
    }
  }
  return false;
}
var version = "4.4.2";
var KNOWN_POSITIONS = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function positionIsHorizontal(position, axis) {
  return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
}
function compare2Level(l1, l2) {
  return function(a, b) {
    return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
  };
}
function onAnimationsComplete(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  chart.notifyPlugins("afterRender");
  callback(animationOptions && animationOptions.onComplete, [
    context
  ], chart);
}
function onAnimationProgress(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  callback(animationOptions && animationOptions.onProgress, [
    context
  ], chart);
}
function getCanvas(item) {
  if (_isDomSupported() && typeof item === "string") {
    item = document.getElementById(item);
  } else if (item && item.length) {
    item = item[0];
  }
  if (item && item.canvas) {
    item = item.canvas;
  }
  return item;
}
var instances = {};
var getChart = (key) => {
  const canvas = getCanvas(key);
  return Object.values(instances).filter((c) => c.canvas === canvas).pop();
};
function moveNumericKeys(obj, start, move) {
  const keys = Object.keys(obj);
  for (const key of keys) {
    const intKey = +key;
    if (intKey >= start) {
      const value = obj[key];
      delete obj[key];
      if (move > 0 || intKey > start) {
        obj[intKey + move] = value;
      }
    }
  }
}
function determineLastEvent(e, lastEvent, inChartArea, isClick) {
  if (!inChartArea || e.type === "mouseout") {
    return null;
  }
  if (isClick) {
    return lastEvent;
  }
  return e;
}
function getSizeForArea(scale, chartArea, field) {
  return scale.options.clip ? scale[field] : chartArea[field];
}
function getDatasetArea(meta, chartArea) {
  const { xScale, yScale } = meta;
  if (xScale && yScale) {
    return {
      left: getSizeForArea(xScale, chartArea, "left"),
      right: getSizeForArea(xScale, chartArea, "right"),
      top: getSizeForArea(yScale, chartArea, "top"),
      bottom: getSizeForArea(yScale, chartArea, "bottom")
    };
  }
  return chartArea;
}
var Chart = class {
  static register(...items) {
    registry.add(...items);
    invalidatePlugins();
  }
  static unregister(...items) {
    registry.remove(...items);
    invalidatePlugins();
  }
  constructor(item, userConfig) {
    const config = this.config = new Config(userConfig);
    const initialCanvas = getCanvas(item);
    const existingChart = getChart(initialCanvas);
    if (existingChart) {
      throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
    }
    const options = config.createResolver(config.chartOptionScopes(), this.getContext());
    this.platform = new (config.platform || _detectPlatform(initialCanvas))();
    this.platform.updateConfig(config);
    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
    const canvas = context && context.canvas;
    const height = canvas && canvas.height;
    const width = canvas && canvas.width;
    this.id = uid();
    this.ctx = context;
    this.canvas = canvas;
    this.width = width;
    this.height = height;
    this._options = options;
    this._aspectRatio = this.aspectRatio;
    this._layers = [];
    this._metasets = [];
    this._stacks = void 0;
    this.boxes = [];
    this.currentDevicePixelRatio = void 0;
    this.chartArea = void 0;
    this._active = [];
    this._lastEvent = void 0;
    this._listeners = {};
    this._responsiveListeners = void 0;
    this._sortedMetasets = [];
    this.scales = {};
    this._plugins = new PluginService();
    this.$proxies = {};
    this._hiddenIndices = {};
    this.attached = false;
    this._animationsDisabled = void 0;
    this.$context = void 0;
    this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
    this._dataChanges = [];
    instances[this.id] = this;
    if (!context || !canvas) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    animator.listen(this, "complete", onAnimationsComplete);
    animator.listen(this, "progress", onAnimationProgress);
    this._initialize();
    if (this.attached) {
      this.update();
    }
  }
  get aspectRatio() {
    const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
    if (!isNullOrUndef(aspectRatio)) {
      return aspectRatio;
    }
    if (maintainAspectRatio && _aspectRatio) {
      return _aspectRatio;
    }
    return height ? width / height : null;
  }
  get data() {
    return this.config.data;
  }
  set data(data) {
    this.config.data = data;
  }
  get options() {
    return this._options;
  }
  set options(options) {
    this.config.options = options;
  }
  get registry() {
    return registry;
  }
  _initialize() {
    this.notifyPlugins("beforeInit");
    if (this.options.responsive) {
      this.resize();
    } else {
      retinaScale(this, this.options.devicePixelRatio);
    }
    this.bindEvents();
    this.notifyPlugins("afterInit");
    return this;
  }
  clear() {
    clearCanvas(this.canvas, this.ctx);
    return this;
  }
  stop() {
    animator.stop(this);
    return this;
  }
  resize(width, height) {
    if (!animator.running(this)) {
      this._resize(width, height);
    } else {
      this._resizeBeforeDraw = {
        width,
        height
      };
    }
  }
  _resize(width, height) {
    const options = this.options;
    const canvas = this.canvas;
    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
    const mode = this.width ? "resize" : "attach";
    this.width = newSize.width;
    this.height = newSize.height;
    this._aspectRatio = this.aspectRatio;
    if (!retinaScale(this, newRatio, true)) {
      return;
    }
    this.notifyPlugins("resize", {
      size: newSize
    });
    callback(options.onResize, [
      this,
      newSize
    ], this);
    if (this.attached) {
      if (this._doResize(mode)) {
        this.render();
      }
    }
  }
  ensureScalesHaveIDs() {
    const options = this.options;
    const scalesOptions = options.scales || {};
    each(scalesOptions, (axisOptions, axisID) => {
      axisOptions.id = axisID;
    });
  }
  buildOrUpdateScales() {
    const options = this.options;
    const scaleOpts = options.scales;
    const scales = this.scales;
    const updated = Object.keys(scales).reduce((obj, id) => {
      obj[id] = false;
      return obj;
    }, {});
    let items = [];
    if (scaleOpts) {
      items = items.concat(Object.keys(scaleOpts).map((id) => {
        const scaleOptions = scaleOpts[id];
        const axis = determineAxis(id, scaleOptions);
        const isRadial = axis === "r";
        const isHorizontal = axis === "x";
        return {
          options: scaleOptions,
          dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
          dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
        };
      }));
    }
    each(items, (item) => {
      const scaleOptions = item.options;
      const id = scaleOptions.id;
      const axis = determineAxis(id, scaleOptions);
      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
      if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
        scaleOptions.position = item.dposition;
      }
      updated[id] = true;
      let scale = null;
      if (id in scales && scales[id].type === scaleType) {
        scale = scales[id];
      } else {
        const scaleClass = registry.getScale(scaleType);
        scale = new scaleClass({
          id,
          type: scaleType,
          ctx: this.ctx,
          chart: this
        });
        scales[scale.id] = scale;
      }
      scale.init(scaleOptions, options);
    });
    each(updated, (hasUpdated, id) => {
      if (!hasUpdated) {
        delete scales[id];
      }
    });
    each(scales, (scale) => {
      layouts.configure(this, scale, scale.options);
      layouts.addBox(this, scale);
    });
  }
  _updateMetasets() {
    const metasets = this._metasets;
    const numData = this.data.datasets.length;
    const numMeta = metasets.length;
    metasets.sort((a, b) => a.index - b.index);
    if (numMeta > numData) {
      for (let i = numData; i < numMeta; ++i) {
        this._destroyDatasetMeta(i);
      }
      metasets.splice(numData, numMeta - numData);
    }
    this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: metasets, data: { datasets } } = this;
    if (metasets.length > datasets.length) {
      delete this._stacks;
    }
    metasets.forEach((meta, index) => {
      if (datasets.filter((x) => x === meta._dataset).length === 0) {
        this._destroyDatasetMeta(index);
      }
    });
  }
  buildOrUpdateControllers() {
    const newControllers = [];
    const datasets = this.data.datasets;
    let i, ilen;
    this._removeUnreferencedMetasets();
    for (i = 0, ilen = datasets.length; i < ilen; i++) {
      const dataset = datasets[i];
      let meta = this.getDatasetMeta(i);
      const type = dataset.type || this.config.type;
      if (meta.type && meta.type !== type) {
        this._destroyDatasetMeta(i);
        meta = this.getDatasetMeta(i);
      }
      meta.type = type;
      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
      meta.order = dataset.order || 0;
      meta.index = i;
      meta.label = "" + dataset.label;
      meta.visible = this.isDatasetVisible(i);
      if (meta.controller) {
        meta.controller.updateIndex(i);
        meta.controller.linkScales();
      } else {
        const ControllerClass = registry.getController(type);
        const { datasetElementType, dataElementType } = defaults.datasets[type];
        Object.assign(ControllerClass, {
          dataElementType: registry.getElement(dataElementType),
          datasetElementType: datasetElementType && registry.getElement(datasetElementType)
        });
        meta.controller = new ControllerClass(this, i);
        newControllers.push(meta.controller);
      }
    }
    this._updateMetasets();
    return newControllers;
  }
  _resetElements() {
    each(this.data.datasets, (dataset, datasetIndex) => {
      this.getDatasetMeta(datasetIndex).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements();
    this.notifyPlugins("reset");
  }
  update(mode) {
    const config = this.config;
    config.update();
    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
    const animsDisabled = this._animationsDisabled = !options.animation;
    this._updateScales();
    this._checkEventBindings();
    this._updateHiddenIndices();
    this._plugins.invalidate();
    if (this.notifyPlugins("beforeUpdate", {
      mode,
      cancelable: true
    }) === false) {
      return;
    }
    const newControllers = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let minPadding = 0;
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
      const { controller } = this.getDatasetMeta(i);
      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
      controller.buildOrUpdateElements(reset);
      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
    }
    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
    this._updateLayout(minPadding);
    if (!animsDisabled) {
      each(newControllers, (controller) => {
        controller.reset();
      });
    }
    this._updateDatasets(mode);
    this.notifyPlugins("afterUpdate", {
      mode
    });
    this._layers.sort(compare2Level("z", "_idx"));
    const { _active, _lastEvent } = this;
    if (_lastEvent) {
      this._eventHandler(_lastEvent, true);
    } else if (_active.length) {
      this._updateHoverStyles(_active, _active, true);
    }
    this.render();
  }
  _updateScales() {
    each(this.scales, (scale) => {
      layouts.removeBox(this, scale);
    });
    this.ensureScalesHaveIDs();
    this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const options = this.options;
    const existingEvents = new Set(Object.keys(this._listeners));
    const newEvents = new Set(options.events);
    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
      this.unbindEvents();
      this.bindEvents();
    }
  }
  _updateHiddenIndices() {
    const { _hiddenIndices } = this;
    const changes = this._getUniformDataChanges() || [];
    for (const { method, start, count } of changes) {
      const move = method === "_removeElements" ? -count : count;
      moveNumericKeys(_hiddenIndices, start, move);
    }
  }
  _getUniformDataChanges() {
    const _dataChanges = this._dataChanges;
    if (!_dataChanges || !_dataChanges.length) {
      return;
    }
    this._dataChanges = [];
    const datasetCount = this.data.datasets.length;
    const makeSet = (idx) => new Set(_dataChanges.filter((c) => c[0] === idx).map((c, i) => i + "," + c.splice(1).join(",")));
    const changeSet = makeSet(0);
    for (let i = 1; i < datasetCount; i++) {
      if (!setsEqual(changeSet, makeSet(i))) {
        return;
      }
    }
    return Array.from(changeSet).map((c) => c.split(",")).map((a) => ({
      method: a[1],
      start: +a[2],
      count: +a[3]
    }));
  }
  _updateLayout(minPadding) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: true
    }) === false) {
      return;
    }
    layouts.update(this, this.width, this.height, minPadding);
    const area = this.chartArea;
    const noArea = area.width <= 0 || area.height <= 0;
    this._layers = [];
    each(this.boxes, (box) => {
      if (noArea && box.position === "chartArea") {
        return;
      }
      if (box.configure) {
        box.configure();
      }
      this._layers.push(...box._layers());
    }, this);
    this._layers.forEach((item, index) => {
      item._idx = index;
    });
    this.notifyPlugins("afterLayout");
  }
  _updateDatasets(mode) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode,
      cancelable: true
    }) === false) {
      return;
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this.getDatasetMeta(i).controller.configure();
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._updateDataset(i, isFunction(mode) ? mode({
        datasetIndex: i
      }) : mode);
    }
    this.notifyPlugins("afterDatasetsUpdate", {
      mode
    });
  }
  _updateDataset(index, mode) {
    const meta = this.getDatasetMeta(index);
    const args = {
      meta,
      index,
      mode,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
      return;
    }
    meta.controller._update(mode);
    args.cancelable = false;
    this.notifyPlugins("afterDatasetUpdate", args);
  }
  render() {
    if (this.notifyPlugins("beforeRender", {
      cancelable: true
    }) === false) {
      return;
    }
    if (animator.has(this)) {
      if (this.attached && !animator.running(this)) {
        animator.start(this);
      }
    } else {
      this.draw();
      onAnimationsComplete({
        chart: this
      });
    }
  }
  draw() {
    let i;
    if (this._resizeBeforeDraw) {
      const { width, height } = this._resizeBeforeDraw;
      this._resize(width, height);
      this._resizeBeforeDraw = null;
    }
    this.clear();
    if (this.width <= 0 || this.height <= 0) {
      return;
    }
    if (this.notifyPlugins("beforeDraw", {
      cancelable: true
    }) === false) {
      return;
    }
    const layers = this._layers;
    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
      layers[i].draw(this.chartArea);
    }
    this._drawDatasets();
    for (; i < layers.length; ++i) {
      layers[i].draw(this.chartArea);
    }
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(filterVisible) {
    const metasets = this._sortedMetasets;
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metasets.length; i < ilen; ++i) {
      const meta = metasets[i];
      if (!filterVisible || meta.visible) {
        result.push(meta);
      }
    }
    return result;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(true);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: true
    }) === false) {
      return;
    }
    const metasets = this.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      this._drawDataset(metasets[i]);
    }
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(meta) {
    const ctx = this.ctx;
    const clip = meta._clip;
    const useClip = !clip.disabled;
    const area = getDatasetArea(meta, this.chartArea);
    const args = {
      meta,
      index: meta.index,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
      return;
    }
    if (useClip) {
      clipArea(ctx, {
        left: clip.left === false ? 0 : area.left - clip.left,
        right: clip.right === false ? this.width : area.right + clip.right,
        top: clip.top === false ? 0 : area.top - clip.top,
        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
      });
    }
    meta.controller.draw();
    if (useClip) {
      unclipArea(ctx);
    }
    args.cancelable = false;
    this.notifyPlugins("afterDatasetDraw", args);
  }
  isPointInArea(point) {
    return _isPointInArea(point, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(e, mode, options, useFinalPosition) {
    const method = Interaction.modes[mode];
    if (typeof method === "function") {
      return method(this, e, options, useFinalPosition);
    }
    return [];
  }
  getDatasetMeta(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    const metasets = this._metasets;
    let meta = metasets.filter((x) => x && x._dataset === dataset).pop();
    if (!meta) {
      meta = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: dataset && dataset.order || 0,
        index: datasetIndex,
        _dataset: dataset,
        _parsed: [],
        _sorted: false
      };
      metasets.push(meta);
    }
    return meta;
  }
  getContext() {
    return this.$context || (this.$context = createContext(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    if (!dataset) {
      return false;
    }
    const meta = this.getDatasetMeta(datasetIndex);
    return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
  }
  setDatasetVisibility(datasetIndex, visible) {
    const meta = this.getDatasetMeta(datasetIndex);
    meta.hidden = !visible;
  }
  toggleDataVisibility(index) {
    this._hiddenIndices[index] = !this._hiddenIndices[index];
  }
  getDataVisibility(index) {
    return !this._hiddenIndices[index];
  }
  _updateVisibility(datasetIndex, dataIndex, visible) {
    const mode = visible ? "show" : "hide";
    const meta = this.getDatasetMeta(datasetIndex);
    const anims = meta.controller._resolveAnimations(void 0, mode);
    if (defined(dataIndex)) {
      meta.data[dataIndex].hidden = !visible;
      this.update();
    } else {
      this.setDatasetVisibility(datasetIndex, visible);
      anims.update(meta, {
        visible
      });
      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
    }
  }
  hide(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, false);
  }
  show(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, true);
  }
  _destroyDatasetMeta(datasetIndex) {
    const meta = this._metasets[datasetIndex];
    if (meta && meta.controller) {
      meta.controller._destroy();
    }
    delete this._metasets[datasetIndex];
  }
  _stop() {
    let i, ilen;
    this.stop();
    animator.remove(this);
    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._destroyDatasetMeta(i);
    }
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas, ctx } = this;
    this._stop();
    this.config.clearCache();
    if (canvas) {
      this.unbindEvents();
      clearCanvas(canvas, ctx);
      this.platform.releaseContext(ctx);
      this.canvas = null;
      this.ctx = null;
    }
    delete instances[this.id];
    this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...args) {
    return this.canvas.toDataURL(...args);
  }
  bindEvents() {
    this.bindUserEvents();
    if (this.options.responsive) {
      this.bindResponsiveEvents();
    } else {
      this.attached = true;
    }
  }
  bindUserEvents() {
    const listeners = this._listeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const listener = (e, x, y) => {
      e.offsetX = x;
      e.offsetY = y;
      this._eventHandler(e);
    };
    each(this.options.events, (type) => _add(type, listener));
  }
  bindResponsiveEvents() {
    if (!this._responsiveListeners) {
      this._responsiveListeners = {};
    }
    const listeners = this._responsiveListeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const _remove = (type, listener2) => {
      if (listeners[type]) {
        platform.removeEventListener(this, type, listener2);
        delete listeners[type];
      }
    };
    const listener = (width, height) => {
      if (this.canvas) {
        this.resize(width, height);
      }
    };
    let detached;
    const attached = () => {
      _remove("attach", attached);
      this.attached = true;
      this.resize();
      _add("resize", listener);
      _add("detach", detached);
    };
    detached = () => {
      this.attached = false;
      _remove("resize", listener);
      this._stop();
      this._resize(0, 0);
      _add("attach", attached);
    };
    if (platform.isAttached(this.canvas)) {
      attached();
    } else {
      detached();
    }
  }
  unbindEvents() {
    each(this._listeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._listeners = {};
    each(this._responsiveListeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._responsiveListeners = void 0;
  }
  updateHoverStyle(items, mode, enabled) {
    const prefix = enabled ? "set" : "remove";
    let meta, item, i, ilen;
    if (mode === "dataset") {
      meta = this.getDatasetMeta(items[0].datasetIndex);
      meta.controller["_" + prefix + "DatasetHoverStyle"]();
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      item = items[i];
      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
      if (controller) {
        controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
      }
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements) {
    const lastActive = this._active || [];
    const active = activeElements.map(({ datasetIndex, index }) => {
      const meta = this.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("No dataset found at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index],
        index
      };
    });
    const changed = !_elementsEqual(active, lastActive);
    if (changed) {
      this._active = active;
      this._lastEvent = null;
      this._updateHoverStyles(active, lastActive);
    }
  }
  notifyPlugins(hook, args, filter) {
    return this._plugins.notify(this, hook, args, filter);
  }
  isPluginEnabled(pluginId) {
    return this._plugins._cache.filter((p) => p.plugin.id === pluginId).length === 1;
  }
  _updateHoverStyles(active, lastActive, replay) {
    const hoverOptions = this.options.hover;
    const diff = (a, b) => a.filter((x) => !b.some((y) => x.datasetIndex === y.datasetIndex && x.index === y.index));
    const deactivated = diff(lastActive, active);
    const activated = replay ? active : diff(active, lastActive);
    if (deactivated.length) {
      this.updateHoverStyle(deactivated, hoverOptions.mode, false);
    }
    if (activated.length && hoverOptions.mode) {
      this.updateHoverStyle(activated, hoverOptions.mode, true);
    }
  }
  _eventHandler(e, replay) {
    const args = {
      event: e,
      replay,
      cancelable: true,
      inChartArea: this.isPointInArea(e)
    };
    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);
    if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
      return;
    }
    const changed = this._handleEvent(e, replay, args.inChartArea);
    args.cancelable = false;
    this.notifyPlugins("afterEvent", args, eventFilter);
    if (changed || args.changed) {
      this.render();
    }
    return this;
  }
  _handleEvent(e, replay, inChartArea) {
    const { _active: lastActive = [], options } = this;
    const useFinalPosition = replay;
    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
    const isClick = _isClickEvent(e);
    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
    if (inChartArea) {
      this._lastEvent = null;
      callback(options.onHover, [
        e,
        active,
        this
      ], this);
      if (isClick) {
        callback(options.onClick, [
          e,
          active,
          this
        ], this);
      }
    }
    const changed = !_elementsEqual(active, lastActive);
    if (changed || replay) {
      this._active = active;
      this._updateHoverStyles(active, lastActive, replay);
    }
    this._lastEvent = lastEvent;
    return changed;
  }
  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const hoverOptions = this.options.hover;
    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
  }
};
__publicField(Chart, "defaults", defaults);
__publicField(Chart, "instances", instances);
__publicField(Chart, "overrides", overrides);
__publicField(Chart, "registry", registry);
__publicField(Chart, "version", version);
__publicField(Chart, "getChart", getChart);
function invalidatePlugins() {
  return each(Chart.instances, (chart) => chart._plugins.invalidate());
}
function clipArc(ctx, element, endAngle) {
  const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element;
  let angleMargin = pixelMargin / outerRadius;
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
  if (innerRadius > pixelMargin) {
    angleMargin = pixelMargin / innerRadius;
    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
  } else {
    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
  }
  ctx.closePath();
  ctx.clip();
}
function toRadiusCorners(value) {
  return _readValueToProps(value, [
    "outerStart",
    "outerEnd",
    "innerStart",
    "innerEnd"
  ]);
}
function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
  const o = toRadiusCorners(arc.options.borderRadius);
  const halfThickness = (outerRadius - innerRadius) / 2;
  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
  const computeOuterLimit = (val) => {
    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
  };
  return {
    outerStart: computeOuterLimit(o.outerStart),
    outerEnd: computeOuterLimit(o.outerEnd),
    innerStart: _limitValue(o.innerStart, 0, innerLimit),
    innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
  };
}
function rThetaToXY(r, theta, x, y) {
  return {
    x: x + r * Math.cos(theta),
    y: y + r * Math.sin(theta)
  };
}
function pathArc(ctx, element, offset2, spacing, end, circular) {
  const { x, y, startAngle: start, pixelMargin, innerRadius: innerR } = element;
  const outerRadius = Math.max(element.outerRadius + spacing + offset2 - pixelMargin, 0);
  const innerRadius = innerR > 0 ? innerR + spacing + offset2 + pixelMargin : 0;
  let spacingOffset = 0;
  const alpha3 = end - start;
  if (spacing) {
    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
    const adjustedAngle = avNogSpacingRadius !== 0 ? alpha3 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha3;
    spacingOffset = (alpha3 - adjustedAngle) / 2;
  }
  const beta = Math.max(1e-3, alpha3 * outerRadius - offset2 / PI) / outerRadius;
  const angleOffset = (alpha3 - beta) / 2;
  const startAngle = start + angleOffset + spacingOffset;
  const endAngle = end - angleOffset - spacingOffset;
  const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
  const outerStartAdjustedRadius = outerRadius - outerStart;
  const outerEndAdjustedRadius = outerRadius - outerEnd;
  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
  const innerStartAdjustedRadius = innerRadius + innerStart;
  const innerEndAdjustedRadius = innerRadius + innerEnd;
  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
  ctx.beginPath();
  if (circular) {
    const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
    ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
    ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
    if (outerEnd > 0) {
      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
    }
    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
    ctx.lineTo(p4.x, p4.y);
    if (innerEnd > 0) {
      const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
    }
    const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
    ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
    ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
    if (innerStart > 0) {
      const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
    }
    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
    ctx.lineTo(p8.x, p8.y);
    if (outerStart > 0) {
      const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
    }
  } else {
    ctx.moveTo(x, y);
    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
    ctx.lineTo(outerStartX, outerStartY);
    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
    ctx.lineTo(outerEndX, outerEndY);
  }
  ctx.closePath();
}
function drawArc(ctx, element, offset2, spacing, circular) {
  const { fullCircles, startAngle, circumference } = element;
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset2, spacing, endAngle, circular);
    for (let i = 0; i < fullCircles; ++i) {
      ctx.fill();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % TAU || TAU);
    }
  }
  pathArc(ctx, element, offset2, spacing, endAngle, circular);
  ctx.fill();
  return endAngle;
}
function drawBorder(ctx, element, offset2, spacing, circular) {
  const { fullCircles, startAngle, circumference, options } = element;
  const { borderWidth, borderJoinStyle, borderDash, borderDashOffset } = options;
  const inner = options.borderAlign === "inner";
  if (!borderWidth) {
    return;
  }
  ctx.setLineDash(borderDash || []);
  ctx.lineDashOffset = borderDashOffset;
  if (inner) {
    ctx.lineWidth = borderWidth * 2;
    ctx.lineJoin = borderJoinStyle || "round";
  } else {
    ctx.lineWidth = borderWidth;
    ctx.lineJoin = borderJoinStyle || "bevel";
  }
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset2, spacing, endAngle, circular);
    for (let i = 0; i < fullCircles; ++i) {
      ctx.stroke();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % TAU || TAU);
    }
  }
  if (inner) {
    clipArc(ctx, element, endAngle);
  }
  if (!fullCircles) {
    pathArc(ctx, element, offset2, spacing, endAngle, circular);
    ctx.stroke();
  }
}
var ArcElement = class extends Element {
  constructor(cfg) {
    super();
    __publicField(this, "circumference");
    __publicField(this, "endAngle");
    __publicField(this, "fullCircles");
    __publicField(this, "innerRadius");
    __publicField(this, "outerRadius");
    __publicField(this, "pixelMargin");
    __publicField(this, "startAngle");
    this.options = void 0;
    this.circumference = void 0;
    this.startAngle = void 0;
    this.endAngle = void 0;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.pixelMargin = 0;
    this.fullCircles = 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(chartX, chartY, useFinalPosition) {
    const point = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    const { angle, distance } = getAngleFromPoint(point, {
      x: chartX,
      y: chartY
    });
    const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], useFinalPosition);
    const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;
    const _circumference = valueOrDefault(circumference, endAngle - startAngle);
    const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
    return betweenAngles && withinRadius;
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius"
    ], useFinalPosition);
    const { offset: offset2, spacing } = this.options;
    const halfAngle = (startAngle + endAngle) / 2;
    const halfRadius = (innerRadius + outerRadius + spacing + offset2) / 2;
    return {
      x: x + Math.cos(halfAngle) * halfRadius,
      y: y + Math.sin(halfAngle) * halfRadius
    };
  }
  tooltipPosition(useFinalPosition) {
    return this.getCenterPoint(useFinalPosition);
  }
  draw(ctx) {
    const { options, circumference } = this;
    const offset2 = (options.offset || 0) / 4;
    const spacing = (options.spacing || 0) / 2;
    const circular = options.circular;
    this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
      return;
    }
    ctx.save();
    const halfAngle = (this.startAngle + this.endAngle) / 2;
    ctx.translate(Math.cos(halfAngle) * offset2, Math.sin(halfAngle) * offset2);
    const fix = 1 - Math.sin(Math.min(PI, circumference || 0));
    const radiusOffset = offset2 * fix;
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    drawArc(ctx, this, radiusOffset, spacing, circular);
    drawBorder(ctx, this, radiusOffset, spacing, circular);
    ctx.restore();
  }
};
__publicField(ArcElement, "id", "arc");
__publicField(ArcElement, "defaults", {
  borderAlign: "center",
  borderColor: "#fff",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0,
  circular: true
});
__publicField(ArcElement, "defaultRoutes", {
  backgroundColor: "backgroundColor"
});
__publicField(ArcElement, "descriptors", {
  _scriptable: true,
  _indexable: (name) => name !== "borderDash"
});
var getBoxSize = (labelOpts, fontSize) => {
  let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
  if (labelOpts.usePointStyle) {
    boxHeight = Math.min(boxHeight, fontSize);
    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
  }
  return {
    boxWidth,
    boxHeight,
    itemHeight: Math.max(fontSize, boxHeight)
  };
};
var itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
var Legend = class extends Element {
  constructor(config) {
    super();
    this._added = false;
    this.legendHitBoxes = [];
    this._hoveredItem = null;
    this.doughnutMode = false;
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this.legendItems = void 0;
    this.columnSizes = void 0;
    this.lineWidths = void 0;
    this.maxHeight = void 0;
    this.maxWidth = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.height = void 0;
    this.width = void 0;
    this._margins = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight, margins) {
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins;
    this.setDimensions();
    this.buildLabels();
    this.fit();
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = this._margins.left;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = this._margins.top;
      this.bottom = this.height;
    }
  }
  buildLabels() {
    const labelOpts = this.options.labels || {};
    let legendItems = callback(labelOpts.generateLabels, [
      this.chart
    ], this) || [];
    if (labelOpts.filter) {
      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
    }
    if (labelOpts.sort) {
      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
    }
    if (this.options.reverse) {
      legendItems.reverse();
    }
    this.legendItems = legendItems;
  }
  fit() {
    const { options, ctx } = this;
    if (!options.display) {
      this.width = this.height = 0;
      return;
    }
    const labelOpts = options.labels;
    const labelFont = toFont(labelOpts.font);
    const fontSize = labelFont.size;
    const titleHeight = this._computeTitleHeight();
    const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
    let width, height;
    ctx.font = labelFont.string;
    if (this.isHorizontal()) {
      width = this.maxWidth;
      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    } else {
      height = this.maxHeight;
      width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
    }
    this.width = Math.min(width, options.maxWidth || this.maxWidth);
    this.height = Math.min(height, options.maxHeight || this.maxHeight);
  }
  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
    const { ctx, maxWidth, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const lineWidths = this.lineWidths = [
      0
    ];
    const lineHeight = itemHeight + padding;
    let totalHeight = titleHeight;
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    let row = -1;
    let top = -lineHeight;
    this.legendItems.forEach((legendItem, i) => {
      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
        totalHeight += lineHeight;
        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
        top += lineHeight;
        row++;
      }
      hitboxes[i] = {
        left: 0,
        top,
        row,
        width: itemWidth,
        height: itemHeight
      };
      lineWidths[lineWidths.length - 1] += itemWidth + padding;
    });
    return totalHeight;
  }
  _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
    const { ctx, maxHeight, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const columnSizes = this.columnSizes = [];
    const heightLimit = maxHeight - titleHeight;
    let totalWidth = padding;
    let currentColWidth = 0;
    let currentColHeight = 0;
    let left = 0;
    let col = 0;
    this.legendItems.forEach((legendItem, i) => {
      const { itemWidth, itemHeight } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);
      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
        totalWidth += currentColWidth + padding;
        columnSizes.push({
          width: currentColWidth,
          height: currentColHeight
        });
        left += currentColWidth + padding;
        col++;
        currentColWidth = currentColHeight = 0;
      }
      hitboxes[i] = {
        left,
        top: currentColHeight,
        col,
        width: itemWidth,
        height: itemHeight
      };
      currentColWidth = Math.max(currentColWidth, itemWidth);
      currentColHeight += itemHeight + padding;
    });
    totalWidth += currentColWidth;
    columnSizes.push({
      width: currentColWidth,
      height: currentColHeight
    });
    return totalWidth;
  }
  adjustHitBoxes() {
    if (!this.options.display) {
      return;
    }
    const titleHeight = this._computeTitleHeight();
    const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
    if (this.isHorizontal()) {
      let row = 0;
      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
      for (const hitbox of hitboxes) {
        if (row !== hitbox.row) {
          row = hitbox.row;
          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        }
        hitbox.top += this.top + titleHeight + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
        left += hitbox.width + padding;
      }
    } else {
      let col = 0;
      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
      for (const hitbox of hitboxes) {
        if (hitbox.col !== col) {
          col = hitbox.col;
          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        }
        hitbox.top = top;
        hitbox.left += this.left + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
        top += hitbox.height + padding;
      }
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const ctx = this.ctx;
      clipArea(ctx, this);
      this._draw();
      unclipArea(ctx);
    }
  }
  _draw() {
    const { options: opts, columnSizes, lineWidths, ctx } = this;
    const { align, labels: labelOpts } = opts;
    const defaultColor = defaults.color;
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const labelFont = toFont(labelOpts.font);
    const { padding } = labelOpts;
    const fontSize = labelFont.size;
    const halfFontSize = fontSize / 2;
    let cursor;
    this.drawTitle();
    ctx.textAlign = rtlHelper.textAlign("left");
    ctx.textBaseline = "middle";
    ctx.lineWidth = 0.5;
    ctx.font = labelFont.string;
    const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
    const drawLegendBox = function(x, y, legendItem) {
      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
        return;
      }
      ctx.save();
      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
      ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
      if (labelOpts.usePointStyle) {
        const drawOptions = {
          radius: boxHeight * Math.SQRT2 / 2,
          pointStyle: legendItem.pointStyle,
          rotation: legendItem.rotation,
          borderWidth: lineWidth
        };
        const centerX = rtlHelper.xPlus(x, boxWidth / 2);
        const centerY = y + halfFontSize;
        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
      } else {
        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
        const borderRadius = toTRBLCorners(legendItem.borderRadius);
        ctx.beginPath();
        if (Object.values(borderRadius).some((v) => v !== 0)) {
          addRoundedRectPath(ctx, {
            x: xBoxLeft,
            y: yBoxTop,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
        } else {
          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
        }
        ctx.fill();
        if (lineWidth !== 0) {
          ctx.stroke();
        }
      }
      ctx.restore();
    };
    const fillText = function(x, y, legendItem) {
      renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
        strikethrough: legendItem.hidden,
        textAlign: rtlHelper.textAlign(legendItem.textAlign)
      });
    };
    const isHorizontal = this.isHorizontal();
    const titleHeight = this._computeTitleHeight();
    if (isHorizontal) {
      cursor = {
        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
        y: this.top + padding + titleHeight,
        line: 0
      };
    } else {
      cursor = {
        x: this.left + padding,
        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
        line: 0
      };
    }
    overrideTextDirection(this.ctx, opts.textDirection);
    const lineHeight = itemHeight + padding;
    this.legendItems.forEach((legendItem, i) => {
      ctx.strokeStyle = legendItem.fontColor;
      ctx.fillStyle = legendItem.fontColor;
      const textWidth = ctx.measureText(legendItem.text).width;
      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
      const width = boxWidth + halfFontSize + textWidth;
      let x = cursor.x;
      let y = cursor.y;
      rtlHelper.setWidth(this.width);
      if (isHorizontal) {
        if (i > 0 && x + width + padding > this.right) {
          y = cursor.y += lineHeight;
          cursor.line++;
          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
        }
      } else if (i > 0 && y + lineHeight > this.bottom) {
        x = cursor.x = x + columnSizes[cursor.line].width + padding;
        cursor.line++;
        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
      }
      const realX = rtlHelper.x(x);
      drawLegendBox(realX, y, legendItem);
      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
      fillText(rtlHelper.x(x), y, legendItem);
      if (isHorizontal) {
        cursor.x += width + padding;
      } else if (typeof legendItem.text !== "string") {
        const fontLineHeight = labelFont.lineHeight;
        cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;
      } else {
        cursor.y += lineHeight;
      }
    });
    restoreTextDirection(this.ctx, opts.textDirection);
  }
  drawTitle() {
    const opts = this.options;
    const titleOpts = opts.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    if (!titleOpts.display) {
      return;
    }
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const ctx = this.ctx;
    const position = titleOpts.position;
    const halfFontSize = titleFont.size / 2;
    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
    let y;
    let left = this.left;
    let maxWidth = this.width;
    if (this.isHorizontal()) {
      maxWidth = Math.max(...this.lineWidths);
      y = this.top + topPaddingPlusHalfFontSize;
      left = _alignStartEnd(opts.align, left, this.right - maxWidth);
    } else {
      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
    }
    const x = _alignStartEnd(position, left, left + maxWidth);
    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
    ctx.textBaseline = "middle";
    ctx.strokeStyle = titleOpts.color;
    ctx.fillStyle = titleOpts.color;
    ctx.font = titleFont.string;
    renderText(ctx, titleOpts.text, x, y, titleFont);
  }
  _computeTitleHeight() {
    const titleOpts = this.options.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
  }
  _getLegendItemAt(x, y) {
    let i, hitBox, lh;
    if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
      lh = this.legendHitBoxes;
      for (i = 0; i < lh.length; ++i) {
        hitBox = lh[i];
        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
          return this.legendItems[i];
        }
      }
    }
    return null;
  }
  handleEvent(e) {
    const opts = this.options;
    if (!isListened(e.type, opts)) {
      return;
    }
    const hoveredItem = this._getLegendItemAt(e.x, e.y);
    if (e.type === "mousemove" || e.type === "mouseout") {
      const previous = this._hoveredItem;
      const sameItem = itemsEqual(previous, hoveredItem);
      if (previous && !sameItem) {
        callback(opts.onLeave, [
          e,
          previous,
          this
        ], this);
      }
      this._hoveredItem = hoveredItem;
      if (hoveredItem && !sameItem) {
        callback(opts.onHover, [
          e,
          hoveredItem,
          this
        ], this);
      }
    } else if (hoveredItem) {
      callback(opts.onClick, [
        e,
        hoveredItem,
        this
      ], this);
    }
  }
};
function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
  const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
  const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
  return {
    itemWidth,
    itemHeight
  };
}
function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
  let legendItemText = legendItem.text;
  if (legendItemText && typeof legendItemText !== "string") {
    legendItemText = legendItemText.reduce((a, b) => a.length > b.length ? a : b);
  }
  return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
}
function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
  let itemHeight = _itemHeight;
  if (typeof legendItem.text !== "string") {
    itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
  }
  return itemHeight;
}
function calculateLegendItemHeight(legendItem, fontLineHeight) {
  const labelHeight = legendItem.text ? legendItem.text.length : 0;
  return fontLineHeight * labelHeight;
}
function isListened(type, opts) {
  if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
    return true;
  }
  if (opts.onClick && (type === "click" || type === "mouseup")) {
    return true;
  }
  return false;
}
var plugin_legend = {
  id: "legend",
  _element: Legend,
  start(chart, _args, options) {
    const legend = chart.legend = new Legend({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, legend, options);
    layouts.addBox(chart, legend);
  },
  stop(chart) {
    layouts.removeBox(chart, chart.legend);
    delete chart.legend;
  },
  beforeUpdate(chart, _args, options) {
    const legend = chart.legend;
    layouts.configure(chart, legend, options);
    legend.options = options;
  },
  afterUpdate(chart) {
    const legend = chart.legend;
    legend.buildLabels();
    legend.adjustHitBoxes();
  },
  afterEvent(chart, args) {
    if (!args.replay) {
      chart.legend.handleEvent(args.event);
    }
  },
  defaults: {
    display: true,
    position: "top",
    align: "center",
    fullSize: true,
    reverse: false,
    weight: 1e3,
    onClick(e, legendItem, legend) {
      const index = legendItem.datasetIndex;
      const ci = legend.chart;
      if (ci.isDatasetVisible(index)) {
        ci.hide(index);
        legendItem.hidden = true;
      } else {
        ci.show(index);
        legendItem.hidden = false;
      }
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (ctx) => ctx.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(chart) {
        const datasets = chart.data.datasets;
        const { labels: { usePointStyle, pointStyle, textAlign, color: color3, useBorderRadius, borderRadius } } = chart.legend.options;
        return chart._getSortedDatasetMetas().map((meta) => {
          const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
          const borderWidth = toPadding(style.borderWidth);
          return {
            text: datasets[meta.index].label,
            fillStyle: style.backgroundColor,
            fontColor: color3,
            hidden: !meta.visible,
            lineCap: style.borderCapStyle,
            lineDash: style.borderDash,
            lineDashOffset: style.borderDashOffset,
            lineJoin: style.borderJoinStyle,
            lineWidth: (borderWidth.width + borderWidth.height) / 4,
            strokeStyle: style.borderColor,
            pointStyle: pointStyle || style.pointStyle,
            rotation: style.rotation,
            textAlign: textAlign || style.textAlign,
            borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
            datasetIndex: meta.index
          };
        }, this);
      }
    },
    title: {
      color: (ctx) => ctx.chart.options.color,
      display: false,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (name) => !name.startsWith("on"),
    labels: {
      _scriptable: (name) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(name)
    }
  }
};
var positioners = {
  average(items) {
    if (!items.length) {
      return false;
    }
    let i, len;
    let xSet = /* @__PURE__ */ new Set();
    let y = 0;
    let count = 0;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const pos = el.tooltipPosition();
        xSet.add(pos.x);
        y += pos.y;
        ++count;
      }
    }
    const xAverage = [
      ...xSet
    ].reduce((a, b) => a + b) / xSet.size;
    return {
      x: xAverage,
      y: y / count
    };
  },
  nearest(items, eventPosition) {
    if (!items.length) {
      return false;
    }
    let x = eventPosition.x;
    let y = eventPosition.y;
    let minDistance = Number.POSITIVE_INFINITY;
    let i, len, nearestElement;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const center = el.getCenterPoint();
        const d = distanceBetweenPoints(eventPosition, center);
        if (d < minDistance) {
          minDistance = d;
          nearestElement = el;
        }
      }
    }
    if (nearestElement) {
      const tp = nearestElement.tooltipPosition();
      x = tp.x;
      y = tp.y;
    }
    return {
      x,
      y
    };
  }
};
function pushOrConcat(base, toPush) {
  if (toPush) {
    if (isArray(toPush)) {
      Array.prototype.push.apply(base, toPush);
    } else {
      base.push(toPush);
    }
  }
  return base;
}
function splitNewlines(str) {
  if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
    return str.split("\n");
  }
  return str;
}
function createTooltipItem(chart, item) {
  const { element, datasetIndex, index } = item;
  const controller = chart.getDatasetMeta(datasetIndex).controller;
  const { label, value } = controller.getLabelAndValue(index);
  return {
    chart,
    label,
    parsed: controller.getParsed(index),
    raw: chart.data.datasets[datasetIndex].data[index],
    formattedValue: value,
    dataset: controller.getDataset(),
    dataIndex: index,
    datasetIndex,
    element
  };
}
function getTooltipSize(tooltip, options) {
  const ctx = tooltip.chart.ctx;
  const { body, footer, title } = tooltip;
  const { boxWidth, boxHeight } = options;
  const bodyFont = toFont(options.bodyFont);
  const titleFont = toFont(options.titleFont);
  const footerFont = toFont(options.footerFont);
  const titleLineCount = title.length;
  const footerLineCount = footer.length;
  const bodyLineItemCount = body.length;
  const padding = toPadding(options.padding);
  let height = padding.height;
  let width = 0;
  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
  if (titleLineCount) {
    height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
  }
  if (combinedBodyLength) {
    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
    height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
  }
  if (footerLineCount) {
    height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
  }
  let widthPadding = 0;
  const maxLineWidth = function(line) {
    width = Math.max(width, ctx.measureText(line).width + widthPadding);
  };
  ctx.save();
  ctx.font = titleFont.string;
  each(tooltip.title, maxLineWidth);
  ctx.font = bodyFont.string;
  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
  widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
  each(body, (bodyItem) => {
    each(bodyItem.before, maxLineWidth);
    each(bodyItem.lines, maxLineWidth);
    each(bodyItem.after, maxLineWidth);
  });
  widthPadding = 0;
  ctx.font = footerFont.string;
  each(tooltip.footer, maxLineWidth);
  ctx.restore();
  width += padding.width;
  return {
    width,
    height
  };
}
function determineYAlign(chart, size) {
  const { y, height } = size;
  if (y < height / 2) {
    return "top";
  } else if (y > chart.height - height / 2) {
    return "bottom";
  }
  return "center";
}
function doesNotFitWithAlign(xAlign, chart, options, size) {
  const { x, width } = size;
  const caret = options.caretSize + options.caretPadding;
  if (xAlign === "left" && x + width + caret > chart.width) {
    return true;
  }
  if (xAlign === "right" && x - width - caret < 0) {
    return true;
  }
}
function determineXAlign(chart, options, size, yAlign) {
  const { x, width } = size;
  const { width: chartWidth, chartArea: { left, right } } = chart;
  let xAlign = "center";
  if (yAlign === "center") {
    xAlign = x <= (left + right) / 2 ? "left" : "right";
  } else if (x <= width / 2) {
    xAlign = "left";
  } else if (x >= chartWidth - width / 2) {
    xAlign = "right";
  }
  if (doesNotFitWithAlign(xAlign, chart, options, size)) {
    xAlign = "center";
  }
  return xAlign;
}
function determineAlignment(chart, options, size) {
  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
  return {
    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
    yAlign
  };
}
function alignX(size, xAlign) {
  let { x, width } = size;
  if (xAlign === "right") {
    x -= width;
  } else if (xAlign === "center") {
    x -= width / 2;
  }
  return x;
}
function alignY(size, yAlign, paddingAndSize) {
  let { y, height } = size;
  if (yAlign === "top") {
    y += paddingAndSize;
  } else if (yAlign === "bottom") {
    y -= height + paddingAndSize;
  } else {
    y -= height / 2;
  }
  return y;
}
function getBackgroundPoint(options, size, alignment, chart) {
  const { caretSize, caretPadding, cornerRadius } = options;
  const { xAlign, yAlign } = alignment;
  const paddingAndSize = caretSize + caretPadding;
  const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
  let x = alignX(size, xAlign);
  const y = alignY(size, yAlign, paddingAndSize);
  if (yAlign === "center") {
    if (xAlign === "left") {
      x += paddingAndSize;
    } else if (xAlign === "right") {
      x -= paddingAndSize;
    }
  } else if (xAlign === "left") {
    x -= Math.max(topLeft, bottomLeft) + caretSize;
  } else if (xAlign === "right") {
    x += Math.max(topRight, bottomRight) + caretSize;
  }
  return {
    x: _limitValue(x, 0, chart.width - size.width),
    y: _limitValue(y, 0, chart.height - size.height)
  };
}
function getAlignedX(tooltip, align, options) {
  const padding = toPadding(options.padding);
  return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
}
function getBeforeAfterBodyLines(callback3) {
  return pushOrConcat([], splitNewlines(callback3));
}
function createTooltipContext(parent, tooltip, tooltipItems) {
  return createContext(parent, {
    tooltip,
    tooltipItems,
    type: "tooltip"
  });
}
function overrideCallbacks(callbacks, context) {
  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
  return override ? callbacks.override(override) : callbacks;
}
var defaultCallbacks = {
  beforeTitle: noop,
  title(tooltipItems) {
    if (tooltipItems.length > 0) {
      const item = tooltipItems[0];
      const labels = item.chart.data.labels;
      const labelCount = labels ? labels.length : 0;
      if (this && this.options && this.options.mode === "dataset") {
        return item.dataset.label || "";
      } else if (item.label) {
        return item.label;
      } else if (labelCount > 0 && item.dataIndex < labelCount) {
        return labels[item.dataIndex];
      }
    }
    return "";
  },
  afterTitle: noop,
  beforeBody: noop,
  beforeLabel: noop,
  label(tooltipItem) {
    if (this && this.options && this.options.mode === "dataset") {
      return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
    }
    let label = tooltipItem.dataset.label || "";
    if (label) {
      label += ": ";
    }
    const value = tooltipItem.formattedValue;
    if (!isNullOrUndef(value)) {
      label += value;
    }
    return label;
  },
  labelColor(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      borderColor: options.borderColor,
      backgroundColor: options.backgroundColor,
      borderWidth: options.borderWidth,
      borderDash: options.borderDash,
      borderDashOffset: options.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      pointStyle: options.pointStyle,
      rotation: options.rotation
    };
  },
  afterLabel: noop,
  afterBody: noop,
  beforeFooter: noop,
  footer: noop,
  afterFooter: noop
};
function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
  const result = callbacks[name].call(ctx, arg);
  if (typeof result === "undefined") {
    return defaultCallbacks[name].call(ctx, arg);
  }
  return result;
}
var Tooltip = class extends Element {
  constructor(config) {
    super();
    this.opacity = 0;
    this._active = [];
    this._eventPosition = void 0;
    this._size = void 0;
    this._cachedAnimations = void 0;
    this._tooltipItems = [];
    this.$animations = void 0;
    this.$context = void 0;
    this.chart = config.chart;
    this.options = config.options;
    this.dataPoints = void 0;
    this.title = void 0;
    this.beforeBody = void 0;
    this.body = void 0;
    this.afterBody = void 0;
    this.footer = void 0;
    this.xAlign = void 0;
    this.yAlign = void 0;
    this.x = void 0;
    this.y = void 0;
    this.height = void 0;
    this.width = void 0;
    this.caretX = void 0;
    this.caretY = void 0;
    this.labelColors = void 0;
    this.labelPointStyles = void 0;
    this.labelTextColors = void 0;
  }
  initialize(options) {
    this.options = options;
    this._cachedAnimations = void 0;
    this.$context = void 0;
  }
  _resolveAnimations() {
    const cached = this._cachedAnimations;
    if (cached) {
      return cached;
    }
    const chart = this.chart;
    const options = this.options.setContext(this.getContext());
    const opts = options.enabled && chart.options.animation && options.animations;
    const animations = new Animations(this.chart, opts);
    if (opts._cacheable) {
      this._cachedAnimations = Object.freeze(animations);
    }
    return animations;
  }
  getContext() {
    return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(context, options) {
    const { callbacks } = options;
    const beforeTitle = invokeCallbackWithFallback(callbacks, "beforeTitle", this, context);
    const title = invokeCallbackWithFallback(callbacks, "title", this, context);
    const afterTitle = invokeCallbackWithFallback(callbacks, "afterTitle", this, context);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeTitle));
    lines = pushOrConcat(lines, splitNewlines(title));
    lines = pushOrConcat(lines, splitNewlines(afterTitle));
    return lines;
  }
  getBeforeBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "beforeBody", this, tooltipItems));
  }
  getBody(tooltipItems, options) {
    const { callbacks } = options;
    const bodyItems = [];
    each(tooltipItems, (context) => {
      const bodyItem = {
        before: [],
        lines: [],
        after: []
      };
      const scoped = overrideCallbacks(callbacks, context);
      pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, "beforeLabel", this, context)));
      pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, "label", this, context));
      pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, "afterLabel", this, context)));
      bodyItems.push(bodyItem);
    });
    return bodyItems;
  }
  getAfterBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "afterBody", this, tooltipItems));
  }
  getFooter(tooltipItems, options) {
    const { callbacks } = options;
    const beforeFooter = invokeCallbackWithFallback(callbacks, "beforeFooter", this, tooltipItems);
    const footer = invokeCallbackWithFallback(callbacks, "footer", this, tooltipItems);
    const afterFooter = invokeCallbackWithFallback(callbacks, "afterFooter", this, tooltipItems);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeFooter));
    lines = pushOrConcat(lines, splitNewlines(footer));
    lines = pushOrConcat(lines, splitNewlines(afterFooter));
    return lines;
  }
  _createItems(options) {
    const active = this._active;
    const data = this.chart.data;
    const labelColors = [];
    const labelPointStyles = [];
    const labelTextColors = [];
    let tooltipItems = [];
    let i, len;
    for (i = 0, len = active.length; i < len; ++i) {
      tooltipItems.push(createTooltipItem(this.chart, active[i]));
    }
    if (options.filter) {
      tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));
    }
    if (options.itemSort) {
      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
    }
    each(tooltipItems, (context) => {
      const scoped = overrideCallbacks(options.callbacks, context);
      labelColors.push(invokeCallbackWithFallback(scoped, "labelColor", this, context));
      labelPointStyles.push(invokeCallbackWithFallback(scoped, "labelPointStyle", this, context));
      labelTextColors.push(invokeCallbackWithFallback(scoped, "labelTextColor", this, context));
    });
    this.labelColors = labelColors;
    this.labelPointStyles = labelPointStyles;
    this.labelTextColors = labelTextColors;
    this.dataPoints = tooltipItems;
    return tooltipItems;
  }
  update(changed, replay) {
    const options = this.options.setContext(this.getContext());
    const active = this._active;
    let properties;
    let tooltipItems = [];
    if (!active.length) {
      if (this.opacity !== 0) {
        properties = {
          opacity: 0
        };
      }
    } else {
      const position = positioners[options.position].call(this, active, this._eventPosition);
      tooltipItems = this._createItems(options);
      this.title = this.getTitle(tooltipItems, options);
      this.beforeBody = this.getBeforeBody(tooltipItems, options);
      this.body = this.getBody(tooltipItems, options);
      this.afterBody = this.getAfterBody(tooltipItems, options);
      this.footer = this.getFooter(tooltipItems, options);
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, size);
      const alignment = determineAlignment(this.chart, options, positionAndSize);
      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
      this.xAlign = alignment.xAlign;
      this.yAlign = alignment.yAlign;
      properties = {
        opacity: 1,
        x: backgroundPoint.x,
        y: backgroundPoint.y,
        width: size.width,
        height: size.height,
        caretX: position.x,
        caretY: position.y
      };
    }
    this._tooltipItems = tooltipItems;
    this.$context = void 0;
    if (properties) {
      this._resolveAnimations().update(this, properties);
    }
    if (changed && options.external) {
      options.external.call(this, {
        chart: this.chart,
        tooltip: this,
        replay
      });
    }
  }
  drawCaret(tooltipPoint, ctx, size, options) {
    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
    ctx.lineTo(caretPosition.x1, caretPosition.y1);
    ctx.lineTo(caretPosition.x2, caretPosition.y2);
    ctx.lineTo(caretPosition.x3, caretPosition.y3);
  }
  getCaretPosition(tooltipPoint, size, options) {
    const { xAlign, yAlign } = this;
    const { caretSize, cornerRadius } = options;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    const { x: ptX, y: ptY } = tooltipPoint;
    const { width, height } = size;
    let x1, x2, x3, y1, y2, y3;
    if (yAlign === "center") {
      y2 = ptY + height / 2;
      if (xAlign === "left") {
        x1 = ptX;
        x2 = x1 - caretSize;
        y1 = y2 + caretSize;
        y3 = y2 - caretSize;
      } else {
        x1 = ptX + width;
        x2 = x1 + caretSize;
        y1 = y2 - caretSize;
        y3 = y2 + caretSize;
      }
      x3 = x1;
    } else {
      if (xAlign === "left") {
        x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
      } else if (xAlign === "right") {
        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
      } else {
        x2 = this.caretX;
      }
      if (yAlign === "top") {
        y1 = ptY;
        y2 = y1 - caretSize;
        x1 = x2 - caretSize;
        x3 = x2 + caretSize;
      } else {
        y1 = ptY + height;
        y2 = y1 + caretSize;
        x1 = x2 + caretSize;
        x3 = x2 - caretSize;
      }
      y3 = y1;
    }
    return {
      x1,
      x2,
      x3,
      y1,
      y2,
      y3
    };
  }
  drawTitle(pt, ctx, options) {
    const title = this.title;
    const length = title.length;
    let titleFont, titleSpacing, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.titleAlign, options);
      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
      ctx.textBaseline = "middle";
      titleFont = toFont(options.titleFont);
      titleSpacing = options.titleSpacing;
      ctx.fillStyle = options.titleColor;
      ctx.font = titleFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
        pt.y += titleFont.lineHeight + titleSpacing;
        if (i + 1 === length) {
          pt.y += options.titleMarginBottom - titleSpacing;
        }
      }
    }
  }
  _drawColorBox(ctx, pt, i, rtlHelper, options) {
    const labelColor = this.labelColors[i];
    const labelPointStyle = this.labelPointStyles[i];
    const { boxHeight, boxWidth } = options;
    const bodyFont = toFont(options.bodyFont);
    const colorX = getAlignedX(this, "left", options);
    const rtlColorX = rtlHelper.x(colorX);
    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
    const colorY = pt.y + yOffSet;
    if (options.usePointStyle) {
      const drawOptions = {
        radius: Math.min(boxWidth, boxHeight) / 2,
        pointStyle: labelPointStyle.pointStyle,
        rotation: labelPointStyle.rotation,
        borderWidth: 1
      };
      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
      const centerY = colorY + boxHeight / 2;
      ctx.strokeStyle = options.multiKeyBackground;
      ctx.fillStyle = options.multiKeyBackground;
      drawPoint(ctx, drawOptions, centerX, centerY);
      ctx.strokeStyle = labelColor.borderColor;
      ctx.fillStyle = labelColor.backgroundColor;
      drawPoint(ctx, drawOptions, centerX, centerY);
    } else {
      ctx.lineWidth = isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;
      ctx.strokeStyle = labelColor.borderColor;
      ctx.setLineDash(labelColor.borderDash || []);
      ctx.lineDashOffset = labelColor.borderDashOffset || 0;
      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
      const borderRadius = toTRBLCorners(labelColor.borderRadius);
      if (Object.values(borderRadius).some((v) => v !== 0)) {
        ctx.beginPath();
        ctx.fillStyle = options.multiKeyBackground;
        addRoundedRectPath(ctx, {
          x: outerX,
          y: colorY,
          w: boxWidth,
          h: boxHeight,
          radius: borderRadius
        });
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = labelColor.backgroundColor;
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: innerX,
          y: colorY + 1,
          w: boxWidth - 2,
          h: boxHeight - 2,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillStyle = options.multiKeyBackground;
        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
        ctx.fillStyle = labelColor.backgroundColor;
        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
      }
    }
    ctx.fillStyle = this.labelTextColors[i];
  }
  drawBody(pt, ctx, options) {
    const { body } = this;
    const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
    const bodyFont = toFont(options.bodyFont);
    let bodyLineHeight = bodyFont.lineHeight;
    let xLinePadding = 0;
    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
    const fillLineOfText = function(line) {
      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
      pt.y += bodyLineHeight + bodySpacing;
    };
    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
    let bodyItem, textColor, lines, i, j, ilen, jlen;
    ctx.textAlign = bodyAlign;
    ctx.textBaseline = "middle";
    ctx.font = bodyFont.string;
    pt.x = getAlignedX(this, bodyAlignForCalculation, options);
    ctx.fillStyle = options.bodyColor;
    each(this.beforeBody, fillLineOfText);
    xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
    for (i = 0, ilen = body.length; i < ilen; ++i) {
      bodyItem = body[i];
      textColor = this.labelTextColors[i];
      ctx.fillStyle = textColor;
      each(bodyItem.before, fillLineOfText);
      lines = bodyItem.lines;
      if (displayColors && lines.length) {
        this._drawColorBox(ctx, pt, i, rtlHelper, options);
        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
      }
      for (j = 0, jlen = lines.length; j < jlen; ++j) {
        fillLineOfText(lines[j]);
        bodyLineHeight = bodyFont.lineHeight;
      }
      each(bodyItem.after, fillLineOfText);
    }
    xLinePadding = 0;
    bodyLineHeight = bodyFont.lineHeight;
    each(this.afterBody, fillLineOfText);
    pt.y -= bodySpacing;
  }
  drawFooter(pt, ctx, options) {
    const footer = this.footer;
    const length = footer.length;
    let footerFont, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.footerAlign, options);
      pt.y += options.footerMarginTop;
      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
      ctx.textBaseline = "middle";
      footerFont = toFont(options.footerFont);
      ctx.fillStyle = options.footerColor;
      ctx.font = footerFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
        pt.y += footerFont.lineHeight + options.footerSpacing;
      }
    }
  }
  drawBackground(pt, ctx, tooltipSize, options) {
    const { xAlign, yAlign } = this;
    const { x, y } = pt;
    const { width, height } = tooltipSize;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.beginPath();
    ctx.moveTo(x + topLeft, y);
    if (yAlign === "top") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width - topRight, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
    if (yAlign === "center" && xAlign === "right") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width, y + height - bottomRight);
    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
    if (yAlign === "bottom") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + bottomLeft, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
    if (yAlign === "center" && xAlign === "left") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x, y + topLeft);
    ctx.quadraticCurveTo(x, y, x + topLeft, y);
    ctx.closePath();
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  _updateAnimationTarget(options) {
    const chart = this.chart;
    const anims = this.$animations;
    const animX = anims && anims.x;
    const animY = anims && anims.y;
    if (animX || animY) {
      const position = positioners[options.position].call(this, this._active, this._eventPosition);
      if (!position) {
        return;
      }
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, this._size);
      const alignment = determineAlignment(chart, options, positionAndSize);
      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
      if (animX._to !== point.x || animY._to !== point.y) {
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        this.width = size.width;
        this.height = size.height;
        this.caretX = position.x;
        this.caretY = position.y;
        this._resolveAnimations().update(this, point);
      }
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(ctx) {
    const options = this.options.setContext(this.getContext());
    let opacity = this.opacity;
    if (!opacity) {
      return;
    }
    this._updateAnimationTarget(options);
    const tooltipSize = {
      width: this.width,
      height: this.height
    };
    const pt = {
      x: this.x,
      y: this.y
    };
    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
    const padding = toPadding(options.padding);
    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    if (options.enabled && hasTooltipContent) {
      ctx.save();
      ctx.globalAlpha = opacity;
      this.drawBackground(pt, ctx, tooltipSize, options);
      overrideTextDirection(ctx, options.textDirection);
      pt.y += padding.top;
      this.drawTitle(pt, ctx, options);
      this.drawBody(pt, ctx, options);
      this.drawFooter(pt, ctx, options);
      restoreTextDirection(ctx, options.textDirection);
      ctx.restore();
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements, eventPosition) {
    const lastActive = this._active;
    const active = activeElements.map(({ datasetIndex, index }) => {
      const meta = this.chart.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("Cannot find a dataset at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index],
        index
      };
    });
    const changed = !_elementsEqual(lastActive, active);
    const positionChanged = this._positionChanged(active, eventPosition);
    if (changed || positionChanged) {
      this._active = active;
      this._eventPosition = eventPosition;
      this._ignoreReplayEvents = true;
      this.update(true);
    }
  }
  handleEvent(e, replay, inChartArea = true) {
    if (replay && this._ignoreReplayEvents) {
      return false;
    }
    this._ignoreReplayEvents = false;
    const options = this.options;
    const lastActive = this._active || [];
    const active = this._getActiveElements(e, lastActive, replay, inChartArea);
    const positionChanged = this._positionChanged(active, e);
    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
    if (changed) {
      this._active = active;
      if (options.enabled || options.external) {
        this._eventPosition = {
          x: e.x,
          y: e.y
        };
        this.update(true, replay);
      }
    }
    return changed;
  }
  _getActiveElements(e, lastActive, replay, inChartArea) {
    const options = this.options;
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive.filter((i) => this.chart.data.datasets[i.datasetIndex] && this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== void 0);
    }
    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
    if (options.reverse) {
      active.reverse();
    }
    return active;
  }
  _positionChanged(active, e) {
    const { caretX, caretY, options } = this;
    const position = positioners[options.position].call(this, active, e);
    return position !== false && (caretX !== position.x || caretY !== position.y);
  }
};
__publicField(Tooltip, "positioners", positioners);
var plugin_tooltip = {
  id: "tooltip",
  _element: Tooltip,
  positioners,
  afterInit(chart, _args, options) {
    if (options) {
      chart.tooltip = new Tooltip({
        chart,
        options
      });
    }
  },
  beforeUpdate(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  reset(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  afterDraw(chart) {
    const tooltip = chart.tooltip;
    if (tooltip && tooltip._willRender()) {
      const args = {
        tooltip
      };
      if (chart.notifyPlugins("beforeTooltipDraw", {
        ...args,
        cancelable: true
      }) === false) {
        return;
      }
      tooltip.draw(chart.ctx);
      chart.notifyPlugins("afterTooltipDraw", args);
    }
  },
  afterEvent(chart, args) {
    if (chart.tooltip) {
      const useFinalPosition = args.replay;
      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
        args.changed = true;
      }
    }
  },
  defaults: {
    enabled: true,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (ctx, opts) => opts.bodyFont.size,
    boxWidth: (ctx, opts) => opts.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: true,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: defaultCallbacks
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
    _indexable: false,
    callbacks: {
      _scriptable: false,
      _indexable: false
    },
    animation: {
      _fallback: false
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
};
function generateTicks$1(generationOptions, dataRange) {
  const ticks = [];
  const MIN_SPACING = 1e-14;
  const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
  const unit = step || 1;
  const maxSpaces = maxTicks - 1;
  const { min: rmin, max: rmax } = dataRange;
  const minDefined = !isNullOrUndef(min);
  const maxDefined = !isNullOrUndef(max);
  const countDefined = !isNullOrUndef(count);
  const minSpacing = (rmax - rmin) / (maxDigits + 1);
  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
  let factor, niceMin, niceMax, numSpaces;
  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
    return [
      {
        value: rmin
      },
      {
        value: rmax
      }
    ];
  }
  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
  if (numSpaces > maxSpaces) {
    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
  }
  if (!isNullOrUndef(precision)) {
    factor = Math.pow(10, precision);
    spacing = Math.ceil(spacing * factor) / factor;
  }
  if (bounds === "ticks") {
    niceMin = Math.floor(rmin / spacing) * spacing;
    niceMax = Math.ceil(rmax / spacing) * spacing;
  } else {
    niceMin = rmin;
    niceMax = rmax;
  }
  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
    spacing = (max - min) / numSpaces;
    niceMin = min;
    niceMax = max;
  } else if (countDefined) {
    niceMin = minDefined ? min : niceMin;
    niceMax = maxDefined ? max : niceMax;
    numSpaces = count - 1;
    spacing = (niceMax - niceMin) / numSpaces;
  } else {
    numSpaces = (niceMax - niceMin) / spacing;
    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
      numSpaces = Math.round(numSpaces);
    } else {
      numSpaces = Math.ceil(numSpaces);
    }
  }
  const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
  niceMin = Math.round(niceMin * factor) / factor;
  niceMax = Math.round(niceMax * factor) / factor;
  let j = 0;
  if (minDefined) {
    if (includeBounds && niceMin !== min) {
      ticks.push({
        value: min
      });
      if (niceMin < min) {
        j++;
      }
      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
        j++;
      }
    } else if (niceMin < min) {
      j++;
    }
  }
  for (; j < numSpaces; ++j) {
    const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;
    if (maxDefined && tickValue > max) {
      break;
    }
    ticks.push({
      value: tickValue
    });
  }
  if (maxDefined && includeBounds && niceMax !== max) {
    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
      ticks[ticks.length - 1].value = max;
    } else {
      ticks.push({
        value: max
      });
    }
  } else if (!maxDefined || niceMax === max) {
    ticks.push({
      value: niceMax
    });
  }
  return ticks;
}
function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
  const rad = toRadians(minRotation);
  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
  const length = 0.75 * minSpacing * ("" + value).length;
  return Math.min(minSpacing / ratio, length);
}
var LinearScaleBase = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._endValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
      return null;
    }
    return +raw;
  }
  handleTickRangeOptions() {
    const { beginAtZero } = this.options;
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max = maxDefined ? max : v;
    if (beginAtZero) {
      const minSign = sign(min);
      const maxSign = sign(max);
      if (minSign < 0 && maxSign < 0) {
        setMax(0);
      } else if (minSign > 0 && maxSign > 0) {
        setMin(0);
      }
    }
    if (min === max) {
      let offset2 = max === 0 ? 1 : Math.abs(max * 0.05);
      setMax(max + offset2);
      if (!beginAtZero) {
        setMin(min - offset2);
      }
    }
    this.min = min;
    this.max = max;
  }
  getTickLimit() {
    const tickOpts = this.options.ticks;
    let { maxTicksLimit, stepSize } = tickOpts;
    let maxTicks;
    if (stepSize) {
      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
      if (maxTicks > 1e3) {
        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
        maxTicks = 1e3;
      }
    } else {
      maxTicks = this.computeTickLimit();
      maxTicksLimit = maxTicksLimit || 11;
    }
    if (maxTicksLimit) {
      maxTicks = Math.min(maxTicksLimit, maxTicks);
    }
    return maxTicks;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const opts = this.options;
    const tickOpts = opts.ticks;
    let maxTicks = this.getTickLimit();
    maxTicks = Math.max(2, maxTicks);
    const numericGeneratorOptions = {
      maxTicks,
      bounds: opts.bounds,
      min: opts.min,
      max: opts.max,
      precision: tickOpts.precision,
      step: tickOpts.stepSize,
      count: tickOpts.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: tickOpts.minRotation || 0,
      includeBounds: tickOpts.includeBounds !== false
    };
    const dataRange = this._range || this;
    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  configure() {
    const ticks = this.ticks;
    let start = this.min;
    let end = this.max;
    super.configure();
    if (this.options.offset && ticks.length) {
      const offset2 = (end - start) / Math.max(ticks.length - 1, 1) / 2;
      start -= offset2;
      end += offset2;
    }
    this._startValue = start;
    this._endValue = end;
    this._valueRange = end - start;
  }
  getLabelForValue(value) {
    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
};
var LinearScale = class extends LinearScaleBase {
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? min : 0;
    this.max = isNumberFinite(max) ? max : 1;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const horizontal = this.isHorizontal();
    const length = horizontal ? this.width : this.height;
    const minRotation = toRadians(this.options.ticks.minRotation);
    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
    const tickFont = this._resolveTickFontOptions(0);
    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
  }
  getPixelForValue(value) {
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
  }
};
__publicField(LinearScale, "id", "linear");
__publicField(LinearScale, "defaults", {
  ticks: {
    callback: Ticks.formatters.numeric
  }
});
var log10Floor = (v) => Math.floor(log10(v));
var changeExponent = (v, m) => Math.pow(10, log10Floor(v) + m);
function isMajor(tickVal) {
  const remain = tickVal / Math.pow(10, log10Floor(tickVal));
  return remain === 1;
}
function steps(min, max, rangeExp) {
  const rangeStep = Math.pow(10, rangeExp);
  const start = Math.floor(min / rangeStep);
  const end = Math.ceil(max / rangeStep);
  return end - start;
}
function startExp(min, max) {
  const range = max - min;
  let rangeExp = log10Floor(range);
  while (steps(min, max, rangeExp) > 10) {
    rangeExp++;
  }
  while (steps(min, max, rangeExp) < 10) {
    rangeExp--;
  }
  return Math.min(rangeExp, log10Floor(min));
}
function generateTicks(generationOptions, { min, max }) {
  min = finiteOrDefault(generationOptions.min, min);
  const ticks = [];
  const minExp = log10Floor(min);
  let exp = startExp(min, max);
  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
  const stepSize = Math.pow(10, exp);
  const base = minExp > exp ? Math.pow(10, minExp) : 0;
  const start = Math.round((min - base) * precision) / precision;
  const offset2 = Math.floor((min - base) / stepSize / 10) * stepSize * 10;
  let significand = Math.floor((start - offset2) / Math.pow(10, exp));
  let value = finiteOrDefault(generationOptions.min, Math.round((base + offset2 + significand * Math.pow(10, exp)) * precision) / precision);
  while (value < max) {
    ticks.push({
      value,
      major: isMajor(value),
      significand
    });
    if (significand >= 10) {
      significand = significand < 15 ? 15 : 20;
    } else {
      significand++;
    }
    if (significand >= 20) {
      exp++;
      significand = 2;
      precision = exp >= 0 ? 1 : precision;
    }
    value = Math.round((base + offset2 + significand * Math.pow(10, exp)) * precision) / precision;
  }
  const lastTick = finiteOrDefault(generationOptions.max, value);
  ticks.push({
    value: lastTick,
    major: isMajor(lastTick),
    significand
  });
  return ticks;
}
var LogarithmicScale = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index) {
    const value = LinearScaleBase.prototype.parse.apply(this, [
      raw,
      index
    ]);
    if (value === 0) {
      this._zero = true;
      return void 0;
    }
    return isNumberFinite(value) && value > 0 ? value : null;
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? Math.max(0, min) : null;
    this.max = isNumberFinite(max) ? Math.max(0, max) : null;
    if (this.options.beginAtZero) {
      this._zero = true;
    }
    if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {
      this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
    }
    this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let min = this.min;
    let max = this.max;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max = maxDefined ? max : v;
    if (min === max) {
      if (min <= 0) {
        setMin(1);
        setMax(10);
      } else {
        setMin(changeExponent(min, -1));
        setMax(changeExponent(max, 1));
      }
    }
    if (min <= 0) {
      setMin(changeExponent(max, -1));
    }
    if (max <= 0) {
      setMax(changeExponent(min, 1));
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const opts = this.options;
    const generationOptions = {
      min: this._userMin,
      max: this._userMax
    };
    const ticks = generateTicks(generationOptions, this);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  getLabelForValue(value) {
    return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const start = this.min;
    super.configure();
    this._startValue = log10(start);
    this._valueRange = log10(this.max) - log10(start);
  }
  getPixelForValue(value) {
    if (value === void 0 || value === 0) {
      value = this.min;
    }
    if (value === null || isNaN(value)) {
      return NaN;
    }
    return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    const decimal = this.getDecimalForPixel(pixel);
    return Math.pow(10, this._startValue + decimal * this._valueRange);
  }
};
__publicField(LogarithmicScale, "id", "logarithmic");
__publicField(LogarithmicScale, "defaults", {
  ticks: {
    callback: Ticks.formatters.logarithmic,
    major: {
      enabled: true
    }
  }
});
function getTickBackdropHeight(opts) {
  const tickOpts = opts.ticks;
  if (tickOpts.display && opts.display) {
    const padding = toPadding(tickOpts.backdropPadding);
    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
  }
  return 0;
}
function measureLabelSize(ctx, font, label) {
  label = isArray(label) ? label : [
    label
  ];
  return {
    w: _longestText(ctx, font.string, label),
    h: label.length * font.lineHeight
  };
}
function determineLimits(angle, pos, size, min, max) {
  if (angle === min || angle === max) {
    return {
      start: pos - size / 2,
      end: pos + size / 2
    };
  } else if (angle < min || angle > max) {
    return {
      start: pos - size,
      end: pos
    };
  }
  return {
    start: pos,
    end: pos + size
  };
}
function fitWithPointLabels(scale) {
  const orig = {
    l: scale.left + scale._padding.left,
    r: scale.right - scale._padding.right,
    t: scale.top + scale._padding.top,
    b: scale.bottom - scale._padding.bottom
  };
  const limits = Object.assign({}, orig);
  const labelSizes = [];
  const padding = [];
  const valueCount = scale._pointLabels.length;
  const pointLabelOpts = scale.options.pointLabels;
  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
  for (let i = 0; i < valueCount; i++) {
    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
    padding[i] = opts.padding;
    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
    const plFont = toFont(opts.font);
    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
    labelSizes[i] = textSize;
    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
    const angle = Math.round(toDegrees(angleRadians));
    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
    updateLimits(limits, orig, angleRadians, hLimits, vLimits);
  }
  scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
}
function updateLimits(limits, orig, angle, hLimits, vLimits) {
  const sin = Math.abs(Math.sin(angle));
  const cos = Math.abs(Math.cos(angle));
  let x = 0;
  let y = 0;
  if (hLimits.start < orig.l) {
    x = (orig.l - hLimits.start) / sin;
    limits.l = Math.min(limits.l, orig.l - x);
  } else if (hLimits.end > orig.r) {
    x = (hLimits.end - orig.r) / sin;
    limits.r = Math.max(limits.r, orig.r + x);
  }
  if (vLimits.start < orig.t) {
    y = (orig.t - vLimits.start) / cos;
    limits.t = Math.min(limits.t, orig.t - y);
  } else if (vLimits.end > orig.b) {
    y = (vLimits.end - orig.b) / cos;
    limits.b = Math.max(limits.b, orig.b + y);
  }
}
function createPointLabelItem(scale, index, itemOpts) {
  const outerDistance = scale.drawingArea;
  const { extra, additionalAngle, padding, size } = itemOpts;
  const pointLabelPosition = scale.getPointPosition(index, outerDistance + extra + padding, additionalAngle);
  const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
  const y = yForAngle(pointLabelPosition.y, size.h, angle);
  const textAlign = getTextAlignForAngle(angle);
  const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
  return {
    visible: true,
    x: pointLabelPosition.x,
    y,
    textAlign,
    left,
    top: y,
    right: left + size.w,
    bottom: y + size.h
  };
}
function isNotOverlapped(item, area) {
  if (!area) {
    return true;
  }
  const { left, top, right, bottom } = item;
  const apexesInArea = _isPointInArea({
    x: left,
    y: top
  }, area) || _isPointInArea({
    x: left,
    y: bottom
  }, area) || _isPointInArea({
    x: right,
    y: top
  }, area) || _isPointInArea({
    x: right,
    y: bottom
  }, area);
  return !apexesInArea;
}
function buildPointLabelItems(scale, labelSizes, padding) {
  const items = [];
  const valueCount = scale._pointLabels.length;
  const opts = scale.options;
  const { centerPointLabels, display } = opts.pointLabels;
  const itemOpts = {
    extra: getTickBackdropHeight(opts) / 2,
    additionalAngle: centerPointLabels ? PI / valueCount : 0
  };
  let area;
  for (let i = 0; i < valueCount; i++) {
    itemOpts.padding = padding[i];
    itemOpts.size = labelSizes[i];
    const item = createPointLabelItem(scale, i, itemOpts);
    items.push(item);
    if (display === "auto") {
      item.visible = isNotOverlapped(item, area);
      if (item.visible) {
        area = item;
      }
    }
  }
  return items;
}
function getTextAlignForAngle(angle) {
  if (angle === 0 || angle === 180) {
    return "center";
  } else if (angle < 180) {
    return "left";
  }
  return "right";
}
function leftForTextAlign(x, w, align) {
  if (align === "right") {
    x -= w;
  } else if (align === "center") {
    x -= w / 2;
  }
  return x;
}
function yForAngle(y, h, angle) {
  if (angle === 90 || angle === 270) {
    y -= h / 2;
  } else if (angle > 270 || angle < 90) {
    y -= h;
  }
  return y;
}
function drawPointLabelBox(ctx, opts, item) {
  const { left, top, right, bottom } = item;
  const { backdropColor } = opts;
  if (!isNullOrUndef(backdropColor)) {
    const borderRadius = toTRBLCorners(opts.borderRadius);
    const padding = toPadding(opts.backdropPadding);
    ctx.fillStyle = backdropColor;
    const backdropLeft = left - padding.left;
    const backdropTop = top - padding.top;
    const backdropWidth = right - left + padding.width;
    const backdropHeight = bottom - top + padding.height;
    if (Object.values(borderRadius).some((v) => v !== 0)) {
      ctx.beginPath();
      addRoundedRectPath(ctx, {
        x: backdropLeft,
        y: backdropTop,
        w: backdropWidth,
        h: backdropHeight,
        radius: borderRadius
      });
      ctx.fill();
    } else {
      ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
    }
  }
}
function drawPointLabels(scale, labelCount) {
  const { ctx, options: { pointLabels } } = scale;
  for (let i = labelCount - 1; i >= 0; i--) {
    const item = scale._pointLabelItems[i];
    if (!item.visible) {
      continue;
    }
    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
    drawPointLabelBox(ctx, optsAtIndex, item);
    const plFont = toFont(optsAtIndex.font);
    const { x, y, textAlign } = item;
    renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
      color: optsAtIndex.color,
      textAlign,
      textBaseline: "middle"
    });
  }
}
function pathRadiusLine(scale, radius, circular, labelCount) {
  const { ctx } = scale;
  if (circular) {
    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
  } else {
    let pointPosition = scale.getPointPosition(0, radius);
    ctx.moveTo(pointPosition.x, pointPosition.y);
    for (let i = 1; i < labelCount; i++) {
      pointPosition = scale.getPointPosition(i, radius);
      ctx.lineTo(pointPosition.x, pointPosition.y);
    }
  }
}
function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
  const ctx = scale.ctx;
  const circular = gridLineOpts.circular;
  const { color: color3, lineWidth } = gridLineOpts;
  if (!circular && !labelCount || !color3 || !lineWidth || radius < 0) {
    return;
  }
  ctx.save();
  ctx.strokeStyle = color3;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash(borderOpts.dash);
  ctx.lineDashOffset = borderOpts.dashOffset;
  ctx.beginPath();
  pathRadiusLine(scale, radius, circular, labelCount);
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}
function createPointLabelContext(parent, index, label) {
  return createContext(parent, {
    label,
    index,
    type: "pointLabel"
  });
}
var RadialLinearScale = class extends LinearScaleBase {
  constructor(cfg) {
    super(cfg);
    this.xCenter = void 0;
    this.yCenter = void 0;
    this.drawingArea = void 0;
    this._pointLabels = [];
    this._pointLabelItems = [];
  }
  setDimensions() {
    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
    const w = this.width = this.maxWidth - padding.width;
    const h = this.height = this.maxHeight - padding.height;
    this.xCenter = Math.floor(this.left + w / 2 + padding.left);
    this.yCenter = Math.floor(this.top + h / 2 + padding.top);
    this.drawingArea = Math.floor(Math.min(w, h) / 2);
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(false);
    this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
    this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
  }
  generateTickLabels(ticks) {
    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
    this._pointLabels = this.getLabels().map((value, index) => {
      const label = callback(this.options.pointLabels.callback, [
        value,
        index
      ], this);
      return label || label === 0 ? label : "";
    }).filter((v, i) => this.chart.getDataVisibility(i));
  }
  fit() {
    const opts = this.options;
    if (opts.display && opts.pointLabels.display) {
      fitWithPointLabels(this);
    } else {
      this.setCenterPoint(0, 0, 0, 0);
    }
  }
  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
  }
  getIndexAngle(index) {
    const angleMultiplier = TAU / (this._pointLabels.length || 1);
    const startAngle = this.options.startAngle || 0;
    return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));
  }
  getDistanceFromCenterForValue(value) {
    if (isNullOrUndef(value)) {
      return NaN;
    }
    const scalingFactor = this.drawingArea / (this.max - this.min);
    if (this.options.reverse) {
      return (this.max - value) * scalingFactor;
    }
    return (value - this.min) * scalingFactor;
  }
  getValueForDistanceFromCenter(distance) {
    if (isNullOrUndef(distance)) {
      return NaN;
    }
    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
  }
  getPointLabelContext(index) {
    const pointLabels = this._pointLabels || [];
    if (index >= 0 && index < pointLabels.length) {
      const pointLabel = pointLabels[index];
      return createPointLabelContext(this.getContext(), index, pointLabel);
    }
  }
  getPointPosition(index, distanceFromCenter, additionalAngle = 0) {
    const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;
    return {
      x: Math.cos(angle) * distanceFromCenter + this.xCenter,
      y: Math.sin(angle) * distanceFromCenter + this.yCenter,
      angle
    };
  }
  getPointPositionForValue(index, value) {
    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
  }
  getBasePosition(index) {
    return this.getPointPositionForValue(index || 0, this.getBaseValue());
  }
  getPointLabelPosition(index) {
    const { left, top, right, bottom } = this._pointLabelItems[index];
    return {
      left,
      top,
      right,
      bottom
    };
  }
  drawBackground() {
    const { backgroundColor, grid: { circular } } = this.options;
    if (backgroundColor) {
      const ctx = this.ctx;
      ctx.save();
      ctx.beginPath();
      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
      ctx.closePath();
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
  }
  drawGrid() {
    const ctx = this.ctx;
    const opts = this.options;
    const { angleLines, grid, border } = opts;
    const labelCount = this._pointLabels.length;
    let i, offset2, position;
    if (opts.pointLabels.display) {
      drawPointLabels(this, labelCount);
    }
    if (grid.display) {
      this.ticks.forEach((tick, index) => {
        if (index !== 0 || index === 0 && this.min < 0) {
          offset2 = this.getDistanceFromCenterForValue(tick.value);
          const context = this.getContext(index);
          const optsAtIndex = grid.setContext(context);
          const optsAtIndexBorder = border.setContext(context);
          drawRadiusLine(this, optsAtIndex, offset2, labelCount, optsAtIndexBorder);
        }
      });
    }
    if (angleLines.display) {
      ctx.save();
      for (i = labelCount - 1; i >= 0; i--) {
        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
        const { color: color3, lineWidth } = optsAtIndex;
        if (!lineWidth || !color3) {
          continue;
        }
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = color3;
        ctx.setLineDash(optsAtIndex.borderDash);
        ctx.lineDashOffset = optsAtIndex.borderDashOffset;
        offset2 = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
        position = this.getPointPosition(i, offset2);
        ctx.beginPath();
        ctx.moveTo(this.xCenter, this.yCenter);
        ctx.lineTo(position.x, position.y);
        ctx.stroke();
      }
      ctx.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const ctx = this.ctx;
    const opts = this.options;
    const tickOpts = opts.ticks;
    if (!tickOpts.display) {
      return;
    }
    const startAngle = this.getIndexAngle(0);
    let offset2, width;
    ctx.save();
    ctx.translate(this.xCenter, this.yCenter);
    ctx.rotate(startAngle);
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    this.ticks.forEach((tick, index) => {
      if (index === 0 && this.min >= 0 && !opts.reverse) {
        return;
      }
      const optsAtIndex = tickOpts.setContext(this.getContext(index));
      const tickFont = toFont(optsAtIndex.font);
      offset2 = this.getDistanceFromCenterForValue(this.ticks[index].value);
      if (optsAtIndex.showLabelBackdrop) {
        ctx.font = tickFont.string;
        width = ctx.measureText(tick.label).width;
        ctx.fillStyle = optsAtIndex.backdropColor;
        const padding = toPadding(optsAtIndex.backdropPadding);
        ctx.fillRect(-width / 2 - padding.left, -offset2 - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
      }
      renderText(ctx, tick.label, 0, -offset2, tickFont, {
        color: optsAtIndex.color,
        strokeColor: optsAtIndex.textStrokeColor,
        strokeWidth: optsAtIndex.textStrokeWidth
      });
    });
    ctx.restore();
  }
  drawTitle() {
  }
};
__publicField(RadialLinearScale, "id", "radialLinear");
__publicField(RadialLinearScale, "defaults", {
  display: true,
  animate: true,
  position: "chartArea",
  angleLines: {
    display: true,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: false
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: true,
    callback: Ticks.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: true,
    font: {
      size: 10
    },
    callback(label) {
      return label;
    },
    padding: 5,
    centerPointLabels: false
  }
});
__publicField(RadialLinearScale, "defaultRoutes", {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
});
__publicField(RadialLinearScale, "descriptors", {
  angleLines: {
    _fallback: "grid"
  }
});
var INTERVALS = {
  millisecond: {
    common: true,
    size: 1,
    steps: 1e3
  },
  second: {
    common: true,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: true,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: true,
    size: 36e5,
    steps: 24
  },
  day: {
    common: true,
    size: 864e5,
    steps: 30
  },
  week: {
    common: false,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: true,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: false,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: true,
    size: 3154e7
  }
};
var UNITS = /* @__PURE__ */ Object.keys(INTERVALS);
function sorter(a, b) {
  return a - b;
}
function parse(scale, input) {
  if (isNullOrUndef(input)) {
    return null;
  }
  const adapter = scale._adapter;
  const { parser, round: round3, isoWeekday } = scale._parseOpts;
  let value = input;
  if (typeof parser === "function") {
    value = parser(value);
  }
  if (!isNumberFinite(value)) {
    value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
  }
  if (value === null) {
    return null;
  }
  if (round3) {
    value = round3 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round3);
  }
  return +value;
}
function determineUnitForAutoTicks(minUnit, min, max, capacity) {
  const ilen = UNITS.length;
  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
    const interval = INTERVALS[UNITS[i]];
    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
      return UNITS[i];
    }
  }
  return UNITS[ilen - 1];
}
function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
    const unit = UNITS[i];
    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
      return unit;
    }
  }
  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
function determineMajorUnit(unit) {
  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
    if (INTERVALS[UNITS[i]].common) {
      return UNITS[i];
    }
  }
}
function addTick(ticks, time, timestamps) {
  if (!timestamps) {
    ticks[time] = true;
  } else if (timestamps.length) {
    const { lo, hi } = _lookup(timestamps, time);
    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
    ticks[timestamp] = true;
  }
}
function setMajorTicks(scale, ticks, map3, majorUnit) {
  const adapter = scale._adapter;
  const first = +adapter.startOf(ticks[0].value, majorUnit);
  const last = ticks[ticks.length - 1].value;
  let major, index;
  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
    index = map3[major];
    if (index >= 0) {
      ticks[index].major = true;
    }
  }
  return ticks;
}
function ticksFromTimestamps(scale, values, majorUnit) {
  const ticks = [];
  const map3 = {};
  const ilen = values.length;
  let i, value;
  for (i = 0; i < ilen; ++i) {
    value = values[i];
    map3[value] = i;
    ticks.push({
      value,
      major: false
    });
  }
  return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map3, majorUnit);
}
var TimeScale = class extends Scale {
  constructor(props) {
    super(props);
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
    this._unit = "day";
    this._majorUnit = void 0;
    this._offsets = {};
    this._normalized = false;
    this._parseOpts = void 0;
  }
  init(scaleOpts, opts = {}) {
    const time = scaleOpts.time || (scaleOpts.time = {});
    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
    adapter.init(opts);
    mergeIf(time.displayFormats, adapter.formats());
    this._parseOpts = {
      parser: time.parser,
      round: time.round,
      isoWeekday: time.isoWeekday
    };
    super.init(scaleOpts);
    this._normalized = opts.normalized;
  }
  parse(raw, index) {
    if (raw === void 0) {
      return null;
    }
    return parse(this, raw);
  }
  beforeLayout() {
    super.beforeLayout();
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const options = this.options;
    const adapter = this._adapter;
    const unit = options.time.unit || "day";
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    function _applyBounds(bounds) {
      if (!minDefined && !isNaN(bounds.min)) {
        min = Math.min(min, bounds.min);
      }
      if (!maxDefined && !isNaN(bounds.max)) {
        max = Math.max(max, bounds.max);
      }
    }
    if (!minDefined || !maxDefined) {
      _applyBounds(this._getLabelBounds());
      if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
        _applyBounds(this.getMinMax(false));
      }
    }
    min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
    max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
    this.min = Math.min(min, max - 1);
    this.max = Math.max(min + 1, max);
  }
  _getLabelBounds() {
    const arr = this.getLabelTimestamps();
    let min = Number.POSITIVE_INFINITY;
    let max = Number.NEGATIVE_INFINITY;
    if (arr.length) {
      min = arr[0];
      max = arr[arr.length - 1];
    }
    return {
      min,
      max
    };
  }
  buildTicks() {
    const options = this.options;
    const timeOpts = options.time;
    const tickOpts = options.ticks;
    const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
    if (options.bounds === "ticks" && timestamps.length) {
      this.min = this._userMin || timestamps[0];
      this.max = this._userMax || timestamps[timestamps.length - 1];
    }
    const min = this.min;
    const max = this.max;
    const ticks = _filterBetween(timestamps, min, max);
    this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
    this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
    this.initOffsets(timestamps);
    if (options.reverse) {
      ticks.reverse();
    }
    return ticksFromTimestamps(this, ticks, this._majorUnit);
  }
  afterAutoSkip() {
    if (this.options.offsetAfterAutoskip) {
      this.initOffsets(this.ticks.map((tick) => +tick.value));
    }
  }
  initOffsets(timestamps = []) {
    let start = 0;
    let end = 0;
    let first, last;
    if (this.options.offset && timestamps.length) {
      first = this.getDecimalForValue(timestamps[0]);
      if (timestamps.length === 1) {
        start = 1 - first;
      } else {
        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
      }
      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
      if (timestamps.length === 1) {
        end = last;
      } else {
        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
      }
    }
    const limit = timestamps.length < 3 ? 0.5 : 0.25;
    start = _limitValue(start, 0, limit);
    end = _limitValue(end, 0, limit);
    this._offsets = {
      start,
      end,
      factor: 1 / (start + 1 + end)
    };
  }
  _generate() {
    const adapter = this._adapter;
    const min = this.min;
    const max = this.max;
    const options = this.options;
    const timeOpts = options.time;
    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
    const stepSize = valueOrDefault(options.ticks.stepSize, 1);
    const weekday = minor === "week" ? timeOpts.isoWeekday : false;
    const hasWeekday = isNumber(weekday) || weekday === true;
    const ticks = {};
    let first = min;
    let time, count;
    if (hasWeekday) {
      first = +adapter.startOf(first, "isoWeek", weekday);
    }
    first = +adapter.startOf(first, hasWeekday ? "day" : minor);
    if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
      throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
    }
    const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
      addTick(ticks, time, timestamps);
    }
    if (time === max || options.bounds === "ticks" || count === 1) {
      addTick(ticks, time, timestamps);
    }
    return Object.keys(ticks).sort(sorter).map((x) => +x);
  }
  getLabelForValue(value) {
    const adapter = this._adapter;
    const timeOpts = this.options.time;
    if (timeOpts.tooltipFormat) {
      return adapter.format(value, timeOpts.tooltipFormat);
    }
    return adapter.format(value, timeOpts.displayFormats.datetime);
  }
  format(value, format) {
    const options = this.options;
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const fmt = format || formats[unit];
    return this._adapter.format(value, fmt);
  }
  _tickFormatFunction(time, index, ticks, format) {
    const options = this.options;
    const formatter = options.ticks.callback;
    if (formatter) {
      return callback(formatter, [
        time,
        index,
        ticks
      ], this);
    }
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const majorUnit = this._majorUnit;
    const minorFormat = unit && formats[unit];
    const majorFormat = majorUnit && formats[majorUnit];
    const tick = ticks[index];
    const major = majorUnit && majorFormat && tick && tick.major;
    return this._adapter.format(time, format || (major ? majorFormat : minorFormat));
  }
  generateTickLabels(ticks) {
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      tick.label = this._tickFormatFunction(tick.value, i, ticks);
    }
  }
  getDecimalForValue(value) {
    return value === null ? NaN : (value - this.min) / (this.max - this.min);
  }
  getPixelForValue(value) {
    const offsets = this._offsets;
    const pos = this.getDecimalForValue(value);
    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return this.min + pos * (this.max - this.min);
  }
  _getLabelSize(label) {
    const ticksOpts = this.options.ticks;
    const tickLabelWidth = this.ctx.measureText(label).width;
    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
    const cosRotation = Math.cos(angle);
    const sinRotation = Math.sin(angle);
    const tickFontSize = this._resolveTickFontOptions(0).size;
    return {
      w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
      h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
    };
  }
  _getLabelCapacity(exampleTime) {
    const timeOpts = this.options.time;
    const displayFormats = timeOpts.displayFormats;
    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
      exampleTime
    ], this._majorUnit), format);
    const size = this._getLabelSize(exampleLabel);
    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
    return capacity > 0 ? capacity : 1;
  }
  getDataTimestamps() {
    let timestamps = this._cache.data || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const metas = this.getMatchingVisibleMetas();
    if (this._normalized && metas.length) {
      return this._cache.data = metas[0].controller.getAllParsedValues(this);
    }
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
    }
    return this._cache.data = this.normalize(timestamps);
  }
  getLabelTimestamps() {
    const timestamps = this._cache.labels || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const labels = this.getLabels();
    for (i = 0, ilen = labels.length; i < ilen; ++i) {
      timestamps.push(parse(this, labels[i]));
    }
    return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
  }
  normalize(values) {
    return _arrayUnique(values.sort(sorter));
  }
};
__publicField(TimeScale, "id", "time");
__publicField(TimeScale, "defaults", {
  bounds: "data",
  adapters: {},
  time: {
    parser: false,
    unit: false,
    round: false,
    isoWeekday: false,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    callback: false,
    major: {
      enabled: false
    }
  }
});
function interpolate2(table, val, reverse) {
  let lo = 0;
  let hi = table.length - 1;
  let prevSource, nextSource, prevTarget, nextTarget;
  if (reverse) {
    if (val >= table[lo].pos && val <= table[hi].pos) {
      ({ lo, hi } = _lookupByKey(table, "pos", val));
    }
    ({ pos: prevSource, time: prevTarget } = table[lo]);
    ({ pos: nextSource, time: nextTarget } = table[hi]);
  } else {
    if (val >= table[lo].time && val <= table[hi].time) {
      ({ lo, hi } = _lookupByKey(table, "time", val));
    }
    ({ time: prevSource, pos: prevTarget } = table[lo]);
    ({ time: nextSource, pos: nextTarget } = table[hi]);
  }
  const span = nextSource - prevSource;
  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
var TimeSeriesScale = class extends TimeScale {
  constructor(props) {
    super(props);
    this._table = [];
    this._minPos = void 0;
    this._tableRange = void 0;
  }
  initOffsets() {
    const timestamps = this._getTimestampsForTable();
    const table = this._table = this.buildLookupTable(timestamps);
    this._minPos = interpolate2(table, this.min);
    this._tableRange = interpolate2(table, this.max) - this._minPos;
    super.initOffsets(timestamps);
  }
  buildLookupTable(timestamps) {
    const { min, max } = this;
    const items = [];
    const table = [];
    let i, ilen, prev, curr, next;
    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
      curr = timestamps[i];
      if (curr >= min && curr <= max) {
        items.push(curr);
      }
    }
    if (items.length < 2) {
      return [
        {
          time: min,
          pos: 0
        },
        {
          time: max,
          pos: 1
        }
      ];
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      next = items[i + 1];
      prev = items[i - 1];
      curr = items[i];
      if (Math.round((next + prev) / 2) !== curr) {
        table.push({
          time: curr,
          pos: i / (ilen - 1)
        });
      }
    }
    return table;
  }
  _generate() {
    const min = this.min;
    const max = this.max;
    let timestamps = super.getDataTimestamps();
    if (!timestamps.includes(min) || !timestamps.length) {
      timestamps.splice(0, 0, min);
    }
    if (!timestamps.includes(max) || timestamps.length === 1) {
      timestamps.push(max);
    }
    return timestamps.sort((a, b) => a - b);
  }
  _getTimestampsForTable() {
    let timestamps = this._cache.all || [];
    if (timestamps.length) {
      return timestamps;
    }
    const data = this.getDataTimestamps();
    const label = this.getLabelTimestamps();
    if (data.length && label.length) {
      timestamps = this.normalize(data.concat(label));
    } else {
      timestamps = data.length ? data : label;
    }
    timestamps = this._cache.all = timestamps;
    return timestamps;
  }
  getDecimalForValue(value) {
    return (interpolate2(this._table, value) - this._minPos) / this._tableRange;
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return interpolate2(this._table, decimal * this._tableRange + this._minPos, true);
  }
};
__publicField(TimeSeriesScale, "id", "timeseries");
__publicField(TimeSeriesScale, "defaults", TimeScale.defaults);

// ../../../node_modules/@kurkle/color/dist/color.esm.js
function round2(v) {
  return v + 0.5 | 0;
}
var lim2 = (v, l2, h) => Math.max(Math.min(v, h), l2);
function p2b2(v) {
  return lim2(round2(v * 2.55), 0, 255);
}
function n2b2(v) {
  return lim2(round2(v * 255), 0, 255);
}
function b2n2(v) {
  return lim2(round2(v / 2.55) / 100, 0, 1);
}
function n2p2(v) {
  return lim2(round2(v * 100), 0, 100);
}
var map$12 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
var hex2 = [..."0123456789ABCDEF"];
var h12 = (b) => hex2[b & 15];
var h22 = (b) => hex2[(b & 240) >> 4] + hex2[b & 15];
var eq2 = (b) => (b & 240) >> 4 === (b & 15);
var isShort2 = (v) => eq2(v.r) && eq2(v.g) && eq2(v.b) && eq2(v.a);
function hexParse2(str) {
  var len = str.length;
  var ret;
  if (str[0] === "#") {
    if (len === 4 || len === 5) {
      ret = {
        r: 255 & map$12[str[1]] * 17,
        g: 255 & map$12[str[2]] * 17,
        b: 255 & map$12[str[3]] * 17,
        a: len === 5 ? map$12[str[4]] * 17 : 255
      };
    } else if (len === 7 || len === 9) {
      ret = {
        r: map$12[str[1]] << 4 | map$12[str[2]],
        g: map$12[str[3]] << 4 | map$12[str[4]],
        b: map$12[str[5]] << 4 | map$12[str[6]],
        a: len === 9 ? map$12[str[7]] << 4 | map$12[str[8]] : 255
      };
    }
  }
  return ret;
}
var alpha2 = (a, f) => a < 255 ? f(a) : "";
function hexString2(v) {
  var f = isShort2(v) ? h12 : h22;
  return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha2(v.a, f) : void 0;
}
var HUE_RE2 = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn2(h, s2, l2) {
  const a = s2 * Math.min(l2, 1 - l2);
  const f = (n2, k = (n2 + h / 30) % 12) => l2 - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  return [f(0), f(8), f(4)];
}
function hsv2rgbn2(h, s2, v) {
  const f = (n2, k = (n2 + h / 60) % 6) => v - v * s2 * Math.max(Math.min(k, 4 - k, 1), 0);
  return [f(5), f(3), f(1)];
}
function hwb2rgbn2(h, w, b) {
  const rgb = hsl2rgbn2(h, 1, 0.5);
  let i;
  if (w + b > 1) {
    i = 1 / (w + b);
    w *= i;
    b *= i;
  }
  for (i = 0; i < 3; i++) {
    rgb[i] *= 1 - w - b;
    rgb[i] += w;
  }
  return rgb;
}
function hueValue2(r, g, b, d, max) {
  if (r === max) {
    return (g - b) / d + (g < b ? 6 : 0);
  }
  if (g === max) {
    return (b - r) / d + 2;
  }
  return (r - g) / d + 4;
}
function rgb2hsl2(v) {
  const range = 255;
  const r = v.r / range;
  const g = v.g / range;
  const b = v.b / range;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l2 = (max + min) / 2;
  let h, s2, d;
  if (max !== min) {
    d = max - min;
    s2 = l2 > 0.5 ? d / (2 - max - min) : d / (max + min);
    h = hueValue2(r, g, b, d, max);
    h = h * 60 + 0.5;
  }
  return [h | 0, s2 || 0, l2];
}
function calln2(f, a, b, c) {
  return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b2);
}
function hsl2rgb2(h, s2, l2) {
  return calln2(hsl2rgbn2, h, s2, l2);
}
function hwb2rgb2(h, w, b) {
  return calln2(hwb2rgbn2, h, w, b);
}
function hsv2rgb2(h, s2, v) {
  return calln2(hsv2rgbn2, h, s2, v);
}
function hue2(h) {
  return (h % 360 + 360) % 360;
}
function hueParse2(str) {
  const m = HUE_RE2.exec(str);
  let a = 255;
  let v;
  if (!m) {
    return;
  }
  if (m[5] !== v) {
    a = m[6] ? p2b2(+m[5]) : n2b2(+m[5]);
  }
  const h = hue2(+m[2]);
  const p1 = +m[3] / 100;
  const p2 = +m[4] / 100;
  if (m[1] === "hwb") {
    v = hwb2rgb2(h, p1, p2);
  } else if (m[1] === "hsv") {
    v = hsv2rgb2(h, p1, p2);
  } else {
    v = hsl2rgb2(h, p1, p2);
  }
  return {
    r: v[0],
    g: v[1],
    b: v[2],
    a
  };
}
function rotate2(v, deg) {
  var h = rgb2hsl2(v);
  h[0] = hue2(h[0] + deg);
  h = hsl2rgb2(h);
  v.r = h[0];
  v.g = h[1];
  v.b = h[2];
}
function hslString2(v) {
  if (!v) {
    return;
  }
  const a = rgb2hsl2(v);
  const h = a[0];
  const s2 = n2p2(a[1]);
  const l2 = n2p2(a[2]);
  return v.a < 255 ? `hsla(${h}, ${s2}%, ${l2}%, ${b2n2(v.a)})` : `hsl(${h}, ${s2}%, ${l2}%)`;
}
var map2 = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
};
var names$12 = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function unpack2() {
  const unpacked = {};
  const keys = Object.keys(names$12);
  const tkeys = Object.keys(map2);
  let i, j, k, ok, nk;
  for (i = 0; i < keys.length; i++) {
    ok = nk = keys[i];
    for (j = 0; j < tkeys.length; j++) {
      k = tkeys[j];
      nk = nk.replace(k, map2[k]);
    }
    k = parseInt(names$12[ok], 16);
    unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
  }
  return unpacked;
}
var names2;
function nameParse2(str) {
  if (!names2) {
    names2 = unpack2();
    names2.transparent = [0, 0, 0, 0];
  }
  const a = names2[str.toLowerCase()];
  return a && {
    r: a[0],
    g: a[1],
    b: a[2],
    a: a.length === 4 ? a[3] : 255
  };
}
var RGB_RE2 = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse2(str) {
  const m = RGB_RE2.exec(str);
  let a = 255;
  let r, g, b;
  if (!m) {
    return;
  }
  if (m[7] !== r) {
    const v = +m[7];
    a = m[8] ? p2b2(v) : lim2(v * 255, 0, 255);
  }
  r = +m[1];
  g = +m[3];
  b = +m[5];
  r = 255 & (m[2] ? p2b2(r) : lim2(r, 0, 255));
  g = 255 & (m[4] ? p2b2(g) : lim2(g, 0, 255));
  b = 255 & (m[6] ? p2b2(b) : lim2(b, 0, 255));
  return {
    r,
    g,
    b,
    a
  };
}
function rgbString2(v) {
  return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n2(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
}
var to2 = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
var from2 = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
function interpolate3(rgb1, rgb2, t) {
  const r = from2(b2n2(rgb1.r));
  const g = from2(b2n2(rgb1.g));
  const b = from2(b2n2(rgb1.b));
  return {
    r: n2b2(to2(r + t * (from2(b2n2(rgb2.r)) - r))),
    g: n2b2(to2(g + t * (from2(b2n2(rgb2.g)) - g))),
    b: n2b2(to2(b + t * (from2(b2n2(rgb2.b)) - b))),
    a: rgb1.a + t * (rgb2.a - rgb1.a)
  };
}
function modHSL2(v, i, ratio) {
  if (v) {
    let tmp = rgb2hsl2(v);
    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
    tmp = hsl2rgb2(tmp);
    v.r = tmp[0];
    v.g = tmp[1];
    v.b = tmp[2];
  }
}
function clone3(v, proto) {
  return v ? Object.assign(proto || {}, v) : v;
}
function fromObject2(input) {
  var v = { r: 0, g: 0, b: 0, a: 255 };
  if (Array.isArray(input)) {
    if (input.length >= 3) {
      v = { r: input[0], g: input[1], b: input[2], a: 255 };
      if (input.length > 3) {
        v.a = n2b2(input[3]);
      }
    }
  } else {
    v = clone3(input, { r: 0, g: 0, b: 0, a: 1 });
    v.a = n2b2(v.a);
  }
  return v;
}
function functionParse2(str) {
  if (str.charAt(0) === "r") {
    return rgbParse2(str);
  }
  return hueParse2(str);
}
var Color2 = class {
  constructor(input) {
    if (input instanceof Color2) {
      return input;
    }
    const type = typeof input;
    let v;
    if (type === "object") {
      v = fromObject2(input);
    } else if (type === "string") {
      v = hexParse2(input) || nameParse2(input) || functionParse2(input);
    }
    this._rgb = v;
    this._valid = !!v;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var v = clone3(this._rgb);
    if (v) {
      v.a = b2n2(v.a);
    }
    return v;
  }
  set rgb(obj) {
    this._rgb = fromObject2(obj);
  }
  rgbString() {
    return this._valid ? rgbString2(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? hexString2(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? hslString2(this._rgb) : void 0;
  }
  mix(color3, weight) {
    if (color3) {
      const c1 = this.rgb;
      const c2 = color3.rgb;
      let w2;
      const p = weight === w2 ? 0.5 : weight;
      const w = 2 * p - 1;
      const a = c1.a - c2.a;
      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
      w2 = 1 - w1;
      c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
      c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
      c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
      c1.a = p * c1.a + (1 - p) * c2.a;
      this.rgb = c1;
    }
    return this;
  }
  interpolate(color3, t) {
    if (color3) {
      this._rgb = interpolate3(this._rgb, color3._rgb, t);
    }
    return this;
  }
  clone() {
    return new Color2(this.rgb);
  }
  alpha(a) {
    this._rgb.a = n2b2(a);
    return this;
  }
  clearer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 - ratio;
    return this;
  }
  greyscale() {
    const rgb = this._rgb;
    const val = round2(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
    rgb.r = rgb.g = rgb.b = val;
    return this;
  }
  opaquer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 + ratio;
    return this;
  }
  negate() {
    const v = this._rgb;
    v.r = 255 - v.r;
    v.g = 255 - v.g;
    v.b = 255 - v.b;
    return this;
  }
  lighten(ratio) {
    modHSL2(this._rgb, 2, ratio);
    return this;
  }
  darken(ratio) {
    modHSL2(this._rgb, 2, -ratio);
    return this;
  }
  saturate(ratio) {
    modHSL2(this._rgb, 1, ratio);
    return this;
  }
  desaturate(ratio) {
    modHSL2(this._rgb, 1, -ratio);
    return this;
  }
  rotate(deg) {
    rotate2(this._rgb, deg);
    return this;
  }
};

// ../../../node_modules/chart.js/dist/chunks/helpers.segment.js
var uid2 = (() => {
  let id = 0;
  return () => id++;
})();
function isNullOrUndef2(value) {
  return value === null || typeof value === "undefined";
}
function isArray2(value) {
  if (Array.isArray && Array.isArray(value)) {
    return true;
  }
  const type = Object.prototype.toString.call(value);
  if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
    return true;
  }
  return false;
}
function isObject2(value) {
  return value !== null && Object.prototype.toString.call(value) === "[object Object]";
}
function isNumberFinite2(value) {
  return (typeof value === "number" || value instanceof Number) && isFinite(+value);
}
function finiteOrDefault2(value, defaultValue) {
  return isNumberFinite2(value) ? value : defaultValue;
}
function valueOrDefault2(value, defaultValue) {
  return typeof value === "undefined" ? defaultValue : value;
}
var toDimension2 = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
function callback2(fn, args, thisArg) {
  if (fn && typeof fn.call === "function") {
    return fn.apply(thisArg, args);
  }
}
function each2(loopable, fn, thisArg, reverse) {
  let i, len, keys;
  if (isArray2(loopable)) {
    len = loopable.length;
    if (reverse) {
      for (i = len - 1; i >= 0; i--) {
        fn.call(thisArg, loopable[i], i);
      }
    } else {
      for (i = 0; i < len; i++) {
        fn.call(thisArg, loopable[i], i);
      }
    }
  } else if (isObject2(loopable)) {
    keys = Object.keys(loopable);
    len = keys.length;
    for (i = 0; i < len; i++) {
      fn.call(thisArg, loopable[keys[i]], keys[i]);
    }
  }
}
function clone4(source) {
  if (isArray2(source)) {
    return source.map(clone4);
  }
  if (isObject2(source)) {
    const target = /* @__PURE__ */ Object.create(null);
    const keys = Object.keys(source);
    const klen = keys.length;
    let k = 0;
    for (; k < klen; ++k) {
      target[keys[k]] = clone4(source[keys[k]]);
    }
    return target;
  }
  return source;
}
function isValidKey2(key) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(key) === -1;
}
function _merger2(key, target, source, options) {
  if (!isValidKey2(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject2(tval) && isObject2(sval)) {
    merge2(tval, sval, options);
  } else {
    target[key] = clone4(sval);
  }
}
function merge2(target, source, options) {
  const sources = isArray2(source) ? source : [
    source
  ];
  const ilen = sources.length;
  if (!isObject2(target)) {
    return target;
  }
  options = options || {};
  const merger = options.merger || _merger2;
  let current;
  for (let i = 0; i < ilen; ++i) {
    current = sources[i];
    if (!isObject2(current)) {
      continue;
    }
    const keys = Object.keys(current);
    for (let k = 0, klen = keys.length; k < klen; ++k) {
      merger(keys[k], target, current, options);
    }
  }
  return target;
}
function mergeIf2(target, source) {
  return merge2(target, source, {
    merger: _mergerIf2
  });
}
function _mergerIf2(key, target, source) {
  if (!isValidKey2(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject2(tval) && isObject2(sval)) {
    mergeIf2(tval, sval);
  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
    target[key] = clone4(sval);
  }
}
var PI2 = Math.PI;
var TAU2 = 2 * PI2;
var PITAU2 = TAU2 + PI2;
var INFINITY2 = Number.POSITIVE_INFINITY;
var RAD_PER_DEG2 = PI2 / 180;
var HALF_PI2 = PI2 / 2;
var QUARTER_PI2 = PI2 / 4;
var TWO_THIRDS_PI2 = PI2 * 2 / 3;
var log102 = Math.log10;
var sign2 = Math.sign;
function almostEquals2(x, y, epsilon) {
  return Math.abs(x - y) < epsilon;
}
function niceNum2(range) {
  const roundedRange = Math.round(range);
  range = almostEquals2(range, roundedRange, range / 1e3) ? roundedRange : range;
  const niceRange = Math.pow(10, Math.floor(log102(range)));
  const fraction = range / niceRange;
  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
  return niceFraction * niceRange;
}
function _factorize2(value) {
  const result = [];
  const sqrt = Math.sqrt(value);
  let i;
  for (i = 1; i < sqrt; i++) {
    if (value % i === 0) {
      result.push(i);
      result.push(value / i);
    }
  }
  if (sqrt === (sqrt | 0)) {
    result.push(sqrt);
  }
  result.sort((a, b) => a - b).pop();
  return result;
}
function isNumber2(n2) {
  return !isNaN(parseFloat(n2)) && isFinite(n2);
}
function almostWhole2(x, epsilon) {
  const rounded = Math.round(x);
  return rounded - epsilon <= x && rounded + epsilon >= x;
}
function _setMinAndMaxByKey2(array, target, property) {
  let i, ilen, value;
  for (i = 0, ilen = array.length; i < ilen; i++) {
    value = array[i][property];
    if (!isNaN(value)) {
      target.min = Math.min(target.min, value);
      target.max = Math.max(target.max, value);
    }
  }
}
function toRadians2(degrees) {
  return degrees * (PI2 / 180);
}
function toDegrees2(radians) {
  return radians * (180 / PI2);
}
function _decimalPlaces2(x) {
  if (!isNumberFinite2(x)) {
    return;
  }
  let e = 1;
  let p = 0;
  while (Math.round(x * e) / e !== x) {
    e *= 10;
    p++;
  }
  return p;
}
function _normalizeAngle2(a) {
  return (a % TAU2 + TAU2) % TAU2;
}
function _limitValue2(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function _int16Range2(value) {
  return _limitValue2(value, -32768, 32767);
}
function _lookup2(table, value, cmp) {
  cmp = cmp || ((index) => table[index] < value);
  let hi = table.length - 1;
  let lo = 0;
  let mid;
  while (hi - lo > 1) {
    mid = lo + hi >> 1;
    if (cmp(mid)) {
      lo = mid;
    } else {
      hi = mid;
    }
  }
  return {
    lo,
    hi
  };
}
var _lookupByKey2 = (table, key, value, last) => _lookup2(table, value, last ? (index) => {
  const ti = table[index][key];
  return ti < value || ti === value && table[index + 1][key] === value;
} : (index) => table[index][key] < value);
function _filterBetween2(values, min, max) {
  let start = 0;
  let end = values.length;
  while (start < end && values[start] < min) {
    start++;
  }
  while (end > start && values[end - 1] > max) {
    end--;
  }
  return start > 0 || end < values.length ? values.slice(start, end) : values;
}
function _arrayUnique2(items) {
  const set3 = new Set(items);
  if (set3.size === items.length) {
    return items;
  }
  return Array.from(set3);
}
var requestAnimFrame2 = function() {
  if (typeof window === "undefined") {
    return function(callback3) {
      return callback3();
    };
  }
  return window.requestAnimationFrame;
}();
var _toLeftRightCenter2 = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
var _alignStartEnd2 = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
function isPatternOrGradient2(value) {
  if (value && typeof value === "object") {
    const type = value.toString();
    return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
  }
  return false;
}
function getHoverColor2(value) {
  return isPatternOrGradient2(value) ? value : new Color2(value).saturate(0.5).darken(0.1).hexString();
}
var numbers2 = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
];
var colors2 = [
  "color",
  "borderColor",
  "backgroundColor"
];
function applyAnimationsDefaults2(defaults3) {
  defaults3.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  });
  defaults3.describe("animation", {
    _fallback: false,
    _indexable: false,
    _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
  });
  defaults3.set("animations", {
    colors: {
      type: "color",
      properties: colors2
    },
    numbers: {
      type: "number",
      properties: numbers2
    }
  });
  defaults3.describe("animations", {
    _fallback: "animation"
  });
  defaults3.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (v) => v | 0
        }
      }
    }
  });
}
function applyLayoutsDefaults2(defaults3) {
  defaults3.set("layout", {
    autoPadding: true,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
var intlCache2 = /* @__PURE__ */ new Map();
function getNumberFormat2(locale, options) {
  options = options || {};
  const cacheKey = locale + JSON.stringify(options);
  let formatter = intlCache2.get(cacheKey);
  if (!formatter) {
    formatter = new Intl.NumberFormat(locale, options);
    intlCache2.set(cacheKey, formatter);
  }
  return formatter;
}
function formatNumber2(num, locale, options) {
  return getNumberFormat2(locale, options).format(num);
}
var formatters2 = {
  values(value) {
    return isArray2(value) ? value : "" + value;
  },
  numeric(tickValue, index, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const locale = this.chart.options.locale;
    let notation;
    let delta = tickValue;
    if (ticks.length > 1) {
      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
      if (maxTick < 1e-4 || maxTick > 1e15) {
        notation = "scientific";
      }
      delta = calculateDelta2(tickValue, ticks);
    }
    const logDelta = log102(Math.abs(delta));
    const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
    const options = {
      notation,
      minimumFractionDigits: numDecimal,
      maximumFractionDigits: numDecimal
    };
    Object.assign(options, this.options.ticks.format);
    return formatNumber2(tickValue, locale, options);
  },
  logarithmic(tickValue, index, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const remain = ticks[index].significand || tickValue / Math.pow(10, Math.floor(log102(tickValue)));
    if ([
      1,
      2,
      3,
      5,
      10,
      15
    ].includes(remain) || index > 0.8 * ticks.length) {
      return formatters2.numeric.call(this, tickValue, index, ticks);
    }
    return "";
  }
};
function calculateDelta2(tickValue, ticks) {
  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
    delta = tickValue - Math.floor(tickValue);
  }
  return delta;
}
var Ticks2 = {
  formatters: formatters2
};
function applyScaleDefaults2(defaults3) {
  defaults3.set("scale", {
    display: true,
    offset: false,
    reverse: false,
    beginAtZero: false,
    bounds: "ticks",
    clip: true,
    grace: 0,
    grid: {
      display: true,
      lineWidth: 1,
      drawOnChartArea: true,
      drawTicks: true,
      tickLength: 8,
      tickWidth: (_ctx, options) => options.lineWidth,
      tickColor: (_ctx, options) => options.color,
      offset: false
    },
    border: {
      display: true,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: false,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: false,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: true,
      autoSkip: true,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Ticks2.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: false,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  });
  defaults3.route("scale.ticks", "color", "", "color");
  defaults3.route("scale.grid", "color", "", "borderColor");
  defaults3.route("scale.border", "color", "", "borderColor");
  defaults3.route("scale.title", "color", "", "color");
  defaults3.describe("scale", {
    _fallback: false,
    _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
    _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash" && name !== "dash"
  });
  defaults3.describe("scales", {
    _fallback: "scale"
  });
  defaults3.describe("scale.ticks", {
    _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
    _indexable: (name) => name !== "backdropPadding"
  });
}
var overrides2 = /* @__PURE__ */ Object.create(null);
var descriptors2 = /* @__PURE__ */ Object.create(null);
function getScope$12(node, key) {
  if (!key) {
    return node;
  }
  const keys = key.split(".");
  for (let i = 0, n2 = keys.length; i < n2; ++i) {
    const k = keys[i];
    node = node[k] || (node[k] = /* @__PURE__ */ Object.create(null));
  }
  return node;
}
function set2(root, scope, values) {
  if (typeof scope === "string") {
    return merge2(getScope$12(root, scope), values);
  }
  return merge2(getScope$12(root, ""), scope);
}
var Defaults2 = class {
  constructor(_descriptors3, _appliers) {
    this.animation = void 0;
    this.backgroundColor = "rgba(0,0,0,0.1)";
    this.borderColor = "rgba(0,0,0,0.1)";
    this.color = "#666";
    this.datasets = {};
    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
    this.elements = {};
    this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ];
    this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    };
    this.hover = {};
    this.hoverBackgroundColor = (ctx, options) => getHoverColor2(options.backgroundColor);
    this.hoverBorderColor = (ctx, options) => getHoverColor2(options.borderColor);
    this.hoverColor = (ctx, options) => getHoverColor2(options.color);
    this.indexAxis = "x";
    this.interaction = {
      mode: "nearest",
      intersect: true,
      includeInvisible: false
    };
    this.maintainAspectRatio = true;
    this.onHover = null;
    this.onClick = null;
    this.parsing = true;
    this.plugins = {};
    this.responsive = true;
    this.scale = void 0;
    this.scales = {};
    this.showLine = true;
    this.drawActiveElementsOnTop = true;
    this.describe(_descriptors3);
    this.apply(_appliers);
  }
  set(scope, values) {
    return set2(this, scope, values);
  }
  get(scope) {
    return getScope$12(this, scope);
  }
  describe(scope, values) {
    return set2(descriptors2, scope, values);
  }
  override(scope, values) {
    return set2(overrides2, scope, values);
  }
  route(scope, name, targetScope, targetName) {
    const scopeObject = getScope$12(this, scope);
    const targetScopeObject = getScope$12(this, targetScope);
    const privateName = "_" + name;
    Object.defineProperties(scopeObject, {
      [privateName]: {
        value: scopeObject[name],
        writable: true
      },
      [name]: {
        enumerable: true,
        get() {
          const local = this[privateName];
          const target = targetScopeObject[targetName];
          if (isObject2(local)) {
            return Object.assign({}, target, local);
          }
          return valueOrDefault2(local, target);
        },
        set(value) {
          this[privateName] = value;
        }
      }
    });
  }
  apply(appliers) {
    appliers.forEach((apply) => apply(this));
  }
};
var defaults2 = /* @__PURE__ */ new Defaults2({
  _scriptable: (name) => !name.startsWith("on"),
  _indexable: (name) => name !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: false,
    _indexable: false
  }
}, [
  applyAnimationsDefaults2,
  applyLayoutsDefaults2,
  applyScaleDefaults2
]);
function toFontString2(font) {
  if (!font || isNullOrUndef2(font.size) || isNullOrUndef2(font.family)) {
    return null;
  }
  return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
}
function _measureText2(ctx, data, gc, longest, string) {
  let textWidth = data[string];
  if (!textWidth) {
    textWidth = data[string] = ctx.measureText(string).width;
    gc.push(string);
  }
  if (textWidth > longest) {
    longest = textWidth;
  }
  return longest;
}
function _longestText2(ctx, font, arrayOfThings, cache) {
  cache = cache || {};
  let data = cache.data = cache.data || {};
  let gc = cache.garbageCollect = cache.garbageCollect || [];
  if (cache.font !== font) {
    data = cache.data = {};
    gc = cache.garbageCollect = [];
    cache.font = font;
  }
  ctx.save();
  ctx.font = font;
  let longest = 0;
  const ilen = arrayOfThings.length;
  let i, j, jlen, thing, nestedThing;
  for (i = 0; i < ilen; i++) {
    thing = arrayOfThings[i];
    if (thing !== void 0 && thing !== null && !isArray2(thing)) {
      longest = _measureText2(ctx, data, gc, longest, thing);
    } else if (isArray2(thing)) {
      for (j = 0, jlen = thing.length; j < jlen; j++) {
        nestedThing = thing[j];
        if (nestedThing !== void 0 && nestedThing !== null && !isArray2(nestedThing)) {
          longest = _measureText2(ctx, data, gc, longest, nestedThing);
        }
      }
    }
  }
  ctx.restore();
  const gcLen = gc.length / 2;
  if (gcLen > arrayOfThings.length) {
    for (i = 0; i < gcLen; i++) {
      delete data[gc[i]];
    }
    gc.splice(0, gcLen);
  }
  return longest;
}
function _alignPixel2(chart, pixel, width) {
  const devicePixelRatio = chart.currentDevicePixelRatio;
  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
function _isPointInArea2(point, area, margin) {
  margin = margin || 0.5;
  return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
}
function clipArea2(ctx, area) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
  ctx.clip();
}
function unclipArea2(ctx) {
  ctx.restore();
}
function setRenderOpts2(ctx, opts) {
  if (opts.translation) {
    ctx.translate(opts.translation[0], opts.translation[1]);
  }
  if (!isNullOrUndef2(opts.rotation)) {
    ctx.rotate(opts.rotation);
  }
  if (opts.color) {
    ctx.fillStyle = opts.color;
  }
  if (opts.textAlign) {
    ctx.textAlign = opts.textAlign;
  }
  if (opts.textBaseline) {
    ctx.textBaseline = opts.textBaseline;
  }
}
function decorateText2(ctx, x, y, line, opts) {
  if (opts.strikethrough || opts.underline) {
    const metrics = ctx.measureText(line);
    const left = x - metrics.actualBoundingBoxLeft;
    const right = x + metrics.actualBoundingBoxRight;
    const top = y - metrics.actualBoundingBoxAscent;
    const bottom = y + metrics.actualBoundingBoxDescent;
    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
    ctx.strokeStyle = ctx.fillStyle;
    ctx.beginPath();
    ctx.lineWidth = opts.decorationWidth || 2;
    ctx.moveTo(left, yDecoration);
    ctx.lineTo(right, yDecoration);
    ctx.stroke();
  }
}
function drawBackdrop2(ctx, opts) {
  const oldColor = ctx.fillStyle;
  ctx.fillStyle = opts.color;
  ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
  ctx.fillStyle = oldColor;
}
function renderText2(ctx, text, x, y, font, opts = {}) {
  const lines = isArray2(text) ? text : [
    text
  ];
  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
  let i, line;
  ctx.save();
  ctx.font = font.string;
  setRenderOpts2(ctx, opts);
  for (i = 0; i < lines.length; ++i) {
    line = lines[i];
    if (opts.backdrop) {
      drawBackdrop2(ctx, opts.backdrop);
    }
    if (stroke) {
      if (opts.strokeColor) {
        ctx.strokeStyle = opts.strokeColor;
      }
      if (!isNullOrUndef2(opts.strokeWidth)) {
        ctx.lineWidth = opts.strokeWidth;
      }
      ctx.strokeText(line, x, y, opts.maxWidth);
    }
    ctx.fillText(line, x, y, opts.maxWidth);
    decorateText2(ctx, x, y, line, opts);
    y += Number(font.lineHeight);
  }
  ctx.restore();
}
function addRoundedRectPath2(ctx, rect) {
  const { x, y, w, h, radius } = rect;
  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI2, PI2, true);
  ctx.lineTo(x, y + h - radius.bottomLeft);
  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI2, HALF_PI2, true);
  ctx.lineTo(x + w - radius.bottomRight, y + h);
  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI2, 0, true);
  ctx.lineTo(x + w, y + radius.topRight);
  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI2, true);
  ctx.lineTo(x + radius.topLeft, y);
}
var LINE_HEIGHT2 = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
var FONT_STYLE2 = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function toLineHeight2(value, size) {
  const matches = ("" + value).match(LINE_HEIGHT2);
  if (!matches || matches[1] === "normal") {
    return size * 1.2;
  }
  value = +matches[2];
  switch (matches[3]) {
    case "px":
      return value;
    case "%":
      value /= 100;
      break;
  }
  return size * value;
}
var numberOrZero2 = (v) => +v || 0;
function _readValueToProps2(value, props) {
  const ret = {};
  const objProps = isObject2(props);
  const keys = objProps ? Object.keys(props) : props;
  const read = isObject2(value) ? objProps ? (prop) => valueOrDefault2(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
  for (const prop of keys) {
    ret[prop] = numberOrZero2(read(prop));
  }
  return ret;
}
function toTRBL2(value) {
  return _readValueToProps2(value, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function toTRBLCorners2(value) {
  return _readValueToProps2(value, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function toPadding2(value) {
  const obj = toTRBL2(value);
  obj.width = obj.left + obj.right;
  obj.height = obj.top + obj.bottom;
  return obj;
}
function toFont2(options, fallback) {
  options = options || {};
  fallback = fallback || defaults2.font;
  let size = valueOrDefault2(options.size, fallback.size);
  if (typeof size === "string") {
    size = parseInt(size, 10);
  }
  let style = valueOrDefault2(options.style, fallback.style);
  if (style && !("" + style).match(FONT_STYLE2)) {
    console.warn('Invalid font style specified: "' + style + '"');
    style = void 0;
  }
  const font = {
    family: valueOrDefault2(options.family, fallback.family),
    lineHeight: toLineHeight2(valueOrDefault2(options.lineHeight, fallback.lineHeight), size),
    size,
    style,
    weight: valueOrDefault2(options.weight, fallback.weight),
    string: ""
  };
  font.string = toFontString2(font);
  return font;
}
function _addGrace2(minmax, grace, beginAtZero) {
  const { min, max } = minmax;
  const change = toDimension2(grace, (max - min) / 2);
  const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
  return {
    min: keepZero(min, -Math.abs(change)),
    max: keepZero(max, change)
  };
}
function createContext2(parentContext, context) {
  return Object.assign(Object.create(parentContext), context);
}
var EPSILON2 = Number.EPSILON || 1e-14;
function _isDomSupported2() {
  return typeof window !== "undefined" && typeof document !== "undefined";
}
var supportsEventListenerOptions2 = function() {
  let passiveSupported = false;
  try {
    const options = {
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    if (_isDomSupported2()) {
      window.addEventListener("test", null, options);
      window.removeEventListener("test", null, options);
    }
  } catch (e) {
  }
  return passiveSupported;
}();

// ../../../node_modules/chart.js/dist/chart.js
function abstract2() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
var DateAdapterBase2 = class {
  constructor(options) {
    __publicField(this, "options");
    this.options = options || {};
  }
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(members) {
    Object.assign(DateAdapterBase2.prototype, members);
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  init() {
  }
  formats() {
    return abstract2();
  }
  parse() {
    return abstract2();
  }
  format() {
    return abstract2();
  }
  add() {
    return abstract2();
  }
  diff() {
    return abstract2();
  }
  startOf() {
    return abstract2();
  }
  endOf() {
    return abstract2();
  }
};
var adapters2 = {
  _date: DateAdapterBase2
};
var Element2 = class {
  constructor() {
    __publicField(this, "x");
    __publicField(this, "y");
    __publicField(this, "active", false);
    __publicField(this, "options");
    __publicField(this, "$animations");
  }
  tooltipPosition(useFinalPosition) {
    const { x, y } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return {
      x,
      y
    };
  }
  hasValue() {
    return isNumber2(this.x) && isNumber2(this.y);
  }
  getProps(props, final) {
    const anims = this.$animations;
    if (!final || !anims) {
      return this;
    }
    const ret = {};
    props.forEach((prop) => {
      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
    });
    return ret;
  }
};
__publicField(Element2, "defaults", {});
__publicField(Element2, "defaultRoutes");
function autoSkip2(scale, ticks) {
  const tickOpts = scale.options.ticks;
  const determinedMaxTicks = determineMaxTicks2(scale);
  const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
  const majorIndices = tickOpts.major.enabled ? getMajorIndices2(ticks) : [];
  const numMajorIndices = majorIndices.length;
  const first = majorIndices[0];
  const last = majorIndices[numMajorIndices - 1];
  const newTicks = [];
  if (numMajorIndices > ticksLimit) {
    skipMajors2(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
    return newTicks;
  }
  const spacing = calculateSpacing2(majorIndices, ticks, ticksLimit);
  if (numMajorIndices > 0) {
    let i, ilen;
    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
    skip2(ticks, newTicks, spacing, isNullOrUndef2(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
      skip2(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
    }
    skip2(ticks, newTicks, spacing, last, isNullOrUndef2(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
    return newTicks;
  }
  skip2(ticks, newTicks, spacing);
  return newTicks;
}
function determineMaxTicks2(scale) {
  const offset2 = scale.options.offset;
  const tickLength = scale._tickSize();
  const maxScale = scale._length / tickLength + (offset2 ? 0 : 1);
  const maxChart = scale._maxLength / tickLength;
  return Math.floor(Math.min(maxScale, maxChart));
}
function calculateSpacing2(majorIndices, ticks, ticksLimit) {
  const evenMajorSpacing = getEvenSpacing2(majorIndices);
  const spacing = ticks.length / ticksLimit;
  if (!evenMajorSpacing) {
    return Math.max(spacing, 1);
  }
  const factors = _factorize2(evenMajorSpacing);
  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
    const factor = factors[i];
    if (factor > spacing) {
      return factor;
    }
  }
  return Math.max(spacing, 1);
}
function getMajorIndices2(ticks) {
  const result = [];
  let i, ilen;
  for (i = 0, ilen = ticks.length; i < ilen; i++) {
    if (ticks[i].major) {
      result.push(i);
    }
  }
  return result;
}
function skipMajors2(ticks, newTicks, majorIndices, spacing) {
  let count = 0;
  let next = majorIndices[0];
  let i;
  spacing = Math.ceil(spacing);
  for (i = 0; i < ticks.length; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = majorIndices[count * spacing];
    }
  }
}
function skip2(ticks, newTicks, spacing, majorStart, majorEnd) {
  const start = valueOrDefault2(majorStart, 0);
  const end = Math.min(valueOrDefault2(majorEnd, ticks.length), ticks.length);
  let count = 0;
  let length, i, next;
  spacing = Math.ceil(spacing);
  if (majorEnd) {
    length = majorEnd - majorStart;
    spacing = length / Math.floor(length / spacing);
  }
  next = start;
  while (next < 0) {
    count++;
    next = Math.round(start + count * spacing);
  }
  for (i = Math.max(start, 0); i < end; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = Math.round(start + count * spacing);
    }
  }
}
function getEvenSpacing2(arr) {
  const len = arr.length;
  let i, diff;
  if (len < 2) {
    return false;
  }
  for (diff = arr[0], i = 1; i < len; ++i) {
    if (arr[i] - arr[i - 1] !== diff) {
      return false;
    }
  }
  return diff;
}
var reverseAlign2 = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
var offsetFromEdge2 = (scale, edge, offset2) => edge === "top" || edge === "left" ? scale[edge] + offset2 : scale[edge] - offset2;
var getTicksLimit2 = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);
function sample2(arr, numItems) {
  const result = [];
  const increment = arr.length / numItems;
  const len = arr.length;
  let i = 0;
  for (; i < len; i += increment) {
    result.push(arr[Math.floor(i)]);
  }
  return result;
}
function getPixelForGridLine2(scale, index, offsetGridLines) {
  const length = scale.ticks.length;
  const validIndex = Math.min(index, length - 1);
  const start = scale._startPixel;
  const end = scale._endPixel;
  const epsilon = 1e-6;
  let lineValue = scale.getPixelForTick(validIndex);
  let offset2;
  if (offsetGridLines) {
    if (length === 1) {
      offset2 = Math.max(lineValue - start, end - lineValue);
    } else if (index === 0) {
      offset2 = (scale.getPixelForTick(1) - lineValue) / 2;
    } else {
      offset2 = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;
    }
    lineValue += validIndex < index ? offset2 : -offset2;
    if (lineValue < start - epsilon || lineValue > end + epsilon) {
      return;
    }
  }
  return lineValue;
}
function garbageCollect2(caches, length) {
  each2(caches, (cache) => {
    const gc = cache.gc;
    const gcLen = gc.length / 2;
    let i;
    if (gcLen > length) {
      for (i = 0; i < gcLen; ++i) {
        delete cache.data[gc[i]];
      }
      gc.splice(0, gcLen);
    }
  });
}
function getTickMarkLength2(options) {
  return options.drawTicks ? options.tickLength : 0;
}
function getTitleHeight2(options, fallback) {
  if (!options.display) {
    return 0;
  }
  const font = toFont2(options.font, fallback);
  const padding = toPadding2(options.padding);
  const lines = isArray2(options.text) ? options.text.length : 1;
  return lines * font.lineHeight + padding.height;
}
function createScaleContext2(parent, scale) {
  return createContext2(parent, {
    scale,
    type: "scale"
  });
}
function createTickContext2(parent, index, tick) {
  return createContext2(parent, {
    tick,
    index,
    type: "tick"
  });
}
function titleAlign2(align, position, reverse) {
  let ret = _toLeftRightCenter2(align);
  if (reverse && position !== "right" || !reverse && position === "right") {
    ret = reverseAlign2(ret);
  }
  return ret;
}
function titleArgs2(scale, offset2, position, align) {
  const { top, left, bottom, right, chart } = scale;
  const { chartArea, scales } = chart;
  let rotation = 0;
  let maxWidth, titleX, titleY;
  const height = bottom - top;
  const width = right - left;
  if (scale.isHorizontal()) {
    titleX = _alignStartEnd2(align, left, right);
    if (isObject2(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleY = scales[positionAxisID].getPixelForValue(value) + height - offset2;
    } else if (position === "center") {
      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset2;
    } else {
      titleY = offsetFromEdge2(scale, position, offset2);
    }
    maxWidth = right - left;
  } else {
    if (isObject2(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleX = scales[positionAxisID].getPixelForValue(value) - width + offset2;
    } else if (position === "center") {
      titleX = (chartArea.left + chartArea.right) / 2 - width + offset2;
    } else {
      titleX = offsetFromEdge2(scale, position, offset2);
    }
    titleY = _alignStartEnd2(align, bottom, top);
    rotation = position === "left" ? -HALF_PI2 : HALF_PI2;
  }
  return {
    titleX,
    titleY,
    maxWidth,
    rotation
  };
}
var Scale2 = class extends Element2 {
  constructor(cfg) {
    super();
    this.id = cfg.id;
    this.type = cfg.type;
    this.options = void 0;
    this.ctx = cfg.ctx;
    this.chart = cfg.chart;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.maxWidth = void 0;
    this.maxHeight = void 0;
    this.paddingTop = void 0;
    this.paddingBottom = void 0;
    this.paddingLeft = void 0;
    this.paddingRight = void 0;
    this.axis = void 0;
    this.labelRotation = void 0;
    this.min = void 0;
    this.max = void 0;
    this._range = void 0;
    this.ticks = [];
    this._gridLineItems = null;
    this._labelItems = null;
    this._labelSizes = null;
    this._length = 0;
    this._maxLength = 0;
    this._longestTextCache = {};
    this._startPixel = void 0;
    this._endPixel = void 0;
    this._reversePixels = false;
    this._userMax = void 0;
    this._userMin = void 0;
    this._suggestedMax = void 0;
    this._suggestedMin = void 0;
    this._ticksLength = 0;
    this._borderValue = 0;
    this._cache = {};
    this._dataLimitsCached = false;
    this.$context = void 0;
  }
  init(options) {
    this.options = options.setContext(this.getContext());
    this.axis = options.axis;
    this._userMin = this.parse(options.min);
    this._userMax = this.parse(options.max);
    this._suggestedMin = this.parse(options.suggestedMin);
    this._suggestedMax = this.parse(options.suggestedMax);
  }
  parse(raw, index) {
    return raw;
  }
  getUserBounds() {
    let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
    _userMin = finiteOrDefault2(_userMin, Number.POSITIVE_INFINITY);
    _userMax = finiteOrDefault2(_userMax, Number.NEGATIVE_INFINITY);
    _suggestedMin = finiteOrDefault2(_suggestedMin, Number.POSITIVE_INFINITY);
    _suggestedMax = finiteOrDefault2(_suggestedMax, Number.NEGATIVE_INFINITY);
    return {
      min: finiteOrDefault2(_userMin, _suggestedMin),
      max: finiteOrDefault2(_userMax, _suggestedMax),
      minDefined: isNumberFinite2(_userMin),
      maxDefined: isNumberFinite2(_userMax)
    };
  }
  getMinMax(canStack) {
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    let range;
    if (minDefined && maxDefined) {
      return {
        min,
        max
      };
    }
    const metas = this.getMatchingVisibleMetas();
    for (let i = 0, ilen = metas.length; i < ilen; ++i) {
      range = metas[i].controller.getMinMax(this, canStack);
      if (!minDefined) {
        min = Math.min(min, range.min);
      }
      if (!maxDefined) {
        max = Math.max(max, range.max);
      }
    }
    min = maxDefined && min > max ? max : min;
    max = minDefined && min > max ? min : max;
    return {
      min: finiteOrDefault2(min, finiteOrDefault2(max, min)),
      max: finiteOrDefault2(max, finiteOrDefault2(min, max))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const data = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
  }
  getLabelItems(chartArea = this.chart.chartArea) {
    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
    return items;
  }
  beforeLayout() {
    this._cache = {};
    this._dataLimitsCached = false;
  }
  beforeUpdate() {
    callback2(this.options.beforeUpdate, [
      this
    ]);
  }
  update(maxWidth, maxHeight, margins) {
    const { beginAtZero, grace, ticks: tickOpts } = this.options;
    const sampleSize = tickOpts.sampleSize;
    this.beforeUpdate();
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, margins);
    this.ticks = null;
    this._labelSizes = null;
    this._gridLineItems = null;
    this._labelItems = null;
    this.beforeSetDimensions();
    this.setDimensions();
    this.afterSetDimensions();
    this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
    if (!this._dataLimitsCached) {
      this.beforeDataLimits();
      this.determineDataLimits();
      this.afterDataLimits();
      this._range = _addGrace2(this, grace, beginAtZero);
      this._dataLimitsCached = true;
    }
    this.beforeBuildTicks();
    this.ticks = this.buildTicks() || [];
    this.afterBuildTicks();
    const samplingEnabled = sampleSize < this.ticks.length;
    this._convertTicksToLabels(samplingEnabled ? sample2(this.ticks, sampleSize) : this.ticks);
    this.configure();
    this.beforeCalculateLabelRotation();
    this.calculateLabelRotation();
    this.afterCalculateLabelRotation();
    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
      this.ticks = autoSkip2(this, this.ticks);
      this._labelSizes = null;
      this.afterAutoSkip();
    }
    if (samplingEnabled) {
      this._convertTicksToLabels(this.ticks);
    }
    this.beforeFit();
    this.fit();
    this.afterFit();
    this.afterUpdate();
  }
  configure() {
    let reversePixels = this.options.reverse;
    let startPixel, endPixel;
    if (this.isHorizontal()) {
      startPixel = this.left;
      endPixel = this.right;
    } else {
      startPixel = this.top;
      endPixel = this.bottom;
      reversePixels = !reversePixels;
    }
    this._startPixel = startPixel;
    this._endPixel = endPixel;
    this._reversePixels = reversePixels;
    this._length = endPixel - startPixel;
    this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    callback2(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    callback2(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = 0;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = 0;
      this.bottom = this.height;
    }
    this.paddingLeft = 0;
    this.paddingTop = 0;
    this.paddingRight = 0;
    this.paddingBottom = 0;
  }
  afterSetDimensions() {
    callback2(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(name) {
    this.chart.notifyPlugins(name, this.getContext());
    callback2(this.options[name], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    callback2(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(ticks) {
    const tickOpts = this.options.ticks;
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      tick = ticks[i];
      tick.label = callback2(tickOpts.callback, [
        tick.value,
        i,
        ticks
      ], this);
    }
  }
  afterTickToLabelConversion() {
    callback2(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    callback2(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const options = this.options;
    const tickOpts = options.ticks;
    const numTicks = getTicksLimit2(this.ticks.length, options.ticks.maxTicksLimit);
    const minRotation = tickOpts.minRotation || 0;
    const maxRotation = tickOpts.maxRotation;
    let labelRotation = minRotation;
    let tickWidth, maxHeight, maxLabelDiagonal;
    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
      this.labelRotation = minRotation;
      return;
    }
    const labelSizes = this._getLabelSizes();
    const maxLabelWidth = labelSizes.widest.width;
    const maxLabelHeight = labelSizes.highest.height;
    const maxWidth = _limitValue2(this.chart.width - maxLabelWidth, 0, this.maxWidth);
    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
    if (maxLabelWidth + 6 > tickWidth) {
      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
      maxHeight = this.maxHeight - getTickMarkLength2(options.grid) - tickOpts.padding - getTitleHeight2(options.title, this.chart.options.font);
      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
      labelRotation = toDegrees2(Math.min(Math.asin(_limitValue2((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue2(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue2(maxLabelHeight / maxLabelDiagonal, -1, 1))));
      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
    }
    this.labelRotation = labelRotation;
  }
  afterCalculateLabelRotation() {
    callback2(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    callback2(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const minSize = {
      width: 0,
      height: 0
    };
    const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
    const display = this._isVisible();
    const isHorizontal = this.isHorizontal();
    if (display) {
      const titleHeight = getTitleHeight2(titleOpts, chart.options.font);
      if (isHorizontal) {
        minSize.width = this.maxWidth;
        minSize.height = getTickMarkLength2(gridOpts) + titleHeight;
      } else {
        minSize.height = this.maxHeight;
        minSize.width = getTickMarkLength2(gridOpts) + titleHeight;
      }
      if (tickOpts.display && this.ticks.length) {
        const { first, last, widest, highest } = this._getLabelSizes();
        const tickPadding = tickOpts.padding * 2;
        const angleRadians = toRadians2(this.labelRotation);
        const cos = Math.cos(angleRadians);
        const sin = Math.sin(angleRadians);
        if (isHorizontal) {
          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
        } else {
          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
        }
        this._calculatePadding(first, last, sin, cos);
      }
    }
    this._handleMargins();
    if (isHorizontal) {
      this.width = this._length = chart.width - this._margins.left - this._margins.right;
      this.height = minSize.height;
    } else {
      this.width = minSize.width;
      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
    }
  }
  _calculatePadding(first, last, sin, cos) {
    const { ticks: { align, padding }, position } = this.options;
    const isRotated = this.labelRotation !== 0;
    const labelsBelowTicks = position !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const offsetLeft = this.getPixelForTick(0) - this.left;
      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
      let paddingLeft = 0;
      let paddingRight = 0;
      if (isRotated) {
        if (labelsBelowTicks) {
          paddingLeft = cos * first.width;
          paddingRight = sin * last.height;
        } else {
          paddingLeft = sin * first.height;
          paddingRight = cos * last.width;
        }
      } else if (align === "start") {
        paddingRight = last.width;
      } else if (align === "end") {
        paddingLeft = first.width;
      } else if (align !== "inner") {
        paddingLeft = first.width / 2;
        paddingRight = last.width / 2;
      }
      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
    } else {
      let paddingTop = last.height / 2;
      let paddingBottom = first.height / 2;
      if (align === "start") {
        paddingTop = 0;
        paddingBottom = first.height;
      } else if (align === "end") {
        paddingTop = last.height;
        paddingBottom = 0;
      }
      this.paddingTop = paddingTop + padding;
      this.paddingBottom = paddingBottom + padding;
    }
  }
  _handleMargins() {
    if (this._margins) {
      this._margins.left = Math.max(this.paddingLeft, this._margins.left);
      this._margins.top = Math.max(this.paddingTop, this._margins.top);
      this._margins.right = Math.max(this.paddingRight, this._margins.right);
      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
    }
  }
  afterFit() {
    callback2(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis, position } = this.options;
    return position === "top" || position === "bottom" || axis === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(ticks) {
    this.beforeTickToLabelConversion();
    this.generateTickLabels(ticks);
    let i, ilen;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      if (isNullOrUndef2(ticks[i].label)) {
        ticks.splice(i, 1);
        ilen--;
        i--;
      }
    }
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let labelSizes = this._labelSizes;
    if (!labelSizes) {
      const sampleSize = this.options.ticks.sampleSize;
      let ticks = this.ticks;
      if (sampleSize < ticks.length) {
        ticks = sample2(ticks, sampleSize);
      }
      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
    }
    return labelSizes;
  }
  _computeLabelSizes(ticks, length, maxTicksLimit) {
    const { ctx, _longestTextCache: caches } = this;
    const widths = [];
    const heights = [];
    const increment = Math.floor(length / getTicksLimit2(length, maxTicksLimit));
    let widestLabelSize = 0;
    let highestLabelSize = 0;
    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
    for (i = 0; i < length; i += increment) {
      label = ticks[i].label;
      tickFont = this._resolveTickFontOptions(i);
      ctx.font = fontString = tickFont.string;
      cache = caches[fontString] = caches[fontString] || {
        data: {},
        gc: []
      };
      lineHeight = tickFont.lineHeight;
      width = height = 0;
      if (!isNullOrUndef2(label) && !isArray2(label)) {
        width = _measureText2(ctx, cache.data, cache.gc, width, label);
        height = lineHeight;
      } else if (isArray2(label)) {
        for (j = 0, jlen = label.length; j < jlen; ++j) {
          nestedLabel = label[j];
          if (!isNullOrUndef2(nestedLabel) && !isArray2(nestedLabel)) {
            width = _measureText2(ctx, cache.data, cache.gc, width, nestedLabel);
            height += lineHeight;
          }
        }
      }
      widths.push(width);
      heights.push(height);
      widestLabelSize = Math.max(width, widestLabelSize);
      highestLabelSize = Math.max(height, highestLabelSize);
    }
    garbageCollect2(caches, length);
    const widest = widths.indexOf(widestLabelSize);
    const highest = heights.indexOf(highestLabelSize);
    const valueAt = (idx) => ({
      width: widths[idx] || 0,
      height: heights[idx] || 0
    });
    return {
      first: valueAt(0),
      last: valueAt(length - 1),
      widest: valueAt(widest),
      highest: valueAt(highest),
      widths,
      heights
    };
  }
  getLabelForValue(value) {
    return value;
  }
  getPixelForValue(value, index) {
    return NaN;
  }
  getValueForPixel(pixel) {
  }
  getPixelForTick(index) {
    const ticks = this.ticks;
    if (index < 0 || index > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index].value);
  }
  getPixelForDecimal(decimal) {
    if (this._reversePixels) {
      decimal = 1 - decimal;
    }
    const pixel = this._startPixel + decimal * this._length;
    return _int16Range2(this._alignToPixels ? _alignPixel2(this.chart, pixel, 0) : pixel);
  }
  getDecimalForPixel(pixel) {
    const decimal = (pixel - this._startPixel) / this._length;
    return this._reversePixels ? 1 - decimal : decimal;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min, max } = this;
    return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
  }
  getContext(index) {
    const ticks = this.ticks || [];
    if (index >= 0 && index < ticks.length) {
      const tick = ticks[index];
      return tick.$context || (tick.$context = createTickContext2(this.getContext(), index, tick));
    }
    return this.$context || (this.$context = createScaleContext2(this.chart.getContext(), this));
  }
  _tickSize() {
    const optionTicks = this.options.ticks;
    const rot = toRadians2(this.labelRotation);
    const cos = Math.abs(Math.cos(rot));
    const sin = Math.abs(Math.sin(rot));
    const labelSizes = this._getLabelSizes();
    const padding = optionTicks.autoSkipPadding || 0;
    const w = labelSizes ? labelSizes.widest.width + padding : 0;
    const h = labelSizes ? labelSizes.highest.height + padding : 0;
    return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
  }
  _isVisible() {
    const display = this.options.display;
    if (display !== "auto") {
      return !!display;
    }
    return this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(chartArea) {
    const axis = this.axis;
    const chart = this.chart;
    const options = this.options;
    const { grid, position, border } = options;
    const offset2 = grid.offset;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const ticksLength = ticks.length + (offset2 ? 1 : 0);
    const tl = getTickMarkLength2(grid);
    const items = [];
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = borderOpts.display ? borderOpts.width : 0;
    const axisHalfWidth = axisWidth / 2;
    const alignBorderValue = function(pixel) {
      return _alignPixel2(chart, pixel, axisWidth);
    };
    let borderValue, i, lineValue, alignedLineValue;
    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
    if (position === "top") {
      borderValue = alignBorderValue(this.bottom);
      ty1 = this.bottom - tl;
      ty2 = borderValue - axisHalfWidth;
      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
      y2 = chartArea.bottom;
    } else if (position === "bottom") {
      borderValue = alignBorderValue(this.top);
      y1 = chartArea.top;
      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
      ty1 = borderValue + axisHalfWidth;
      ty2 = this.top + tl;
    } else if (position === "left") {
      borderValue = alignBorderValue(this.right);
      tx1 = this.right - tl;
      tx2 = borderValue - axisHalfWidth;
      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
      x2 = chartArea.right;
    } else if (position === "right") {
      borderValue = alignBorderValue(this.left);
      x1 = chartArea.left;
      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
      tx1 = borderValue + axisHalfWidth;
      tx2 = this.left + tl;
    } else if (axis === "x") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
      } else if (isObject2(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      y1 = chartArea.top;
      y2 = chartArea.bottom;
      ty1 = borderValue + axisHalfWidth;
      ty2 = ty1 + tl;
    } else if (axis === "y") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
      } else if (isObject2(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      tx1 = borderValue - axisHalfWidth;
      tx2 = tx1 - tl;
      x1 = chartArea.left;
      x2 = chartArea.right;
    }
    const limit = valueOrDefault2(options.ticks.maxTicksLimit, ticksLength);
    const step = Math.max(1, Math.ceil(ticksLength / limit));
    for (i = 0; i < ticksLength; i += step) {
      const context = this.getContext(i);
      const optsAtIndex = grid.setContext(context);
      const optsAtIndexBorder = border.setContext(context);
      const lineWidth = optsAtIndex.lineWidth;
      const lineColor = optsAtIndex.color;
      const borderDash = optsAtIndexBorder.dash || [];
      const borderDashOffset = optsAtIndexBorder.dashOffset;
      const tickWidth = optsAtIndex.tickWidth;
      const tickColor = optsAtIndex.tickColor;
      const tickBorderDash = optsAtIndex.tickBorderDash || [];
      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
      lineValue = getPixelForGridLine2(this, i, offset2);
      if (lineValue === void 0) {
        continue;
      }
      alignedLineValue = _alignPixel2(chart, lineValue, lineWidth);
      if (isHorizontal) {
        tx1 = tx2 = x1 = x2 = alignedLineValue;
      } else {
        ty1 = ty2 = y1 = y2 = alignedLineValue;
      }
      items.push({
        tx1,
        ty1,
        tx2,
        ty2,
        x1,
        y1,
        x2,
        y2,
        width: lineWidth,
        color: lineColor,
        borderDash,
        borderDashOffset,
        tickWidth,
        tickColor,
        tickBorderDash,
        tickBorderDashOffset
      });
    }
    this._ticksLength = ticksLength;
    this._borderValue = borderValue;
    return items;
  }
  _computeLabelItems(chartArea) {
    const axis = this.axis;
    const options = this.options;
    const { position, ticks: optionTicks } = options;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const { align, crossAlign, padding, mirror } = optionTicks;
    const tl = getTickMarkLength2(options.grid);
    const tickAndPadding = tl + padding;
    const hTickAndPadding = mirror ? -padding : tickAndPadding;
    const rotation = -toRadians2(this.labelRotation);
    const items = [];
    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
    let textBaseline = "middle";
    if (position === "top") {
      y = this.bottom - hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "bottom") {
      y = this.top + hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "left") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (position === "right") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (axis === "x") {
      if (position === "center") {
        y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
      } else if (isObject2(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
      }
      textAlign = this._getXAxisLabelAlignment();
    } else if (axis === "y") {
      if (position === "center") {
        x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
      } else if (isObject2(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        x = this.chart.scales[positionAxisID].getPixelForValue(value);
      }
      textAlign = this._getYAxisLabelAlignment(tl).textAlign;
    }
    if (axis === "y") {
      if (align === "start") {
        textBaseline = "top";
      } else if (align === "end") {
        textBaseline = "bottom";
      }
    }
    const labelSizes = this._getLabelSizes();
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      label = tick.label;
      const optsAtIndex = optionTicks.setContext(this.getContext(i));
      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
      font = this._resolveTickFontOptions(i);
      lineHeight = font.lineHeight;
      lineCount = isArray2(label) ? label.length : 1;
      const halfCount = lineCount / 2;
      const color3 = optsAtIndex.color;
      const strokeColor = optsAtIndex.textStrokeColor;
      const strokeWidth = optsAtIndex.textStrokeWidth;
      let tickTextAlign = textAlign;
      if (isHorizontal) {
        x = pixel;
        if (textAlign === "inner") {
          if (i === ilen - 1) {
            tickTextAlign = !this.options.reverse ? "right" : "left";
          } else if (i === 0) {
            tickTextAlign = !this.options.reverse ? "left" : "right";
          } else {
            tickTextAlign = "center";
          }
        }
        if (position === "top") {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = -lineCount * lineHeight + lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
          } else {
            textOffset = -labelSizes.highest.height + lineHeight / 2;
          }
        } else {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
          } else {
            textOffset = labelSizes.highest.height - lineCount * lineHeight;
          }
        }
        if (mirror) {
          textOffset *= -1;
        }
        if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
          x += lineHeight / 2 * Math.sin(rotation);
        }
      } else {
        y = pixel;
        textOffset = (1 - lineCount) * lineHeight / 2;
      }
      let backdrop;
      if (optsAtIndex.showLabelBackdrop) {
        const labelPadding = toPadding2(optsAtIndex.backdropPadding);
        const height = labelSizes.heights[i];
        const width = labelSizes.widths[i];
        let top = textOffset - labelPadding.top;
        let left = 0 - labelPadding.left;
        switch (textBaseline) {
          case "middle":
            top -= height / 2;
            break;
          case "bottom":
            top -= height;
            break;
        }
        switch (textAlign) {
          case "center":
            left -= width / 2;
            break;
          case "right":
            left -= width;
            break;
          case "inner":
            if (i === ilen - 1) {
              left -= width;
            } else if (i > 0) {
              left -= width / 2;
            }
            break;
        }
        backdrop = {
          left,
          top,
          width: width + labelPadding.width,
          height: height + labelPadding.height,
          color: optsAtIndex.backdropColor
        };
      }
      items.push({
        label,
        font,
        textOffset,
        options: {
          rotation,
          color: color3,
          strokeColor,
          strokeWidth,
          textAlign: tickTextAlign,
          textBaseline,
          translation: [
            x,
            y
          ],
          backdrop
        }
      });
    }
    return items;
  }
  _getXAxisLabelAlignment() {
    const { position, ticks } = this.options;
    const rotation = -toRadians2(this.labelRotation);
    if (rotation) {
      return position === "top" ? "left" : "right";
    }
    let align = "center";
    if (ticks.align === "start") {
      align = "left";
    } else if (ticks.align === "end") {
      align = "right";
    } else if (ticks.align === "inner") {
      align = "inner";
    }
    return align;
  }
  _getYAxisLabelAlignment(tl) {
    const { position, ticks: { crossAlign, mirror, padding } } = this.options;
    const labelSizes = this._getLabelSizes();
    const tickAndPadding = tl + padding;
    const widest = labelSizes.widest.width;
    let textAlign;
    let x;
    if (position === "left") {
      if (mirror) {
        x = this.right + padding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x += widest;
        }
      } else {
        x = this.right - tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x = this.left;
        }
      }
    } else if (position === "right") {
      if (mirror) {
        x = this.left + padding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x -= widest;
        }
      } else {
        x = this.left + tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x = this.right;
        }
      }
    } else {
      textAlign = "right";
    }
    return {
      textAlign,
      x
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror) {
      return;
    }
    const chart = this.chart;
    const position = this.options.position;
    if (position === "left" || position === "right") {
      return {
        top: 0,
        left: this.left,
        bottom: chart.height,
        right: this.right
      };
    }
    if (position === "top" || position === "bottom") {
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: chart.width
      };
    }
  }
  drawBackground() {
    const { ctx, options: { backgroundColor }, left, top, width, height } = this;
    if (backgroundColor) {
      ctx.save();
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(left, top, width, height);
      ctx.restore();
    }
  }
  getLineWidthForValue(value) {
    const grid = this.options.grid;
    if (!this._isVisible() || !grid.display) {
      return 0;
    }
    const ticks = this.ticks;
    const index = ticks.findIndex((t) => t.value === value);
    if (index >= 0) {
      const opts = grid.setContext(this.getContext(index));
      return opts.lineWidth;
    }
    return 0;
  }
  drawGrid(chartArea) {
    const grid = this.options.grid;
    const ctx = this.ctx;
    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
    let i, ilen;
    const drawLine = (p1, p2, style) => {
      if (!style.width || !style.color) {
        return;
      }
      ctx.save();
      ctx.lineWidth = style.width;
      ctx.strokeStyle = style.color;
      ctx.setLineDash(style.borderDash || []);
      ctx.lineDashOffset = style.borderDashOffset;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
      ctx.restore();
    };
    if (grid.display) {
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        const item = items[i];
        if (grid.drawOnChartArea) {
          drawLine({
            x: item.x1,
            y: item.y1
          }, {
            x: item.x2,
            y: item.y2
          }, item);
        }
        if (grid.drawTicks) {
          drawLine({
            x: item.tx1,
            y: item.ty1
          }, {
            x: item.tx2,
            y: item.ty2
          }, {
            color: item.tickColor,
            width: item.tickWidth,
            borderDash: item.tickBorderDash,
            borderDashOffset: item.tickBorderDashOffset
          });
        }
      }
    }
  }
  drawBorder() {
    const { chart, ctx, options: { border, grid } } = this;
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = border.display ? borderOpts.width : 0;
    if (!axisWidth) {
      return;
    }
    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
    const borderValue = this._borderValue;
    let x1, x2, y1, y2;
    if (this.isHorizontal()) {
      x1 = _alignPixel2(chart, this.left, axisWidth) - axisWidth / 2;
      x2 = _alignPixel2(chart, this.right, lastLineWidth) + lastLineWidth / 2;
      y1 = y2 = borderValue;
    } else {
      y1 = _alignPixel2(chart, this.top, axisWidth) - axisWidth / 2;
      y2 = _alignPixel2(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
      x1 = x2 = borderValue;
    }
    ctx.save();
    ctx.lineWidth = borderOpts.width;
    ctx.strokeStyle = borderOpts.color;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }
  drawLabels(chartArea) {
    const optionTicks = this.options.ticks;
    if (!optionTicks.display) {
      return;
    }
    const ctx = this.ctx;
    const area = this._computeLabelArea();
    if (area) {
      clipArea2(ctx, area);
    }
    const items = this.getLabelItems(chartArea);
    for (const item of items) {
      const renderTextOptions = item.options;
      const tickFont = item.font;
      const label = item.label;
      const y = item.textOffset;
      renderText2(ctx, label, 0, y, tickFont, renderTextOptions);
    }
    if (area) {
      unclipArea2(ctx);
    }
  }
  drawTitle() {
    const { ctx, options: { position, title, reverse } } = this;
    if (!title.display) {
      return;
    }
    const font = toFont2(title.font);
    const padding = toPadding2(title.padding);
    const align = title.align;
    let offset2 = font.lineHeight / 2;
    if (position === "bottom" || position === "center" || isObject2(position)) {
      offset2 += padding.bottom;
      if (isArray2(title.text)) {
        offset2 += font.lineHeight * (title.text.length - 1);
      }
    } else {
      offset2 += padding.top;
    }
    const { titleX, titleY, maxWidth, rotation } = titleArgs2(this, offset2, position, align);
    renderText2(ctx, title.text, 0, 0, font, {
      color: title.color,
      maxWidth,
      rotation,
      textAlign: titleAlign2(align, position, reverse),
      textBaseline: "middle",
      translation: [
        titleX,
        titleY
      ]
    });
  }
  draw(chartArea) {
    if (!this._isVisible()) {
      return;
    }
    this.drawBackground();
    this.drawGrid(chartArea);
    this.drawBorder();
    this.drawTitle();
    this.drawLabels(chartArea);
  }
  _layers() {
    const opts = this.options;
    const tz = opts.ticks && opts.ticks.z || 0;
    const gz = valueOrDefault2(opts.grid && opts.grid.z, -1);
    const bz = valueOrDefault2(opts.border && opts.border.z, 0);
    if (!this._isVisible() || this.draw !== Scale2.prototype.draw) {
      return [
        {
          z: tz,
          draw: (chartArea) => {
            this.draw(chartArea);
          }
        }
      ];
    }
    return [
      {
        z: gz,
        draw: (chartArea) => {
          this.drawBackground();
          this.drawGrid(chartArea);
          this.drawTitle();
        }
      },
      {
        z: bz,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: tz,
        draw: (chartArea) => {
          this.drawLabels(chartArea);
        }
      }
    ];
  }
  getMatchingVisibleMetas(type) {
    const metas = this.chart.getSortedVisibleDatasetMetas();
    const axisID = this.axis + "AxisID";
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      const meta = metas[i];
      if (meta[axisID] === this.id && (!type || meta.type === type)) {
        result.push(meta);
      }
    }
    return result;
  }
  _resolveTickFontOptions(index) {
    const opts = this.options.ticks.setContext(this.getContext(index));
    return toFont2(opts.font);
  }
  _maxDigits() {
    const fontSize = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / fontSize;
  }
};
function generateTicks$12(generationOptions, dataRange) {
  const ticks = [];
  const MIN_SPACING = 1e-14;
  const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
  const unit = step || 1;
  const maxSpaces = maxTicks - 1;
  const { min: rmin, max: rmax } = dataRange;
  const minDefined = !isNullOrUndef2(min);
  const maxDefined = !isNullOrUndef2(max);
  const countDefined = !isNullOrUndef2(count);
  const minSpacing = (rmax - rmin) / (maxDigits + 1);
  let spacing = niceNum2((rmax - rmin) / maxSpaces / unit) * unit;
  let factor, niceMin, niceMax, numSpaces;
  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
    return [
      {
        value: rmin
      },
      {
        value: rmax
      }
    ];
  }
  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
  if (numSpaces > maxSpaces) {
    spacing = niceNum2(numSpaces * spacing / maxSpaces / unit) * unit;
  }
  if (!isNullOrUndef2(precision)) {
    factor = Math.pow(10, precision);
    spacing = Math.ceil(spacing * factor) / factor;
  }
  if (bounds === "ticks") {
    niceMin = Math.floor(rmin / spacing) * spacing;
    niceMax = Math.ceil(rmax / spacing) * spacing;
  } else {
    niceMin = rmin;
    niceMax = rmax;
  }
  if (minDefined && maxDefined && step && almostWhole2((max - min) / step, spacing / 1e3)) {
    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
    spacing = (max - min) / numSpaces;
    niceMin = min;
    niceMax = max;
  } else if (countDefined) {
    niceMin = minDefined ? min : niceMin;
    niceMax = maxDefined ? max : niceMax;
    numSpaces = count - 1;
    spacing = (niceMax - niceMin) / numSpaces;
  } else {
    numSpaces = (niceMax - niceMin) / spacing;
    if (almostEquals2(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
      numSpaces = Math.round(numSpaces);
    } else {
      numSpaces = Math.ceil(numSpaces);
    }
  }
  const decimalPlaces = Math.max(_decimalPlaces2(spacing), _decimalPlaces2(niceMin));
  factor = Math.pow(10, isNullOrUndef2(precision) ? decimalPlaces : precision);
  niceMin = Math.round(niceMin * factor) / factor;
  niceMax = Math.round(niceMax * factor) / factor;
  let j = 0;
  if (minDefined) {
    if (includeBounds && niceMin !== min) {
      ticks.push({
        value: min
      });
      if (niceMin < min) {
        j++;
      }
      if (almostEquals2(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize2(min, minSpacing, generationOptions))) {
        j++;
      }
    } else if (niceMin < min) {
      j++;
    }
  }
  for (; j < numSpaces; ++j) {
    const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;
    if (maxDefined && tickValue > max) {
      break;
    }
    ticks.push({
      value: tickValue
    });
  }
  if (maxDefined && includeBounds && niceMax !== max) {
    if (ticks.length && almostEquals2(ticks[ticks.length - 1].value, max, relativeLabelSize2(max, minSpacing, generationOptions))) {
      ticks[ticks.length - 1].value = max;
    } else {
      ticks.push({
        value: max
      });
    }
  } else if (!maxDefined || niceMax === max) {
    ticks.push({
      value: niceMax
    });
  }
  return ticks;
}
function relativeLabelSize2(value, minSpacing, { horizontal, minRotation }) {
  const rad = toRadians2(minRotation);
  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
  const length = 0.75 * minSpacing * ("" + value).length;
  return Math.min(minSpacing / ratio, length);
}
var LinearScaleBase2 = class extends Scale2 {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._endValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index) {
    if (isNullOrUndef2(raw)) {
      return null;
    }
    if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
      return null;
    }
    return +raw;
  }
  handleTickRangeOptions() {
    const { beginAtZero } = this.options;
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max = maxDefined ? max : v;
    if (beginAtZero) {
      const minSign = sign2(min);
      const maxSign = sign2(max);
      if (minSign < 0 && maxSign < 0) {
        setMax(0);
      } else if (minSign > 0 && maxSign > 0) {
        setMin(0);
      }
    }
    if (min === max) {
      let offset2 = max === 0 ? 1 : Math.abs(max * 0.05);
      setMax(max + offset2);
      if (!beginAtZero) {
        setMin(min - offset2);
      }
    }
    this.min = min;
    this.max = max;
  }
  getTickLimit() {
    const tickOpts = this.options.ticks;
    let { maxTicksLimit, stepSize } = tickOpts;
    let maxTicks;
    if (stepSize) {
      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
      if (maxTicks > 1e3) {
        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
        maxTicks = 1e3;
      }
    } else {
      maxTicks = this.computeTickLimit();
      maxTicksLimit = maxTicksLimit || 11;
    }
    if (maxTicksLimit) {
      maxTicks = Math.min(maxTicksLimit, maxTicks);
    }
    return maxTicks;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const opts = this.options;
    const tickOpts = opts.ticks;
    let maxTicks = this.getTickLimit();
    maxTicks = Math.max(2, maxTicks);
    const numericGeneratorOptions = {
      maxTicks,
      bounds: opts.bounds,
      min: opts.min,
      max: opts.max,
      precision: tickOpts.precision,
      step: tickOpts.stepSize,
      count: tickOpts.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: tickOpts.minRotation || 0,
      includeBounds: tickOpts.includeBounds !== false
    };
    const dataRange = this._range || this;
    const ticks = generateTicks$12(numericGeneratorOptions, dataRange);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey2(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  configure() {
    const ticks = this.ticks;
    let start = this.min;
    let end = this.max;
    super.configure();
    if (this.options.offset && ticks.length) {
      const offset2 = (end - start) / Math.max(ticks.length - 1, 1) / 2;
      start -= offset2;
      end += offset2;
    }
    this._startValue = start;
    this._endValue = end;
    this._valueRange = end - start;
  }
  getLabelForValue(value) {
    return formatNumber2(value, this.chart.options.locale, this.options.ticks.format);
  }
};
var LinearScale2 = class extends LinearScaleBase2 {
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite2(min) ? min : 0;
    this.max = isNumberFinite2(max) ? max : 1;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const horizontal = this.isHorizontal();
    const length = horizontal ? this.width : this.height;
    const minRotation = toRadians2(this.options.ticks.minRotation);
    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
    const tickFont = this._resolveTickFontOptions(0);
    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
  }
  getPixelForValue(value) {
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
  }
};
__publicField(LinearScale2, "id", "linear");
__publicField(LinearScale2, "defaults", {
  ticks: {
    callback: Ticks2.formatters.numeric
  }
});
var log10Floor2 = (v) => Math.floor(log102(v));
var changeExponent2 = (v, m) => Math.pow(10, log10Floor2(v) + m);
function isMajor2(tickVal) {
  const remain = tickVal / Math.pow(10, log10Floor2(tickVal));
  return remain === 1;
}
function steps2(min, max, rangeExp) {
  const rangeStep = Math.pow(10, rangeExp);
  const start = Math.floor(min / rangeStep);
  const end = Math.ceil(max / rangeStep);
  return end - start;
}
function startExp2(min, max) {
  const range = max - min;
  let rangeExp = log10Floor2(range);
  while (steps2(min, max, rangeExp) > 10) {
    rangeExp++;
  }
  while (steps2(min, max, rangeExp) < 10) {
    rangeExp--;
  }
  return Math.min(rangeExp, log10Floor2(min));
}
function generateTicks2(generationOptions, { min, max }) {
  min = finiteOrDefault2(generationOptions.min, min);
  const ticks = [];
  const minExp = log10Floor2(min);
  let exp = startExp2(min, max);
  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
  const stepSize = Math.pow(10, exp);
  const base = minExp > exp ? Math.pow(10, minExp) : 0;
  const start = Math.round((min - base) * precision) / precision;
  const offset2 = Math.floor((min - base) / stepSize / 10) * stepSize * 10;
  let significand = Math.floor((start - offset2) / Math.pow(10, exp));
  let value = finiteOrDefault2(generationOptions.min, Math.round((base + offset2 + significand * Math.pow(10, exp)) * precision) / precision);
  while (value < max) {
    ticks.push({
      value,
      major: isMajor2(value),
      significand
    });
    if (significand >= 10) {
      significand = significand < 15 ? 15 : 20;
    } else {
      significand++;
    }
    if (significand >= 20) {
      exp++;
      significand = 2;
      precision = exp >= 0 ? 1 : precision;
    }
    value = Math.round((base + offset2 + significand * Math.pow(10, exp)) * precision) / precision;
  }
  const lastTick = finiteOrDefault2(generationOptions.max, value);
  ticks.push({
    value: lastTick,
    major: isMajor2(lastTick),
    significand
  });
  return ticks;
}
var LogarithmicScale2 = class extends Scale2 {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index) {
    const value = LinearScaleBase2.prototype.parse.apply(this, [
      raw,
      index
    ]);
    if (value === 0) {
      this._zero = true;
      return void 0;
    }
    return isNumberFinite2(value) && value > 0 ? value : null;
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite2(min) ? Math.max(0, min) : null;
    this.max = isNumberFinite2(max) ? Math.max(0, max) : null;
    if (this.options.beginAtZero) {
      this._zero = true;
    }
    if (this._zero && this.min !== this._suggestedMin && !isNumberFinite2(this._userMin)) {
      this.min = min === changeExponent2(this.min, 0) ? changeExponent2(this.min, -1) : changeExponent2(this.min, 0);
    }
    this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let min = this.min;
    let max = this.max;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max = maxDefined ? max : v;
    if (min === max) {
      if (min <= 0) {
        setMin(1);
        setMax(10);
      } else {
        setMin(changeExponent2(min, -1));
        setMax(changeExponent2(max, 1));
      }
    }
    if (min <= 0) {
      setMin(changeExponent2(max, -1));
    }
    if (max <= 0) {
      setMax(changeExponent2(min, 1));
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const opts = this.options;
    const generationOptions = {
      min: this._userMin,
      max: this._userMax
    };
    const ticks = generateTicks2(generationOptions, this);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey2(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  getLabelForValue(value) {
    return value === void 0 ? "0" : formatNumber2(value, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const start = this.min;
    super.configure();
    this._startValue = log102(start);
    this._valueRange = log102(this.max) - log102(start);
  }
  getPixelForValue(value) {
    if (value === void 0 || value === 0) {
      value = this.min;
    }
    if (value === null || isNaN(value)) {
      return NaN;
    }
    return this.getPixelForDecimal(value === this.min ? 0 : (log102(value) - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    const decimal = this.getDecimalForPixel(pixel);
    return Math.pow(10, this._startValue + decimal * this._valueRange);
  }
};
__publicField(LogarithmicScale2, "id", "logarithmic");
__publicField(LogarithmicScale2, "defaults", {
  ticks: {
    callback: Ticks2.formatters.logarithmic,
    major: {
      enabled: true
    }
  }
});
function getTickBackdropHeight2(opts) {
  const tickOpts = opts.ticks;
  if (tickOpts.display && opts.display) {
    const padding = toPadding2(tickOpts.backdropPadding);
    return valueOrDefault2(tickOpts.font && tickOpts.font.size, defaults2.font.size) + padding.height;
  }
  return 0;
}
function measureLabelSize2(ctx, font, label) {
  label = isArray2(label) ? label : [
    label
  ];
  return {
    w: _longestText2(ctx, font.string, label),
    h: label.length * font.lineHeight
  };
}
function determineLimits2(angle, pos, size, min, max) {
  if (angle === min || angle === max) {
    return {
      start: pos - size / 2,
      end: pos + size / 2
    };
  } else if (angle < min || angle > max) {
    return {
      start: pos - size,
      end: pos
    };
  }
  return {
    start: pos,
    end: pos + size
  };
}
function fitWithPointLabels2(scale) {
  const orig = {
    l: scale.left + scale._padding.left,
    r: scale.right - scale._padding.right,
    t: scale.top + scale._padding.top,
    b: scale.bottom - scale._padding.bottom
  };
  const limits = Object.assign({}, orig);
  const labelSizes = [];
  const padding = [];
  const valueCount = scale._pointLabels.length;
  const pointLabelOpts = scale.options.pointLabels;
  const additionalAngle = pointLabelOpts.centerPointLabels ? PI2 / valueCount : 0;
  for (let i = 0; i < valueCount; i++) {
    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
    padding[i] = opts.padding;
    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
    const plFont = toFont2(opts.font);
    const textSize = measureLabelSize2(scale.ctx, plFont, scale._pointLabels[i]);
    labelSizes[i] = textSize;
    const angleRadians = _normalizeAngle2(scale.getIndexAngle(i) + additionalAngle);
    const angle = Math.round(toDegrees2(angleRadians));
    const hLimits = determineLimits2(angle, pointPosition.x, textSize.w, 0, 180);
    const vLimits = determineLimits2(angle, pointPosition.y, textSize.h, 90, 270);
    updateLimits2(limits, orig, angleRadians, hLimits, vLimits);
  }
  scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
  scale._pointLabelItems = buildPointLabelItems2(scale, labelSizes, padding);
}
function updateLimits2(limits, orig, angle, hLimits, vLimits) {
  const sin = Math.abs(Math.sin(angle));
  const cos = Math.abs(Math.cos(angle));
  let x = 0;
  let y = 0;
  if (hLimits.start < orig.l) {
    x = (orig.l - hLimits.start) / sin;
    limits.l = Math.min(limits.l, orig.l - x);
  } else if (hLimits.end > orig.r) {
    x = (hLimits.end - orig.r) / sin;
    limits.r = Math.max(limits.r, orig.r + x);
  }
  if (vLimits.start < orig.t) {
    y = (orig.t - vLimits.start) / cos;
    limits.t = Math.min(limits.t, orig.t - y);
  } else if (vLimits.end > orig.b) {
    y = (vLimits.end - orig.b) / cos;
    limits.b = Math.max(limits.b, orig.b + y);
  }
}
function createPointLabelItem2(scale, index, itemOpts) {
  const outerDistance = scale.drawingArea;
  const { extra, additionalAngle, padding, size } = itemOpts;
  const pointLabelPosition = scale.getPointPosition(index, outerDistance + extra + padding, additionalAngle);
  const angle = Math.round(toDegrees2(_normalizeAngle2(pointLabelPosition.angle + HALF_PI2)));
  const y = yForAngle2(pointLabelPosition.y, size.h, angle);
  const textAlign = getTextAlignForAngle2(angle);
  const left = leftForTextAlign2(pointLabelPosition.x, size.w, textAlign);
  return {
    visible: true,
    x: pointLabelPosition.x,
    y,
    textAlign,
    left,
    top: y,
    right: left + size.w,
    bottom: y + size.h
  };
}
function isNotOverlapped2(item, area) {
  if (!area) {
    return true;
  }
  const { left, top, right, bottom } = item;
  const apexesInArea = _isPointInArea2({
    x: left,
    y: top
  }, area) || _isPointInArea2({
    x: left,
    y: bottom
  }, area) || _isPointInArea2({
    x: right,
    y: top
  }, area) || _isPointInArea2({
    x: right,
    y: bottom
  }, area);
  return !apexesInArea;
}
function buildPointLabelItems2(scale, labelSizes, padding) {
  const items = [];
  const valueCount = scale._pointLabels.length;
  const opts = scale.options;
  const { centerPointLabels, display } = opts.pointLabels;
  const itemOpts = {
    extra: getTickBackdropHeight2(opts) / 2,
    additionalAngle: centerPointLabels ? PI2 / valueCount : 0
  };
  let area;
  for (let i = 0; i < valueCount; i++) {
    itemOpts.padding = padding[i];
    itemOpts.size = labelSizes[i];
    const item = createPointLabelItem2(scale, i, itemOpts);
    items.push(item);
    if (display === "auto") {
      item.visible = isNotOverlapped2(item, area);
      if (item.visible) {
        area = item;
      }
    }
  }
  return items;
}
function getTextAlignForAngle2(angle) {
  if (angle === 0 || angle === 180) {
    return "center";
  } else if (angle < 180) {
    return "left";
  }
  return "right";
}
function leftForTextAlign2(x, w, align) {
  if (align === "right") {
    x -= w;
  } else if (align === "center") {
    x -= w / 2;
  }
  return x;
}
function yForAngle2(y, h, angle) {
  if (angle === 90 || angle === 270) {
    y -= h / 2;
  } else if (angle > 270 || angle < 90) {
    y -= h;
  }
  return y;
}
function drawPointLabelBox2(ctx, opts, item) {
  const { left, top, right, bottom } = item;
  const { backdropColor } = opts;
  if (!isNullOrUndef2(backdropColor)) {
    const borderRadius = toTRBLCorners2(opts.borderRadius);
    const padding = toPadding2(opts.backdropPadding);
    ctx.fillStyle = backdropColor;
    const backdropLeft = left - padding.left;
    const backdropTop = top - padding.top;
    const backdropWidth = right - left + padding.width;
    const backdropHeight = bottom - top + padding.height;
    if (Object.values(borderRadius).some((v) => v !== 0)) {
      ctx.beginPath();
      addRoundedRectPath2(ctx, {
        x: backdropLeft,
        y: backdropTop,
        w: backdropWidth,
        h: backdropHeight,
        radius: borderRadius
      });
      ctx.fill();
    } else {
      ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
    }
  }
}
function drawPointLabels2(scale, labelCount) {
  const { ctx, options: { pointLabels } } = scale;
  for (let i = labelCount - 1; i >= 0; i--) {
    const item = scale._pointLabelItems[i];
    if (!item.visible) {
      continue;
    }
    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
    drawPointLabelBox2(ctx, optsAtIndex, item);
    const plFont = toFont2(optsAtIndex.font);
    const { x, y, textAlign } = item;
    renderText2(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
      color: optsAtIndex.color,
      textAlign,
      textBaseline: "middle"
    });
  }
}
function pathRadiusLine2(scale, radius, circular, labelCount) {
  const { ctx } = scale;
  if (circular) {
    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU2);
  } else {
    let pointPosition = scale.getPointPosition(0, radius);
    ctx.moveTo(pointPosition.x, pointPosition.y);
    for (let i = 1; i < labelCount; i++) {
      pointPosition = scale.getPointPosition(i, radius);
      ctx.lineTo(pointPosition.x, pointPosition.y);
    }
  }
}
function drawRadiusLine2(scale, gridLineOpts, radius, labelCount, borderOpts) {
  const ctx = scale.ctx;
  const circular = gridLineOpts.circular;
  const { color: color3, lineWidth } = gridLineOpts;
  if (!circular && !labelCount || !color3 || !lineWidth || radius < 0) {
    return;
  }
  ctx.save();
  ctx.strokeStyle = color3;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash(borderOpts.dash);
  ctx.lineDashOffset = borderOpts.dashOffset;
  ctx.beginPath();
  pathRadiusLine2(scale, radius, circular, labelCount);
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}
function createPointLabelContext2(parent, index, label) {
  return createContext2(parent, {
    label,
    index,
    type: "pointLabel"
  });
}
var RadialLinearScale2 = class extends LinearScaleBase2 {
  constructor(cfg) {
    super(cfg);
    this.xCenter = void 0;
    this.yCenter = void 0;
    this.drawingArea = void 0;
    this._pointLabels = [];
    this._pointLabelItems = [];
  }
  setDimensions() {
    const padding = this._padding = toPadding2(getTickBackdropHeight2(this.options) / 2);
    const w = this.width = this.maxWidth - padding.width;
    const h = this.height = this.maxHeight - padding.height;
    this.xCenter = Math.floor(this.left + w / 2 + padding.left);
    this.yCenter = Math.floor(this.top + h / 2 + padding.top);
    this.drawingArea = Math.floor(Math.min(w, h) / 2);
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(false);
    this.min = isNumberFinite2(min) && !isNaN(min) ? min : 0;
    this.max = isNumberFinite2(max) && !isNaN(max) ? max : 0;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / getTickBackdropHeight2(this.options));
  }
  generateTickLabels(ticks) {
    LinearScaleBase2.prototype.generateTickLabels.call(this, ticks);
    this._pointLabels = this.getLabels().map((value, index) => {
      const label = callback2(this.options.pointLabels.callback, [
        value,
        index
      ], this);
      return label || label === 0 ? label : "";
    }).filter((v, i) => this.chart.getDataVisibility(i));
  }
  fit() {
    const opts = this.options;
    if (opts.display && opts.pointLabels.display) {
      fitWithPointLabels2(this);
    } else {
      this.setCenterPoint(0, 0, 0, 0);
    }
  }
  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
  }
  getIndexAngle(index) {
    const angleMultiplier = TAU2 / (this._pointLabels.length || 1);
    const startAngle = this.options.startAngle || 0;
    return _normalizeAngle2(index * angleMultiplier + toRadians2(startAngle));
  }
  getDistanceFromCenterForValue(value) {
    if (isNullOrUndef2(value)) {
      return NaN;
    }
    const scalingFactor = this.drawingArea / (this.max - this.min);
    if (this.options.reverse) {
      return (this.max - value) * scalingFactor;
    }
    return (value - this.min) * scalingFactor;
  }
  getValueForDistanceFromCenter(distance) {
    if (isNullOrUndef2(distance)) {
      return NaN;
    }
    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
  }
  getPointLabelContext(index) {
    const pointLabels = this._pointLabels || [];
    if (index >= 0 && index < pointLabels.length) {
      const pointLabel = pointLabels[index];
      return createPointLabelContext2(this.getContext(), index, pointLabel);
    }
  }
  getPointPosition(index, distanceFromCenter, additionalAngle = 0) {
    const angle = this.getIndexAngle(index) - HALF_PI2 + additionalAngle;
    return {
      x: Math.cos(angle) * distanceFromCenter + this.xCenter,
      y: Math.sin(angle) * distanceFromCenter + this.yCenter,
      angle
    };
  }
  getPointPositionForValue(index, value) {
    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
  }
  getBasePosition(index) {
    return this.getPointPositionForValue(index || 0, this.getBaseValue());
  }
  getPointLabelPosition(index) {
    const { left, top, right, bottom } = this._pointLabelItems[index];
    return {
      left,
      top,
      right,
      bottom
    };
  }
  drawBackground() {
    const { backgroundColor, grid: { circular } } = this.options;
    if (backgroundColor) {
      const ctx = this.ctx;
      ctx.save();
      ctx.beginPath();
      pathRadiusLine2(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
      ctx.closePath();
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
  }
  drawGrid() {
    const ctx = this.ctx;
    const opts = this.options;
    const { angleLines, grid, border } = opts;
    const labelCount = this._pointLabels.length;
    let i, offset2, position;
    if (opts.pointLabels.display) {
      drawPointLabels2(this, labelCount);
    }
    if (grid.display) {
      this.ticks.forEach((tick, index) => {
        if (index !== 0 || index === 0 && this.min < 0) {
          offset2 = this.getDistanceFromCenterForValue(tick.value);
          const context = this.getContext(index);
          const optsAtIndex = grid.setContext(context);
          const optsAtIndexBorder = border.setContext(context);
          drawRadiusLine2(this, optsAtIndex, offset2, labelCount, optsAtIndexBorder);
        }
      });
    }
    if (angleLines.display) {
      ctx.save();
      for (i = labelCount - 1; i >= 0; i--) {
        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
        const { color: color3, lineWidth } = optsAtIndex;
        if (!lineWidth || !color3) {
          continue;
        }
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = color3;
        ctx.setLineDash(optsAtIndex.borderDash);
        ctx.lineDashOffset = optsAtIndex.borderDashOffset;
        offset2 = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
        position = this.getPointPosition(i, offset2);
        ctx.beginPath();
        ctx.moveTo(this.xCenter, this.yCenter);
        ctx.lineTo(position.x, position.y);
        ctx.stroke();
      }
      ctx.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const ctx = this.ctx;
    const opts = this.options;
    const tickOpts = opts.ticks;
    if (!tickOpts.display) {
      return;
    }
    const startAngle = this.getIndexAngle(0);
    let offset2, width;
    ctx.save();
    ctx.translate(this.xCenter, this.yCenter);
    ctx.rotate(startAngle);
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    this.ticks.forEach((tick, index) => {
      if (index === 0 && this.min >= 0 && !opts.reverse) {
        return;
      }
      const optsAtIndex = tickOpts.setContext(this.getContext(index));
      const tickFont = toFont2(optsAtIndex.font);
      offset2 = this.getDistanceFromCenterForValue(this.ticks[index].value);
      if (optsAtIndex.showLabelBackdrop) {
        ctx.font = tickFont.string;
        width = ctx.measureText(tick.label).width;
        ctx.fillStyle = optsAtIndex.backdropColor;
        const padding = toPadding2(optsAtIndex.backdropPadding);
        ctx.fillRect(-width / 2 - padding.left, -offset2 - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
      }
      renderText2(ctx, tick.label, 0, -offset2, tickFont, {
        color: optsAtIndex.color,
        strokeColor: optsAtIndex.textStrokeColor,
        strokeWidth: optsAtIndex.textStrokeWidth
      });
    });
    ctx.restore();
  }
  drawTitle() {
  }
};
__publicField(RadialLinearScale2, "id", "radialLinear");
__publicField(RadialLinearScale2, "defaults", {
  display: true,
  animate: true,
  position: "chartArea",
  angleLines: {
    display: true,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: false
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: true,
    callback: Ticks2.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: true,
    font: {
      size: 10
    },
    callback(label) {
      return label;
    },
    padding: 5,
    centerPointLabels: false
  }
});
__publicField(RadialLinearScale2, "defaultRoutes", {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
});
__publicField(RadialLinearScale2, "descriptors", {
  angleLines: {
    _fallback: "grid"
  }
});
var INTERVALS2 = {
  millisecond: {
    common: true,
    size: 1,
    steps: 1e3
  },
  second: {
    common: true,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: true,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: true,
    size: 36e5,
    steps: 24
  },
  day: {
    common: true,
    size: 864e5,
    steps: 30
  },
  week: {
    common: false,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: true,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: false,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: true,
    size: 3154e7
  }
};
var UNITS2 = /* @__PURE__ */ Object.keys(INTERVALS2);
function sorter2(a, b) {
  return a - b;
}
function parse2(scale, input) {
  if (isNullOrUndef2(input)) {
    return null;
  }
  const adapter = scale._adapter;
  const { parser, round: round3, isoWeekday } = scale._parseOpts;
  let value = input;
  if (typeof parser === "function") {
    value = parser(value);
  }
  if (!isNumberFinite2(value)) {
    value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
  }
  if (value === null) {
    return null;
  }
  if (round3) {
    value = round3 === "week" && (isNumber2(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round3);
  }
  return +value;
}
function determineUnitForAutoTicks2(minUnit, min, max, capacity) {
  const ilen = UNITS2.length;
  for (let i = UNITS2.indexOf(minUnit); i < ilen - 1; ++i) {
    const interval = INTERVALS2[UNITS2[i]];
    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
      return UNITS2[i];
    }
  }
  return UNITS2[ilen - 1];
}
function determineUnitForFormatting2(scale, numTicks, minUnit, min, max) {
  for (let i = UNITS2.length - 1; i >= UNITS2.indexOf(minUnit); i--) {
    const unit = UNITS2[i];
    if (INTERVALS2[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
      return unit;
    }
  }
  return UNITS2[minUnit ? UNITS2.indexOf(minUnit) : 0];
}
function determineMajorUnit2(unit) {
  for (let i = UNITS2.indexOf(unit) + 1, ilen = UNITS2.length; i < ilen; ++i) {
    if (INTERVALS2[UNITS2[i]].common) {
      return UNITS2[i];
    }
  }
}
function addTick2(ticks, time, timestamps) {
  if (!timestamps) {
    ticks[time] = true;
  } else if (timestamps.length) {
    const { lo, hi } = _lookup2(timestamps, time);
    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
    ticks[timestamp] = true;
  }
}
function setMajorTicks2(scale, ticks, map3, majorUnit) {
  const adapter = scale._adapter;
  const first = +adapter.startOf(ticks[0].value, majorUnit);
  const last = ticks[ticks.length - 1].value;
  let major, index;
  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
    index = map3[major];
    if (index >= 0) {
      ticks[index].major = true;
    }
  }
  return ticks;
}
function ticksFromTimestamps2(scale, values, majorUnit) {
  const ticks = [];
  const map3 = {};
  const ilen = values.length;
  let i, value;
  for (i = 0; i < ilen; ++i) {
    value = values[i];
    map3[value] = i;
    ticks.push({
      value,
      major: false
    });
  }
  return ilen === 0 || !majorUnit ? ticks : setMajorTicks2(scale, ticks, map3, majorUnit);
}
var TimeScale2 = class extends Scale2 {
  constructor(props) {
    super(props);
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
    this._unit = "day";
    this._majorUnit = void 0;
    this._offsets = {};
    this._normalized = false;
    this._parseOpts = void 0;
  }
  init(scaleOpts, opts = {}) {
    const time = scaleOpts.time || (scaleOpts.time = {});
    const adapter = this._adapter = new adapters2._date(scaleOpts.adapters.date);
    adapter.init(opts);
    mergeIf2(time.displayFormats, adapter.formats());
    this._parseOpts = {
      parser: time.parser,
      round: time.round,
      isoWeekday: time.isoWeekday
    };
    super.init(scaleOpts);
    this._normalized = opts.normalized;
  }
  parse(raw, index) {
    if (raw === void 0) {
      return null;
    }
    return parse2(this, raw);
  }
  beforeLayout() {
    super.beforeLayout();
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const options = this.options;
    const adapter = this._adapter;
    const unit = options.time.unit || "day";
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    function _applyBounds(bounds) {
      if (!minDefined && !isNaN(bounds.min)) {
        min = Math.min(min, bounds.min);
      }
      if (!maxDefined && !isNaN(bounds.max)) {
        max = Math.max(max, bounds.max);
      }
    }
    if (!minDefined || !maxDefined) {
      _applyBounds(this._getLabelBounds());
      if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
        _applyBounds(this.getMinMax(false));
      }
    }
    min = isNumberFinite2(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
    max = isNumberFinite2(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
    this.min = Math.min(min, max - 1);
    this.max = Math.max(min + 1, max);
  }
  _getLabelBounds() {
    const arr = this.getLabelTimestamps();
    let min = Number.POSITIVE_INFINITY;
    let max = Number.NEGATIVE_INFINITY;
    if (arr.length) {
      min = arr[0];
      max = arr[arr.length - 1];
    }
    return {
      min,
      max
    };
  }
  buildTicks() {
    const options = this.options;
    const timeOpts = options.time;
    const tickOpts = options.ticks;
    const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
    if (options.bounds === "ticks" && timestamps.length) {
      this.min = this._userMin || timestamps[0];
      this.max = this._userMax || timestamps[timestamps.length - 1];
    }
    const min = this.min;
    const max = this.max;
    const ticks = _filterBetween2(timestamps, min, max);
    this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks2(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting2(this, ticks.length, timeOpts.minUnit, this.min, this.max));
    this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit2(this._unit);
    this.initOffsets(timestamps);
    if (options.reverse) {
      ticks.reverse();
    }
    return ticksFromTimestamps2(this, ticks, this._majorUnit);
  }
  afterAutoSkip() {
    if (this.options.offsetAfterAutoskip) {
      this.initOffsets(this.ticks.map((tick) => +tick.value));
    }
  }
  initOffsets(timestamps = []) {
    let start = 0;
    let end = 0;
    let first, last;
    if (this.options.offset && timestamps.length) {
      first = this.getDecimalForValue(timestamps[0]);
      if (timestamps.length === 1) {
        start = 1 - first;
      } else {
        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
      }
      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
      if (timestamps.length === 1) {
        end = last;
      } else {
        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
      }
    }
    const limit = timestamps.length < 3 ? 0.5 : 0.25;
    start = _limitValue2(start, 0, limit);
    end = _limitValue2(end, 0, limit);
    this._offsets = {
      start,
      end,
      factor: 1 / (start + 1 + end)
    };
  }
  _generate() {
    const adapter = this._adapter;
    const min = this.min;
    const max = this.max;
    const options = this.options;
    const timeOpts = options.time;
    const minor = timeOpts.unit || determineUnitForAutoTicks2(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
    const stepSize = valueOrDefault2(options.ticks.stepSize, 1);
    const weekday = minor === "week" ? timeOpts.isoWeekday : false;
    const hasWeekday = isNumber2(weekday) || weekday === true;
    const ticks = {};
    let first = min;
    let time, count;
    if (hasWeekday) {
      first = +adapter.startOf(first, "isoWeek", weekday);
    }
    first = +adapter.startOf(first, hasWeekday ? "day" : minor);
    if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
      throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
    }
    const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
      addTick2(ticks, time, timestamps);
    }
    if (time === max || options.bounds === "ticks" || count === 1) {
      addTick2(ticks, time, timestamps);
    }
    return Object.keys(ticks).sort(sorter2).map((x) => +x);
  }
  getLabelForValue(value) {
    const adapter = this._adapter;
    const timeOpts = this.options.time;
    if (timeOpts.tooltipFormat) {
      return adapter.format(value, timeOpts.tooltipFormat);
    }
    return adapter.format(value, timeOpts.displayFormats.datetime);
  }
  format(value, format) {
    const options = this.options;
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const fmt = format || formats[unit];
    return this._adapter.format(value, fmt);
  }
  _tickFormatFunction(time, index, ticks, format) {
    const options = this.options;
    const formatter = options.ticks.callback;
    if (formatter) {
      return callback2(formatter, [
        time,
        index,
        ticks
      ], this);
    }
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const majorUnit = this._majorUnit;
    const minorFormat = unit && formats[unit];
    const majorFormat = majorUnit && formats[majorUnit];
    const tick = ticks[index];
    const major = majorUnit && majorFormat && tick && tick.major;
    return this._adapter.format(time, format || (major ? majorFormat : minorFormat));
  }
  generateTickLabels(ticks) {
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      tick.label = this._tickFormatFunction(tick.value, i, ticks);
    }
  }
  getDecimalForValue(value) {
    return value === null ? NaN : (value - this.min) / (this.max - this.min);
  }
  getPixelForValue(value) {
    const offsets = this._offsets;
    const pos = this.getDecimalForValue(value);
    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return this.min + pos * (this.max - this.min);
  }
  _getLabelSize(label) {
    const ticksOpts = this.options.ticks;
    const tickLabelWidth = this.ctx.measureText(label).width;
    const angle = toRadians2(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
    const cosRotation = Math.cos(angle);
    const sinRotation = Math.sin(angle);
    const tickFontSize = this._resolveTickFontOptions(0).size;
    return {
      w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
      h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
    };
  }
  _getLabelCapacity(exampleTime) {
    const timeOpts = this.options.time;
    const displayFormats = timeOpts.displayFormats;
    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps2(this, [
      exampleTime
    ], this._majorUnit), format);
    const size = this._getLabelSize(exampleLabel);
    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
    return capacity > 0 ? capacity : 1;
  }
  getDataTimestamps() {
    let timestamps = this._cache.data || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const metas = this.getMatchingVisibleMetas();
    if (this._normalized && metas.length) {
      return this._cache.data = metas[0].controller.getAllParsedValues(this);
    }
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
    }
    return this._cache.data = this.normalize(timestamps);
  }
  getLabelTimestamps() {
    const timestamps = this._cache.labels || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const labels = this.getLabels();
    for (i = 0, ilen = labels.length; i < ilen; ++i) {
      timestamps.push(parse2(this, labels[i]));
    }
    return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
  }
  normalize(values) {
    return _arrayUnique2(values.sort(sorter2));
  }
};
__publicField(TimeScale2, "id", "time");
__publicField(TimeScale2, "defaults", {
  bounds: "data",
  adapters: {},
  time: {
    parser: false,
    unit: false,
    round: false,
    isoWeekday: false,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    callback: false,
    major: {
      enabled: false
    }
  }
});
function interpolate4(table, val, reverse) {
  let lo = 0;
  let hi = table.length - 1;
  let prevSource, nextSource, prevTarget, nextTarget;
  if (reverse) {
    if (val >= table[lo].pos && val <= table[hi].pos) {
      ({ lo, hi } = _lookupByKey2(table, "pos", val));
    }
    ({ pos: prevSource, time: prevTarget } = table[lo]);
    ({ pos: nextSource, time: nextTarget } = table[hi]);
  } else {
    if (val >= table[lo].time && val <= table[hi].time) {
      ({ lo, hi } = _lookupByKey2(table, "time", val));
    }
    ({ time: prevSource, pos: prevTarget } = table[lo]);
    ({ time: nextSource, pos: nextTarget } = table[hi]);
  }
  const span = nextSource - prevSource;
  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
var TimeSeriesScale2 = class extends TimeScale2 {
  constructor(props) {
    super(props);
    this._table = [];
    this._minPos = void 0;
    this._tableRange = void 0;
  }
  initOffsets() {
    const timestamps = this._getTimestampsForTable();
    const table = this._table = this.buildLookupTable(timestamps);
    this._minPos = interpolate4(table, this.min);
    this._tableRange = interpolate4(table, this.max) - this._minPos;
    super.initOffsets(timestamps);
  }
  buildLookupTable(timestamps) {
    const { min, max } = this;
    const items = [];
    const table = [];
    let i, ilen, prev, curr, next;
    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
      curr = timestamps[i];
      if (curr >= min && curr <= max) {
        items.push(curr);
      }
    }
    if (items.length < 2) {
      return [
        {
          time: min,
          pos: 0
        },
        {
          time: max,
          pos: 1
        }
      ];
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      next = items[i + 1];
      prev = items[i - 1];
      curr = items[i];
      if (Math.round((next + prev) / 2) !== curr) {
        table.push({
          time: curr,
          pos: i / (ilen - 1)
        });
      }
    }
    return table;
  }
  _generate() {
    const min = this.min;
    const max = this.max;
    let timestamps = super.getDataTimestamps();
    if (!timestamps.includes(min) || !timestamps.length) {
      timestamps.splice(0, 0, min);
    }
    if (!timestamps.includes(max) || timestamps.length === 1) {
      timestamps.push(max);
    }
    return timestamps.sort((a, b) => a - b);
  }
  _getTimestampsForTable() {
    let timestamps = this._cache.all || [];
    if (timestamps.length) {
      return timestamps;
    }
    const data = this.getDataTimestamps();
    const label = this.getLabelTimestamps();
    if (data.length && label.length) {
      timestamps = this.normalize(data.concat(label));
    } else {
      timestamps = data.length ? data : label;
    }
    timestamps = this._cache.all = timestamps;
    return timestamps;
  }
  getDecimalForValue(value) {
    return (interpolate4(this._table, value) - this._minPos) / this._tableRange;
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return interpolate4(this._table, decimal * this._tableRange + this._minPos, true);
  }
};
__publicField(TimeSeriesScale2, "id", "timeseries");
__publicField(TimeSeriesScale2, "defaults", TimeScale2.defaults);

// ../../../node_modules/luxon/src/errors.js
var LuxonError = class extends Error {
};
var InvalidDateTimeError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid DateTime: ${reason.toMessage()}`);
  }
};
var InvalidIntervalError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid Interval: ${reason.toMessage()}`);
  }
};
var InvalidDurationError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid Duration: ${reason.toMessage()}`);
  }
};
var ConflictingSpecificationError = class extends LuxonError {
};
var InvalidUnitError = class extends LuxonError {
  constructor(unit) {
    super(`Invalid unit ${unit}`);
  }
};
var InvalidArgumentError = class extends LuxonError {
};
var ZoneIsAbstractError = class extends LuxonError {
  constructor() {
    super("Zone is an abstract class");
  }
};

// ../../../node_modules/luxon/src/impl/formats.js
var n = "numeric";
var s = "short";
var l = "long";
var DATE_SHORT = {
  year: n,
  month: n,
  day: n
};
var DATE_MED = {
  year: n,
  month: s,
  day: n
};
var DATE_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s
};
var DATE_FULL = {
  year: n,
  month: l,
  day: n
};
var DATE_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l
};
var TIME_SIMPLE = {
  hour: n,
  minute: n
};
var TIME_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n
};
var TIME_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s
};
var TIME_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};
var TIME_24_SIMPLE = {
  hour: n,
  minute: n,
  hourCycle: "h23"
};
var TIME_24_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23"
};
var TIME_24_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: s
};
var TIME_24_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: l
};
var DATETIME_SHORT = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n
};
var DATETIME_SHORT_WITH_SECONDS = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n,
  second: n
};
var DATETIME_MED = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n
};
var DATETIME_MED_WITH_SECONDS = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n,
  second: n
};
var DATETIME_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s,
  hour: n,
  minute: n
};
var DATETIME_FULL = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  timeZoneName: s
};
var DATETIME_FULL_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s
};
var DATETIME_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  timeZoneName: l
};
var DATETIME_HUGE_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};

// ../../../node_modules/luxon/src/zone.js
var Zone = class {
  /**
   * The type of zone
   * @abstract
   * @type {string}
   */
  get type() {
    throw new ZoneIsAbstractError();
  }
  /**
   * The name of this zone.
   * @abstract
   * @type {string}
   */
  get name() {
    throw new ZoneIsAbstractError();
  }
  get ianaName() {
    return this.name;
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year.
   * @abstract
   * @type {boolean}
   */
  get isUniversal() {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(ts, opts) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(ts, format) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(ts) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(otherZone) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */
  get isValid() {
    throw new ZoneIsAbstractError();
  }
};

// ../../../node_modules/luxon/src/zones/systemZone.js
var singleton = null;
var SystemZone = class extends Zone {
  /**
   * Get a singleton instance of the local zone
   * @return {SystemZone}
   */
  static get instance() {
    if (singleton === null) {
      singleton = new SystemZone();
    }
    return singleton;
  }
  /** @override **/
  get type() {
    return "system";
  }
  /** @override **/
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName(ts, { format, locale }) {
    return parseZoneInfo(ts, format, locale);
  }
  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  /** @override **/
  offset(ts) {
    return -new Date(ts).getTimezoneOffset();
  }
  /** @override **/
  equals(otherZone) {
    return otherZone.type === "system";
  }
  /** @override **/
  get isValid() {
    return true;
  }
};

// ../../../node_modules/luxon/src/zones/IANAZone.js
var dtfCache = {};
function makeDTF(zone) {
  if (!dtfCache[zone]) {
    dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: zone,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      era: "short"
    });
  }
  return dtfCache[zone];
}
var typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function hackyOffset(dtf, date) {
  const formatted = dtf.format(date).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
}
function partsOffset(dtf, date) {
  const formatted = dtf.formatToParts(date);
  const filled = [];
  for (let i = 0; i < formatted.length; i++) {
    const { type, value } = formatted[i];
    const pos = typeToPos[type];
    if (type === "era") {
      filled[pos] = value;
    } else if (!isUndefined(pos)) {
      filled[pos] = parseInt(value, 10);
    }
  }
  return filled;
}
var ianaZoneCache = {};
var IANAZone = class extends Zone {
  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  static create(name) {
    if (!ianaZoneCache[name]) {
      ianaZoneCache[name] = new IANAZone(name);
    }
    return ianaZoneCache[name];
  }
  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCache() {
    ianaZoneCache = {};
    dtfCache = {};
  }
  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.
   * @return {boolean}
   */
  static isValidSpecifier(s2) {
    return this.isValidZone(s2);
  }
  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  static isValidZone(zone) {
    if (!zone) {
      return false;
    }
    try {
      new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
      return true;
    } catch (e) {
      return false;
    }
  }
  constructor(name) {
    super();
    this.zoneName = name;
    this.valid = IANAZone.isValidZone(name);
  }
  /** @override **/
  get type() {
    return "iana";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName(ts, { format, locale }) {
    return parseZoneInfo(ts, format, locale, this.name);
  }
  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  /** @override **/
  offset(ts) {
    const date = new Date(ts);
    if (isNaN(date))
      return NaN;
    const dtf = makeDTF(this.name);
    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
    if (adOrBc === "BC") {
      year = -Math.abs(year) + 1;
    }
    const adjustedHour = hour === 24 ? 0 : hour;
    const asUTC = objToLocalTS({
      year,
      month,
      day,
      hour: adjustedHour,
      minute,
      second,
      millisecond: 0
    });
    let asTS = +date;
    const over = asTS % 1e3;
    asTS -= over >= 0 ? over : 1e3 + over;
    return (asUTC - asTS) / (60 * 1e3);
  }
  /** @override **/
  equals(otherZone) {
    return otherZone.type === "iana" && otherZone.name === this.name;
  }
  /** @override **/
  get isValid() {
    return this.valid;
  }
};

// ../../../node_modules/luxon/src/impl/locale.js
var intlLFCache = {};
function getCachedLF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlLFCache[key];
  if (!dtf) {
    dtf = new Intl.ListFormat(locString, opts);
    intlLFCache[key] = dtf;
  }
  return dtf;
}
var intlDTCache = {};
function getCachedDTF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlDTCache[key];
  if (!dtf) {
    dtf = new Intl.DateTimeFormat(locString, opts);
    intlDTCache[key] = dtf;
  }
  return dtf;
}
var intlNumCache = {};
function getCachedINF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let inf = intlNumCache[key];
  if (!inf) {
    inf = new Intl.NumberFormat(locString, opts);
    intlNumCache[key] = inf;
  }
  return inf;
}
var intlRelCache = {};
function getCachedRTF(locString, opts = {}) {
  const { base, ...cacheKeyOpts } = opts;
  const key = JSON.stringify([locString, cacheKeyOpts]);
  let inf = intlRelCache[key];
  if (!inf) {
    inf = new Intl.RelativeTimeFormat(locString, opts);
    intlRelCache[key] = inf;
  }
  return inf;
}
var sysLocaleCache = null;
function systemLocale() {
  if (sysLocaleCache) {
    return sysLocaleCache;
  } else {
    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
    return sysLocaleCache;
  }
}
var weekInfoCache = {};
function getCachedWeekInfo(locString) {
  let data = weekInfoCache[locString];
  if (!data) {
    const locale = new Intl.Locale(locString);
    data = "getWeekInfo" in locale ? locale.getWeekInfo() : locale.weekInfo;
    weekInfoCache[locString] = data;
  }
  return data;
}
function parseLocaleString(localeStr) {
  const xIndex = localeStr.indexOf("-x-");
  if (xIndex !== -1) {
    localeStr = localeStr.substring(0, xIndex);
  }
  const uIndex = localeStr.indexOf("-u-");
  if (uIndex === -1) {
    return [localeStr];
  } else {
    let options;
    let selectedStr;
    try {
      options = getCachedDTF(localeStr).resolvedOptions();
      selectedStr = localeStr;
    } catch (e) {
      const smaller = localeStr.substring(0, uIndex);
      options = getCachedDTF(smaller).resolvedOptions();
      selectedStr = smaller;
    }
    const { numberingSystem, calendar } = options;
    return [selectedStr, numberingSystem, calendar];
  }
}
function intlConfigString(localeStr, numberingSystem, outputCalendar) {
  if (outputCalendar || numberingSystem) {
    if (!localeStr.includes("-u-")) {
      localeStr += "-u";
    }
    if (outputCalendar) {
      localeStr += `-ca-${outputCalendar}`;
    }
    if (numberingSystem) {
      localeStr += `-nu-${numberingSystem}`;
    }
    return localeStr;
  } else {
    return localeStr;
  }
}
function mapMonths(f) {
  const ms = [];
  for (let i = 1; i <= 12; i++) {
    const dt = DateTime.utc(2009, i, 1);
    ms.push(f(dt));
  }
  return ms;
}
function mapWeekdays(f) {
  const ms = [];
  for (let i = 1; i <= 7; i++) {
    const dt = DateTime.utc(2016, 11, 13 + i);
    ms.push(f(dt));
  }
  return ms;
}
function listStuff(loc, length, englishFn, intlFn) {
  const mode = loc.listingMode();
  if (mode === "error") {
    return null;
  } else if (mode === "en") {
    return englishFn(length);
  } else {
    return intlFn(length);
  }
}
function supportsFastNumbers(loc) {
  if (loc.numberingSystem && loc.numberingSystem !== "latn") {
    return false;
  } else {
    return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
  }
}
var PolyNumberFormatter = class {
  constructor(intl, forceSimple, opts) {
    this.padTo = opts.padTo || 0;
    this.floor = opts.floor || false;
    const { padTo, floor, ...otherOpts } = opts;
    if (!forceSimple || Object.keys(otherOpts).length > 0) {
      const intlOpts = { useGrouping: false, ...opts };
      if (opts.padTo > 0)
        intlOpts.minimumIntegerDigits = opts.padTo;
      this.inf = getCachedINF(intl, intlOpts);
    }
  }
  format(i) {
    if (this.inf) {
      const fixed = this.floor ? Math.floor(i) : i;
      return this.inf.format(fixed);
    } else {
      const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
      return padStart(fixed, this.padTo);
    }
  }
};
var PolyDateFormatter = class {
  constructor(dt, intl, opts) {
    this.opts = opts;
    this.originalZone = void 0;
    let z = void 0;
    if (this.opts.timeZone) {
      this.dt = dt;
    } else if (dt.zone.type === "fixed") {
      const gmtOffset = -1 * (dt.offset / 60);
      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
      if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
        z = offsetZ;
        this.dt = dt;
      } else {
        z = "UTC";
        this.dt = dt.offset === 0 ? dt : dt.setZone("UTC").plus({ minutes: dt.offset });
        this.originalZone = dt.zone;
      }
    } else if (dt.zone.type === "system") {
      this.dt = dt;
    } else if (dt.zone.type === "iana") {
      this.dt = dt;
      z = dt.zone.name;
    } else {
      z = "UTC";
      this.dt = dt.setZone("UTC").plus({ minutes: dt.offset });
      this.originalZone = dt.zone;
    }
    const intlOpts = { ...this.opts };
    intlOpts.timeZone = intlOpts.timeZone || z;
    this.dtf = getCachedDTF(intl, intlOpts);
  }
  format() {
    if (this.originalZone) {
      return this.formatToParts().map(({ value }) => value).join("");
    }
    return this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    const parts = this.dtf.formatToParts(this.dt.toJSDate());
    if (this.originalZone) {
      return parts.map((part) => {
        if (part.type === "timeZoneName") {
          const offsetName = this.originalZone.offsetName(this.dt.ts, {
            locale: this.dt.locale,
            format: this.opts.timeZoneName
          });
          return {
            ...part,
            value: offsetName
          };
        } else {
          return part;
        }
      });
    }
    return parts;
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
};
var PolyRelFormatter = class {
  constructor(intl, isEnglish, opts) {
    this.opts = { style: "long", ...opts };
    if (!isEnglish && hasRelative()) {
      this.rtf = getCachedRTF(intl, opts);
    }
  }
  format(count, unit) {
    if (this.rtf) {
      return this.rtf.format(count, unit);
    } else {
      return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
    }
  }
  formatToParts(count, unit) {
    if (this.rtf) {
      return this.rtf.formatToParts(count, unit);
    } else {
      return [];
    }
  }
};
var fallbackWeekSettings = {
  firstDay: 1,
  minimalDays: 4,
  weekend: [6, 7]
};
var Locale = class {
  static fromOpts(opts) {
    return Locale.create(
      opts.locale,
      opts.numberingSystem,
      opts.outputCalendar,
      opts.weekSettings,
      opts.defaultToEN
    );
  }
  static create(locale, numberingSystem, outputCalendar, weekSettings, defaultToEN = false) {
    const specifiedLocale = locale || Settings.defaultLocale;
    const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
    const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
    const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
    const weekSettingsR = validateWeekSettings(weekSettings) || Settings.defaultWeekSettings;
    return new Locale(localeR, numberingSystemR, outputCalendarR, weekSettingsR, specifiedLocale);
  }
  static resetCache() {
    sysLocaleCache = null;
    intlDTCache = {};
    intlNumCache = {};
    intlRelCache = {};
  }
  static fromObject({ locale, numberingSystem, outputCalendar, weekSettings } = {}) {
    return Locale.create(locale, numberingSystem, outputCalendar, weekSettings);
  }
  constructor(locale, numbering, outputCalendar, weekSettings, specifiedLocale) {
    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
    this.locale = parsedLocale;
    this.numberingSystem = numbering || parsedNumberingSystem || null;
    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
    this.weekSettings = weekSettings;
    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
    this.weekdaysCache = { format: {}, standalone: {} };
    this.monthsCache = { format: {}, standalone: {} };
    this.meridiemCache = null;
    this.eraCache = {};
    this.specifiedLocale = specifiedLocale;
    this.fastNumbersCached = null;
  }
  get fastNumbers() {
    if (this.fastNumbersCached == null) {
      this.fastNumbersCached = supportsFastNumbers(this);
    }
    return this.fastNumbersCached;
  }
  listingMode() {
    const isActuallyEn = this.isEnglish();
    const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return isActuallyEn && hasNoWeirdness ? "en" : "intl";
  }
  clone(alts) {
    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
      return this;
    } else {
      return Locale.create(
        alts.locale || this.specifiedLocale,
        alts.numberingSystem || this.numberingSystem,
        alts.outputCalendar || this.outputCalendar,
        validateWeekSettings(alts.weekSettings) || this.weekSettings,
        alts.defaultToEN || false
      );
    }
  }
  redefaultToEN(alts = {}) {
    return this.clone({ ...alts, defaultToEN: true });
  }
  redefaultToSystem(alts = {}) {
    return this.clone({ ...alts, defaultToEN: false });
  }
  months(length, format = false) {
    return listStuff(this, length, months, () => {
      const intl = format ? { month: length, day: "numeric" } : { month: length }, formatStr = format ? "format" : "standalone";
      if (!this.monthsCache[formatStr][length]) {
        this.monthsCache[formatStr][length] = mapMonths((dt) => this.extract(dt, intl, "month"));
      }
      return this.monthsCache[formatStr][length];
    });
  }
  weekdays(length, format = false) {
    return listStuff(this, length, weekdays, () => {
      const intl = format ? { weekday: length, year: "numeric", month: "long", day: "numeric" } : { weekday: length }, formatStr = format ? "format" : "standalone";
      if (!this.weekdaysCache[formatStr][length]) {
        this.weekdaysCache[formatStr][length] = mapWeekdays(
          (dt) => this.extract(dt, intl, "weekday")
        );
      }
      return this.weekdaysCache[formatStr][length];
    });
  }
  meridiems() {
    return listStuff(
      this,
      void 0,
      () => meridiems,
      () => {
        if (!this.meridiemCache) {
          const intl = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(
            (dt) => this.extract(dt, intl, "dayperiod")
          );
        }
        return this.meridiemCache;
      }
    );
  }
  eras(length) {
    return listStuff(this, length, eras, () => {
      const intl = { era: length };
      if (!this.eraCache[length]) {
        this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(
          (dt) => this.extract(dt, intl, "era")
        );
      }
      return this.eraCache[length];
    });
  }
  extract(dt, intlOpts, field) {
    const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m) => m.type.toLowerCase() === field);
    return matching ? matching.value : null;
  }
  numberFormatter(opts = {}) {
    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
  }
  dtFormatter(dt, intlOpts = {}) {
    return new PolyDateFormatter(dt, this.intl, intlOpts);
  }
  relFormatter(opts = {}) {
    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
  }
  listFormatter(opts = {}) {
    return getCachedLF(this.intl, opts);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  getWeekSettings() {
    if (this.weekSettings) {
      return this.weekSettings;
    } else if (!hasLocaleWeekInfo()) {
      return fallbackWeekSettings;
    } else {
      return getCachedWeekInfo(this.locale);
    }
  }
  getStartOfWeek() {
    return this.getWeekSettings().firstDay;
  }
  getMinDaysInFirstWeek() {
    return this.getWeekSettings().minimalDays;
  }
  getWeekendDays() {
    return this.getWeekSettings().weekend;
  }
  equals(other) {
    return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
  }
};

// ../../../node_modules/luxon/src/zones/fixedOffsetZone.js
var singleton2 = null;
var FixedOffsetZone = class extends Zone {
  /**
   * Get a singleton instance of UTC
   * @return {FixedOffsetZone}
   */
  static get utcInstance() {
    if (singleton2 === null) {
      singleton2 = new FixedOffsetZone(0);
    }
    return singleton2;
  }
  /**
   * Get an instance with a specified offset
   * @param {number} offset - The offset in minutes
   * @return {FixedOffsetZone}
   */
  static instance(offset2) {
    return offset2 === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset2);
  }
  /**
   * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
   * @param {string} s - The offset string to parse
   * @example FixedOffsetZone.parseSpecifier("UTC+6")
   * @example FixedOffsetZone.parseSpecifier("UTC+06")
   * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
   * @return {FixedOffsetZone}
   */
  static parseSpecifier(s2) {
    if (s2) {
      const r = s2.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (r) {
        return new FixedOffsetZone(signedOffset(r[1], r[2]));
      }
    }
    return null;
  }
  constructor(offset2) {
    super();
    this.fixed = offset2;
  }
  /** @override **/
  get type() {
    return "fixed";
  }
  /** @override **/
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
  }
  get ianaName() {
    if (this.fixed === 0) {
      return "Etc/UTC";
    } else {
      return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
    }
  }
  /** @override **/
  offsetName() {
    return this.name;
  }
  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.fixed, format);
  }
  /** @override **/
  get isUniversal() {
    return true;
  }
  /** @override **/
  offset() {
    return this.fixed;
  }
  /** @override **/
  equals(otherZone) {
    return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
  }
  /** @override **/
  get isValid() {
    return true;
  }
};

// ../../../node_modules/luxon/src/zones/invalidZone.js
var InvalidZone = class extends Zone {
  constructor(zoneName) {
    super();
    this.zoneName = zoneName;
  }
  /** @override **/
  get type() {
    return "invalid";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName() {
    return null;
  }
  /** @override **/
  formatOffset() {
    return "";
  }
  /** @override **/
  offset() {
    return NaN;
  }
  /** @override **/
  equals() {
    return false;
  }
  /** @override **/
  get isValid() {
    return false;
  }
};

// ../../../node_modules/luxon/src/impl/zoneUtil.js
function normalizeZone(input, defaultZone2) {
  let offset2;
  if (isUndefined(input) || input === null) {
    return defaultZone2;
  } else if (input instanceof Zone) {
    return input;
  } else if (isString(input)) {
    const lowered = input.toLowerCase();
    if (lowered === "default")
      return defaultZone2;
    else if (lowered === "local" || lowered === "system")
      return SystemZone.instance;
    else if (lowered === "utc" || lowered === "gmt")
      return FixedOffsetZone.utcInstance;
    else
      return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
  } else if (isNumber3(input)) {
    return FixedOffsetZone.instance(input);
  } else if (typeof input === "object" && "offset" in input && typeof input.offset === "function") {
    return input;
  } else {
    return new InvalidZone(input);
  }
}

// ../../../node_modules/luxon/src/settings.js
var now = () => Date.now();
var defaultZone = "system";
var defaultLocale = null;
var defaultNumberingSystem = null;
var defaultOutputCalendar = null;
var twoDigitCutoffYear = 60;
var throwOnInvalid;
var defaultWeekSettings = null;
var Settings = class {
  /**
   * Get the callback for returning the current timestamp.
   * @type {function}
   */
  static get now() {
    return now;
  }
  /**
   * Set the callback for returning the current timestamp.
   * The function should return a number, which will be interpreted as an Epoch millisecond count
   * @type {function}
   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
   */
  static set now(n2) {
    now = n2;
  }
  /**
   * Set the default time zone to create DateTimes in. Does not affect existing instances.
   * Use the value "system" to reset this value to the system's time zone.
   * @type {string}
   */
  static set defaultZone(zone) {
    defaultZone = zone;
  }
  /**
   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
   * The default value is the system's time zone (the one set on the machine that runs this code).
   * @type {Zone}
   */
  static get defaultZone() {
    return normalizeZone(defaultZone, SystemZone.instance);
  }
  /**
   * Get the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultLocale() {
    return defaultLocale;
  }
  /**
   * Set the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultLocale(locale) {
    defaultLocale = locale;
  }
  /**
   * Get the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultNumberingSystem() {
    return defaultNumberingSystem;
  }
  /**
   * Set the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultNumberingSystem(numberingSystem) {
    defaultNumberingSystem = numberingSystem;
  }
  /**
   * Get the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultOutputCalendar() {
    return defaultOutputCalendar;
  }
  /**
   * Set the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultOutputCalendar(outputCalendar) {
    defaultOutputCalendar = outputCalendar;
  }
  /**
   * @typedef {Object} WeekSettings
   * @property {number} firstDay
   * @property {number} minimalDays
   * @property {number[]} weekend
   */
  /**
   * @return {WeekSettings|null}
   */
  static get defaultWeekSettings() {
    return defaultWeekSettings;
  }
  /**
   * Allows overriding the default locale week settings, i.e. the start of the week, the weekend and
   * how many days are required in the first week of a year.
   * Does not affect existing instances.
   *
   * @param {WeekSettings|null} weekSettings
   */
  static set defaultWeekSettings(weekSettings) {
    defaultWeekSettings = validateWeekSettings(weekSettings);
  }
  /**
   * Get the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
   * @type {number}
   */
  static get twoDigitCutoffYear() {
    return twoDigitCutoffYear;
  }
  /**
   * Set the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
   * @type {number}
   * @example Settings.twoDigitCutoffYear = 0 // cut-off year is 0, so all 'yy' are interpreted as current century
   * @example Settings.twoDigitCutoffYear = 50 // '49' -> 1949; '50' -> 2050
   * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50
   * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50
   */
  static set twoDigitCutoffYear(cutoffYear) {
    twoDigitCutoffYear = cutoffYear % 100;
  }
  /**
   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static get throwOnInvalid() {
    return throwOnInvalid;
  }
  /**
   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static set throwOnInvalid(t) {
    throwOnInvalid = t;
  }
  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCaches() {
    Locale.resetCache();
    IANAZone.resetCache();
  }
};

// ../../../node_modules/luxon/src/impl/invalid.js
var Invalid = class {
  constructor(reason, explanation) {
    this.reason = reason;
    this.explanation = explanation;
  }
  toMessage() {
    if (this.explanation) {
      return `${this.reason}: ${this.explanation}`;
    } else {
      return this.reason;
    }
  }
};

// ../../../node_modules/luxon/src/impl/conversions.js
var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function unitOutOfRange(unit, value) {
  return new Invalid(
    "unit out of range",
    `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`
  );
}
function dayOfWeek(year, month, day) {
  const d = new Date(Date.UTC(year, month - 1, day));
  if (year < 100 && year >= 0) {
    d.setUTCFullYear(d.getUTCFullYear() - 1900);
  }
  const js = d.getUTCDay();
  return js === 0 ? 7 : js;
}
function computeOrdinal(year, month, day) {
  return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
}
function uncomputeOrdinal(year, ordinal) {
  const table = isLeapYear(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex((i) => i < ordinal), day = ordinal - table[month0];
  return { month: month0 + 1, day };
}
function isoWeekdayToLocal(isoWeekday, startOfWeek) {
  return (isoWeekday - startOfWeek + 7) % 7 + 1;
}
function gregorianToWeek(gregObj, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const { year, month, day } = gregObj, ordinal = computeOrdinal(year, month, day), weekday = isoWeekdayToLocal(dayOfWeek(year, month, day), startOfWeek);
  let weekNumber = Math.floor((ordinal - weekday + 14 - minDaysInFirstWeek) / 7), weekYear;
  if (weekNumber < 1) {
    weekYear = year - 1;
    weekNumber = weeksInWeekYear(weekYear, minDaysInFirstWeek, startOfWeek);
  } else if (weekNumber > weeksInWeekYear(year, minDaysInFirstWeek, startOfWeek)) {
    weekYear = year + 1;
    weekNumber = 1;
  } else {
    weekYear = year;
  }
  return { weekYear, weekNumber, weekday, ...timeObject(gregObj) };
}
function weekToGregorian(weekData, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const { weekYear, weekNumber, weekday } = weekData, weekdayOfJan4 = isoWeekdayToLocal(dayOfWeek(weekYear, 1, minDaysInFirstWeek), startOfWeek), yearInDays = daysInYear(weekYear);
  let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 7 + minDaysInFirstWeek, year;
  if (ordinal < 1) {
    year = weekYear - 1;
    ordinal += daysInYear(year);
  } else if (ordinal > yearInDays) {
    year = weekYear + 1;
    ordinal -= daysInYear(weekYear);
  } else {
    year = weekYear;
  }
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return { year, month, day, ...timeObject(weekData) };
}
function gregorianToOrdinal(gregData) {
  const { year, month, day } = gregData;
  const ordinal = computeOrdinal(year, month, day);
  return { year, ordinal, ...timeObject(gregData) };
}
function ordinalToGregorian(ordinalData) {
  const { year, ordinal } = ordinalData;
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return { year, month, day, ...timeObject(ordinalData) };
}
function usesLocalWeekValues(obj, loc) {
  const hasLocaleWeekData = !isUndefined(obj.localWeekday) || !isUndefined(obj.localWeekNumber) || !isUndefined(obj.localWeekYear);
  if (hasLocaleWeekData) {
    const hasIsoWeekData = !isUndefined(obj.weekday) || !isUndefined(obj.weekNumber) || !isUndefined(obj.weekYear);
    if (hasIsoWeekData) {
      throw new ConflictingSpecificationError(
        "Cannot mix locale-based week fields with ISO-based week fields"
      );
    }
    if (!isUndefined(obj.localWeekday))
      obj.weekday = obj.localWeekday;
    if (!isUndefined(obj.localWeekNumber))
      obj.weekNumber = obj.localWeekNumber;
    if (!isUndefined(obj.localWeekYear))
      obj.weekYear = obj.localWeekYear;
    delete obj.localWeekday;
    delete obj.localWeekNumber;
    delete obj.localWeekYear;
    return {
      minDaysInFirstWeek: loc.getMinDaysInFirstWeek(),
      startOfWeek: loc.getStartOfWeek()
    };
  } else {
    return { minDaysInFirstWeek: 4, startOfWeek: 1 };
  }
}
function hasInvalidWeekData(obj, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const validYear = isInteger(obj.weekYear), validWeek = integerBetween(
    obj.weekNumber,
    1,
    weeksInWeekYear(obj.weekYear, minDaysInFirstWeek, startOfWeek)
  ), validWeekday = integerBetween(obj.weekday, 1, 7);
  if (!validYear) {
    return unitOutOfRange("weekYear", obj.weekYear);
  } else if (!validWeek) {
    return unitOutOfRange("week", obj.weekNumber);
  } else if (!validWeekday) {
    return unitOutOfRange("weekday", obj.weekday);
  } else
    return false;
}
function hasInvalidOrdinalData(obj) {
  const validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validOrdinal) {
    return unitOutOfRange("ordinal", obj.ordinal);
  } else
    return false;
}
function hasInvalidGregorianData(obj) {
  const validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validMonth) {
    return unitOutOfRange("month", obj.month);
  } else if (!validDay) {
    return unitOutOfRange("day", obj.day);
  } else
    return false;
}
function hasInvalidTimeData(obj) {
  const { hour, minute, second, millisecond } = obj;
  const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
  if (!validHour) {
    return unitOutOfRange("hour", hour);
  } else if (!validMinute) {
    return unitOutOfRange("minute", minute);
  } else if (!validSecond) {
    return unitOutOfRange("second", second);
  } else if (!validMillisecond) {
    return unitOutOfRange("millisecond", millisecond);
  } else
    return false;
}

// ../../../node_modules/luxon/src/impl/util.js
function isUndefined(o) {
  return typeof o === "undefined";
}
function isNumber3(o) {
  return typeof o === "number";
}
function isInteger(o) {
  return typeof o === "number" && o % 1 === 0;
}
function isString(o) {
  return typeof o === "string";
}
function isDate(o) {
  return Object.prototype.toString.call(o) === "[object Date]";
}
function hasRelative() {
  try {
    return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
  } catch (e) {
    return false;
  }
}
function hasLocaleWeekInfo() {
  try {
    return typeof Intl !== "undefined" && !!Intl.Locale && ("weekInfo" in Intl.Locale.prototype || "getWeekInfo" in Intl.Locale.prototype);
  } catch (e) {
    return false;
  }
}
function maybeArray(thing) {
  return Array.isArray(thing) ? thing : [thing];
}
function bestBy(arr, by, compare) {
  if (arr.length === 0) {
    return void 0;
  }
  return arr.reduce((best, next) => {
    const pair = [by(next), next];
    if (!best) {
      return pair;
    } else if (compare(best[0], pair[0]) === best[0]) {
      return best;
    } else {
      return pair;
    }
  }, null)[1];
}
function pick(obj, keys) {
  return keys.reduce((a, k) => {
    a[k] = obj[k];
    return a;
  }, {});
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function validateWeekSettings(settings) {
  if (settings == null) {
    return null;
  } else if (typeof settings !== "object") {
    throw new InvalidArgumentError("Week settings must be an object");
  } else {
    if (!integerBetween(settings.firstDay, 1, 7) || !integerBetween(settings.minimalDays, 1, 7) || !Array.isArray(settings.weekend) || settings.weekend.some((v) => !integerBetween(v, 1, 7))) {
      throw new InvalidArgumentError("Invalid week settings");
    }
    return {
      firstDay: settings.firstDay,
      minimalDays: settings.minimalDays,
      weekend: Array.from(settings.weekend)
    };
  }
}
function integerBetween(thing, bottom, top) {
  return isInteger(thing) && thing >= bottom && thing <= top;
}
function floorMod(x, n2) {
  return x - n2 * Math.floor(x / n2);
}
function padStart(input, n2 = 2) {
  const isNeg = input < 0;
  let padded;
  if (isNeg) {
    padded = "-" + ("" + -input).padStart(n2, "0");
  } else {
    padded = ("" + input).padStart(n2, "0");
  }
  return padded;
}
function parseInteger(string) {
  if (isUndefined(string) || string === null || string === "") {
    return void 0;
  } else {
    return parseInt(string, 10);
  }
}
function parseFloating(string) {
  if (isUndefined(string) || string === null || string === "") {
    return void 0;
  } else {
    return parseFloat(string);
  }
}
function parseMillis(fraction) {
  if (isUndefined(fraction) || fraction === null || fraction === "") {
    return void 0;
  } else {
    const f = parseFloat("0." + fraction) * 1e3;
    return Math.floor(f);
  }
}
function roundTo(number, digits, towardZero = false) {
  const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;
  return rounder(number * factor) / factor;
}
function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
function daysInMonth(year, month) {
  const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
  if (modMonth === 2) {
    return isLeapYear(modYear) ? 29 : 28;
  } else {
    return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
  }
}
function objToLocalTS(obj) {
  let d = Date.UTC(
    obj.year,
    obj.month - 1,
    obj.day,
    obj.hour,
    obj.minute,
    obj.second,
    obj.millisecond
  );
  if (obj.year < 100 && obj.year >= 0) {
    d = new Date(d);
    d.setUTCFullYear(obj.year, obj.month - 1, obj.day);
  }
  return +d;
}
function firstWeekOffset(year, minDaysInFirstWeek, startOfWeek) {
  const fwdlw = isoWeekdayToLocal(dayOfWeek(year, 1, minDaysInFirstWeek), startOfWeek);
  return -fwdlw + minDaysInFirstWeek - 1;
}
function weeksInWeekYear(weekYear, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const weekOffset = firstWeekOffset(weekYear, minDaysInFirstWeek, startOfWeek);
  const weekOffsetNext = firstWeekOffset(weekYear + 1, minDaysInFirstWeek, startOfWeek);
  return (daysInYear(weekYear) - weekOffset + weekOffsetNext) / 7;
}
function untruncateYear(year) {
  if (year > 99) {
    return year;
  } else
    return year > Settings.twoDigitCutoffYear ? 1900 + year : 2e3 + year;
}
function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {
  const date = new Date(ts), intlOpts = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  if (timeZone) {
    intlOpts.timeZone = timeZone;
  }
  const modified = { timeZoneName: offsetFormat, ...intlOpts };
  const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find((m) => m.type.toLowerCase() === "timezonename");
  return parsed ? parsed.value : null;
}
function signedOffset(offHourStr, offMinuteStr) {
  let offHour = parseInt(offHourStr, 10);
  if (Number.isNaN(offHour)) {
    offHour = 0;
  }
  const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
  return offHour * 60 + offMinSigned;
}
function asNumber(value) {
  const numericValue = Number(value);
  if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
    throw new InvalidArgumentError(`Invalid unit value ${value}`);
  return numericValue;
}
function normalizeObject(obj, normalizer) {
  const normalized = {};
  for (const u in obj) {
    if (hasOwnProperty(obj, u)) {
      const v = obj[u];
      if (v === void 0 || v === null)
        continue;
      normalized[normalizer(u)] = asNumber(v);
    }
  }
  return normalized;
}
function formatOffset(offset2, format) {
  const hours = Math.trunc(Math.abs(offset2 / 60)), minutes = Math.trunc(Math.abs(offset2 % 60)), sign3 = offset2 >= 0 ? "+" : "-";
  switch (format) {
    case "short":
      return `${sign3}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
    case "narrow":
      return `${sign3}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
    case "techie":
      return `${sign3}${padStart(hours, 2)}${padStart(minutes, 2)}`;
    default:
      throw new RangeError(`Value format ${format} is out of range for property format`);
  }
}
function timeObject(obj) {
  return pick(obj, ["hour", "minute", "second", "millisecond"]);
}

// ../../../node_modules/luxon/src/impl/english.js
var monthsLong = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
var monthsShort = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function months(length) {
  switch (length) {
    case "narrow":
      return [...monthsNarrow];
    case "short":
      return [...monthsShort];
    case "long":
      return [...monthsLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
var weekdaysLong = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
];
var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
function weekdays(length) {
  switch (length) {
    case "narrow":
      return [...weekdaysNarrow];
    case "short":
      return [...weekdaysShort];
    case "long":
      return [...weekdaysLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
var meridiems = ["AM", "PM"];
var erasLong = ["Before Christ", "Anno Domini"];
var erasShort = ["BC", "AD"];
var erasNarrow = ["B", "A"];
function eras(length) {
  switch (length) {
    case "narrow":
      return [...erasNarrow];
    case "short":
      return [...erasShort];
    case "long":
      return [...erasLong];
    default:
      return null;
  }
}
function meridiemForDateTime(dt) {
  return meridiems[dt.hour < 12 ? 0 : 1];
}
function weekdayForDateTime(dt, length) {
  return weekdays(length)[dt.weekday - 1];
}
function monthForDateTime(dt, length) {
  return months(length)[dt.month - 1];
}
function eraForDateTime(dt, length) {
  return eras(length)[dt.year < 0 ? 0 : 1];
}
function formatRelativeTime(unit, count, numeric = "always", narrow = false) {
  const units = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  };
  const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
  if (numeric === "auto" && lastable) {
    const isDay = unit === "days";
    switch (count) {
      case 1:
        return isDay ? "tomorrow" : `next ${units[unit][0]}`;
      case -1:
        return isDay ? "yesterday" : `last ${units[unit][0]}`;
      case 0:
        return isDay ? "today" : `this ${units[unit][0]}`;
      default:
    }
  }
  const isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
  return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
}

// ../../../node_modules/luxon/src/impl/formatter.js
function stringifyTokens(splits, tokenToString) {
  let s2 = "";
  for (const token of splits) {
    if (token.literal) {
      s2 += token.val;
    } else {
      s2 += tokenToString(token.val);
    }
  }
  return s2;
}
var macroTokenToFormatOpts = {
  D: DATE_SHORT,
  DD: DATE_MED,
  DDD: DATE_FULL,
  DDDD: DATE_HUGE,
  t: TIME_SIMPLE,
  tt: TIME_WITH_SECONDS,
  ttt: TIME_WITH_SHORT_OFFSET,
  tttt: TIME_WITH_LONG_OFFSET,
  T: TIME_24_SIMPLE,
  TT: TIME_24_WITH_SECONDS,
  TTT: TIME_24_WITH_SHORT_OFFSET,
  TTTT: TIME_24_WITH_LONG_OFFSET,
  f: DATETIME_SHORT,
  ff: DATETIME_MED,
  fff: DATETIME_FULL,
  ffff: DATETIME_HUGE,
  F: DATETIME_SHORT_WITH_SECONDS,
  FF: DATETIME_MED_WITH_SECONDS,
  FFF: DATETIME_FULL_WITH_SECONDS,
  FFFF: DATETIME_HUGE_WITH_SECONDS
};
var Formatter = class {
  static create(locale, opts = {}) {
    return new Formatter(locale, opts);
  }
  static parseFormat(fmt) {
    let current = null, currentFull = "", bracketed = false;
    const splits = [];
    for (let i = 0; i < fmt.length; i++) {
      const c = fmt.charAt(i);
      if (c === "'") {
        if (currentFull.length > 0) {
          splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
        }
        current = null;
        currentFull = "";
        bracketed = !bracketed;
      } else if (bracketed) {
        currentFull += c;
      } else if (c === current) {
        currentFull += c;
      } else {
        if (currentFull.length > 0) {
          splits.push({ literal: /^\s+$/.test(currentFull), val: currentFull });
        }
        currentFull = c;
        current = c;
      }
    }
    if (currentFull.length > 0) {
      splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
    }
    return splits;
  }
  static macroTokenToFormatOpts(token) {
    return macroTokenToFormatOpts[token];
  }
  constructor(locale, formatOpts) {
    this.opts = formatOpts;
    this.loc = locale;
    this.systemLoc = null;
  }
  formatWithSystemDefault(dt, opts) {
    if (this.systemLoc === null) {
      this.systemLoc = this.loc.redefaultToSystem();
    }
    const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.format();
  }
  dtFormatter(dt, opts = {}) {
    return this.loc.dtFormatter(dt, { ...this.opts, ...opts });
  }
  formatDateTime(dt, opts) {
    return this.dtFormatter(dt, opts).format();
  }
  formatDateTimeParts(dt, opts) {
    return this.dtFormatter(dt, opts).formatToParts();
  }
  formatInterval(interval, opts) {
    const df = this.dtFormatter(interval.start, opts);
    return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
  }
  resolvedOptions(dt, opts) {
    return this.dtFormatter(dt, opts).resolvedOptions();
  }
  num(n2, p = 0) {
    if (this.opts.forceSimple) {
      return padStart(n2, p);
    }
    const opts = { ...this.opts };
    if (p > 0) {
      opts.padTo = p;
    }
    return this.loc.numberFormatter(opts).format(n2);
  }
  formatDateTimeFromString(dt, fmt) {
    const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string = (opts, extract) => this.loc.extract(dt, opts, extract), formatOffset2 = (opts) => {
      if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
        return "Z";
      }
      return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
    }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), month = (length, standalone) => knownEnglish ? monthForDateTime(dt, length) : string(standalone ? { month: length } : { month: length, day: "numeric" }, "month"), weekday = (length, standalone) => knownEnglish ? weekdayForDateTime(dt, length) : string(
      standalone ? { weekday: length } : { weekday: length, month: "long", day: "numeric" },
      "weekday"
    ), maybeMacro = (token) => {
      const formatOpts = Formatter.macroTokenToFormatOpts(token);
      if (formatOpts) {
        return this.formatWithSystemDefault(dt, formatOpts);
      } else {
        return token;
      }
    }, era = (length) => knownEnglish ? eraForDateTime(dt, length) : string({ era: length }, "era"), tokenToString = (token) => {
      switch (token) {
        case "S":
          return this.num(dt.millisecond);
        case "u":
        case "SSS":
          return this.num(dt.millisecond, 3);
        case "s":
          return this.num(dt.second);
        case "ss":
          return this.num(dt.second, 2);
        case "uu":
          return this.num(Math.floor(dt.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(dt.millisecond / 100));
        case "m":
          return this.num(dt.minute);
        case "mm":
          return this.num(dt.minute, 2);
        case "h":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
        case "hh":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
        case "H":
          return this.num(dt.hour);
        case "HH":
          return this.num(dt.hour, 2);
        case "Z":
          return formatOffset2({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return formatOffset2({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return formatOffset2({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
        case "z":
          return dt.zoneName;
        case "a":
          return meridiem();
        case "d":
          return useDateTimeFormatter ? string({ day: "numeric" }, "day") : this.num(dt.day);
        case "dd":
          return useDateTimeFormatter ? string({ day: "2-digit" }, "day") : this.num(dt.day, 2);
        case "c":
          return this.num(dt.weekday);
        case "ccc":
          return weekday("short", true);
        case "cccc":
          return weekday("long", true);
        case "ccccc":
          return weekday("narrow", true);
        case "E":
          return this.num(dt.weekday);
        case "EEE":
          return weekday("short", false);
        case "EEEE":
          return weekday("long", false);
        case "EEEEE":
          return weekday("narrow", false);
        case "L":
          return useDateTimeFormatter ? string({ month: "numeric", day: "numeric" }, "month") : this.num(dt.month);
        case "LL":
          return useDateTimeFormatter ? string({ month: "2-digit", day: "numeric" }, "month") : this.num(dt.month, 2);
        case "LLL":
          return month("short", true);
        case "LLLL":
          return month("long", true);
        case "LLLLL":
          return month("narrow", true);
        case "M":
          return useDateTimeFormatter ? string({ month: "numeric" }, "month") : this.num(dt.month);
        case "MM":
          return useDateTimeFormatter ? string({ month: "2-digit" }, "month") : this.num(dt.month, 2);
        case "MMM":
          return month("short", false);
        case "MMMM":
          return month("long", false);
        case "MMMMM":
          return month("narrow", false);
        case "y":
          return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year);
        case "yy":
          return useDateTimeFormatter ? string({ year: "2-digit" }, "year") : this.num(dt.year.toString().slice(-2), 2);
        case "yyyy":
          return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 4);
        case "yyyyyy":
          return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 6);
        case "G":
          return era("short");
        case "GG":
          return era("long");
        case "GGGGG":
          return era("narrow");
        case "kk":
          return this.num(dt.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(dt.weekYear, 4);
        case "W":
          return this.num(dt.weekNumber);
        case "WW":
          return this.num(dt.weekNumber, 2);
        case "n":
          return this.num(dt.localWeekNumber);
        case "nn":
          return this.num(dt.localWeekNumber, 2);
        case "ii":
          return this.num(dt.localWeekYear.toString().slice(-2), 2);
        case "iiii":
          return this.num(dt.localWeekYear, 4);
        case "o":
          return this.num(dt.ordinal);
        case "ooo":
          return this.num(dt.ordinal, 3);
        case "q":
          return this.num(dt.quarter);
        case "qq":
          return this.num(dt.quarter, 2);
        case "X":
          return this.num(Math.floor(dt.ts / 1e3));
        case "x":
          return this.num(dt.ts);
        default:
          return maybeMacro(token);
      }
    };
    return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);
  }
  formatDurationFromString(dur, fmt) {
    const tokenToField = (token) => {
      switch (token[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, tokenToString = (lildur) => (token) => {
      const mapped = tokenToField(token);
      if (mapped) {
        return this.num(lildur.get(mapped), token.length);
      } else {
        return token;
      }
    }, tokens = Formatter.parseFormat(fmt), realTokens = tokens.reduce(
      (found, { literal, val }) => literal ? found : found.concat(val),
      []
    ), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t) => t));
    return stringifyTokens(tokens, tokenToString(collapsed));
  }
};

// ../../../node_modules/luxon/src/impl/regexParser.js
var ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function combineRegexes(...regexes) {
  const full = regexes.reduce((f, r) => f + r.source, "");
  return RegExp(`^${full}$`);
}
function combineExtractors(...extractors) {
  return (m) => extractors.reduce(
    ([mergedVals, mergedZone, cursor], ex) => {
      const [val, zone, next] = ex(m, cursor);
      return [{ ...mergedVals, ...val }, zone || mergedZone, next];
    },
    [{}, null, 1]
  ).slice(0, 2);
}
function parse3(s2, ...patterns) {
  if (s2 == null) {
    return [null, null];
  }
  for (const [regex, extractor] of patterns) {
    const m = regex.exec(s2);
    if (m) {
      return extractor(m);
    }
  }
  return [null, null];
}
function simpleParse(...keys) {
  return (match2, cursor) => {
    const ret = {};
    let i;
    for (i = 0; i < keys.length; i++) {
      ret[keys[i]] = parseInteger(match2[cursor + i]);
    }
    return [ret, null, cursor + i];
  };
}
var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
var isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
var isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
var isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
var extractISOOrdinalData = simpleParse("year", "ordinal");
var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
var sqlTimeRegex = RegExp(
  `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`
);
var sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
function int(match2, pos, fallback) {
  const m = match2[pos];
  return isUndefined(m) ? fallback : parseInteger(m);
}
function extractISOYmd(match2, cursor) {
  const item = {
    year: int(match2, cursor),
    month: int(match2, cursor + 1, 1),
    day: int(match2, cursor + 2, 1)
  };
  return [item, null, cursor + 3];
}
function extractISOTime(match2, cursor) {
  const item = {
    hours: int(match2, cursor, 0),
    minutes: int(match2, cursor + 1, 0),
    seconds: int(match2, cursor + 2, 0),
    milliseconds: parseMillis(match2[cursor + 3])
  };
  return [item, null, cursor + 4];
}
function extractISOOffset(match2, cursor) {
  const local = !match2[cursor] && !match2[cursor + 1], fullOffset = signedOffset(match2[cursor + 1], match2[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
  return [{}, zone, cursor + 3];
}
function extractIANAZone(match2, cursor) {
  const zone = match2[cursor] ? IANAZone.create(match2[cursor]) : null;
  return [{}, zone, cursor + 1];
}
var isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);
var isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function extractISODuration(match2) {
  const [s2, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match2;
  const hasNegativePrefix = s2[0] === "-";
  const negativeSeconds = secondStr && secondStr[0] === "-";
  const maybeNegate = (num, force = false) => num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
  return [
    {
      years: maybeNegate(parseFloating(yearStr)),
      months: maybeNegate(parseFloating(monthStr)),
      weeks: maybeNegate(parseFloating(weekStr)),
      days: maybeNegate(parseFloating(dayStr)),
      hours: maybeNegate(parseFloating(hourStr)),
      minutes: maybeNegate(parseFloating(minuteStr)),
      seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
      milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
    }
  ];
}
var obsOffsets = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  const result = {
    year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
    month: monthsShort.indexOf(monthStr) + 1,
    day: parseInteger(dayStr),
    hour: parseInteger(hourStr),
    minute: parseInteger(minuteStr)
  };
  if (secondStr)
    result.second = parseInteger(secondStr);
  if (weekdayStr) {
    result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
  }
  return result;
}
var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function extractRFC2822(match2) {
  const [
    ,
    weekdayStr,
    dayStr,
    monthStr,
    yearStr,
    hourStr,
    minuteStr,
    secondStr,
    obsOffset,
    milOffset,
    offHourStr,
    offMinuteStr
  ] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  let offset2;
  if (obsOffset) {
    offset2 = obsOffsets[obsOffset];
  } else if (milOffset) {
    offset2 = 0;
  } else {
    offset2 = signedOffset(offHourStr, offMinuteStr);
  }
  return [result, new FixedOffsetZone(offset2)];
}
function preprocessRFC2822(s2) {
  return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
var rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function extractRFC1123Or850(match2) {
  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
function extractASCII(match2) {
  const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
var extractISOYmdTimeAndOffset = combineExtractors(
  extractISOYmd,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
var extractISOWeekTimeAndOffset = combineExtractors(
  extractISOWeekData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
var extractISOOrdinalDateAndTime = combineExtractors(
  extractISOOrdinalData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
var extractISOTimeAndOffset = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
function parseISODate(s2) {
  return parse3(
    s2,
    [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],
    [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],
    [isoTimeCombinedRegex, extractISOTimeAndOffset]
  );
}
function parseRFC2822Date(s2) {
  return parse3(preprocessRFC2822(s2), [rfc2822, extractRFC2822]);
}
function parseHTTPDate(s2) {
  return parse3(
    s2,
    [rfc1123, extractRFC1123Or850],
    [rfc850, extractRFC1123Or850],
    [ascii, extractASCII]
  );
}
function parseISODuration(s2) {
  return parse3(s2, [isoDuration, extractISODuration]);
}
var extractISOTimeOnly = combineExtractors(extractISOTime);
function parseISOTimeOnly(s2) {
  return parse3(s2, [isoTimeOnly, extractISOTimeOnly]);
}
var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
var extractISOTimeOffsetAndIANAZone = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
function parseSQL(s2) {
  return parse3(
    s2,
    [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]
  );
}

// ../../../node_modules/luxon/src/duration.js
var INVALID = "Invalid Duration";
var lowOrderMatrix = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
};
var casualMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  },
  ...lowOrderMatrix
};
var daysInYearAccurate = 146097 / 400;
var daysInMonthAccurate = 146097 / 4800;
var accurateMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: daysInYearAccurate / 7,
    days: daysInYearAccurate,
    hours: daysInYearAccurate * 24,
    minutes: daysInYearAccurate * 24 * 60,
    seconds: daysInYearAccurate * 24 * 60 * 60,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: daysInYearAccurate / 28,
    days: daysInYearAccurate / 4,
    hours: daysInYearAccurate * 24 / 4,
    minutes: daysInYearAccurate * 24 * 60 / 4,
    seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: daysInMonthAccurate / 7,
    days: daysInMonthAccurate,
    hours: daysInMonthAccurate * 24,
    minutes: daysInMonthAccurate * 24 * 60,
    seconds: daysInMonthAccurate * 24 * 60 * 60,
    milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
  },
  ...lowOrderMatrix
};
var orderedUnits = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
];
var reverseUnits = orderedUnits.slice(0).reverse();
function clone5(dur, alts, clear = false) {
  const conf = {
    values: clear ? alts.values : { ...dur.values, ...alts.values || {} },
    loc: dur.loc.clone(alts.loc),
    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
    matrix: alts.matrix || dur.matrix
  };
  return new Duration(conf);
}
function durationToMillis(matrix, vals) {
  let sum = vals.milliseconds ?? 0;
  for (const unit of reverseUnits.slice(1)) {
    if (vals[unit]) {
      sum += vals[unit] * matrix[unit]["milliseconds"];
    }
  }
  return sum;
}
function normalizeValues(matrix, vals) {
  const factor = durationToMillis(matrix, vals) < 0 ? -1 : 1;
  orderedUnits.reduceRight((previous, current) => {
    if (!isUndefined(vals[current])) {
      if (previous) {
        const previousVal = vals[previous] * factor;
        const conv = matrix[current][previous];
        const rollUp = Math.floor(previousVal / conv);
        vals[current] += rollUp * factor;
        vals[previous] -= rollUp * conv * factor;
      }
      return current;
    } else {
      return previous;
    }
  }, null);
  orderedUnits.reduce((previous, current) => {
    if (!isUndefined(vals[current])) {
      if (previous) {
        const fraction = vals[previous] % 1;
        vals[previous] -= fraction;
        vals[current] += fraction * matrix[previous][current];
      }
      return current;
    } else {
      return previous;
    }
  }, null);
}
function removeZeroes(vals) {
  const newVals = {};
  for (const [key, value] of Object.entries(vals)) {
    if (value !== 0) {
      newVals[key] = value;
    }
  }
  return newVals;
}
var Duration = class {
  /**
   * @private
   */
  constructor(config) {
    const accurate = config.conversionAccuracy === "longterm" || false;
    let matrix = accurate ? accurateMatrix : casualMatrix;
    if (config.matrix) {
      matrix = config.matrix;
    }
    this.values = config.values;
    this.loc = config.loc || Locale.create();
    this.conversionAccuracy = accurate ? "longterm" : "casual";
    this.invalid = config.invalid || null;
    this.matrix = matrix;
    this.isLuxonDuration = true;
  }
  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromMillis(count, opts) {
    return Duration.fromObject({ milliseconds: count }, opts);
  }
  /**
   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {Object} [opts=[]] - options for creating this Duration
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the custom conversion system to use
   * @return {Duration}
   */
  static fromObject(obj, opts = {}) {
    if (obj == null || typeof obj !== "object") {
      throw new InvalidArgumentError(
        `Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`
      );
    }
    return new Duration({
      values: normalizeObject(obj, Duration.normalizeUnit),
      loc: Locale.fromObject(opts),
      conversionAccuracy: opts.conversionAccuracy,
      matrix: opts.matrix
    });
  }
  /**
   * Create a Duration from DurationLike.
   *
   * @param {Object | number | Duration} durationLike
   * One of:
   * - object with keys like 'years' and 'hours'.
   * - number representing milliseconds
   * - Duration instance
   * @return {Duration}
   */
  static fromDurationLike(durationLike) {
    if (isNumber3(durationLike)) {
      return Duration.fromMillis(durationLike);
    } else if (Duration.isDuration(durationLike)) {
      return durationLike;
    } else if (typeof durationLike === "object") {
      return Duration.fromObject(durationLike);
    } else {
      throw new InvalidArgumentError(
        `Unknown duration argument ${durationLike} of type ${typeof durationLike}`
      );
    }
  }
  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the preset conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  static fromISO(text, opts) {
    const [parsed] = parseISODuration(text);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
  }
  /**
   * Create a Duration from an ISO 8601 time string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @return {Duration}
   */
  static fromISOTime(text, opts) {
    const [parsed] = parseISOTimeOnly(text);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
  }
  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDurationError(invalid);
    } else {
      return new Duration({ invalid });
    }
  }
  /**
   * @private
   */
  static normalizeUnit(unit) {
    const normalized = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[unit ? unit.toLowerCase() : unit];
    if (!normalized)
      throw new InvalidUnitError(unit);
    return normalized;
  }
  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDuration(o) {
    return o && o.isLuxonDuration || false;
  }
  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `w` for weeks
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * Tokens can be escaped by wrapping with single quotes.
   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    const fmtOpts = {
      ...opts,
      floor: opts.round !== false && opts.floor !== false
    };
    return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID;
  }
  /**
   * Returns a string representation of a Duration with all units included.
   * To modify its behavior, use `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#options
   * @param {Object} opts - Formatting options. Accepts the same keys as the options parameter of the native `Intl.NumberFormat` constructor, as well as `listStyle`.
   * @param {string} [opts.listStyle='narrow'] - How to format the merged list. Corresponds to the `style` property of the options parameter of the native `Intl.ListFormat` constructor.
   * @example
   * ```js
   * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
   * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
   * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
   * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
   * ```
   */
  toHuman(opts = {}) {
    if (!this.isValid)
      return INVALID;
    const l2 = orderedUnits.map((unit) => {
      const val = this.values[unit];
      if (isUndefined(val)) {
        return null;
      }
      return this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...opts, unit: unit.slice(0, -1) }).format(val);
    }).filter((n2) => n2);
    return this.loc.listFormatter({ type: "conjunction", style: opts.listStyle || "narrow", ...opts }).format(l2);
  }
  /**
   * Returns a JavaScript object with this Duration's values.
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  toObject() {
    if (!this.isValid)
      return {};
    return { ...this.values };
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  toISO() {
    if (!this.isValid)
      return null;
    let s2 = "P";
    if (this.years !== 0)
      s2 += this.years + "Y";
    if (this.months !== 0 || this.quarters !== 0)
      s2 += this.months + this.quarters * 3 + "M";
    if (this.weeks !== 0)
      s2 += this.weeks + "W";
    if (this.days !== 0)
      s2 += this.days + "D";
    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
      s2 += "T";
    if (this.hours !== 0)
      s2 += this.hours + "H";
    if (this.minutes !== 0)
      s2 += this.minutes + "M";
    if (this.seconds !== 0 || this.milliseconds !== 0)
      s2 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
    if (s2 === "P")
      s2 += "T0S";
    return s2;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
   * @return {string}
   */
  toISOTime(opts = {}) {
    if (!this.isValid)
      return null;
    const millis = this.toMillis();
    if (millis < 0 || millis >= 864e5)
      return null;
    opts = {
      suppressMilliseconds: false,
      suppressSeconds: false,
      includePrefix: false,
      format: "extended",
      ...opts,
      includeOffset: false
    };
    const dateTime = DateTime.fromMillis(millis, { zone: "UTC" });
    return dateTime.toISOTime(opts);
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  toString() {
    return this.toISO();
  }
  /**
   * Returns a string representation of this Duration appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `Duration { values: ${JSON.stringify(this.values)} }`;
    } else {
      return `Duration { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  toMillis() {
    if (!this.isValid)
      return NaN;
    return durationToMillis(this.matrix, this.values);
  }
  /**
   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  plus(duration) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration), result = {};
    for (const k of orderedUnits) {
      if (hasOwnProperty(dur.values, k) || hasOwnProperty(this.values, k)) {
        result[k] = dur.get(k) + this.get(k);
      }
    }
    return clone5(this, { values: result }, true);
  }
  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  minus(duration) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration);
    return this.plus(dur.negate());
  }
  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  mapUnits(fn) {
    if (!this.isValid)
      return this;
    const result = {};
    for (const k of Object.keys(this.values)) {
      result[k] = asNumber(fn(this.values[k], k));
    }
    return clone5(this, { values: result }, true);
  }
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
   * @return {number}
   */
  get(unit) {
    return this[Duration.normalizeUnit(unit)];
  }
  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  set(values) {
    if (!this.isValid)
      return this;
    const mixed = { ...this.values, ...normalizeObject(values, Duration.normalizeUnit) };
    return clone5(this, { values: mixed });
  }
  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  reconfigure({ locale, numberingSystem, conversionAccuracy, matrix } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem });
    const opts = { loc, matrix, conversionAccuracy };
    return clone5(this, opts);
  }
  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  as(unit) {
    return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
  }
  /**
   * Reduce this Duration to its canonical representation in its current units.
   * Assuming the overall value of the Duration is positive, this means:
   * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)
   * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise
   *   the overall value would be negative, see third example)
   * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)
   *
   * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }
   * @return {Duration}
   */
  normalize() {
    if (!this.isValid)
      return this;
    const vals = this.toObject();
    normalizeValues(this.matrix, vals);
    return clone5(this, { values: vals }, true);
  }
  /**
   * Rescale units to its largest representation
   * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
   * @return {Duration}
   */
  rescale() {
    if (!this.isValid)
      return this;
    const vals = removeZeroes(this.normalize().shiftToAll().toObject());
    return clone5(this, { values: vals }, true);
  }
  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  shiftTo(...units) {
    if (!this.isValid)
      return this;
    if (units.length === 0) {
      return this;
    }
    units = units.map((u) => Duration.normalizeUnit(u));
    const built = {}, accumulated = {}, vals = this.toObject();
    let lastUnit;
    for (const k of orderedUnits) {
      if (units.indexOf(k) >= 0) {
        lastUnit = k;
        let own = 0;
        for (const ak in accumulated) {
          own += this.matrix[ak][k] * accumulated[ak];
          accumulated[ak] = 0;
        }
        if (isNumber3(vals[k])) {
          own += vals[k];
        }
        const i = Math.trunc(own);
        built[k] = i;
        accumulated[k] = (own * 1e3 - i * 1e3) / 1e3;
      } else if (isNumber3(vals[k])) {
        accumulated[k] = vals[k];
      }
    }
    for (const key in accumulated) {
      if (accumulated[key] !== 0) {
        built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
      }
    }
    normalizeValues(this.matrix, built);
    return clone5(this, { values: built }, true);
  }
  /**
   * Shift this Duration to all available units.
   * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
   * @return {Duration}
   */
  shiftToAll() {
    if (!this.isValid)
      return this;
    return this.shiftTo(
      "years",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    );
  }
  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  negate() {
    if (!this.isValid)
      return this;
    const negated = {};
    for (const k of Object.keys(this.values)) {
      negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
    }
    return clone5(this, { values: negated }, true);
  }
  /**
   * Get the years.
   * @type {number}
   */
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  /**
   * Get the quarters.
   * @type {number}
   */
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  /**
   * Get the months.
   * @type {number}
   */
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  /**
   * Get the weeks
   * @type {number}
   */
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  /**
   * Get the days.
   * @type {number}
   */
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  /**
   * Get the hours.
   * @type {number}
   */
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  /**
   * Get the minutes.
   * @type {number}
   */
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  /**
   * Get the seconds.
   * @return {number}
   */
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  /**
   * Get the milliseconds.
   * @return {number}
   */
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    if (!this.loc.equals(other.loc)) {
      return false;
    }
    function eq3(v1, v2) {
      if (v1 === void 0 || v1 === 0)
        return v2 === void 0 || v2 === 0;
      return v1 === v2;
    }
    for (const u of orderedUnits) {
      if (!eq3(this.values[u], other.values[u])) {
        return false;
      }
    }
    return true;
  }
};

// ../../../node_modules/luxon/src/interval.js
var INVALID2 = "Invalid Interval";
function validateStartEnd(start, end) {
  if (!start || !start.isValid) {
    return Interval.invalid("missing or invalid start");
  } else if (!end || !end.isValid) {
    return Interval.invalid("missing or invalid end");
  } else if (end < start) {
    return Interval.invalid(
      "end before start",
      `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`
    );
  } else {
    return null;
  }
}
var Interval = class {
  /**
   * @private
   */
  constructor(config) {
    this.s = config.start;
    this.e = config.end;
    this.invalid = config.invalid || null;
    this.isLuxonInterval = true;
  }
  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidIntervalError(invalid);
    } else {
      return new Interval({ invalid });
    }
  }
  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */
  static fromDateTimes(start, end) {
    const builtStart = friendlyDateTime(start), builtEnd = friendlyDateTime(end);
    const validateError = validateStartEnd(builtStart, builtEnd);
    if (validateError == null) {
      return new Interval({
        start: builtStart,
        end: builtEnd
      });
    } else {
      return validateError;
    }
  }
  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static after(start, duration) {
    const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(start);
    return Interval.fromDateTimes(dt, dt.plus(dur));
  }
  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static before(end, duration) {
    const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(end);
    return Interval.fromDateTimes(dt.minus(dur), dt);
  }
  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */
  static fromISO(text, opts) {
    const [s2, e] = (text || "").split("/", 2);
    if (s2 && e) {
      let start, startIsValid;
      try {
        start = DateTime.fromISO(s2, opts);
        startIsValid = start.isValid;
      } catch (e2) {
        startIsValid = false;
      }
      let end, endIsValid;
      try {
        end = DateTime.fromISO(e, opts);
        endIsValid = end.isValid;
      } catch (e2) {
        endIsValid = false;
      }
      if (startIsValid && endIsValid) {
        return Interval.fromDateTimes(start, end);
      }
      if (startIsValid) {
        const dur = Duration.fromISO(e, opts);
        if (dur.isValid) {
          return Interval.after(start, dur);
        }
      } else if (endIsValid) {
        const dur = Duration.fromISO(s2, opts);
        if (dur.isValid) {
          return Interval.before(end, dur);
        }
      }
    }
    return Interval.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
  }
  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isInterval(o) {
    return o && o.isLuxonInterval || false;
  }
  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */
  get start() {
    return this.isValid ? this.s : null;
  }
  /**
   * Returns the end of the Interval
   * @type {DateTime}
   */
  get end() {
    return this.isValid ? this.e : null;
  }
  /**
   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
   * @type {boolean}
   */
  get isValid() {
    return this.invalidReason === null;
  }
  /**
   * Returns an error code if this Interval is invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */
  length(unit = "milliseconds") {
    return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
  }
  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; this operation will always use the locale of the start DateTime
   * @return {number}
   */
  count(unit = "milliseconds", opts) {
    if (!this.isValid)
      return NaN;
    const start = this.start.startOf(unit, opts);
    let end;
    if (opts?.useLocaleWeeks) {
      end = this.end.reconfigure({ locale: start.locale });
    } else {
      end = this.end;
    }
    end = end.startOf(unit, opts);
    return Math.floor(end.diff(start, unit).get(unit)) + (end.valueOf() !== this.end.valueOf());
  }
  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */
  hasSame(unit) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
  }
  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isAfter(dateTime) {
    if (!this.isValid)
      return false;
    return this.s > dateTime;
  }
  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isBefore(dateTime) {
    if (!this.isValid)
      return false;
    return this.e <= dateTime;
  }
  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  contains(dateTime) {
    if (!this.isValid)
      return false;
    return this.s <= dateTime && this.e > dateTime;
  }
  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */
  set({ start, end } = {}) {
    if (!this.isValid)
      return this;
    return Interval.fromDateTimes(start || this.s, end || this.e);
  }
  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...DateTime} dateTimes - the unit of time to count.
   * @return {Array}
   */
  splitAt(...dateTimes) {
    if (!this.isValid)
      return [];
    const sorted = dateTimes.map(friendlyDateTime).filter((d) => this.contains(d)).sort((a, b) => a.toMillis() - b.toMillis()), results = [];
    let { s: s2 } = this, i = 0;
    while (s2 < this.e) {
      const added = sorted[i] || this.e, next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s2, next));
      s2 = next;
      i += 1;
    }
    return results;
  }
  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {Array}
   */
  splitBy(duration) {
    const dur = Duration.fromDurationLike(duration);
    if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
      return [];
    }
    let { s: s2 } = this, idx = 1, next;
    const results = [];
    while (s2 < this.e) {
      const added = this.start.plus(dur.mapUnits((x) => x * idx));
      next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s2, next));
      s2 = next;
      idx += 1;
    }
    return results;
  }
  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {Array}
   */
  divideEqually(numberOfParts) {
    if (!this.isValid)
      return [];
    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
  }
  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */
  overlaps(other) {
    return this.e > other.s && this.s < other.e;
  }
  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsStart(other) {
    if (!this.isValid)
      return false;
    return +this.e === +other.s;
  }
  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsEnd(other) {
    if (!this.isValid)
      return false;
    return +other.e === +this.s;
  }
  /**
   * Return whether this Interval engulfs the start and end of the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  engulfs(other) {
    if (!this.isValid)
      return false;
    return this.s <= other.s && this.e >= other.e;
  }
  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    return this.s.equals(other.s) && this.e.equals(other.e);
  }
  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, meaning, the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */
  intersection(other) {
    if (!this.isValid)
      return this;
    const s2 = this.s > other.s ? this.s : other.s, e = this.e < other.e ? this.e : other.e;
    if (s2 >= e) {
      return null;
    } else {
      return Interval.fromDateTimes(s2, e);
    }
  }
  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */
  union(other) {
    if (!this.isValid)
      return this;
    const s2 = this.s < other.s ? this.s : other.s, e = this.e > other.e ? this.e : other.e;
    return Interval.fromDateTimes(s2, e);
  }
  /**
   * Merge an array of Intervals into a equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static merge(intervals) {
    const [found, final] = intervals.sort((a, b) => a.s - b.s).reduce(
      ([sofar, current], item) => {
        if (!current) {
          return [sofar, item];
        } else if (current.overlaps(item) || current.abutsStart(item)) {
          return [sofar, current.union(item)];
        } else {
          return [sofar.concat([current]), item];
        }
      },
      [[], null]
    );
    if (final) {
      found.push(final);
    }
    return found;
  }
  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static xor(intervals) {
    let start = null, currentCount = 0;
    const results = [], ends = intervals.map((i) => [
      { time: i.s, type: "s" },
      { time: i.e, type: "e" }
    ]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a, b) => a.time - b.time);
    for (const i of arr) {
      currentCount += i.type === "s" ? 1 : -1;
      if (currentCount === 1) {
        start = i.time;
      } else {
        if (start && +start !== +i.time) {
          results.push(Interval.fromDateTimes(start, i.time));
        }
        start = null;
      }
    }
    return Interval.merge(results);
  }
  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {Array}
   */
  difference(...intervals) {
    return Interval.xor([this].concat(intervals)).map((i) => this.intersection(i)).filter((i) => i && !i.isEmpty());
  }
  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */
  toString() {
    if (!this.isValid)
      return INVALID2;
    return `[${this.s.toISO()} \u2013 ${this.e.toISO()})`;
  }
  /**
   * Returns a string representation of this Interval appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }`;
    } else {
      return `Interval { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  /**
   * Returns a localized string representing this Interval. Accepts the same options as the
   * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
   * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
   * is browser-specific, but in general it will return an appropriate representation of the
   * Interval in the assigned locale. Defaults to the system's locale if no locale has been
   * specified.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
   * Intl.DateTimeFormat constructor options.
   * @param {Object} opts - Options to override the configuration of the start DateTime.
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022  11/8/2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7  8, 2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 78 novembre 2022
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00  8:00 PM
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00  8:00 p
   * @return {string}
   */
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID2;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISO(opts) {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
  }
  /**
   * Returns an ISO 8601-compliant string representation of date of this Interval.
   * The time components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {string}
   */
  toISODate() {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toISODate()}/${this.e.toISODate()}`;
  }
  /**
   * Returns an ISO 8601-compliant string representation of time of this Interval.
   * The date components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISOTime(opts) {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
  }
  /**
   * Returns a string representation of this Interval formatted according to the specified format
   * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
   * formatting tool.
   * @param {string} dateFormat - The format string. This string formats the start and end time.
   * See {@link DateTime#toFormat} for details.
   * @param {Object} opts - Options.
   * @param {string} [opts.separator =  '  '] - A separator to place between the start and end
   * representations.
   * @return {string}
   */
  toFormat(dateFormat, { separator = " \u2013 " } = {}) {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
  }
  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */
  toDuration(unit, opts) {
    if (!this.isValid) {
      return Duration.invalid(this.invalidReason);
    }
    return this.e.diff(this.s, unit, opts);
  }
  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */
  mapEndpoints(mapFn) {
    return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
  }
};

// ../../../node_modules/luxon/src/info.js
var Info = class {
  /**
   * Return whether the specified zone contains a DST.
   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
   * @return {boolean}
   */
  static hasDST(zone = Settings.defaultZone) {
    const proto = DateTime.now().setZone(zone).set({ month: 12 });
    return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
  }
  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */
  static isValidIANAZone(zone) {
    return IANAZone.isValidZone(zone);
  }
  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   *   with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   *   instance with {@link Zone#isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   *   in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */
  static normalizeZone(input) {
    return normalizeZone(input, Settings.defaultZone);
  }
  /**
   * Get the weekday on which the week starts according to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number} the start of the week, 1 for Monday through 7 for Sunday
   */
  static getStartOfWeek({ locale = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale)).getStartOfWeek();
  }
  /**
   * Get the minimum number of days necessary in a week before it is considered part of the next year according
   * to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number}
   */
  static getMinimumDaysInFirstWeek({ locale = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale)).getMinDaysInFirstWeek();
  }
  /**
   * Get the weekdays, which are considered the weekend according to the given locale
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number[]} an array of weekdays, 1 for Monday through 7 for Sunday
   */
  static getWeekendWeekdays({ locale = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale)).getWeekendDays().slice();
  }
  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> ''
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabi I'
   * @return {Array}
   */
  static months(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
  }
  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link Info#months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {Array}
   */
  static monthsFormat(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
  }
  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> ''
   * @return {Array}
   */
  static weekdays(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
  }
  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link Info#weekdays}
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @return {Array}
   */
  static weekdaysFormat(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
  }
  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ '', '' ]
   * @return {Array}
   */
  static meridiems({ locale = null } = {}) {
    return Locale.create(locale).meridiems();
  }
  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jsus-Christ', 'aprs Jsus-Christ' ]
   * @return {Array}
   */
  static eras(length = "short", { locale = null } = {}) {
    return Locale.create(locale, null, "gregory").eras(length);
  }
  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `relative`: whether this environment supports relative time formatting
   * * `localeWeek`: whether this environment supports different weekdays for the start of the week based on the locale
   * @example Info.features() //=> { relative: false, localeWeek: true }
   * @return {Object}
   */
  static features() {
    return { relative: hasRelative(), localeWeek: hasLocaleWeekInfo() };
  }
};

// ../../../node_modules/luxon/src/impl/diff.js
function dayDiff(earlier, later) {
  const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
  return Math.floor(Duration.fromMillis(ms).as("days"));
}
function highOrderDiffs(cursor, later, units) {
  const differs = [
    ["years", (a, b) => b.year - a.year],
    ["quarters", (a, b) => b.quarter - a.quarter + (b.year - a.year) * 4],
    ["months", (a, b) => b.month - a.month + (b.year - a.year) * 12],
    [
      "weeks",
      (a, b) => {
        const days = dayDiff(a, b);
        return (days - days % 7) / 7;
      }
    ],
    ["days", dayDiff]
  ];
  const results = {};
  const earlier = cursor;
  let lowestOrder, highWater;
  for (const [unit, differ] of differs) {
    if (units.indexOf(unit) >= 0) {
      lowestOrder = unit;
      results[unit] = differ(cursor, later);
      highWater = earlier.plus(results);
      if (highWater > later) {
        results[unit]--;
        cursor = earlier.plus(results);
        if (cursor > later) {
          highWater = cursor;
          results[unit]--;
          cursor = earlier.plus(results);
        }
      } else {
        cursor = highWater;
      }
    }
  }
  return [cursor, results, highWater, lowestOrder];
}
function diff_default(earlier, later, units, opts) {
  let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
  const remainingMillis = later - cursor;
  const lowerOrderUnits = units.filter(
    (u) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0
  );
  if (lowerOrderUnits.length === 0) {
    if (highWater < later) {
      highWater = cursor.plus({ [lowestOrder]: 1 });
    }
    if (highWater !== cursor) {
      results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
    }
  }
  const duration = Duration.fromObject(results, opts);
  if (lowerOrderUnits.length > 0) {
    return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
  } else {
    return duration;
  }
}

// ../../../node_modules/luxon/src/impl/digits.js
var numberingSystems = {
  arab: "[\u0660-\u0669]",
  arabext: "[\u06F0-\u06F9]",
  bali: "[\u1B50-\u1B59]",
  beng: "[\u09E6-\u09EF]",
  deva: "[\u0966-\u096F]",
  fullwide: "[\uFF10-\uFF19]",
  gujr: "[\u0AE6-\u0AEF]",
  hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
  khmr: "[\u17E0-\u17E9]",
  knda: "[\u0CE6-\u0CEF]",
  laoo: "[\u0ED0-\u0ED9]",
  limb: "[\u1946-\u194F]",
  mlym: "[\u0D66-\u0D6F]",
  mong: "[\u1810-\u1819]",
  mymr: "[\u1040-\u1049]",
  orya: "[\u0B66-\u0B6F]",
  tamldec: "[\u0BE6-\u0BEF]",
  telu: "[\u0C66-\u0C6F]",
  thai: "[\u0E50-\u0E59]",
  tibt: "[\u0F20-\u0F29]",
  latn: "\\d"
};
var numberingSystemsUTF16 = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
};
var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
function parseDigits(str) {
  let value = parseInt(str, 10);
  if (isNaN(value)) {
    value = "";
    for (let i = 0; i < str.length; i++) {
      const code = str.charCodeAt(i);
      if (str[i].search(numberingSystems.hanidec) !== -1) {
        value += hanidecChars.indexOf(str[i]);
      } else {
        for (const key in numberingSystemsUTF16) {
          const [min, max] = numberingSystemsUTF16[key];
          if (code >= min && code <= max) {
            value += code - min;
          }
        }
      }
    }
    return parseInt(value, 10);
  } else {
    return value;
  }
}
function digitRegex({ numberingSystem }, append = "") {
  return new RegExp(`${numberingSystems[numberingSystem || "latn"]}${append}`);
}

// ../../../node_modules/luxon/src/impl/tokenParser.js
var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
function intUnit(regex, post = (i) => i) {
  return { regex, deser: ([s2]) => post(parseDigits(s2)) };
}
var NBSP = String.fromCharCode(160);
var spaceOrNBSP = `[ ${NBSP}]`;
var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
function fixListRegex(s2) {
  return s2.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
}
function stripInsensitivities(s2) {
  return s2.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
}
function oneOf(strings, startIndex) {
  if (strings === null) {
    return null;
  } else {
    return {
      regex: RegExp(strings.map(fixListRegex).join("|")),
      deser: ([s2]) => strings.findIndex((i) => stripInsensitivities(s2) === stripInsensitivities(i)) + startIndex
    };
  }
}
function offset(regex, groups) {
  return { regex, deser: ([, h, m]) => signedOffset(h, m), groups };
}
function simple(regex) {
  return { regex, deser: ([s2]) => s2 };
}
function escapeToken(value) {
  return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function unitForToken(token, loc) {
  const one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal = (t) => ({ regex: RegExp(escapeToken(t.val)), deser: ([s2]) => s2, literal: true }), unitate = (t) => {
    if (token.literal) {
      return literal(t);
    }
    switch (t.val) {
      case "G":
        return oneOf(loc.eras("short"), 0);
      case "GG":
        return oneOf(loc.eras("long"), 0);
      case "y":
        return intUnit(oneToSix);
      case "yy":
        return intUnit(twoToFour, untruncateYear);
      case "yyyy":
        return intUnit(four);
      case "yyyyy":
        return intUnit(fourToSix);
      case "yyyyyy":
        return intUnit(six);
      case "M":
        return intUnit(oneOrTwo);
      case "MM":
        return intUnit(two);
      case "MMM":
        return oneOf(loc.months("short", true), 1);
      case "MMMM":
        return oneOf(loc.months("long", true), 1);
      case "L":
        return intUnit(oneOrTwo);
      case "LL":
        return intUnit(two);
      case "LLL":
        return oneOf(loc.months("short", false), 1);
      case "LLLL":
        return oneOf(loc.months("long", false), 1);
      case "d":
        return intUnit(oneOrTwo);
      case "dd":
        return intUnit(two);
      case "o":
        return intUnit(oneToThree);
      case "ooo":
        return intUnit(three);
      case "HH":
        return intUnit(two);
      case "H":
        return intUnit(oneOrTwo);
      case "hh":
        return intUnit(two);
      case "h":
        return intUnit(oneOrTwo);
      case "mm":
        return intUnit(two);
      case "m":
        return intUnit(oneOrTwo);
      case "q":
        return intUnit(oneOrTwo);
      case "qq":
        return intUnit(two);
      case "s":
        return intUnit(oneOrTwo);
      case "ss":
        return intUnit(two);
      case "S":
        return intUnit(oneToThree);
      case "SSS":
        return intUnit(three);
      case "u":
        return simple(oneToNine);
      case "uu":
        return simple(oneOrTwo);
      case "uuu":
        return intUnit(one);
      case "a":
        return oneOf(loc.meridiems(), 0);
      case "kkkk":
        return intUnit(four);
      case "kk":
        return intUnit(twoToFour, untruncateYear);
      case "W":
        return intUnit(oneOrTwo);
      case "WW":
        return intUnit(two);
      case "E":
      case "c":
        return intUnit(one);
      case "EEE":
        return oneOf(loc.weekdays("short", false), 1);
      case "EEEE":
        return oneOf(loc.weekdays("long", false), 1);
      case "ccc":
        return oneOf(loc.weekdays("short", true), 1);
      case "cccc":
        return oneOf(loc.weekdays("long", true), 1);
      case "Z":
      case "ZZ":
        return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
      case "ZZZ":
        return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
      case "z":
        return simple(/[a-z_+-/]{1,256}?/i);
      case " ":
        return simple(/[^\S\n\r]/);
      default:
        return literal(t);
    }
  };
  const unit = unitate(token) || {
    invalidReason: MISSING_FTP
  };
  unit.token = token;
  return unit;
}
var partTypeStyleToTokenVal = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour12: {
    numeric: "h",
    "2-digit": "hh"
  },
  hour24: {
    numeric: "H",
    "2-digit": "HH"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ"
  }
};
function tokenForPart(part, formatOpts, resolvedOpts) {
  const { type, value } = part;
  if (type === "literal") {
    const isSpace = /^\s+$/.test(value);
    return {
      literal: !isSpace,
      val: isSpace ? " " : value
    };
  }
  const style = formatOpts[type];
  let actualType = type;
  if (type === "hour") {
    if (formatOpts.hour12 != null) {
      actualType = formatOpts.hour12 ? "hour12" : "hour24";
    } else if (formatOpts.hourCycle != null) {
      if (formatOpts.hourCycle === "h11" || formatOpts.hourCycle === "h12") {
        actualType = "hour12";
      } else {
        actualType = "hour24";
      }
    } else {
      actualType = resolvedOpts.hour12 ? "hour12" : "hour24";
    }
  }
  let val = partTypeStyleToTokenVal[actualType];
  if (typeof val === "object") {
    val = val[style];
  }
  if (val) {
    return {
      literal: false,
      val
    };
  }
  return void 0;
}
function buildRegex(units) {
  const re = units.map((u) => u.regex).reduce((f, r) => `${f}(${r.source})`, "");
  return [`^${re}$`, units];
}
function match(input, regex, handlers) {
  const matches = input.match(regex);
  if (matches) {
    const all = {};
    let matchIndex = 1;
    for (const i in handlers) {
      if (hasOwnProperty(handlers, i)) {
        const h = handlers[i], groups = h.groups ? h.groups + 1 : 1;
        if (!h.literal && h.token) {
          all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
        }
        matchIndex += groups;
      }
    }
    return [matches, all];
  } else {
    return [matches, {}];
  }
}
function dateTimeFromMatches(matches) {
  const toField = (token) => {
    switch (token) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let zone = null;
  let specificOffset;
  if (!isUndefined(matches.z)) {
    zone = IANAZone.create(matches.z);
  }
  if (!isUndefined(matches.Z)) {
    if (!zone) {
      zone = new FixedOffsetZone(matches.Z);
    }
    specificOffset = matches.Z;
  }
  if (!isUndefined(matches.q)) {
    matches.M = (matches.q - 1) * 3 + 1;
  }
  if (!isUndefined(matches.h)) {
    if (matches.h < 12 && matches.a === 1) {
      matches.h += 12;
    } else if (matches.h === 12 && matches.a === 0) {
      matches.h = 0;
    }
  }
  if (matches.G === 0 && matches.y) {
    matches.y = -matches.y;
  }
  if (!isUndefined(matches.u)) {
    matches.S = parseMillis(matches.u);
  }
  const vals = Object.keys(matches).reduce((r, k) => {
    const f = toField(k);
    if (f) {
      r[f] = matches[k];
    }
    return r;
  }, {});
  return [vals, zone, specificOffset];
}
var dummyDateTimeCache = null;
function getDummyDateTime() {
  if (!dummyDateTimeCache) {
    dummyDateTimeCache = DateTime.fromMillis(1555555555555);
  }
  return dummyDateTimeCache;
}
function maybeExpandMacroToken(token, locale) {
  if (token.literal) {
    return token;
  }
  const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
  const tokens = formatOptsToTokens(formatOpts, locale);
  if (tokens == null || tokens.includes(void 0)) {
    return token;
  }
  return tokens;
}
function expandMacroTokens(tokens, locale) {
  return Array.prototype.concat(...tokens.map((t) => maybeExpandMacroToken(t, locale)));
}
function explainFromTokens(locale, input, format) {
  const tokens = expandMacroTokens(Formatter.parseFormat(format), locale), units = tokens.map((t) => unitForToken(t, locale)), disqualifyingUnit = units.find((t) => t.invalidReason);
  if (disqualifyingUnit) {
    return { input, tokens, invalidReason: disqualifyingUnit.invalidReason };
  } else {
    const [regexString, handlers] = buildRegex(units), regex = RegExp(regexString, "i"), [rawMatches, matches] = match(input, regex, handlers), [result, zone, specificOffset] = matches ? dateTimeFromMatches(matches) : [null, null, void 0];
    if (hasOwnProperty(matches, "a") && hasOwnProperty(matches, "H")) {
      throw new ConflictingSpecificationError(
        "Can't include meridiem when specifying 24-hour format"
      );
    }
    return { input, tokens, regex, rawMatches, matches, result, zone, specificOffset };
  }
}
function parseFromTokens(locale, input, format) {
  const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale, input, format);
  return [result, zone, specificOffset, invalidReason];
}
function formatOptsToTokens(formatOpts, locale) {
  if (!formatOpts) {
    return null;
  }
  const formatter = Formatter.create(locale, formatOpts);
  const df = formatter.dtFormatter(getDummyDateTime());
  const parts = df.formatToParts();
  const resolvedOpts = df.resolvedOptions();
  return parts.map((p) => tokenForPart(p, formatOpts, resolvedOpts));
}

// ../../../node_modules/luxon/src/datetime.js
var INVALID3 = "Invalid DateTime";
var MAX_DATE = 864e13;
function unsupportedZone(zone) {
  return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
}
function possiblyCachedWeekData(dt) {
  if (dt.weekData === null) {
    dt.weekData = gregorianToWeek(dt.c);
  }
  return dt.weekData;
}
function possiblyCachedLocalWeekData(dt) {
  if (dt.localWeekData === null) {
    dt.localWeekData = gregorianToWeek(
      dt.c,
      dt.loc.getMinDaysInFirstWeek(),
      dt.loc.getStartOfWeek()
    );
  }
  return dt.localWeekData;
}
function clone6(inst, alts) {
  const current = {
    ts: inst.ts,
    zone: inst.zone,
    c: inst.c,
    o: inst.o,
    loc: inst.loc,
    invalid: inst.invalid
  };
  return new DateTime({ ...current, ...alts, old: current });
}
function fixOffset(localTS, o, tz) {
  let utcGuess = localTS - o * 60 * 1e3;
  const o2 = tz.offset(utcGuess);
  if (o === o2) {
    return [utcGuess, o];
  }
  utcGuess -= (o2 - o) * 60 * 1e3;
  const o3 = tz.offset(utcGuess);
  if (o2 === o3) {
    return [utcGuess, o2];
  }
  return [localTS - Math.min(o2, o3) * 60 * 1e3, Math.max(o2, o3)];
}
function tsToObj(ts, offset2) {
  ts += offset2 * 60 * 1e3;
  const d = new Date(ts);
  return {
    year: d.getUTCFullYear(),
    month: d.getUTCMonth() + 1,
    day: d.getUTCDate(),
    hour: d.getUTCHours(),
    minute: d.getUTCMinutes(),
    second: d.getUTCSeconds(),
    millisecond: d.getUTCMilliseconds()
  };
}
function objToTS(obj, offset2, zone) {
  return fixOffset(objToLocalTS(obj), offset2, zone);
}
function adjustTime(inst, dur) {
  const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c = {
    ...inst.c,
    year,
    month,
    day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
  }, millisToAdd = Duration.fromObject({
    years: dur.years - Math.trunc(dur.years),
    quarters: dur.quarters - Math.trunc(dur.quarters),
    months: dur.months - Math.trunc(dur.months),
    weeks: dur.weeks - Math.trunc(dur.weeks),
    days: dur.days - Math.trunc(dur.days),
    hours: dur.hours,
    minutes: dur.minutes,
    seconds: dur.seconds,
    milliseconds: dur.milliseconds
  }).as("milliseconds"), localTS = objToLocalTS(c);
  let [ts, o] = fixOffset(localTS, oPre, inst.zone);
  if (millisToAdd !== 0) {
    ts += millisToAdd;
    o = inst.zone.offset(ts);
  }
  return { ts, o };
}
function parseDataToDateTime(parsed, parsedZone, opts, format, text, specificOffset) {
  const { setZone, zone } = opts;
  if (parsed && Object.keys(parsed).length !== 0 || parsedZone) {
    const interpretationZone = parsedZone || zone, inst = DateTime.fromObject(parsed, {
      ...opts,
      zone: interpretationZone,
      specificOffset
    });
    return setZone ? inst : inst.setZone(zone);
  } else {
    return DateTime.invalid(
      new Invalid("unparsable", `the input "${text}" can't be parsed as ${format}`)
    );
  }
}
function toTechFormat(dt, format, allowZ = true) {
  return dt.isValid ? Formatter.create(Locale.create("en-US"), {
    allowZ,
    forceSimple: true
  }).formatDateTimeFromString(dt, format) : null;
}
function toISODate(o, extended) {
  const longFormat = o.c.year > 9999 || o.c.year < 0;
  let c = "";
  if (longFormat && o.c.year >= 0)
    c += "+";
  c += padStart(o.c.year, longFormat ? 6 : 4);
  if (extended) {
    c += "-";
    c += padStart(o.c.month);
    c += "-";
    c += padStart(o.c.day);
  } else {
    c += padStart(o.c.month);
    c += padStart(o.c.day);
  }
  return c;
}
function toISOTime(o, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
  let c = padStart(o.c.hour);
  if (extended) {
    c += ":";
    c += padStart(o.c.minute);
    if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
      c += ":";
    }
  } else {
    c += padStart(o.c.minute);
  }
  if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
    c += padStart(o.c.second);
    if (o.c.millisecond !== 0 || !suppressMilliseconds) {
      c += ".";
      c += padStart(o.c.millisecond, 3);
    }
  }
  if (includeOffset) {
    if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {
      c += "Z";
    } else if (o.o < 0) {
      c += "-";
      c += padStart(Math.trunc(-o.o / 60));
      c += ":";
      c += padStart(Math.trunc(-o.o % 60));
    } else {
      c += "+";
      c += padStart(Math.trunc(o.o / 60));
      c += ":";
      c += padStart(Math.trunc(o.o % 60));
    }
  }
  if (extendedZone) {
    c += "[" + o.zone.ianaName + "]";
  }
  return c;
}
var defaultUnitValues = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var defaultWeekUnitValues = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var defaultOrdinalUnitValues = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var orderedUnits2 = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
var orderedWeekUnits = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond"
];
var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function normalizeUnit(unit) {
  const normalized = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[unit.toLowerCase()];
  if (!normalized)
    throw new InvalidUnitError(unit);
  return normalized;
}
function normalizeUnitWithLocalWeeks(unit) {
  switch (unit.toLowerCase()) {
    case "localweekday":
    case "localweekdays":
      return "localWeekday";
    case "localweeknumber":
    case "localweeknumbers":
      return "localWeekNumber";
    case "localweekyear":
    case "localweekyears":
      return "localWeekYear";
    default:
      return normalizeUnit(unit);
  }
}
function quickDT(obj, opts) {
  const zone = normalizeZone(opts.zone, Settings.defaultZone), loc = Locale.fromObject(opts), tsNow = Settings.now();
  let ts, o;
  if (!isUndefined(obj.year)) {
    for (const u of orderedUnits2) {
      if (isUndefined(obj[u])) {
        obj[u] = defaultUnitValues[u];
      }
    }
    const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
    if (invalid) {
      return DateTime.invalid(invalid);
    }
    const offsetProvis = zone.offset(tsNow);
    [ts, o] = objToTS(obj, offsetProvis, zone);
  } else {
    ts = tsNow;
  }
  return new DateTime({ ts, zone, loc, o });
}
function diffRelative(start, end, opts) {
  const round3 = isUndefined(opts.round) ? true : opts.round, format = (c, unit) => {
    c = roundTo(c, round3 || opts.calendary ? 0 : 2, true);
    const formatter = end.loc.clone(opts).relFormatter(opts);
    return formatter.format(c, unit);
  }, differ = (unit) => {
    if (opts.calendary) {
      if (!end.hasSame(start, unit)) {
        return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
      } else
        return 0;
    } else {
      return end.diff(start, unit).get(unit);
    }
  };
  if (opts.unit) {
    return format(differ(opts.unit), opts.unit);
  }
  for (const unit of opts.units) {
    const count = differ(unit);
    if (Math.abs(count) >= 1) {
      return format(count, unit);
    }
  }
  return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
}
function lastOpts(argList) {
  let opts = {}, args;
  if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
    opts = argList[argList.length - 1];
    args = Array.from(argList).slice(0, argList.length - 1);
  } else {
    args = Array.from(argList);
  }
  return [opts, args];
}
var DateTime = class {
  /**
   * @access private
   */
  constructor(config) {
    const zone = config.zone || Settings.defaultZone;
    let invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
    this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;
    let c = null, o = null;
    if (!invalid) {
      const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);
      if (unchanged) {
        [c, o] = [config.old.c, config.old.o];
      } else {
        const ot = zone.offset(this.ts);
        c = tsToObj(this.ts, ot);
        invalid = Number.isNaN(c.year) ? new Invalid("invalid input") : null;
        c = invalid ? null : c;
        o = invalid ? null : ot;
      }
    }
    this._zone = zone;
    this.loc = config.loc || Locale.create();
    this.invalid = invalid;
    this.weekData = null;
    this.localWeekData = null;
    this.c = c;
    this.o = o;
    this.isLuxonDateTime = true;
  }
  // CONSTRUCT
  /**
   * Create a DateTime for the current instant, in the system's time zone.
   *
   * Use Settings to override these default values if needed.
   * @example DateTime.now().toISO() //~> now in the ISO format
   * @return {DateTime}
   */
  static now() {
    return new DateTime({});
  }
  /**
   * Create a local DateTime
   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month, 1-indexed
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.local()                                  //~> now
   * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */
  static local() {
    const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }
  /**
   * Create a DateTime in UTC
   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @param {Object} options - configuration options for the DateTime
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.utc()                                              //~> now
   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
   * @return {DateTime}
   */
  static utc() {
    const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
    opts.zone = FixedOffsetZone.utcInstance;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }
  /**
   * Create a DateTime from a JavaScript Date object. Uses the default zone.
   * @param {Date} date - a JavaScript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */
  static fromJSDate(date, options = {}) {
    const ts = isDate(date) ? date.valueOf() : NaN;
    if (Number.isNaN(ts)) {
      return DateTime.invalid("invalid input");
    }
    const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }
    return new DateTime({
      ts,
      zone: zoneToUse,
      loc: Locale.fromObject(options)
    });
  }
  /**
   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromMillis(milliseconds, options = {}) {
    if (!isNumber3(milliseconds)) {
      throw new InvalidArgumentError(
        `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`
      );
    } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
      return DateTime.invalid("Timestamp out of range");
    } else {
      return new DateTime({
        ts: milliseconds,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  /**
   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromSeconds(seconds, options = {}) {
    if (!isNumber3(seconds)) {
      throw new InvalidArgumentError("fromSeconds requires a numerical input");
    } else {
      return new DateTime({
        ts: seconds * 1e3,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  /**
   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.localWeekYear - a week year, according to the locale
   * @param {number} obj.localWeekNumber - a week number, between 1 and 52 or 53, depending on the year, according to the locale
   * @param {number} obj.localWeekday - a weekday, 1-7, where 1 is the first and 7 is the last day of the week, according to the locale
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {Object} opts - options for creating this DateTime
   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [opts.locale='system\'s locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @example DateTime.fromObject({ localWeekYear: 2022, localWeekNumber: 1, localWeekday: 1 }, { locale: "en-US" }).toISODate() //=> '2021-12-26'
   * @return {DateTime}
   */
  static fromObject(obj, opts = {}) {
    obj = obj || {};
    const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }
    const loc = Locale.fromObject(opts);
    const normalized = normalizeObject(obj, normalizeUnitWithLocalWeeks);
    const { minDaysInFirstWeek, startOfWeek } = usesLocalWeekValues(normalized, loc);
    const tsNow = Settings.now(), offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
    let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
    if (useWeekData) {
      units = orderedWeekUnits;
      defaultValues = defaultWeekUnitValues;
      objNow = gregorianToWeek(objNow, minDaysInFirstWeek, startOfWeek);
    } else if (containsOrdinal) {
      units = orderedOrdinalUnits;
      defaultValues = defaultOrdinalUnitValues;
      objNow = gregorianToOrdinal(objNow);
    } else {
      units = orderedUnits2;
      defaultValues = defaultUnitValues;
    }
    let foundFirst = false;
    for (const u of units) {
      const v = normalized[u];
      if (!isUndefined(v)) {
        foundFirst = true;
      } else if (foundFirst) {
        normalized[u] = defaultValues[u];
      } else {
        normalized[u] = objNow[u];
      }
    }
    const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
    if (invalid) {
      return DateTime.invalid(invalid);
    }
    const gregorian = useWeekData ? weekToGregorian(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new DateTime({
      ts: tsFinal,
      zone: zoneToUse,
      o: offsetFinal,
      loc
    });
    if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
      return DateTime.invalid(
        "mismatched weekday",
        `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`
      );
    }
    return inst;
  }
  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */
  static fromISO(text, opts = {}) {
    const [vals, parsedZone] = parseISODate(text);
    return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
  }
  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */
  static fromRFC2822(text, opts = {}) {
    const [vals, parsedZone] = parseRFC2822Date(text);
    return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
  }
  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
   * @return {DateTime}
   */
  static fromHTTP(text, opts = {}) {
    const [vals, parsedZone] = parseHTTPDate(text);
    return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
  }
  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromFormat(text, fmt, opts = {}) {
    if (isUndefined(text) || isUndefined(fmt)) {
      throw new InvalidArgumentError("fromFormat requires an input string and a format");
    }
    const { locale = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    }), [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text, fmt);
    if (invalid) {
      return DateTime.invalid(invalid);
    } else {
      return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);
    }
  }
  /**
   * @deprecated use fromFormat instead
   */
  static fromString(text, fmt, opts = {}) {
    return DateTime.fromFormat(text, fmt, opts);
  }
  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */
  static fromSQL(text, opts = {}) {
    const [vals, parsedZone] = parseSQL(text);
    return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
  }
  /**
   * Create an invalid DateTime.
   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDateTimeError(invalid);
    } else {
      return new DateTime({ invalid });
    }
  }
  /**
   * Check if an object is an instance of DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDateTime(o) {
    return o && o.isLuxonDateTime || false;
  }
  /**
   * Produce the format string for a set of options
   * @param formatOpts
   * @param localeOpts
   * @returns {string}
   */
  static parseFormatForOpts(formatOpts, localeOpts = {}) {
    const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
    return !tokenList ? null : tokenList.map((t) => t ? t.val : null).join("");
  }
  /**
   * Produce the the fully expanded format token for the locale
   * Does NOT quote characters, so quoted tokens will not round trip correctly
   * @param fmt
   * @param localeOpts
   * @returns {string}
   */
  static expandFormat(fmt, localeOpts = {}) {
    const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts));
    return expanded.map((t) => t.val).join("");
  }
  // INFO
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */
  get(unit) {
    return this[unit];
  }
  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
   *
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
   *
   * @type {string}
   */
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  /**
   * Get the time zone associated with this DateTime.
   * @type {Zone}
   */
  get zone() {
    return this._zone;
  }
  /**
   * Get the name of the time zone.
   * @type {string}
   */
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  /**
   * Get the year
   * @example DateTime.local(2017, 5, 25).year //=> 2017
   * @type {number}
   */
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  /**
   * Get the quarter
   * @example DateTime.local(2017, 5, 25).quarter //=> 2
   * @type {number}
   */
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  /**
   * Get the month (1-12).
   * @example DateTime.local(2017, 5, 25).month //=> 5
   * @type {number}
   */
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  /**
   * Get the day of the month (1-30ish).
   * @example DateTime.local(2017, 5, 25).day //=> 25
   * @type {number}
   */
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  /**
   * Get the hour of the day (0-23).
   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
   * @type {number}
   */
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  /**
   * Get the minute of the hour (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
   * @type {number}
   */
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  /**
   * Get the second of the minute (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
   * @type {number}
   */
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  /**
   * Get the millisecond of the second (0-999).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
   * @type {number}
   */
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  /**
   * Get the week year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
   * @type {number}
   */
  get weekYear() {
    return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
  }
  /**
   * Get the week number of the week year (1-52ish).
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
   * @type {number}
   */
  get weekNumber() {
    return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
  }
  /**
   * Get the day of the week.
   * 1 is Monday and 7 is Sunday
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekday //=> 4
   * @type {number}
   */
  get weekday() {
    return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
  }
  /**
   * Returns true if this date is on a weekend according to the locale, false otherwise
   * @returns {boolean}
   */
  get isWeekend() {
    return this.isValid && this.loc.getWeekendDays().includes(this.weekday);
  }
  /**
   * Get the day of the week according to the locale.
   * 1 is the first day of the week and 7 is the last day of the week.
   * If the locale assigns Sunday as the first day of the week, then a date which is a Sunday will return 1,
   * @returns {number}
   */
  get localWeekday() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekday : NaN;
  }
  /**
   * Get the week number of the week year according to the locale. Different locales assign week numbers differently,
   * because the week can start on different days of the week (see localWeekday) and because a different number of days
   * is required for a week to count as the first week of a year.
   * @returns {number}
   */
  get localWeekNumber() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekNumber : NaN;
  }
  /**
   * Get the week year according to the locale. Different locales assign week numbers (and therefor week years)
   * differently, see localWeekNumber.
   * @returns {number}
   */
  get localWeekYear() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekYear : NaN;
  }
  /**
   * Get the ordinal (meaning the day of the year)
   * @example DateTime.local(2017, 5, 25).ordinal //=> 145
   * @type {number|DateTime}
   */
  get ordinal() {
    return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
  }
  /**
   * Get the human readable short month name, such as 'Oct'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
   * @type {string}
   */
  get monthShort() {
    return this.isValid ? Info.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable long month name, such as 'October'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthLong //=> October
   * @type {string}
   */
  get monthLong() {
    return this.isValid ? Info.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable short weekday, such as 'Mon'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
   * @type {string}
   */
  get weekdayShort() {
    return this.isValid ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the human readable long weekday, such as 'Monday'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
   * @type {string}
   */
  get weekdayLong() {
    return this.isValid ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the UTC offset of this DateTime in minutes
   * @example DateTime.now().offset //=> -240
   * @example DateTime.utc().offset //=> 0
   * @type {number}
   */
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  /**
   * Get the short human name for the zone's current offset, for example "EST" or "EDT".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameShort() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "short",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  /**
   * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameLong() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "long",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  /**
   * Get whether this zone's offset ever changes, as in a DST.
   * @type {boolean}
   */
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  /**
   * Get whether the DateTime is in a DST.
   * @type {boolean}
   */
  get isInDST() {
    if (this.isOffsetFixed) {
      return false;
    } else {
      return this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
    }
  }
  /**
   * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC
   * in this DateTime's zone. During DST changes local time can be ambiguous, for example
   * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.
   * This method will return both possible DateTimes if this DateTime's local time is ambiguous.
   * @returns {DateTime[]}
   */
  getPossibleOffsets() {
    if (!this.isValid || this.isOffsetFixed) {
      return [this];
    }
    const dayMs = 864e5;
    const minuteMs = 6e4;
    const localTS = objToLocalTS(this.c);
    const oEarlier = this.zone.offset(localTS - dayMs);
    const oLater = this.zone.offset(localTS + dayMs);
    const o1 = this.zone.offset(localTS - oEarlier * minuteMs);
    const o2 = this.zone.offset(localTS - oLater * minuteMs);
    if (o1 === o2) {
      return [this];
    }
    const ts1 = localTS - o1 * minuteMs;
    const ts2 = localTS - o2 * minuteMs;
    const c1 = tsToObj(ts1, o1);
    const c2 = tsToObj(ts2, o2);
    if (c1.hour === c2.hour && c1.minute === c2.minute && c1.second === c2.second && c1.millisecond === c2.millisecond) {
      return [clone6(this, { ts: ts1 }), clone6(this, { ts: ts2 })];
    }
    return [this];
  }
  /**
   * Returns true if this DateTime is in a leap year, false otherwise
   * @example DateTime.local(2016).isInLeapYear //=> true
   * @example DateTime.local(2013).isInLeapYear //=> false
   * @type {boolean}
   */
  get isInLeapYear() {
    return isLeapYear(this.year);
  }
  /**
   * Returns the number of days in this DateTime's month
   * @example DateTime.local(2016, 2).daysInMonth //=> 29
   * @example DateTime.local(2016, 3).daysInMonth //=> 31
   * @type {number}
   */
  get daysInMonth() {
    return daysInMonth(this.year, this.month);
  }
  /**
   * Returns the number of days in this DateTime's year
   * @example DateTime.local(2016).daysInYear //=> 366
   * @example DateTime.local(2013).daysInYear //=> 365
   * @type {number}
   */
  get daysInYear() {
    return this.isValid ? daysInYear(this.year) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2004).weeksInWeekYear //=> 53
   * @example DateTime.local(2013).weeksInWeekYear //=> 52
   * @type {number}
   */
  get weeksInWeekYear() {
    return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's local week year
   * @example DateTime.local(2020, 6, {locale: 'en-US'}).weeksInLocalWeekYear //=> 52
   * @example DateTime.local(2020, 6, {locale: 'de-DE'}).weeksInLocalWeekYear //=> 53
   * @type {number}
   */
  get weeksInLocalWeekYear() {
    return this.isValid ? weeksInWeekYear(
      this.localWeekYear,
      this.loc.getMinDaysInFirstWeek(),
      this.loc.getStartOfWeek()
    ) : NaN;
  }
  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */
  resolvedLocaleOptions(opts = {}) {
    const { locale, numberingSystem, calendar } = Formatter.create(
      this.loc.clone(opts),
      opts
    ).resolvedOptions(this);
    return { locale, numberingSystem, outputCalendar: calendar };
  }
  // TRANSFORM
  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link DateTime#setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */
  toUTC(offset2 = 0, opts = {}) {
    return this.setZone(FixedOffsetZone.instance(offset2), opts);
  }
  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */
  toLocal() {
    return this.setZone(Settings.defaultZone);
  }
  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */
  setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
    zone = normalizeZone(zone, Settings.defaultZone);
    if (zone.equals(this.zone)) {
      return this;
    } else if (!zone.isValid) {
      return DateTime.invalid(unsupportedZone(zone));
    } else {
      let newTS = this.ts;
      if (keepLocalTime || keepCalendarTime) {
        const offsetGuess = zone.offset(this.ts);
        const asObj = this.toObject();
        [newTS] = objToTS(asObj, offsetGuess, zone);
      }
      return clone6(this, { ts: newTS, zone });
    }
  }
  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */
  reconfigure({ locale, numberingSystem, outputCalendar } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });
    return clone6(this, { loc });
  }
  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */
  setLocale(locale) {
    return this.reconfigure({ locale });
  }
  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
   *
   * This method also supports setting locale-based week units, i.e. `localWeekday`, `localWeekNumber` and `localWeekYear`.
   * They cannot be mixed with ISO-week units like `weekday`.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */
  set(values) {
    if (!this.isValid)
      return this;
    const normalized = normalizeObject(values, normalizeUnitWithLocalWeeks);
    const { minDaysInFirstWeek, startOfWeek } = usesLocalWeekValues(normalized, this.loc);
    const settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    let mixed;
    if (settingWeekStuff) {
      mixed = weekToGregorian(
        { ...gregorianToWeek(this.c, minDaysInFirstWeek, startOfWeek), ...normalized },
        minDaysInFirstWeek,
        startOfWeek
      );
    } else if (!isUndefined(normalized.ordinal)) {
      mixed = ordinalToGregorian({ ...gregorianToOrdinal(this.c), ...normalized });
    } else {
      mixed = { ...this.toObject(), ...normalized };
      if (isUndefined(normalized.day)) {
        mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
      }
    }
    const [ts, o] = objToTS(mixed, this.o, this.zone);
    return clone6(this, { ts, o });
  }
  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.now().plus(123) //~> in 123 milliseconds
   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */
  plus(duration) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration);
    return clone6(this, adjustTime(this, dur));
  }
  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link DateTime#plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
   */
  minus(duration) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration).negate();
    return clone6(this, adjustTime(this, dur));
  }
  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */
  startOf(unit, { useLocaleWeeks = false } = {}) {
    if (!this.isValid)
      return this;
    const o = {}, normalizedUnit = Duration.normalizeUnit(unit);
    switch (normalizedUnit) {
      case "years":
        o.month = 1;
      case "quarters":
      case "months":
        o.day = 1;
      case "weeks":
      case "days":
        o.hour = 0;
      case "hours":
        o.minute = 0;
      case "minutes":
        o.second = 0;
      case "seconds":
        o.millisecond = 0;
        break;
      case "milliseconds":
        break;
    }
    if (normalizedUnit === "weeks") {
      if (useLocaleWeeks) {
        const startOfWeek = this.loc.getStartOfWeek();
        const { weekday } = this;
        if (weekday < startOfWeek) {
          o.weekNumber = this.weekNumber - 1;
        }
        o.weekday = startOfWeek;
      } else {
        o.weekday = 1;
      }
    }
    if (normalizedUnit === "quarters") {
      const q = Math.ceil(this.month / 3);
      o.month = (q - 1) * 3 + 1;
    }
    return this.set(o);
  }
  /**
   * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */
  endOf(unit, opts) {
    return this.isValid ? this.plus({ [unit]: 1 }).startOf(unit, opts).minus(1) : this;
  }
  // OUTPUT
  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID3;
  }
  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toLocaleString(); //=> 4/20/2017
   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 aot 2022'
   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
   * @return {string}
   */
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID3;
  }
  /**
   * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.now().toLocaleParts(); //=> [
   *                                   //=>   { type: 'day', value: '25' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'month', value: '05' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'year', value: '1982' }
   *                                   //=> ]
   */
  toLocaleParts(opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
   * @return {string}
   */
  toISO({
    format = "extended",
    suppressSeconds = false,
    suppressMilliseconds = false,
    includeOffset = true,
    extendedZone = false
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    const ext = format === "extended";
    let c = toISODate(this, ext);
    c += "T";
    c += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
    return c;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @param {Object} opts - options
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
   * @return {string}
   */
  toISODate({ format = "extended" } = {}) {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, format === "extended");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */
  toISOWeekDate() {
    return toTechFormat(this, "kkkk-'W'WW-c");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
   * @return {string}
   */
  toISOTime({
    suppressMilliseconds = false,
    suppressSeconds = false,
    includeOffset = true,
    includePrefix = false,
    extendedZone = false,
    format = "extended"
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    let c = includePrefix ? "T" : "";
    return c + toISOTime(
      this,
      format === "extended",
      suppressSeconds,
      suppressMilliseconds,
      includeOffset,
      extendedZone
    );
  }
  /**
   * Returns an RFC 2822-compatible string representation of this DateTime
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */
  toRFC2822() {
    return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */
  toHTTP() {
    return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string}
   */
  toSQLDate() {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, true);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */
  toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
    let fmt = "HH:mm:ss.SSS";
    if (includeZone || includeOffset) {
      if (includeOffsetSpace) {
        fmt += " ";
      }
      if (includeZone) {
        fmt += "z";
      } else if (includeOffset) {
        fmt += "ZZ";
      }
    }
    return toTechFormat(this, fmt, true);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */
  toSQL(opts = {}) {
    if (!this.isValid) {
      return null;
    }
    return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
  }
  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */
  toString() {
    return this.isValid ? this.toISO() : INVALID3;
  }
  /**
   * Returns a string representation of this DateTime appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }`;
    } else {
      return `DateTime { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  /**
   * Returns the epoch seconds of this DateTime.
   * @return {number}
   */
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  /**
   * Returns the epoch seconds (as a whole number) of this DateTime.
   * @return {number}
   */
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */
  toBSON() {
    return this.toJSDate();
  }
  /**
   * Returns a JavaScript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */
  toObject(opts = {}) {
    if (!this.isValid)
      return {};
    const base = { ...this.c };
    if (opts.includeConfig) {
      base.outputCalendar = this.outputCalendar;
      base.numberingSystem = this.loc.numberingSystem;
      base.locale = this.loc.locale;
    }
    return base;
  }
  /**
   * Returns a JavaScript Date equivalent to this DateTime.
   * @return {Date}
   */
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  // COMPARE
  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *     i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */
  diff(otherDateTime, unit = "milliseconds", opts = {}) {
    if (!this.isValid || !otherDateTime.isValid) {
      return Duration.invalid("created by diffing an invalid DateTime");
    }
    const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };
    const units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff_default(earlier, later, units, durOpts);
    return otherIsLater ? diffed.negate() : diffed;
  }
  /**
   * Return the difference between this DateTime and right now.
   * See {@link DateTime#diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  diffNow(unit = "milliseconds", opts = {}) {
    return this.diff(DateTime.now(), unit, opts);
  }
  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval}
   */
  until(otherDateTime) {
    return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
  }
  /**
   * Return whether this DateTime is in the same unit of time as another DateTime.
   * Higher-order units must also be identical for this function to return `true`.
   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; only the locale of this DateTime is used
   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
   * @return {boolean}
   */
  hasSame(otherDateTime, unit, opts) {
    if (!this.isValid)
      return false;
    const inputMs = otherDateTime.valueOf();
    const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
    return adjustedToZone.startOf(unit, opts) <= inputMs && inputMs <= adjustedToZone.endOf(unit, opts);
  }
  /**
   * Equality check
   * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === +dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */
  equals(other) {
    return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
  }
  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeTimeFormat. Rounds down by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 da"
   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */
  toRelative(options = {}) {
    if (!this.isValid)
      return null;
    const base = options.base || DateTime.fromObject({}, { zone: this.zone }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;
    let units = ["years", "months", "days", "hours", "minutes", "seconds"];
    let unit = options.unit;
    if (Array.isArray(options.unit)) {
      units = options.unit;
      unit = void 0;
    }
    return diffRelative(base, this.plus(padding), {
      ...options,
      numeric: "always",
      units,
      unit
    });
  }
  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""maana"
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */
  toRelativeCalendar(options = {}) {
    if (!this.isValid)
      return null;
    return diffRelative(options.base || DateTime.fromObject({}, { zone: this.zone }), this, {
      ...options,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: true
    });
  }
  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */
  static min(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("min requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i) => i.valueOf(), Math.min);
  }
  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */
  static max(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("max requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i) => i.valueOf(), Math.max);
  }
  // MISC
  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */
  static fromFormatExplain(text, fmt, options = {}) {
    const { locale = null, numberingSystem = null } = options, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    });
    return explainFromTokens(localeToUse, text, fmt);
  }
  /**
   * @deprecated use fromFormatExplain instead
   */
  static fromStringExplain(text, fmt, options = {}) {
    return DateTime.fromFormatExplain(text, fmt, options);
  }
  // FORMAT PRESETS
  /**
   * {@link DateTime#toLocaleString} format like 10/14/1983
   * @type {Object}
   */
  static get DATE_SHORT() {
    return DATE_SHORT;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED() {
    return DATE_MED;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED_WITH_WEEKDAY() {
    return DATE_MED_WITH_WEEKDAY;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983'
   * @type {Object}
   */
  static get DATE_FULL() {
    return DATE_FULL;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
   * @type {Object}
   */
  static get DATE_HUGE() {
    return DATE_HUGE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_SIMPLE() {
    return TIME_SIMPLE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SECONDS() {
    return TIME_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SHORT_OFFSET() {
    return TIME_WITH_SHORT_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_LONG_OFFSET() {
    return TIME_WITH_LONG_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_SIMPLE() {
    return TIME_24_SIMPLE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SECONDS() {
    return TIME_24_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SHORT_OFFSET() {
    return TIME_24_WITH_SHORT_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_LONG_OFFSET() {
    return TIME_24_WITH_LONG_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT() {
    return DATETIME_SHORT;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT_WITH_SECONDS() {
    return DATETIME_SHORT_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED() {
    return DATETIME_MED;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_SECONDS() {
    return DATETIME_MED_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_WEEKDAY() {
    return DATETIME_MED_WITH_WEEKDAY;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL() {
    return DATETIME_FULL;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL_WITH_SECONDS() {
    return DATETIME_FULL_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE() {
    return DATETIME_HUGE;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE_WITH_SECONDS() {
    return DATETIME_HUGE_WITH_SECONDS;
  }
};
function friendlyDateTime(dateTimeish) {
  if (DateTime.isDateTime(dateTimeish)) {
    return dateTimeish;
  } else if (dateTimeish && dateTimeish.valueOf && isNumber3(dateTimeish.valueOf())) {
    return DateTime.fromJSDate(dateTimeish);
  } else if (dateTimeish && typeof dateTimeish === "object") {
    return DateTime.fromObject(dateTimeish);
  } else {
    throw new InvalidArgumentError(
      `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`
    );
  }
}

// ../../../node_modules/chartjs-adapter-luxon/dist/chartjs-adapter-luxon.esm.js
var FORMATS = {
  datetime: DateTime.DATETIME_MED_WITH_SECONDS,
  millisecond: "h:mm:ss.SSS a",
  second: DateTime.TIME_WITH_SECONDS,
  minute: DateTime.TIME_SIMPLE,
  hour: { hour: "numeric" },
  day: { day: "numeric", month: "short" },
  week: "DD",
  month: { month: "short", year: "numeric" },
  quarter: "'Q'q - yyyy",
  year: { year: "numeric" }
};
adapters2._date.override({
  _id: "luxon",
  // DEBUG
  /**
   * @private
   */
  _create: function(time) {
    return DateTime.fromMillis(time, this.options);
  },
  init(chartOptions) {
    if (!this.options.locale) {
      this.options.locale = chartOptions.locale;
    }
  },
  formats: function() {
    return FORMATS;
  },
  parse: function(value, format) {
    const options = this.options;
    const type = typeof value;
    if (value === null || type === "undefined") {
      return null;
    }
    if (type === "number") {
      value = this._create(value);
    } else if (type === "string") {
      if (typeof format === "string") {
        value = DateTime.fromFormat(value, format, options);
      } else {
        value = DateTime.fromISO(value, options);
      }
    } else if (value instanceof Date) {
      value = DateTime.fromJSDate(value, options);
    } else if (type === "object" && !(value instanceof DateTime)) {
      value = DateTime.fromObject(value, options);
    }
    return value.isValid ? value.valueOf() : null;
  },
  format: function(time, format) {
    const datetime = this._create(time);
    return typeof format === "string" ? datetime.toFormat(format) : datetime.toLocaleString(format);
  },
  add: function(time, amount, unit) {
    const args = {};
    args[unit] = amount;
    return this._create(time).plus(args).valueOf();
  },
  diff: function(max, min, unit) {
    return this._create(max).diff(this._create(min)).as(unit).valueOf();
  },
  startOf: function(time, unit, weekday) {
    if (unit === "isoWeek") {
      weekday = Math.trunc(Math.min(Math.max(0, weekday), 6));
      const dateTime = this._create(time);
      return dateTime.minus({ days: (dateTime.weekday - weekday + 7) % 7 }).startOf("day").valueOf();
    }
    return unit ? this._create(time).startOf(unit).valueOf() : time;
  },
  endOf: function(time, unit) {
    return this._create(time).endOf(unit).valueOf();
  }
});

// resources/js/hunger-chart.js
var HungerController = class extends DoughnutController {
  draw() {
    super.draw(arguments);
    var width = this.chart.width, height = this.chart.height;
    var fontSize = (height / 114).toFixed(2);
    this.chart.ctx.font = fontSize + "em Verdana";
    this.chart.ctx.textBaseline = "middle";
    this.chart.ctx.fillStyle = "green";
    var text = this.getStatusText(), textX = Math.round((width - this.chart.ctx.measureText(text).width) / 2), textY = height - this.chart.ctx.measureText(text).hangingBaseline;
    this.chart.ctx.fillStyle = this.getTextColor();
    this.chart.ctx.fillText(text, textX, textY);
  }
  getStatusText() {
    if (this.chart.hungerLevel >= 50) {
      return this.chart.lang["ok"];
    } else if (this.chart.hungerLevel >= 20) {
      return this.chart.lang["hungry"];
    }
    return this.chart.lang["starving"];
  }
  getTextColor() {
    if (this.chart.hungerLevel >= 50) {
      return "green";
    } else if (this.chart.hungerLevel >= 20) {
      return "orange";
    }
    return "red";
  }
};
HungerController.id = "hunger";
HungerController.defaults = DoughnutController.defaults;
Chart.register(HungerController, ArcElement, plugin_tooltip, plugin_legend);

// resources/js/components/feeder.js
function duckFeederWidget({ chart, lang, starvationRate, breadHealth }) {
  return {
    hungerLevel: 100,
    ducksMurdered: 0,
    audioPlayed: false,
    init() {
      this.initChart();
      setInterval(() => {
        this.hungerLevel--;
        if (this.hungerLevel < 0) {
          this.hungerLevel = 100;
          this.ducksMurdered++;
        }
        this.updateChart();
      }, starvationRate);
      setInterval(() => {
        this.audioPlayed = false;
      }, 3e3);
    },
    feedDuck() {
      if (!this.audioPlayed) {
        this.$refs.duckmodeAudio.play();
        this.audioPlayed = true;
      }
      this.hungerLevel += breadHealth;
      if (this.hungerLevel > 100) {
        this.hungerLevel = 100;
      }
      this.updateChart();
    },
    initChart() {
      const newChart = new Chart(this.$refs.canvas, {
        type: chart.type,
        data: chart.cachedData,
        options: chart.options
      });
      newChart.hungerLevel = this.hungerLevel;
      newChart.lang = lang;
      return newChart;
    },
    updateChart() {
      const chart2 = this.getChart();
      chart2.data = {
        datasets: [{
          data: [this.hungerLevel, 100 - this.hungerLevel],
          backgroundColor: [this.getStateColour(), "Gray"]
        }],
        lang
      };
      chart2.hungerLevel = this.hungerLevel;
      chart2.update("resize");
    },
    getStateColour() {
      return this.hungerLevel >= 50 ? "Green" : this.hungerLevel >= 20 ? "Orange" : "Red";
    },
    getChart() {
      return Chart.getChart(this.$refs.canvas);
    }
  };
}
export {
  duckFeederWidget as default
};
/*! Bundled license information:

@kurkle/color/dist/color.esm.js:
  (*!
   * @kurkle/color v0.3.2
   * https://github.com/kurkle/color#readme
   * (c) 2023 Jukka Kurkela
   * Released under the MIT License
   *)

chart.js/dist/chunks/helpers.segment.js:
  (*!
   * Chart.js v4.4.2
   * https://www.chartjs.org
   * (c) 2024 Chart.js Contributors
   * Released under the MIT License
   *)

chart.js/dist/chart.js:
  (*!
   * Chart.js v4.4.2
   * https://www.chartjs.org
   * (c) 2024 Chart.js Contributors
   * Released under the MIT License
   *)

@kurkle/color/dist/color.esm.js:
  (*!
   * @kurkle/color v0.3.2
   * https://github.com/kurkle/color#readme
   * (c) 2023 Jukka Kurkela
   * Released under the MIT License
   *)

chart.js/dist/chunks/helpers.segment.js:
  (*!
   * Chart.js v4.4.2
   * https://www.chartjs.org
   * (c) 2024 Chart.js Contributors
   * Released under the MIT License
   *)

chart.js/dist/chart.js:
  (*!
   * Chart.js v4.4.2
   * https://www.chartjs.org
   * (c) 2024 Chart.js Contributors
   * Released under the MIT License
   *)

chartjs-adapter-luxon/dist/chartjs-adapter-luxon.esm.js:
  (*!
   * chartjs-adapter-luxon v1.3.1
   * https://www.chartjs.org
   * (c) 2023 chartjs-adapter-luxon Contributors
   * Released under the MIT license
   *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BrdXJrbGUvY29sb3IvZGlzdC9jb2xvci5lc20uanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuY29yZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5tYXRoLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmNvbGxlY3Rpb24udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmVhc2luZy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5jb2xvci50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5hbmltYXRpb25zLmRlZmF1bHRzLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmxheW91dHMuZGVmYXVsdHMuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuaW50bC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS50aWNrcy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5zY2FsZS5kZWZhdWx0cy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5kZWZhdWx0cy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5jYW52YXMudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5jb25maWcudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuY3VydmUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuZG9tLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmludGVycG9sYXRpb24udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMucnRsLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLnNlZ21lbnQuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuYW5pbWF0b3IuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuYW5pbWF0aW9uLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmFuaW1hdGlvbnMuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLmJhci5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIuYnViYmxlLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5kb3VnaG51dC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIubGluZS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIucG9sYXJBcmVhLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5waWUuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLnJhZGFyLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5zY2F0dGVyLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmFkYXB0ZXJzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmludGVyYWN0aW9uLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmxheW91dHMuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbGF0Zm9ybS9wbGF0Zm9ybS5iYXNlLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGxhdGZvcm0vcGxhdGZvcm0uYmFzaWMuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbGF0Zm9ybS9wbGF0Zm9ybS5kb20uanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbGF0Zm9ybS9pbmRleC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5lbGVtZW50LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLnNjYWxlLmF1dG9za2lwLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLnNjYWxlLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLnR5cGVkUmVnaXN0cnkuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUucmVnaXN0cnkuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUucGx1Z2lucy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5jb25maWcuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuY29udHJvbGxlci5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2VsZW1lbnRzL2VsZW1lbnQuYXJjLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvZWxlbWVudHMvZWxlbWVudC5saW5lLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvZWxlbWVudHMvZWxlbWVudC5wb2ludC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2VsZW1lbnRzL2VsZW1lbnQuYmFyLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uY29sb3JzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZGVjaW1hdGlvbi5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9maWxsZXIuc2VnbWVudC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9maWxsZXIuaGVscGVyLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL2ZpbGxlci5vcHRpb25zLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL2ZpbGxlci50YXJnZXQuc3RhY2suanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvc2ltcGxlQXJjLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL2ZpbGxlci50YXJnZXQuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvZmlsbGVyLmRyYXdpbmcuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5sZWdlbmQuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi50aXRsZS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLnN1YnRpdGxlLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4udG9vbHRpcC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS5jYXRlZ29yeS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS5saW5lYXJiYXNlLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvc2NhbGVzL3NjYWxlLmxpbmVhci5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS5sb2dhcml0aG1pYy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS5yYWRpYWxMaW5lYXIuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9zY2FsZXMvc2NhbGUudGltZS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS50aW1lc2VyaWVzLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaW5kZXgudHMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BrdXJrbGUvY29sb3IvZGlzdC9jb2xvci5lc20uanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuY29yZS50cyIsICIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5tYXRoLnRzIiwgIi4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmNvbGxlY3Rpb24udHMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLnRzIiwgIi4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmVhc2luZy50cyIsICIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5jb2xvci50cyIsICIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5hbmltYXRpb25zLmRlZmF1bHRzLmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmxheW91dHMuZGVmYXVsdHMuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuaW50bC50cyIsICIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS50aWNrcy5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5zY2FsZS5kZWZhdWx0cy5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5kZWZhdWx0cy5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5jYW52YXMudHMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy50cyIsICIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5jb25maWcudHMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuY3VydmUudHMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuZG9tLnRzIiwgIi4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmludGVycG9sYXRpb24udHMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMucnRsLnRzIiwgIi4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLnNlZ21lbnQuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuYW5pbWF0b3IuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuYW5pbWF0aW9uLmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmFuaW1hdGlvbnMuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLmJhci5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIuYnViYmxlLmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5kb3VnaG51dC5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIubGluZS5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIucG9sYXJBcmVhLmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5waWUuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLnJhZGFyLmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5zY2F0dGVyLmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmFkYXB0ZXJzLnRzIiwgIi4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmludGVyYWN0aW9uLmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmxheW91dHMuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbGF0Zm9ybS9wbGF0Zm9ybS5iYXNlLmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGxhdGZvcm0vcGxhdGZvcm0uYmFzaWMuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbGF0Zm9ybS9wbGF0Zm9ybS5kb20uanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbGF0Zm9ybS9pbmRleC5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5lbGVtZW50LnRzIiwgIi4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLnNjYWxlLmF1dG9za2lwLmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLnNjYWxlLmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLnR5cGVkUmVnaXN0cnkuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUucmVnaXN0cnkuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUucGx1Z2lucy5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5jb25maWcuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuY29udHJvbGxlci5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2VsZW1lbnRzL2VsZW1lbnQuYXJjLnRzIiwgIi4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvZWxlbWVudHMvZWxlbWVudC5saW5lLmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvZWxlbWVudHMvZWxlbWVudC5wb2ludC50cyIsICIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2VsZW1lbnRzL2VsZW1lbnQuYmFyLmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uY29sb3JzLnRzIiwgIi4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZGVjaW1hdGlvbi5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9maWxsZXIuc2VnbWVudC5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9maWxsZXIuaGVscGVyLmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL2ZpbGxlci5vcHRpb25zLmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL2ZpbGxlci50YXJnZXQuc3RhY2suanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvc2ltcGxlQXJjLmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL2ZpbGxlci50YXJnZXQuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvZmlsbGVyLmRyYXdpbmcuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvaW5kZXguanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5sZWdlbmQuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi50aXRsZS5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLnN1YnRpdGxlLmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4udG9vbHRpcC5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS5jYXRlZ29yeS5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS5saW5lYXJiYXNlLmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvc2NhbGVzL3NjYWxlLmxpbmVhci5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS5sb2dhcml0aG1pYy5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS5yYWRpYWxMaW5lYXIuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9zY2FsZXMvc2NhbGUudGltZS5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS50aW1lc2VyaWVzLmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaW5kZXgudHMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9lcnJvcnMuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2Zvcm1hdHMuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy96b25lLmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvem9uZXMvc3lzdGVtWm9uZS5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3pvbmVzL0lBTkFab25lLmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9sb2NhbGUuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy96b25lcy9maXhlZE9mZnNldFpvbmUuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy96b25lcy9pbnZhbGlkWm9uZS5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvem9uZVV0aWwuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9zZXR0aW5ncy5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvaW52YWxpZC5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvY29udmVyc2lvbnMuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL3V0aWwuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2VuZ2xpc2guanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2Zvcm1hdHRlci5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvcmVnZXhQYXJzZXIuanMiLCAiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9kdXJhdGlvbi5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ludGVydmFsLmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW5mby5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZGlmZi5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZGlnaXRzLmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC90b2tlblBhcnNlci5qcyIsICIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2RhdGV0aW1lLmpzIiwgIi4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jaGFydGpzLWFkYXB0ZXItbHV4b24vZGlzdC9jaGFydGpzLWFkYXB0ZXItbHV4b24uZXNtLmpzIiwgIi4uLy4uL2pzL2h1bmdlci1jaGFydC5qcyIsICIuLi8uLi9qcy9jb21wb25lbnRzL2ZlZWRlci5qcyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLyohXG4gKiBAa3Vya2xlL2NvbG9yIHYwLjMuMlxuICogaHR0cHM6Ly9naXRodWIuY29tL2t1cmtsZS9jb2xvciNyZWFkbWVcbiAqIChjKSAyMDIzIEp1a2thIEt1cmtlbGFcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG5mdW5jdGlvbiByb3VuZCh2KSB7XG4gIHJldHVybiB2ICsgMC41IHwgMDtcbn1cbmNvbnN0IGxpbSA9ICh2LCBsLCBoKSA9PiBNYXRoLm1heChNYXRoLm1pbih2LCBoKSwgbCk7XG5mdW5jdGlvbiBwMmIodikge1xuICByZXR1cm4gbGltKHJvdW5kKHYgKiAyLjU1KSwgMCwgMjU1KTtcbn1cbmZ1bmN0aW9uIGIycCh2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAvIDIuNTUpLCAwLCAxMDApO1xufVxuZnVuY3Rpb24gbjJiKHYpIHtcbiAgcmV0dXJuIGxpbShyb3VuZCh2ICogMjU1KSwgMCwgMjU1KTtcbn1cbmZ1bmN0aW9uIGIybih2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAvIDIuNTUpIC8gMTAwLCAwLCAxKTtcbn1cbmZ1bmN0aW9uIG4ycCh2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAqIDEwMCksIDAsIDEwMCk7XG59XG5cbmNvbnN0IG1hcCQxID0gezA6IDAsIDE6IDEsIDI6IDIsIDM6IDMsIDQ6IDQsIDU6IDUsIDY6IDYsIDc6IDcsIDg6IDgsIDk6IDksIEE6IDEwLCBCOiAxMSwgQzogMTIsIEQ6IDEzLCBFOiAxNCwgRjogMTUsIGE6IDEwLCBiOiAxMSwgYzogMTIsIGQ6IDEzLCBlOiAxNCwgZjogMTV9O1xuY29uc3QgaGV4ID0gWy4uLicwMTIzNDU2Nzg5QUJDREVGJ107XG5jb25zdCBoMSA9IGIgPT4gaGV4W2IgJiAweEZdO1xuY29uc3QgaDIgPSBiID0+IGhleFsoYiAmIDB4RjApID4+IDRdICsgaGV4W2IgJiAweEZdO1xuY29uc3QgZXEgPSBiID0+ICgoYiAmIDB4RjApID4+IDQpID09PSAoYiAmIDB4Rik7XG5jb25zdCBpc1Nob3J0ID0gdiA9PiBlcSh2LnIpICYmIGVxKHYuZykgJiYgZXEodi5iKSAmJiBlcSh2LmEpO1xuZnVuY3Rpb24gaGV4UGFyc2Uoc3RyKSB7XG4gIHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuICB2YXIgcmV0O1xuICBpZiAoc3RyWzBdID09PSAnIycpIHtcbiAgICBpZiAobGVuID09PSA0IHx8IGxlbiA9PT0gNSkge1xuICAgICAgcmV0ID0ge1xuICAgICAgICByOiAyNTUgJiBtYXAkMVtzdHJbMV1dICogMTcsXG4gICAgICAgIGc6IDI1NSAmIG1hcCQxW3N0clsyXV0gKiAxNyxcbiAgICAgICAgYjogMjU1ICYgbWFwJDFbc3RyWzNdXSAqIDE3LFxuICAgICAgICBhOiBsZW4gPT09IDUgPyBtYXAkMVtzdHJbNF1dICogMTcgOiAyNTVcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDcgfHwgbGVuID09PSA5KSB7XG4gICAgICByZXQgPSB7XG4gICAgICAgIHI6IG1hcCQxW3N0clsxXV0gPDwgNCB8IG1hcCQxW3N0clsyXV0sXG4gICAgICAgIGc6IG1hcCQxW3N0clszXV0gPDwgNCB8IG1hcCQxW3N0cls0XV0sXG4gICAgICAgIGI6IG1hcCQxW3N0cls1XV0gPDwgNCB8IG1hcCQxW3N0cls2XV0sXG4gICAgICAgIGE6IGxlbiA9PT0gOSA/IChtYXAkMVtzdHJbN11dIDw8IDQgfCBtYXAkMVtzdHJbOF1dKSA6IDI1NVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmNvbnN0IGFscGhhID0gKGEsIGYpID0+IGEgPCAyNTUgPyBmKGEpIDogJyc7XG5mdW5jdGlvbiBoZXhTdHJpbmcodikge1xuICB2YXIgZiA9IGlzU2hvcnQodikgPyBoMSA6IGgyO1xuICByZXR1cm4gdlxuICAgID8gJyMnICsgZih2LnIpICsgZih2LmcpICsgZih2LmIpICsgYWxwaGEodi5hLCBmKVxuICAgIDogdW5kZWZpbmVkO1xufVxuXG5jb25zdCBIVUVfUkUgPSAvXihoc2xhP3xod2J8aHN2KVxcKFxccyooWy0rLmVcXGRdKykoPzpkZWcpP1tcXHMsXSsoWy0rLmVcXGRdKyklW1xccyxdKyhbLSsuZVxcZF0rKSUoPzpbXFxzLF0rKFstKy5lXFxkXSspKCUpPyk/XFxzKlxcKSQvO1xuZnVuY3Rpb24gaHNsMnJnYm4oaCwgcywgbCkge1xuICBjb25zdCBhID0gcyAqIE1hdGgubWluKGwsIDEgLSBsKTtcbiAgY29uc3QgZiA9IChuLCBrID0gKG4gKyBoIC8gMzApICUgMTIpID0+IGwgLSBhICogTWF0aC5tYXgoTWF0aC5taW4oayAtIDMsIDkgLSBrLCAxKSwgLTEpO1xuICByZXR1cm4gW2YoMCksIGYoOCksIGYoNCldO1xufVxuZnVuY3Rpb24gaHN2MnJnYm4oaCwgcywgdikge1xuICBjb25zdCBmID0gKG4sIGsgPSAobiArIGggLyA2MCkgJSA2KSA9PiB2IC0gdiAqIHMgKiBNYXRoLm1heChNYXRoLm1pbihrLCA0IC0gaywgMSksIDApO1xuICByZXR1cm4gW2YoNSksIGYoMyksIGYoMSldO1xufVxuZnVuY3Rpb24gaHdiMnJnYm4oaCwgdywgYikge1xuICBjb25zdCByZ2IgPSBoc2wycmdibihoLCAxLCAwLjUpO1xuICBsZXQgaTtcbiAgaWYgKHcgKyBiID4gMSkge1xuICAgIGkgPSAxIC8gKHcgKyBiKTtcbiAgICB3ICo9IGk7XG4gICAgYiAqPSBpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICByZ2JbaV0gKj0gMSAtIHcgLSBiO1xuICAgIHJnYltpXSArPSB3O1xuICB9XG4gIHJldHVybiByZ2I7XG59XG5mdW5jdGlvbiBodWVWYWx1ZShyLCBnLCBiLCBkLCBtYXgpIHtcbiAgaWYgKHIgPT09IG1heCkge1xuICAgIHJldHVybiAoKGcgLSBiKSAvIGQpICsgKGcgPCBiID8gNiA6IDApO1xuICB9XG4gIGlmIChnID09PSBtYXgpIHtcbiAgICByZXR1cm4gKGIgLSByKSAvIGQgKyAyO1xuICB9XG4gIHJldHVybiAociAtIGcpIC8gZCArIDQ7XG59XG5mdW5jdGlvbiByZ2IyaHNsKHYpIHtcbiAgY29uc3QgcmFuZ2UgPSAyNTU7XG4gIGNvbnN0IHIgPSB2LnIgLyByYW5nZTtcbiAgY29uc3QgZyA9IHYuZyAvIHJhbmdlO1xuICBjb25zdCBiID0gdi5iIC8gcmFuZ2U7XG4gIGNvbnN0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICBjb25zdCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgY29uc3QgbCA9IChtYXggKyBtaW4pIC8gMjtcbiAgbGV0IGgsIHMsIGQ7XG4gIGlmIChtYXggIT09IG1pbikge1xuICAgIGQgPSBtYXggLSBtaW47XG4gICAgcyA9IGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pO1xuICAgIGggPSBodWVWYWx1ZShyLCBnLCBiLCBkLCBtYXgpO1xuICAgIGggPSBoICogNjAgKyAwLjU7XG4gIH1cbiAgcmV0dXJuIFtoIHwgMCwgcyB8fCAwLCBsXTtcbn1cbmZ1bmN0aW9uIGNhbGxuKGYsIGEsIGIsIGMpIHtcbiAgcmV0dXJuIChcbiAgICBBcnJheS5pc0FycmF5KGEpXG4gICAgICA/IGYoYVswXSwgYVsxXSwgYVsyXSlcbiAgICAgIDogZihhLCBiLCBjKVxuICApLm1hcChuMmIpO1xufVxuZnVuY3Rpb24gaHNsMnJnYihoLCBzLCBsKSB7XG4gIHJldHVybiBjYWxsbihoc2wycmdibiwgaCwgcywgbCk7XG59XG5mdW5jdGlvbiBod2IycmdiKGgsIHcsIGIpIHtcbiAgcmV0dXJuIGNhbGxuKGh3YjJyZ2JuLCBoLCB3LCBiKTtcbn1cbmZ1bmN0aW9uIGhzdjJyZ2IoaCwgcywgdikge1xuICByZXR1cm4gY2FsbG4oaHN2MnJnYm4sIGgsIHMsIHYpO1xufVxuZnVuY3Rpb24gaHVlKGgpIHtcbiAgcmV0dXJuIChoICUgMzYwICsgMzYwKSAlIDM2MDtcbn1cbmZ1bmN0aW9uIGh1ZVBhcnNlKHN0cikge1xuICBjb25zdCBtID0gSFVFX1JFLmV4ZWMoc3RyKTtcbiAgbGV0IGEgPSAyNTU7XG4gIGxldCB2O1xuICBpZiAoIW0pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG1bNV0gIT09IHYpIHtcbiAgICBhID0gbVs2XSA/IHAyYigrbVs1XSkgOiBuMmIoK21bNV0pO1xuICB9XG4gIGNvbnN0IGggPSBodWUoK21bMl0pO1xuICBjb25zdCBwMSA9ICttWzNdIC8gMTAwO1xuICBjb25zdCBwMiA9ICttWzRdIC8gMTAwO1xuICBpZiAobVsxXSA9PT0gJ2h3YicpIHtcbiAgICB2ID0gaHdiMnJnYihoLCBwMSwgcDIpO1xuICB9IGVsc2UgaWYgKG1bMV0gPT09ICdoc3YnKSB7XG4gICAgdiA9IGhzdjJyZ2IoaCwgcDEsIHAyKTtcbiAgfSBlbHNlIHtcbiAgICB2ID0gaHNsMnJnYihoLCBwMSwgcDIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgcjogdlswXSxcbiAgICBnOiB2WzFdLFxuICAgIGI6IHZbMl0sXG4gICAgYTogYVxuICB9O1xufVxuZnVuY3Rpb24gcm90YXRlKHYsIGRlZykge1xuICB2YXIgaCA9IHJnYjJoc2wodik7XG4gIGhbMF0gPSBodWUoaFswXSArIGRlZyk7XG4gIGggPSBoc2wycmdiKGgpO1xuICB2LnIgPSBoWzBdO1xuICB2LmcgPSBoWzFdO1xuICB2LmIgPSBoWzJdO1xufVxuZnVuY3Rpb24gaHNsU3RyaW5nKHYpIHtcbiAgaWYgKCF2KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGEgPSByZ2IyaHNsKHYpO1xuICBjb25zdCBoID0gYVswXTtcbiAgY29uc3QgcyA9IG4ycChhWzFdKTtcbiAgY29uc3QgbCA9IG4ycChhWzJdKTtcbiAgcmV0dXJuIHYuYSA8IDI1NVxuICAgID8gYGhzbGEoJHtofSwgJHtzfSUsICR7bH0lLCAke2Iybih2LmEpfSlgXG4gICAgOiBgaHNsKCR7aH0sICR7c30lLCAke2x9JSlgO1xufVxuXG5jb25zdCBtYXAgPSB7XG4gIHg6ICdkYXJrJyxcbiAgWjogJ2xpZ2h0JyxcbiAgWTogJ3JlJyxcbiAgWDogJ2JsdScsXG4gIFc6ICdncicsXG4gIFY6ICdtZWRpdW0nLFxuICBVOiAnc2xhdGUnLFxuICBBOiAnZWUnLFxuICBUOiAnb2wnLFxuICBTOiAnb3InLFxuICBCOiAncmEnLFxuICBDOiAnbGF0ZWcnLFxuICBEOiAnaWdodHMnLFxuICBSOiAnaW4nLFxuICBROiAndHVycXVvaXMnLFxuICBFOiAnaGknLFxuICBQOiAncm8nLFxuICBPOiAnYWwnLFxuICBOOiAnbGUnLFxuICBNOiAnZGUnLFxuICBMOiAneWVsbG8nLFxuICBGOiAnZW4nLFxuICBLOiAnY2gnLFxuICBHOiAnYXJrcycsXG4gIEg6ICdlYScsXG4gIEk6ICdpZ2h0ZycsXG4gIEo6ICd3aCdcbn07XG5jb25zdCBuYW1lcyQxID0ge1xuICBPaWNlWGU6ICdmMGY4ZmYnLFxuICBhbnRpcXVld0V0ZTogJ2ZhZWJkNycsXG4gIGFxdWE6ICdmZmZmJyxcbiAgYXF1YW1hclJlOiAnN2ZmZmQ0JyxcbiAgYXp1WTogJ2YwZmZmZicsXG4gIGJlaWdlOiAnZjVmNWRjJyxcbiAgYmlzcXVlOiAnZmZlNGM0JyxcbiAgYmxhY2s6ICcwJyxcbiAgYmxhbktlZE9tb25kOiAnZmZlYmNkJyxcbiAgWGU6ICdmZicsXG4gIFhldmlUZXQ6ICc4YTJiZTInLFxuICBiUHduOiAnYTUyYTJhJyxcbiAgYnVybHl3b29kOiAnZGViODg3JyxcbiAgY2FNdFhlOiAnNWY5ZWEwJyxcbiAgS2FydFl1c2U6ICc3ZmZmMDAnLFxuICBLb2NUYXRlOiAnZDI2OTFlJyxcbiAgY1NPOiAnZmY3ZjUwJyxcbiAgY1NuZmxvd2VyWGU6ICc2NDk1ZWQnLFxuICBjU25zaWxrOiAnZmZmOGRjJyxcbiAgY3JpbXNvbjogJ2RjMTQzYycsXG4gIGN5YW46ICdmZmZmJyxcbiAgeFhlOiAnOGInLFxuICB4Y3lhbjogJzhiOGInLFxuICB4Z1RNblBkOiAnYjg4NjBiJyxcbiAgeFdheTogJ2E5YTlhOScsXG4gIHhnWUY6ICc2NDAwJyxcbiAgeGdZeTogJ2E5YTlhOScsXG4gIHhraGFraTogJ2JkYjc2YicsXG4gIHhtYWdGdGE6ICc4YjAwOGInLFxuICB4VGl2ZWdZRjogJzU1NmIyZicsXG4gIHhTYW5nZTogJ2ZmOGMwMCcsXG4gIHhTY0VkOiAnOTkzMmNjJyxcbiAgeFlkOiAnOGIwMDAwJyxcbiAgeHNPbW9uOiAnZTk5NjdhJyxcbiAgeHNIZ1lGOiAnOGZiYzhmJyxcbiAgeFVYZTogJzQ4M2Q4YicsXG4gIHhVV2F5OiAnMmY0ZjRmJyxcbiAgeFVnWXk6ICcyZjRmNGYnLFxuICB4UWU6ICdjZWQxJyxcbiAgeHZpVGV0OiAnOTQwMGQzJyxcbiAgZEFwcFJrOiAnZmYxNDkzJyxcbiAgZEFwc2t5WGU6ICdiZmZmJyxcbiAgZGltV2F5OiAnNjk2OTY5JyxcbiAgZGltZ1l5OiAnNjk2OTY5JyxcbiAgZG9kZ2VyWGU6ICcxZTkwZmYnLFxuICBmaVlicmljazogJ2IyMjIyMicsXG4gIGZsU093RXRlOiAnZmZmYWYwJyxcbiAgZm9Zc3RXQW46ICcyMjhiMjInLFxuICBmdUtzaWE6ICdmZjAwZmYnLFxuICBnYVJzYlNvOiAnZGNkY2RjJyxcbiAgZ2hvc3R3RXRlOiAnZjhmOGZmJyxcbiAgZ1RkOiAnZmZkNzAwJyxcbiAgZ1RNblBkOiAnZGFhNTIwJyxcbiAgV2F5OiAnODA4MDgwJyxcbiAgZ1lGOiAnODAwMCcsXG4gIGdZRkx3OiAnYWRmZjJmJyxcbiAgZ1l5OiAnODA4MDgwJyxcbiAgaG9uZXlNdzogJ2YwZmZmMCcsXG4gIGhvdHBSazogJ2ZmNjliNCcsXG4gIFJkaWFuWWQ6ICdjZDVjNWMnLFxuICBSZGlnbzogJzRiMDA4MicsXG4gIGl2U3k6ICdmZmZmZjAnLFxuICBraGFraTogJ2YwZTY4YycsXG4gIGxhdkZNcjogJ2U2ZTZmYScsXG4gIGxhdkZNclhzaDogJ2ZmZjBmNScsXG4gIGxhd25nWUY6ICc3Y2ZjMDAnLFxuICBObW9uY0VmZm9uOiAnZmZmYWNkJyxcbiAgWlhlOiAnYWRkOGU2JyxcbiAgWmNTTzogJ2YwODA4MCcsXG4gIFpjeWFuOiAnZTBmZmZmJyxcbiAgWmdUTW5QZEx3OiAnZmFmYWQyJyxcbiAgWldheTogJ2QzZDNkMycsXG4gIFpnWUY6ICc5MGVlOTAnLFxuICBaZ1l5OiAnZDNkM2QzJyxcbiAgWnBSazogJ2ZmYjZjMScsXG4gIFpzT21vbjogJ2ZmYTA3YScsXG4gIFpzSGdZRjogJzIwYjJhYScsXG4gIFpza3lYZTogJzg3Y2VmYScsXG4gIFpVV2F5OiAnNzc4ODk5JyxcbiAgWlVnWXk6ICc3Nzg4OTknLFxuICBac3RBbFhlOiAnYjBjNGRlJyxcbiAgWkx3OiAnZmZmZmUwJyxcbiAgbGltZTogJ2ZmMDAnLFxuICBsaW1lZ1lGOiAnMzJjZDMyJyxcbiAgbFJGOiAnZmFmMGU2JyxcbiAgbWFnRnRhOiAnZmYwMGZmJyxcbiAgbWFQb246ICc4MDAwMDAnLFxuICBWYXF1YW1hclJlOiAnNjZjZGFhJyxcbiAgVlhlOiAnY2QnLFxuICBWU2NFZDogJ2JhNTVkMycsXG4gIFZwdXJwTjogJzkzNzBkYicsXG4gIFZzSGdZRjogJzNjYjM3MScsXG4gIFZVWGU6ICc3YjY4ZWUnLFxuICBWc3ByUmdnWUY6ICdmYTlhJyxcbiAgVlFlOiAnNDhkMWNjJyxcbiAgVnZpVGV0WWQ6ICdjNzE1ODUnLFxuICBtaWRuaWdodFhlOiAnMTkxOTcwJyxcbiAgbVJ0Y1lhbTogJ2Y1ZmZmYScsXG4gIG1pc3R5UHNlOiAnZmZlNGUxJyxcbiAgbW9jY2FzUjogJ2ZmZTRiNScsXG4gIG5hdmFqb3dFdGU6ICdmZmRlYWQnLFxuICBuYXZ5OiAnODAnLFxuICBUZGxhY2U6ICdmZGY1ZTYnLFxuICBUaXZlOiAnODA4MDAwJyxcbiAgVGl2ZWRCYjogJzZiOGUyMycsXG4gIFNhbmdlOiAnZmZhNTAwJyxcbiAgU2FuZ2VZZDogJ2ZmNDUwMCcsXG4gIFNjRWQ6ICdkYTcwZDYnLFxuICBwT2VnVE1uUGQ6ICdlZWU4YWEnLFxuICBwT2VnWUY6ICc5OGZiOTgnLFxuICBwT2VRZTogJ2FmZWVlZScsXG4gIHBPZXZpVGV0WWQ6ICdkYjcwOTMnLFxuICBwYXBheWF3RXA6ICdmZmVmZDUnLFxuICBwSEtwdWZmOiAnZmZkYWI5JyxcbiAgcGVydTogJ2NkODUzZicsXG4gIHBSazogJ2ZmYzBjYicsXG4gIHBsdW06ICdkZGEwZGQnLFxuICBwb3dNclhlOiAnYjBlMGU2JyxcbiAgcHVycE46ICc4MDAwODAnLFxuICBZYmVjY2FwdXJwTjogJzY2MzM5OScsXG4gIFlkOiAnZmYwMDAwJyxcbiAgUHN5YnJvd246ICdiYzhmOGYnLFxuICBQeU9YZTogJzQxNjllMScsXG4gIHNhZGROYlB3bjogJzhiNDUxMycsXG4gIHNPbW9uOiAnZmE4MDcyJyxcbiAgc2FuZHliUHduOiAnZjRhNDYwJyxcbiAgc0hnWUY6ICcyZThiNTcnLFxuICBzSHNoZWxsOiAnZmZmNWVlJyxcbiAgc2lGbmE6ICdhMDUyMmQnLFxuICBzaWx2ZXI6ICdjMGMwYzAnLFxuICBza3lYZTogJzg3Y2VlYicsXG4gIFVYZTogJzZhNWFjZCcsXG4gIFVXYXk6ICc3MDgwOTAnLFxuICBVZ1l5OiAnNzA4MDkwJyxcbiAgc25vdzogJ2ZmZmFmYScsXG4gIHNwclJnZ1lGOiAnZmY3ZicsXG4gIHN0QWxYZTogJzQ2ODJiNCcsXG4gIHRhbjogJ2QyYjQ4YycsXG4gIHRlTzogJzgwODAnLFxuICB0RXN0TjogJ2Q4YmZkOCcsXG4gIHRvbWF0bzogJ2ZmNjM0NycsXG4gIFFlOiAnNDBlMGQwJyxcbiAgdmlUZXQ6ICdlZTgyZWUnLFxuICBKSHQ6ICdmNWRlYjMnLFxuICB3RXRlOiAnZmZmZmZmJyxcbiAgd0V0ZXNtb2tlOiAnZjVmNWY1JyxcbiAgTHc6ICdmZmZmMDAnLFxuICBMd2dZRjogJzlhY2QzMidcbn07XG5mdW5jdGlvbiB1bnBhY2soKSB7XG4gIGNvbnN0IHVucGFja2VkID0ge307XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhuYW1lcyQxKTtcbiAgY29uc3QgdGtleXMgPSBPYmplY3Qua2V5cyhtYXApO1xuICBsZXQgaSwgaiwgaywgb2ssIG5rO1xuICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIG9rID0gbmsgPSBrZXlzW2ldO1xuICAgIGZvciAoaiA9IDA7IGogPCB0a2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgayA9IHRrZXlzW2pdO1xuICAgICAgbmsgPSBuay5yZXBsYWNlKGssIG1hcFtrXSk7XG4gICAgfVxuICAgIGsgPSBwYXJzZUludChuYW1lcyQxW29rXSwgMTYpO1xuICAgIHVucGFja2VkW25rXSA9IFtrID4+IDE2ICYgMHhGRiwgayA+PiA4ICYgMHhGRiwgayAmIDB4RkZdO1xuICB9XG4gIHJldHVybiB1bnBhY2tlZDtcbn1cblxubGV0IG5hbWVzO1xuZnVuY3Rpb24gbmFtZVBhcnNlKHN0cikge1xuICBpZiAoIW5hbWVzKSB7XG4gICAgbmFtZXMgPSB1bnBhY2soKTtcbiAgICBuYW1lcy50cmFuc3BhcmVudCA9IFswLCAwLCAwLCAwXTtcbiAgfVxuICBjb25zdCBhID0gbmFtZXNbc3RyLnRvTG93ZXJDYXNlKCldO1xuICByZXR1cm4gYSAmJiB7XG4gICAgcjogYVswXSxcbiAgICBnOiBhWzFdLFxuICAgIGI6IGFbMl0sXG4gICAgYTogYS5sZW5ndGggPT09IDQgPyBhWzNdIDogMjU1XG4gIH07XG59XG5cbmNvbnN0IFJHQl9SRSA9IC9ecmdiYT9cXChcXHMqKFstKy5cXGRdKykoJSk/W1xccyxdKyhbLSsuZVxcZF0rKSglKT9bXFxzLF0rKFstKy5lXFxkXSspKCUpPyg/OltcXHMsL10rKFstKy5lXFxkXSspKCUpPyk/XFxzKlxcKSQvO1xuZnVuY3Rpb24gcmdiUGFyc2Uoc3RyKSB7XG4gIGNvbnN0IG0gPSBSR0JfUkUuZXhlYyhzdHIpO1xuICBsZXQgYSA9IDI1NTtcbiAgbGV0IHIsIGcsIGI7XG4gIGlmICghbSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobVs3XSAhPT0gcikge1xuICAgIGNvbnN0IHYgPSArbVs3XTtcbiAgICBhID0gbVs4XSA/IHAyYih2KSA6IGxpbSh2ICogMjU1LCAwLCAyNTUpO1xuICB9XG4gIHIgPSArbVsxXTtcbiAgZyA9ICttWzNdO1xuICBiID0gK21bNV07XG4gIHIgPSAyNTUgJiAobVsyXSA/IHAyYihyKSA6IGxpbShyLCAwLCAyNTUpKTtcbiAgZyA9IDI1NSAmIChtWzRdID8gcDJiKGcpIDogbGltKGcsIDAsIDI1NSkpO1xuICBiID0gMjU1ICYgKG1bNl0gPyBwMmIoYikgOiBsaW0oYiwgMCwgMjU1KSk7XG4gIHJldHVybiB7XG4gICAgcjogcixcbiAgICBnOiBnLFxuICAgIGI6IGIsXG4gICAgYTogYVxuICB9O1xufVxuZnVuY3Rpb24gcmdiU3RyaW5nKHYpIHtcbiAgcmV0dXJuIHYgJiYgKFxuICAgIHYuYSA8IDI1NVxuICAgICAgPyBgcmdiYSgke3Yucn0sICR7di5nfSwgJHt2LmJ9LCAke2Iybih2LmEpfSlgXG4gICAgICA6IGByZ2IoJHt2LnJ9LCAke3YuZ30sICR7di5ifSlgXG4gICk7XG59XG5cbmNvbnN0IHRvID0gdiA9PiB2IDw9IDAuMDAzMTMwOCA/IHYgKiAxMi45MiA6IE1hdGgucG93KHYsIDEuMCAvIDIuNCkgKiAxLjA1NSAtIDAuMDU1O1xuY29uc3QgZnJvbSA9IHYgPT4gdiA8PSAwLjA0MDQ1ID8gdiAvIDEyLjkyIDogTWF0aC5wb3coKHYgKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbmZ1bmN0aW9uIGludGVycG9sYXRlKHJnYjEsIHJnYjIsIHQpIHtcbiAgY29uc3QgciA9IGZyb20oYjJuKHJnYjEucikpO1xuICBjb25zdCBnID0gZnJvbShiMm4ocmdiMS5nKSk7XG4gIGNvbnN0IGIgPSBmcm9tKGIybihyZ2IxLmIpKTtcbiAgcmV0dXJuIHtcbiAgICByOiBuMmIodG8ociArIHQgKiAoZnJvbShiMm4ocmdiMi5yKSkgLSByKSkpLFxuICAgIGc6IG4yYih0byhnICsgdCAqIChmcm9tKGIybihyZ2IyLmcpKSAtIGcpKSksXG4gICAgYjogbjJiKHRvKGIgKyB0ICogKGZyb20oYjJuKHJnYjIuYikpIC0gYikpKSxcbiAgICBhOiByZ2IxLmEgKyB0ICogKHJnYjIuYSAtIHJnYjEuYSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gbW9kSFNMKHYsIGksIHJhdGlvKSB7XG4gIGlmICh2KSB7XG4gICAgbGV0IHRtcCA9IHJnYjJoc2wodik7XG4gICAgdG1wW2ldID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odG1wW2ldICsgdG1wW2ldICogcmF0aW8sIGkgPT09IDAgPyAzNjAgOiAxKSk7XG4gICAgdG1wID0gaHNsMnJnYih0bXApO1xuICAgIHYuciA9IHRtcFswXTtcbiAgICB2LmcgPSB0bXBbMV07XG4gICAgdi5iID0gdG1wWzJdO1xuICB9XG59XG5mdW5jdGlvbiBjbG9uZSh2LCBwcm90bykge1xuICByZXR1cm4gdiA/IE9iamVjdC5hc3NpZ24ocHJvdG8gfHwge30sIHYpIDogdjtcbn1cbmZ1bmN0aW9uIGZyb21PYmplY3QoaW5wdXQpIHtcbiAgdmFyIHYgPSB7cjogMCwgZzogMCwgYjogMCwgYTogMjU1fTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgaWYgKGlucHV0Lmxlbmd0aCA+PSAzKSB7XG4gICAgICB2ID0ge3I6IGlucHV0WzBdLCBnOiBpbnB1dFsxXSwgYjogaW5wdXRbMl0sIGE6IDI1NX07XG4gICAgICBpZiAoaW5wdXQubGVuZ3RoID4gMykge1xuICAgICAgICB2LmEgPSBuMmIoaW5wdXRbM10pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2ID0gY2xvbmUoaW5wdXQsIHtyOiAwLCBnOiAwLCBiOiAwLCBhOiAxfSk7XG4gICAgdi5hID0gbjJiKHYuYSk7XG4gIH1cbiAgcmV0dXJuIHY7XG59XG5mdW5jdGlvbiBmdW5jdGlvblBhcnNlKHN0cikge1xuICBpZiAoc3RyLmNoYXJBdCgwKSA9PT0gJ3InKSB7XG4gICAgcmV0dXJuIHJnYlBhcnNlKHN0cik7XG4gIH1cbiAgcmV0dXJuIGh1ZVBhcnNlKHN0cik7XG59XG5jbGFzcyBDb2xvciB7XG4gIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQ29sb3IpIHtcbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBpbnB1dDtcbiAgICBsZXQgdjtcbiAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHYgPSBmcm9tT2JqZWN0KGlucHV0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2ID0gaGV4UGFyc2UoaW5wdXQpIHx8IG5hbWVQYXJzZShpbnB1dCkgfHwgZnVuY3Rpb25QYXJzZShpbnB1dCk7XG4gICAgfVxuICAgIHRoaXMuX3JnYiA9IHY7XG4gICAgdGhpcy5fdmFsaWQgPSAhIXY7XG4gIH1cbiAgZ2V0IHZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZDtcbiAgfVxuICBnZXQgcmdiKCkge1xuICAgIHZhciB2ID0gY2xvbmUodGhpcy5fcmdiKTtcbiAgICBpZiAodikge1xuICAgICAgdi5hID0gYjJuKHYuYSk7XG4gICAgfVxuICAgIHJldHVybiB2O1xuICB9XG4gIHNldCByZ2Iob2JqKSB7XG4gICAgdGhpcy5fcmdiID0gZnJvbU9iamVjdChvYmopO1xuICB9XG4gIHJnYlN0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWQgPyByZ2JTdHJpbmcodGhpcy5fcmdiKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBoZXhTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkID8gaGV4U3RyaW5nKHRoaXMuX3JnYikgOiB1bmRlZmluZWQ7XG4gIH1cbiAgaHNsU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZCA/IGhzbFN0cmluZyh0aGlzLl9yZ2IpIDogdW5kZWZpbmVkO1xuICB9XG4gIG1peChjb2xvciwgd2VpZ2h0KSB7XG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICBjb25zdCBjMSA9IHRoaXMucmdiO1xuICAgICAgY29uc3QgYzIgPSBjb2xvci5yZ2I7XG4gICAgICBsZXQgdzI7XG4gICAgICBjb25zdCBwID0gd2VpZ2h0ID09PSB3MiA/IDAuNSA6IHdlaWdodDtcbiAgICAgIGNvbnN0IHcgPSAyICogcCAtIDE7XG4gICAgICBjb25zdCBhID0gYzEuYSAtIGMyLmE7XG4gICAgICBjb25zdCB3MSA9ICgodyAqIGEgPT09IC0xID8gdyA6ICh3ICsgYSkgLyAoMSArIHcgKiBhKSkgKyAxKSAvIDIuMDtcbiAgICAgIHcyID0gMSAtIHcxO1xuICAgICAgYzEuciA9IDB4RkYgJiB3MSAqIGMxLnIgKyB3MiAqIGMyLnIgKyAwLjU7XG4gICAgICBjMS5nID0gMHhGRiAmIHcxICogYzEuZyArIHcyICogYzIuZyArIDAuNTtcbiAgICAgIGMxLmIgPSAweEZGICYgdzEgKiBjMS5iICsgdzIgKiBjMi5iICsgMC41O1xuICAgICAgYzEuYSA9IHAgKiBjMS5hICsgKDEgLSBwKSAqIGMyLmE7XG4gICAgICB0aGlzLnJnYiA9IGMxO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpbnRlcnBvbGF0ZShjb2xvciwgdCkge1xuICAgIGlmIChjb2xvcikge1xuICAgICAgdGhpcy5fcmdiID0gaW50ZXJwb2xhdGUodGhpcy5fcmdiLCBjb2xvci5fcmdiLCB0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBDb2xvcih0aGlzLnJnYik7XG4gIH1cbiAgYWxwaGEoYSkge1xuICAgIHRoaXMuX3JnYi5hID0gbjJiKGEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNsZWFyZXIocmF0aW8pIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgcmdiLmEgKj0gMSAtIHJhdGlvO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdyZXlzY2FsZSgpIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgY29uc3QgdmFsID0gcm91bmQocmdiLnIgKiAwLjMgKyByZ2IuZyAqIDAuNTkgKyByZ2IuYiAqIDAuMTEpO1xuICAgIHJnYi5yID0gcmdiLmcgPSByZ2IuYiA9IHZhbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBvcGFxdWVyKHJhdGlvKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5fcmdiO1xuICAgIHJnYi5hICo9IDEgKyByYXRpbztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBuZWdhdGUoKSB7XG4gICAgY29uc3QgdiA9IHRoaXMuX3JnYjtcbiAgICB2LnIgPSAyNTUgLSB2LnI7XG4gICAgdi5nID0gMjU1IC0gdi5nO1xuICAgIHYuYiA9IDI1NSAtIHYuYjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBsaWdodGVuKHJhdGlvKSB7XG4gICAgbW9kSFNMKHRoaXMuX3JnYiwgMiwgcmF0aW8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGRhcmtlbihyYXRpbykge1xuICAgIG1vZEhTTCh0aGlzLl9yZ2IsIDIsIC1yYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2F0dXJhdGUocmF0aW8pIHtcbiAgICBtb2RIU0wodGhpcy5fcmdiLCAxLCByYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZGVzYXR1cmF0ZShyYXRpbykge1xuICAgIG1vZEhTTCh0aGlzLl9yZ2IsIDEsIC1yYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcm90YXRlKGRlZykge1xuICAgIHJvdGF0ZSh0aGlzLl9yZ2IsIGRlZyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhfZXNtKGlucHV0KSB7XG4gIHJldHVybiBuZXcgQ29sb3IoaW5wdXQpO1xufVxuXG5leHBvcnQgeyBDb2xvciwgYjJuLCBiMnAsIGluZGV4X2VzbSBhcyBkZWZhdWx0LCBoZXhQYXJzZSwgaGV4U3RyaW5nLCBoc2wycmdiLCBoc2xTdHJpbmcsIGhzdjJyZ2IsIGh1ZVBhcnNlLCBod2IycmdiLCBsaW0sIG4yYiwgbjJwLCBuYW1lUGFyc2UsIHAyYiwgcmdiMmhzbCwgcmdiUGFyc2UsIHJnYlN0cmluZywgcm90YXRlLCByb3VuZCB9O1xuIiwgIi8qKlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzXG4gKi9cblxuaW1wb3J0IHR5cGUge0FueU9iamVjdH0gZnJvbSAnLi4vdHlwZXMvYmFzaWMuanMnO1xuaW1wb3J0IHR5cGUge0FjdGl2ZURhdGFQb2ludCwgQ2hhcnRFdmVudH0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuXG4vKipcbiAqIEFuIGVtcHR5IGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQsIGZvciBleGFtcGxlLCBmb3Igb3B0aW9uYWwgY2FsbGJhY2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub29wKCkge1xuICAvKiBub29wICovXG59XG5cbi8qKlxuICogUmV0dXJucyBhIHVuaXF1ZSBpZCwgc2VxdWVudGlhbGx5IGdlbmVyYXRlZCBmcm9tIGEgZ2xvYmFsIHZhcmlhYmxlLlxuICovXG5leHBvcnQgY29uc3QgdWlkID0gKCgpID0+IHtcbiAgbGV0IGlkID0gMDtcbiAgcmV0dXJuICgpID0+IGlkKys7XG59KSgpO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIG5laXRoZXIgbnVsbCBub3IgdW5kZWZpbmVkLCBlbHNlIHJldHVybnMgZmFsc2UuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOdWxsT3JVbmRlZih2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIG51bGwgfCB1bmRlZmluZWQge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSAoaW5jbHVkaW5nIHR5cGVkIGFycmF5cyksIGVsc2UgcmV0dXJucyBmYWxzZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FycmF5PFQgPSB1bmtub3duPih2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIFRbXSB7XG4gIGlmIChBcnJheS5pc0FycmF5ICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh0eXBlLnNsaWNlKDAsIDcpID09PSAnW29iamVjdCcgJiYgdHlwZS5zbGljZSgtNikgPT09ICdBcnJheV0nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCAoZXhjbHVkaW5nIG51bGwpLCBlbHNlIHJldHVybnMgZmFsc2UuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBBbnlPYmplY3Qge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgbnVtYmVyLCBlbHNlIHJldHVybnMgZmFsc2VcbiAqIEBwYXJhbSB2YWx1ZSAgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXJGaW5pdGUodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBudW1iZXIge1xuICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpICYmIGlzRmluaXRlKCt2YWx1ZSk7XG59XG5leHBvcnQge1xuICBpc051bWJlckZpbml0ZSBhcyBpc0Zpbml0ZSxcbn07XG5cbi8qKlxuICogUmV0dXJucyBgdmFsdWVgIGlmIGZpbml0ZSwgZWxzZSByZXR1cm5zIGBkZWZhdWx0VmFsdWVgLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHJldHVybiBpZiBkZWZpbmVkLlxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSAtIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgYHZhbHVlYCBpcyBub3QgZmluaXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluaXRlT3JEZWZhdWx0KHZhbHVlOiB1bmtub3duLCBkZWZhdWx0VmFsdWU6IG51bWJlcikge1xuICByZXR1cm4gaXNOdW1iZXJGaW5pdGUodmFsdWUpID8gdmFsdWUgOiBkZWZhdWx0VmFsdWU7XG59XG5cbi8qKlxuICogUmV0dXJucyBgdmFsdWVgIGlmIGRlZmluZWQsIGVsc2UgcmV0dXJucyBgZGVmYXVsdFZhbHVlYC5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgZGVmaW5lZC5cbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgLSBUaGUgdmFsdWUgdG8gcmV0dXJuIGlmIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsdWVPckRlZmF1bHQ8VD4odmFsdWU6IFQgfCB1bmRlZmluZWQsIGRlZmF1bHRWYWx1ZTogVCkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xufVxuXG5leHBvcnQgY29uc3QgdG9QZXJjZW50YWdlID0gKHZhbHVlOiBudW1iZXIgfCBzdHJpbmcsIGRpbWVuc2lvbjogbnVtYmVyKSA9PlxuICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmVuZHNXaXRoKCclJykgP1xuICAgIHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwXG4gICAgOiArdmFsdWUgLyBkaW1lbnNpb247XG5cbmV4cG9ydCBjb25zdCB0b0RpbWVuc2lvbiA9ICh2YWx1ZTogbnVtYmVyIHwgc3RyaW5nLCBkaW1lbnNpb246IG51bWJlcikgPT5cbiAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5lbmRzV2l0aCgnJScpID9cbiAgICBwYXJzZUZsb2F0KHZhbHVlKSAvIDEwMCAqIGRpbWVuc2lvblxuICAgIDogK3ZhbHVlO1xuXG4vKipcbiAqIENhbGxzIGBmbmAgd2l0aCB0aGUgZ2l2ZW4gYGFyZ3NgIGluIHRoZSBzY29wZSBkZWZpbmVkIGJ5IGB0aGlzQXJnYCBhbmQgcmV0dXJucyB0aGVcbiAqIHZhbHVlIHJldHVybmVkIGJ5IGBmbmAuIElmIGBmbmAgaXMgbm90IGEgZnVuY3Rpb24sIHRoaXMgbWV0aG9kIHJldHVybnMgdW5kZWZpbmVkLlxuICogQHBhcmFtIGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG4gKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgd2l0aCB3aGljaCBgZm5gIHNob3VsZCBiZSBjYWxsZWQuXG4gKiBAcGFyYW0gW3RoaXNBcmddIC0gVGhlIHZhbHVlIG9mIGB0aGlzYCBwcm92aWRlZCBmb3IgdGhlIGNhbGwgdG8gYGZuYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGxiYWNrPFQgZXh0ZW5kcyAodGhpczogVEEsIC4uLnJlc3RBcmdzOiB1bmtub3duW10pID0+IFIsIFRBLCBSPihcbiAgZm46IFQgfCB1bmRlZmluZWQsXG4gIGFyZ3M6IHVua25vd25bXSxcbiAgdGhpc0FyZz86IFRBXG4pOiBSIHwgdW5kZWZpbmVkIHtcbiAgaWYgKGZuICYmIHR5cGVvZiBmbi5jYWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9XG59XG5cbi8qKlxuICogTm90ZShTQikgZm9yIHBlcmZvcm1hbmNlIHNha2UsIHRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiBsb29wYWJsZSB0eXBlXG4gKiBpcyB1bmtub3duIG9yIGluIG5vbmUgaW50ZW5zaXZlIGNvZGUgKG5vdCBjYWxsZWQgb2Z0ZW4gYW5kIHNtYWxsIGxvb3BhYmxlKS4gRWxzZVxuICogaXQncyBwcmVmZXJhYmxlIHRvIHVzZSBhIHJlZ3VsYXIgZm9yKCkgbG9vcCBhbmQgc2F2ZSBleHRyYSBmdW5jdGlvbiBjYWxscy5cbiAqIEBwYXJhbSBsb29wYWJsZSAtIFRoZSBvYmplY3Qgb3IgYXJyYXkgdG8gYmUgaXRlcmF0ZWQuXG4gKiBAcGFyYW0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpdGVtLlxuICogQHBhcmFtIFt0aGlzQXJnXSAtIFRoZSB2YWx1ZSBvZiBgdGhpc2AgcHJvdmlkZWQgZm9yIHRoZSBjYWxsIHRvIGBmbmAuXG4gKiBAcGFyYW0gW3JldmVyc2VdIC0gSWYgdHJ1ZSwgaXRlcmF0ZXMgYmFja3dhcmQgb24gdGhlIGxvb3BhYmxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZWFjaDxULCBUQT4oXG4gIGxvb3BhYmxlOiBSZWNvcmQ8c3RyaW5nLCBUPixcbiAgZm46ICh0aGlzOiBUQSwgdjogVCwgaTogc3RyaW5nKSA9PiB2b2lkLFxuICB0aGlzQXJnPzogVEEsXG4gIHJldmVyc2U/OiBib29sZWFuXG4pOiB2b2lkO1xuZXhwb3J0IGZ1bmN0aW9uIGVhY2g8VCwgVEE+KFxuICBsb29wYWJsZTogVFtdLFxuICBmbjogKHRoaXM6IFRBLCB2OiBULCBpOiBudW1iZXIpID0+IHZvaWQsXG4gIHRoaXNBcmc/OiBUQSxcbiAgcmV2ZXJzZT86IGJvb2xlYW5cbik6IHZvaWQ7XG5leHBvcnQgZnVuY3Rpb24gZWFjaDxULCBUQT4oXG4gIGxvb3BhYmxlOiBUW10gfCBSZWNvcmQ8c3RyaW5nLCBUPixcbiAgZm46ICh0aGlzOiBUQSwgdjogVCwgaTogYW55KSA9PiB2b2lkLFxuICB0aGlzQXJnPzogVEEsXG4gIHJldmVyc2U/OiBib29sZWFuXG4pIHtcbiAgbGV0IGk6IG51bWJlciwgbGVuOiBudW1iZXIsIGtleXM6IHN0cmluZ1tdO1xuICBpZiAoaXNBcnJheShsb29wYWJsZSkpIHtcbiAgICBsZW4gPSBsb29wYWJsZS5sZW5ndGg7XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVbaV0sIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtpXSwgaSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxvb3BhYmxlKSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyhsb29wYWJsZSk7XG4gICAgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2tleXNbaV1dLCBrZXlzW2ldKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGBhMGAgYW5kIGBhMWAgYXJyYXlzIGhhdmUgdGhlIHNhbWUgY29udGVudCwgZWxzZSByZXR1cm5zIGZhbHNlLlxuICogQHBhcmFtIGEwIC0gVGhlIGFycmF5IHRvIGNvbXBhcmVcbiAqIEBwYXJhbSBhMSAtIFRoZSBhcnJheSB0byBjb21wYXJlXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2VsZW1lbnRzRXF1YWwoYTA6IEFjdGl2ZURhdGFQb2ludFtdLCBhMTogQWN0aXZlRGF0YVBvaW50W10pIHtcbiAgbGV0IGk6IG51bWJlciwgaWxlbjogbnVtYmVyLCB2MDogQWN0aXZlRGF0YVBvaW50LCB2MTogQWN0aXZlRGF0YVBvaW50O1xuXG4gIGlmICghYTAgfHwgIWExIHx8IGEwLmxlbmd0aCAhPT0gYTEubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IGEwLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIHYwID0gYTBbaV07XG4gICAgdjEgPSBhMVtpXTtcblxuICAgIGlmICh2MC5kYXRhc2V0SW5kZXggIT09IHYxLmRhdGFzZXRJbmRleCB8fCB2MC5pbmRleCAhPT0gdjEuaW5kZXgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZGVlcCBjb3B5IG9mIGBzb3VyY2VgIHdpdGhvdXQga2VlcGluZyByZWZlcmVuY2VzIG9uIG9iamVjdHMgYW5kIGFycmF5cy5cbiAqIEBwYXJhbSBzb3VyY2UgLSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZTxUPihzb3VyY2U6IFQpOiBUIHtcbiAgaWYgKGlzQXJyYXkoc291cmNlKSkge1xuICAgIHJldHVybiBzb3VyY2UubWFwKGNsb25lKSBhcyB1bmtub3duIGFzIFQ7XG4gIH1cblxuICBpZiAoaXNPYmplY3Qoc291cmNlKSkge1xuICAgIGNvbnN0IHRhcmdldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgY29uc3Qga2xlbiA9IGtleXMubGVuZ3RoO1xuICAgIGxldCBrID0gMDtcblxuICAgIGZvciAoOyBrIDwga2xlbjsgKytrKSB7XG4gICAgICB0YXJnZXRba2V5c1trXV0gPSBjbG9uZShzb3VyY2Vba2V5c1trXV0pO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICByZXR1cm4gc291cmNlO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleTogc3RyaW5nKSB7XG4gIHJldHVybiBbJ19fcHJvdG9fXycsICdwcm90b3R5cGUnLCAnY29uc3RydWN0b3InXS5pbmRleE9mKGtleSkgPT09IC0xO1xufVxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IG1lcmdlciB3aGVuIENoYXJ0LmhlbHBlcnMubWVyZ2UgaXMgY2FsbGVkIHdpdGhvdXQgbWVyZ2VyIG9wdGlvbi5cbiAqIE5vdGUoU0IpOiBhbHNvIHVzZWQgYnkgbWVyZ2VDb25maWcgYW5kIG1lcmdlU2NhbGVDb25maWcgYXMgZmFsbGJhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX21lcmdlcihrZXk6IHN0cmluZywgdGFyZ2V0OiBBbnlPYmplY3QsIHNvdXJjZTogQW55T2JqZWN0LCBvcHRpb25zOiBBbnlPYmplY3QpIHtcbiAgaWYgKCFpc1ZhbGlkS2V5KGtleSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB0dmFsID0gdGFyZ2V0W2tleV07XG4gIGNvbnN0IHN2YWwgPSBzb3VyY2Vba2V5XTtcblxuICBpZiAoaXNPYmplY3QodHZhbCkgJiYgaXNPYmplY3Qoc3ZhbCkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgbWVyZ2UodHZhbCwgc3ZhbCwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0W2tleV0gPSBjbG9uZShzdmFsKTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1lcmdlT3B0aW9ucyB7XG4gIG1lcmdlcj86IChrZXk6IHN0cmluZywgdGFyZ2V0OiBBbnlPYmplY3QsIHNvdXJjZTogQW55T2JqZWN0LCBvcHRpb25zPzogQW55T2JqZWN0KSA9PiB2b2lkO1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGRlZXAgY29waWVzIGBzb3VyY2VgIHByb3BlcnRpZXMgaW50byBgdGFyZ2V0YCB3aXRoIHRoZSBnaXZlbiBgb3B0aW9uc2AuXG4gKiBJTVBPUlRBTlQ6IGB0YXJnZXRgIGlzIG5vdCBjbG9uZWQgYW5kIHdpbGwgYmUgdXBkYXRlZCB3aXRoIGBzb3VyY2VgIHByb3BlcnRpZXMuXG4gKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHRhcmdldCBvYmplY3QgaW4gd2hpY2ggYWxsIHNvdXJjZXMgYXJlIG1lcmdlZCBpbnRvLlxuICogQHBhcmFtIHNvdXJjZSAtIE9iamVjdChzKSB0byBtZXJnZSBpbnRvIGB0YXJnZXRgLlxuICogQHBhcmFtIFtvcHRpb25zXSAtIE1lcmdpbmcgb3B0aW9uczpcbiAqIEBwYXJhbSBbb3B0aW9ucy5tZXJnZXJdIC0gVGhlIG1lcmdlIG1ldGhvZCAoa2V5LCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucylcbiAqIEByZXR1cm5zIFRoZSBgdGFyZ2V0YCBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZTxUPih0YXJnZXQ6IFQsIHNvdXJjZTogW10sIG9wdGlvbnM/OiBNZXJnZU9wdGlvbnMpOiBUO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQsIFMxPih0YXJnZXQ6IFQsIHNvdXJjZTogUzEsIG9wdGlvbnM/OiBNZXJnZU9wdGlvbnMpOiBUICYgUzE7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VCwgUzE+KHRhcmdldDogVCwgc291cmNlOiBbUzFdLCBvcHRpb25zPzogTWVyZ2VPcHRpb25zKTogVCAmIFMxO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQsIFMxLCBTMj4odGFyZ2V0OiBULCBzb3VyY2U6IFtTMSwgUzJdLCBvcHRpb25zPzogTWVyZ2VPcHRpb25zKTogVCAmIFMxICYgUzI7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VCwgUzEsIFMyLCBTMz4odGFyZ2V0OiBULCBzb3VyY2U6IFtTMSwgUzIsIFMzXSwgb3B0aW9ucz86IE1lcmdlT3B0aW9ucyk6IFQgJiBTMSAmIFMyICYgUzM7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VCwgUzEsIFMyLCBTMywgUzQ+KFxuICB0YXJnZXQ6IFQsXG4gIHNvdXJjZTogW1MxLCBTMiwgUzMsIFM0XSxcbiAgb3B0aW9ucz86IE1lcmdlT3B0aW9uc1xuKTogVCAmIFMxICYgUzIgJiBTMyAmIFM0O1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQ+KHRhcmdldDogVCwgc291cmNlOiBBbnlPYmplY3RbXSwgb3B0aW9ucz86IE1lcmdlT3B0aW9ucyk6IEFueU9iamVjdDtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZTxUPih0YXJnZXQ6IFQsIHNvdXJjZTogQW55T2JqZWN0W10sIG9wdGlvbnM/OiBNZXJnZU9wdGlvbnMpOiBBbnlPYmplY3Qge1xuICBjb25zdCBzb3VyY2VzID0gaXNBcnJheShzb3VyY2UpID8gc291cmNlIDogW3NvdXJjZV07XG4gIGNvbnN0IGlsZW4gPSBzb3VyY2VzLmxlbmd0aDtcblxuICBpZiAoIWlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0IGFzIEFueU9iamVjdDtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBtZXJnZXIgPSBvcHRpb25zLm1lcmdlciB8fCBfbWVyZ2VyO1xuICBsZXQgY3VycmVudDogQW55T2JqZWN0O1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY3VycmVudCA9IHNvdXJjZXNbaV07XG4gICAgaWYgKCFpc09iamVjdChjdXJyZW50KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGN1cnJlbnQpO1xuICAgIGZvciAobGV0IGsgPSAwLCBrbGVuID0ga2V5cy5sZW5ndGg7IGsgPCBrbGVuOyArK2spIHtcbiAgICAgIG1lcmdlcihrZXlzW2tdLCB0YXJnZXQsIGN1cnJlbnQsIG9wdGlvbnMgYXMgQW55T2JqZWN0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGRlZXAgY29waWVzIGBzb3VyY2VgIHByb3BlcnRpZXMgaW50byBgdGFyZ2V0YCAqb25seSogaWYgbm90IGRlZmluZWQgaW4gdGFyZ2V0LlxuICogSU1QT1JUQU5UOiBgdGFyZ2V0YCBpcyBub3QgY2xvbmVkIGFuZCB3aWxsIGJlIHVwZGF0ZWQgd2l0aCBgc291cmNlYCBwcm9wZXJ0aWVzLlxuICogQHBhcmFtIHRhcmdldCAtIFRoZSB0YXJnZXQgb2JqZWN0IGluIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSBtZXJnZWQgaW50by5cbiAqIEBwYXJhbSBzb3VyY2UgLSBPYmplY3QocykgdG8gbWVyZ2UgaW50byBgdGFyZ2V0YC5cbiAqIEByZXR1cm5zIFRoZSBgdGFyZ2V0YCBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUlmPFQ+KHRhcmdldDogVCwgc291cmNlOiBbXSk6IFQ7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VJZjxULCBTMT4odGFyZ2V0OiBULCBzb3VyY2U6IFMxKTogVCAmIFMxO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VCwgUzE+KHRhcmdldDogVCwgc291cmNlOiBbUzFdKTogVCAmIFMxO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VCwgUzEsIFMyPih0YXJnZXQ6IFQsIHNvdXJjZTogW1MxLCBTMl0pOiBUICYgUzEgJiBTMjtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUlmPFQsIFMxLCBTMiwgUzM+KHRhcmdldDogVCwgc291cmNlOiBbUzEsIFMyLCBTM10pOiBUICYgUzEgJiBTMiAmIFMzO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VCwgUzEsIFMyLCBTMywgUzQ+KHRhcmdldDogVCwgc291cmNlOiBbUzEsIFMyLCBTMywgUzRdKTogVCAmIFMxICYgUzIgJiBTMyAmIFM0O1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VD4odGFyZ2V0OiBULCBzb3VyY2U6IEFueU9iamVjdFtdKTogQW55T2JqZWN0O1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VD4odGFyZ2V0OiBULCBzb3VyY2U6IEFueU9iamVjdFtdKTogQW55T2JqZWN0IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICByZXR1cm4gbWVyZ2U8VD4odGFyZ2V0LCBzb3VyY2UsIHttZXJnZXI6IF9tZXJnZXJJZn0pO1xufVxuXG4vKipcbiAqIE1lcmdlcyBzb3VyY2Vba2V5XSBpbiB0YXJnZXRba2V5XSBvbmx5IGlmIHRhcmdldFtrZXldIGlzIHVuZGVmaW5lZC5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfbWVyZ2VySWYoa2V5OiBzdHJpbmcsIHRhcmdldDogQW55T2JqZWN0LCBzb3VyY2U6IEFueU9iamVjdCkge1xuICBpZiAoIWlzVmFsaWRLZXkoa2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHR2YWwgPSB0YXJnZXRba2V5XTtcbiAgY29uc3Qgc3ZhbCA9IHNvdXJjZVtrZXldO1xuXG4gIGlmIChpc09iamVjdCh0dmFsKSAmJiBpc09iamVjdChzdmFsKSkge1xuICAgIG1lcmdlSWYodHZhbCwgc3ZhbCk7XG4gIH0gZWxzZSBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkpIHtcbiAgICB0YXJnZXRba2V5XSA9IGNsb25lKHN2YWwpO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9kZXByZWNhdGVkKHNjb3BlOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duLCBwcmV2aW91czogc3RyaW5nLCBjdXJyZW50OiBzdHJpbmcpIHtcbiAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zb2xlLndhcm4oc2NvcGUgKyAnOiBcIicgKyBwcmV2aW91cyArXG4gICAgICAnXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcIicgKyBjdXJyZW50ICsgJ1wiIGluc3RlYWQnKTtcbiAgfVxufVxuXG4vLyByZXNvbHZlT2JqZWN0S2V5IHJlc29sdmVyIGNhY2hlXG5jb25zdCBrZXlSZXNvbHZlcnMgPSB7XG4gIC8vIENoYXJ0LmhlbHBlcnMuY29yZSByZXNvbHZlT2JqZWN0S2V5IHNob3VsZCByZXNvbHZlIGVtcHR5IGtleSB0byByb290IG9iamVjdFxuICAnJzogdiA9PiB2LFxuICAvLyBkZWZhdWx0IHJlc29sdmVyc1xuICB4OiBvID0+IG8ueCxcbiAgeTogbyA9PiBvLnlcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9zcGxpdEtleShrZXk6IHN0cmluZykge1xuICBjb25zdCBwYXJ0cyA9IGtleS5zcGxpdCgnLicpO1xuICBjb25zdCBrZXlzOiBzdHJpbmdbXSA9IFtdO1xuICBsZXQgdG1wID0gJyc7XG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgIHRtcCArPSBwYXJ0O1xuICAgIGlmICh0bXAuZW5kc1dpdGgoJ1xcXFwnKSkge1xuICAgICAgdG1wID0gdG1wLnNsaWNlKDAsIC0xKSArICcuJztcbiAgICB9IGVsc2Uge1xuICAgICAga2V5cy5wdXNoKHRtcCk7XG4gICAgICB0bXAgPSAnJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9nZXRLZXlSZXNvbHZlcihrZXk6IHN0cmluZykge1xuICBjb25zdCBrZXlzID0gX3NwbGl0S2V5KGtleSk7XG4gIHJldHVybiBvYmogPT4ge1xuICAgIGZvciAoY29uc3QgayBvZiBrZXlzKSB7XG4gICAgICBpZiAoayA9PT0gJycpIHtcbiAgICAgICAgLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHk6XG4gICAgICAgIC8vIENoYXJ0LmhlbHBlcnMuY29yZSByZXNvbHZlT2JqZWN0S2V5IHNob3VsZCBicmVhayBhdCBlbXB0eSBrZXlcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBvYmogPSBvYmogJiYgb2JqW2tdO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZU9iamVjdEtleShvYmo6IEFueU9iamVjdCwga2V5OiBzdHJpbmcpOiBhbnkge1xuICBjb25zdCByZXNvbHZlciA9IGtleVJlc29sdmVyc1trZXldIHx8IChrZXlSZXNvbHZlcnNba2V5XSA9IF9nZXRLZXlSZXNvbHZlcihrZXkpKTtcbiAgcmV0dXJuIHJlc29sdmVyKG9iaik7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9jYXBpdGFsaXplKHN0cjogc3RyaW5nKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59XG5cblxuZXhwb3J0IGNvbnN0IGRlZmluZWQgPSAodmFsdWU6IHVua25vd24pID0+IHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCc7XG5cbmV4cG9ydCBjb25zdCBpc0Z1bmN0aW9uID0gKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkgPT4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuXG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzExMjg4NTUvY29tcGFyaW5nLWVjbWE2LXNldHMtZm9yLWVxdWFsaXR5IzMxMTI5Mzg0XG5leHBvcnQgY29uc3Qgc2V0c0VxdWFsID0gPFQ+KGE6IFNldDxUPiwgYjogU2V0PFQ+KSA9PiB7XG4gIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAoY29uc3QgaXRlbSBvZiBhKSB7XG4gICAgaWYgKCFiLmhhcyhpdGVtKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gZSAtIFRoZSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9pc0NsaWNrRXZlbnQoZTogQ2hhcnRFdmVudCkge1xuICByZXR1cm4gZS50eXBlID09PSAnbW91c2V1cCcgfHwgZS50eXBlID09PSAnY2xpY2snIHx8IGUudHlwZSA9PT0gJ2NvbnRleHRtZW51Jztcbn1cbiIsICJpbXBvcnQgdHlwZSB7UG9pbnR9IGZyb20gJy4uL3R5cGVzL2dlb21ldHJpYy5qcyc7XG5pbXBvcnQge2lzRmluaXRlIGFzIGlzRmluaXRlTnVtYmVyfSBmcm9tICcuL2hlbHBlcnMuY29yZS5qcyc7XG5cbi8qKlxuICogQGFsaWFzIENoYXJ0LmhlbHBlcnMubWF0aFxuICogQG5hbWVzcGFjZVxuICovXG5cbmV4cG9ydCBjb25zdCBQSSA9IE1hdGguUEk7XG5leHBvcnQgY29uc3QgVEFVID0gMiAqIFBJO1xuZXhwb3J0IGNvbnN0IFBJVEFVID0gVEFVICsgUEk7XG5leHBvcnQgY29uc3QgSU5GSU5JVFkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5leHBvcnQgY29uc3QgUkFEX1BFUl9ERUcgPSBQSSAvIDE4MDtcbmV4cG9ydCBjb25zdCBIQUxGX1BJID0gUEkgLyAyO1xuZXhwb3J0IGNvbnN0IFFVQVJURVJfUEkgPSBQSSAvIDQ7XG5leHBvcnQgY29uc3QgVFdPX1RISVJEU19QSSA9IFBJICogMiAvIDM7XG5cbmV4cG9ydCBjb25zdCBsb2cxMCA9IE1hdGgubG9nMTA7XG5leHBvcnQgY29uc3Qgc2lnbiA9IE1hdGguc2lnbjtcblxuZXhwb3J0IGZ1bmN0aW9uIGFsbW9zdEVxdWFscyh4OiBudW1iZXIsIHk6IG51bWJlciwgZXBzaWxvbjogbnVtYmVyKSB7XG4gIHJldHVybiBNYXRoLmFicyh4IC0geSkgPCBlcHNpbG9uO1xufVxuXG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBuaWNlIG51bWJlciBhbGdvcml0aG0gdXNlZCBpbiBkZXRlcm1pbmluZyB3aGVyZSBheGlzIGxhYmVscyB3aWxsIGdvXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBuaWNlTnVtKHJhbmdlOiBudW1iZXIpIHtcbiAgY29uc3Qgcm91bmRlZFJhbmdlID0gTWF0aC5yb3VuZChyYW5nZSk7XG4gIHJhbmdlID0gYWxtb3N0RXF1YWxzKHJhbmdlLCByb3VuZGVkUmFuZ2UsIHJhbmdlIC8gMTAwMCkgPyByb3VuZGVkUmFuZ2UgOiByYW5nZTtcbiAgY29uc3QgbmljZVJhbmdlID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAocmFuZ2UpKSk7XG4gIGNvbnN0IGZyYWN0aW9uID0gcmFuZ2UgLyBuaWNlUmFuZ2U7XG4gIGNvbnN0IG5pY2VGcmFjdGlvbiA9IGZyYWN0aW9uIDw9IDEgPyAxIDogZnJhY3Rpb24gPD0gMiA/IDIgOiBmcmFjdGlvbiA8PSA1ID8gNSA6IDEwO1xuICByZXR1cm4gbmljZUZyYWN0aW9uICogbmljZVJhbmdlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgZmFjdG9ycyBzb3J0ZWQgZnJvbSAxIHRvIHNxcnQodmFsdWUpXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2ZhY3Rvcml6ZSh2YWx1ZTogbnVtYmVyKSB7XG4gIGNvbnN0IHJlc3VsdDogbnVtYmVyW10gPSBbXTtcbiAgY29uc3Qgc3FydCA9IE1hdGguc3FydCh2YWx1ZSk7XG4gIGxldCBpOiBudW1iZXI7XG5cbiAgZm9yIChpID0gMTsgaSA8IHNxcnQ7IGkrKykge1xuICAgIGlmICh2YWx1ZSAlIGkgPT09IDApIHtcbiAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgICAgcmVzdWx0LnB1c2godmFsdWUgLyBpKTtcbiAgICB9XG4gIH1cbiAgaWYgKHNxcnQgPT09IChzcXJ0IHwgMCkpIHsgLy8gaWYgdmFsdWUgaXMgYSBzcXVhcmUgbnVtYmVyXG4gICAgcmVzdWx0LnB1c2goc3FydCk7XG4gIH1cblxuICByZXN1bHQuc29ydCgoYSwgYikgPT4gYSAtIGIpLnBvcCgpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIobjogdW5rbm93bik6IG4gaXMgbnVtYmVyIHtcbiAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG4gYXMgc3RyaW5nKSkgJiYgaXNGaW5pdGUobiBhcyBudW1iZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWxtb3N0V2hvbGUoeDogbnVtYmVyLCBlcHNpbG9uOiBudW1iZXIpIHtcbiAgY29uc3Qgcm91bmRlZCA9IE1hdGgucm91bmQoeCk7XG4gIHJldHVybiAoKHJvdW5kZWQgLSBlcHNpbG9uKSA8PSB4KSAmJiAoKHJvdW5kZWQgKyBlcHNpbG9uKSA+PSB4KTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX3NldE1pbkFuZE1heEJ5S2V5KFxuICBhcnJheTogUmVjb3JkPHN0cmluZywgbnVtYmVyPltdLFxuICB0YXJnZXQ6IHsgbWluOiBudW1iZXIsIG1heDogbnVtYmVyIH0sXG4gIHByb3BlcnR5OiBzdHJpbmdcbikge1xuICBsZXQgaTogbnVtYmVyLCBpbGVuOiBudW1iZXIsIHZhbHVlOiBudW1iZXI7XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgIHZhbHVlID0gYXJyYXlbaV1bcHJvcGVydHldO1xuICAgIGlmICghaXNOYU4odmFsdWUpKSB7XG4gICAgICB0YXJnZXQubWluID0gTWF0aC5taW4odGFyZ2V0Lm1pbiwgdmFsdWUpO1xuICAgICAgdGFyZ2V0Lm1heCA9IE1hdGgubWF4KHRhcmdldC5tYXgsIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvUmFkaWFucyhkZWdyZWVzOiBudW1iZXIpIHtcbiAgcmV0dXJuIGRlZ3JlZXMgKiAoUEkgLyAxODApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9EZWdyZWVzKHJhZGlhbnM6IG51bWJlcikge1xuICByZXR1cm4gcmFkaWFucyAqICgxODAgLyBQSSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzXG4gKiBpLmUuIHRoZSBudW1iZXIgb2YgZGlnaXRzIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBOdW1iZXIuXG4gKiBAcGFyYW0geCAtIEEgbnVtYmVyLlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcy5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZGVjaW1hbFBsYWNlcyh4OiBudW1iZXIpIHtcbiAgaWYgKCFpc0Zpbml0ZU51bWJlcih4KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgZSA9IDE7XG4gIGxldCBwID0gMDtcbiAgd2hpbGUgKE1hdGgucm91bmQoeCAqIGUpIC8gZSAhPT0geCkge1xuICAgIGUgKj0gMTA7XG4gICAgcCsrO1xuICB9XG4gIHJldHVybiBwO1xufVxuXG4vLyBHZXRzIHRoZSBhbmdsZSBmcm9tIHZlcnRpY2FsIHVwcmlnaHQgdG8gdGhlIHBvaW50IGFib3V0IGEgY2VudHJlLlxuZXhwb3J0IGZ1bmN0aW9uIGdldEFuZ2xlRnJvbVBvaW50KFxuICBjZW50cmVQb2ludDogUG9pbnQsXG4gIGFuZ2xlUG9pbnQ6IFBvaW50XG4pIHtcbiAgY29uc3QgZGlzdGFuY2VGcm9tWENlbnRlciA9IGFuZ2xlUG9pbnQueCAtIGNlbnRyZVBvaW50Lng7XG4gIGNvbnN0IGRpc3RhbmNlRnJvbVlDZW50ZXIgPSBhbmdsZVBvaW50LnkgLSBjZW50cmVQb2ludC55O1xuICBjb25zdCByYWRpYWxEaXN0YW5jZUZyb21DZW50ZXIgPSBNYXRoLnNxcnQoZGlzdGFuY2VGcm9tWENlbnRlciAqIGRpc3RhbmNlRnJvbVhDZW50ZXIgKyBkaXN0YW5jZUZyb21ZQ2VudGVyICogZGlzdGFuY2VGcm9tWUNlbnRlcik7XG5cbiAgbGV0IGFuZ2xlID0gTWF0aC5hdGFuMihkaXN0YW5jZUZyb21ZQ2VudGVyLCBkaXN0YW5jZUZyb21YQ2VudGVyKTtcblxuICBpZiAoYW5nbGUgPCAoLTAuNSAqIFBJKSkge1xuICAgIGFuZ2xlICs9IFRBVTsgLy8gbWFrZSBzdXJlIHRoZSByZXR1cm5lZCBhbmdsZSBpcyBpbiB0aGUgcmFuZ2Ugb2YgKC1QSS8yLCAzUEkvMl1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYW5nbGUsXG4gICAgZGlzdGFuY2U6IHJhZGlhbERpc3RhbmNlRnJvbUNlbnRlclxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKHB0MTogUG9pbnQsIHB0MjogUG9pbnQpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwdDIueCAtIHB0MS54LCAyKSArIE1hdGgucG93KHB0Mi55IC0gcHQxLnksIDIpKTtcbn1cblxuLyoqXG4gKiBTaG9ydGVzdCBkaXN0YW5jZSBiZXR3ZWVuIGFuZ2xlcywgaW4gZWl0aGVyIGRpcmVjdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYW5nbGVEaWZmKGE6IG51bWJlciwgYjogbnVtYmVyKSB7XG4gIHJldHVybiAoYSAtIGIgKyBQSVRBVSkgJSBUQVUgLSBQSTtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYW5nbGUgdG8gYmUgYmV0d2VlbiAwIGFuZCAyKlBJXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX25vcm1hbGl6ZUFuZ2xlKGE6IG51bWJlcikge1xuICByZXR1cm4gKGEgJSBUQVUgKyBUQVUpICUgVEFVO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYW5nbGVCZXR3ZWVuKGFuZ2xlOiBudW1iZXIsIHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyLCBzYW1lQW5nbGVJc0Z1bGxDaXJjbGU/OiBib29sZWFuKSB7XG4gIGNvbnN0IGEgPSBfbm9ybWFsaXplQW5nbGUoYW5nbGUpO1xuICBjb25zdCBzID0gX25vcm1hbGl6ZUFuZ2xlKHN0YXJ0KTtcbiAgY29uc3QgZSA9IF9ub3JtYWxpemVBbmdsZShlbmQpO1xuICBjb25zdCBhbmdsZVRvU3RhcnQgPSBfbm9ybWFsaXplQW5nbGUocyAtIGEpO1xuICBjb25zdCBhbmdsZVRvRW5kID0gX25vcm1hbGl6ZUFuZ2xlKGUgLSBhKTtcbiAgY29uc3Qgc3RhcnRUb0FuZ2xlID0gX25vcm1hbGl6ZUFuZ2xlKGEgLSBzKTtcbiAgY29uc3QgZW5kVG9BbmdsZSA9IF9ub3JtYWxpemVBbmdsZShhIC0gZSk7XG4gIHJldHVybiBhID09PSBzIHx8IGEgPT09IGUgfHwgKHNhbWVBbmdsZUlzRnVsbENpcmNsZSAmJiBzID09PSBlKVxuICAgIHx8IChhbmdsZVRvU3RhcnQgPiBhbmdsZVRvRW5kICYmIHN0YXJ0VG9BbmdsZSA8IGVuZFRvQW5nbGUpO1xufVxuXG4vKipcbiAqIExpbWl0IGB2YWx1ZWAgYmV0d2VlbiBgbWluYCBhbmQgYG1heGBcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHBhcmFtIG1pblxuICogQHBhcmFtIG1heFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9saW1pdFZhbHVlKHZhbHVlOiBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcikge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHZhbHVlKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2ludDE2UmFuZ2UodmFsdWU6IG51bWJlcikge1xuICByZXR1cm4gX2xpbWl0VmFsdWUodmFsdWUsIC0zMjc2OCwgMzI3NjcpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHBhcmFtIHN0YXJ0XG4gKiBAcGFyYW0gZW5kXG4gKiBAcGFyYW0gW2Vwc2lsb25dXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2lzQmV0d2Vlbih2YWx1ZTogbnVtYmVyLCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlciwgZXBzaWxvbiA9IDFlLTYpIHtcbiAgcmV0dXJuIHZhbHVlID49IE1hdGgubWluKHN0YXJ0LCBlbmQpIC0gZXBzaWxvbiAmJiB2YWx1ZSA8PSBNYXRoLm1heChzdGFydCwgZW5kKSArIGVwc2lsb247XG59XG4iLCAiaW1wb3J0IHtfY2FwaXRhbGl6ZX0gZnJvbSAnLi9oZWxwZXJzLmNvcmUuanMnO1xuXG4vKipcbiAqIEJpbmFyeSBzZWFyY2hcbiAqIEBwYXJhbSB0YWJsZSAtIHRoZSB0YWJsZSBzZWFyY2guIG11c3QgYmUgc29ydGVkIVxuICogQHBhcmFtIHZhbHVlIC0gdmFsdWUgdG8gZmluZFxuICogQHBhcmFtIGNtcFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9sb29rdXAoXG4gIHRhYmxlOiBudW1iZXJbXSxcbiAgdmFsdWU6IG51bWJlcixcbiAgY21wPzogKHZhbHVlOiBudW1iZXIpID0+IGJvb2xlYW5cbik6IHtsbzogbnVtYmVyLCBoaTogbnVtYmVyfTtcbmV4cG9ydCBmdW5jdGlvbiBfbG9va3VwPFQ+KFxuICB0YWJsZTogVFtdLFxuICB2YWx1ZTogbnVtYmVyLFxuICBjbXA6ICh2YWx1ZTogbnVtYmVyKSA9PiBib29sZWFuXG4pOiB7bG86IG51bWJlciwgaGk6IG51bWJlcn07XG5leHBvcnQgZnVuY3Rpb24gX2xvb2t1cChcbiAgdGFibGU6IHVua25vd25bXSxcbiAgdmFsdWU6IG51bWJlcixcbiAgY21wPzogKHZhbHVlOiBudW1iZXIpID0+IGJvb2xlYW5cbikge1xuICBjbXAgPSBjbXAgfHwgKChpbmRleCkgPT4gdGFibGVbaW5kZXhdIDwgdmFsdWUpO1xuICBsZXQgaGkgPSB0YWJsZS5sZW5ndGggLSAxO1xuICBsZXQgbG8gPSAwO1xuICBsZXQgbWlkOiBudW1iZXI7XG5cbiAgd2hpbGUgKGhpIC0gbG8gPiAxKSB7XG4gICAgbWlkID0gKGxvICsgaGkpID4+IDE7XG4gICAgaWYgKGNtcChtaWQpKSB7XG4gICAgICBsbyA9IG1pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgaGkgPSBtaWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtsbywgaGl9O1xufVxuXG4vKipcbiAqIEJpbmFyeSBzZWFyY2hcbiAqIEBwYXJhbSB0YWJsZSAtIHRoZSB0YWJsZSBzZWFyY2guIG11c3QgYmUgc29ydGVkIVxuICogQHBhcmFtIGtleSAtIHByb3BlcnR5IG5hbWUgZm9yIHRoZSB2YWx1ZSBpbiBlYWNoIGVudHJ5XG4gKiBAcGFyYW0gdmFsdWUgLSB2YWx1ZSB0byBmaW5kXG4gKiBAcGFyYW0gbGFzdCAtIGxvb2t1cCBsYXN0IGluZGV4XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgX2xvb2t1cEJ5S2V5ID0gKFxuICB0YWJsZTogUmVjb3JkPHN0cmluZywgbnVtYmVyPltdLFxuICBrZXk6IHN0cmluZyxcbiAgdmFsdWU6IG51bWJlcixcbiAgbGFzdD86IGJvb2xlYW5cbikgPT5cbiAgX2xvb2t1cCh0YWJsZSwgdmFsdWUsIGxhc3RcbiAgICA/IGluZGV4ID0+IHtcbiAgICAgIGNvbnN0IHRpID0gdGFibGVbaW5kZXhdW2tleV07XG4gICAgICByZXR1cm4gdGkgPCB2YWx1ZSB8fCB0aSA9PT0gdmFsdWUgJiYgdGFibGVbaW5kZXggKyAxXVtrZXldID09PSB2YWx1ZTtcbiAgICB9XG4gICAgOiBpbmRleCA9PiB0YWJsZVtpbmRleF1ba2V5XSA8IHZhbHVlKTtcblxuLyoqXG4gKiBSZXZlcnNlIGJpbmFyeSBzZWFyY2hcbiAqIEBwYXJhbSB0YWJsZSAtIHRoZSB0YWJsZSBzZWFyY2guIG11c3QgYmUgc29ydGVkIVxuICogQHBhcmFtIGtleSAtIHByb3BlcnR5IG5hbWUgZm9yIHRoZSB2YWx1ZSBpbiBlYWNoIGVudHJ5XG4gKiBAcGFyYW0gdmFsdWUgLSB2YWx1ZSB0byBmaW5kXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgX3Jsb29rdXBCeUtleSA9IChcbiAgdGFibGU6IFJlY29yZDxzdHJpbmcsIG51bWJlcj5bXSxcbiAga2V5OiBzdHJpbmcsXG4gIHZhbHVlOiBudW1iZXJcbikgPT5cbiAgX2xvb2t1cCh0YWJsZSwgdmFsdWUsIGluZGV4ID0+IHRhYmxlW2luZGV4XVtrZXldID49IHZhbHVlKTtcblxuLyoqXG4gKiBSZXR1cm4gc3Vic2V0IG9mIGB2YWx1ZXNgIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgIGluY2x1c2l2ZS5cbiAqIFZhbHVlcyBhcmUgYXNzdW1lZCB0byBiZSBpbiBzb3J0ZWQgb3JkZXIuXG4gKiBAcGFyYW0gdmFsdWVzIC0gc29ydGVkIGFycmF5IG9mIHZhbHVlc1xuICogQHBhcmFtIG1pbiAtIG1pbiB2YWx1ZVxuICogQHBhcmFtIG1heCAtIG1heCB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2ZpbHRlckJldHdlZW4odmFsdWVzOiBudW1iZXJbXSwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKSB7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBlbmQgPSB2YWx1ZXMubGVuZ3RoO1xuXG4gIHdoaWxlIChzdGFydCA8IGVuZCAmJiB2YWx1ZXNbc3RhcnRdIDwgbWluKSB7XG4gICAgc3RhcnQrKztcbiAgfVxuICB3aGlsZSAoZW5kID4gc3RhcnQgJiYgdmFsdWVzW2VuZCAtIDFdID4gbWF4KSB7XG4gICAgZW5kLS07XG4gIH1cblxuICByZXR1cm4gc3RhcnQgPiAwIHx8IGVuZCA8IHZhbHVlcy5sZW5ndGhcbiAgICA/IHZhbHVlcy5zbGljZShzdGFydCwgZW5kKVxuICAgIDogdmFsdWVzO1xufVxuXG5jb25zdCBhcnJheUV2ZW50cyA9IFsncHVzaCcsICdwb3AnLCAnc2hpZnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSBhcyBjb25zdDtcblxuZXhwb3J0IGludGVyZmFjZSBBcnJheUxpc3RlbmVyPFQ+IHtcbiAgX29uRGF0YVB1c2g/KC4uLml0ZW06IFRbXSk6IHZvaWQ7XG4gIF9vbkRhdGFQb3A/KCk6IHZvaWQ7XG4gIF9vbkRhdGFTaGlmdD8oKTogdm9pZDtcbiAgX29uRGF0YVNwbGljZT8oaW5kZXg6IG51bWJlciwgZGVsZXRlQ291bnQ6IG51bWJlciwgLi4uaXRlbXM6IFRbXSk6IHZvaWQ7XG4gIF9vbkRhdGFVbnNoaWZ0PyguLi5pdGVtOiBUW10pOiB2b2lkO1xufVxuXG4vKipcbiAqIEhvb2tzIHRoZSBhcnJheSBtZXRob2RzIHRoYXQgYWRkIG9yIHJlbW92ZSB2YWx1ZXMgKCdwdXNoJywgcG9wJywgJ3NoaWZ0JywgJ3NwbGljZScsXG4gKiAndW5zaGlmdCcpIGFuZCBub3RpZnkgdGhlIGxpc3RlbmVyIEFGVEVSIHRoZSBhcnJheSBoYXMgYmVlbiBhbHRlcmVkLiBMaXN0ZW5lcnMgYXJlXG4gKiBjYWxsZWQgb24gdGhlICdfb25EYXRhKicgY2FsbGJhY2tzIChlLmcuIF9vbkRhdGFQdXNoLCBldGMuKSB3aXRoIHNhbWUgYXJndW1lbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuQXJyYXlFdmVudHM8VD4oYXJyYXk6IFRbXSwgbGlzdGVuZXI6IEFycmF5TGlzdGVuZXI8VD4pOiB2b2lkO1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3RlbkFycmF5RXZlbnRzKGFycmF5LCBsaXN0ZW5lcikge1xuICBpZiAoYXJyYXkuX2NoYXJ0anMpIHtcbiAgICBhcnJheS5fY2hhcnRqcy5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCAnX2NoYXJ0anMnLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiB7XG4gICAgICBsaXN0ZW5lcnM6IFtsaXN0ZW5lcl1cbiAgICB9XG4gIH0pO1xuXG4gIGFycmF5RXZlbnRzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGNvbnN0IG1ldGhvZCA9ICdfb25EYXRhJyArIF9jYXBpdGFsaXplKGtleSk7XG4gICAgY29uc3QgYmFzZSA9IGFycmF5W2tleV07XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyYXksIGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZSguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJhc2UuYXBwbHkodGhpcywgYXJncyk7XG5cbiAgICAgICAgYXJyYXkuX2NoYXJ0anMubGlzdGVuZXJzLmZvckVhY2goKG9iamVjdCkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0W21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9iamVjdFttZXRob2RdKC4uLmFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBnaXZlbiBhcnJheSBldmVudCBsaXN0ZW5lciBhbmQgY2xlYW51cCBleHRyYSBhdHRhY2hlZCBwcm9wZXJ0aWVzIChzdWNoIGFzXG4gKiB0aGUgX2NoYXJ0anMgc3R1YiBhbmQgb3ZlcnJpZGRlbiBtZXRob2RzKSBpZiBhcnJheSBkb2Vzbid0IGhhdmUgYW55IG1vcmUgbGlzdGVuZXJzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5saXN0ZW5BcnJheUV2ZW50czxUPihhcnJheTogVFtdLCBsaXN0ZW5lcjogQXJyYXlMaXN0ZW5lcjxUPik6IHZvaWQ7XG5leHBvcnQgZnVuY3Rpb24gdW5saXN0ZW5BcnJheUV2ZW50cyhhcnJheSwgbGlzdGVuZXIpIHtcbiAgY29uc3Qgc3R1YiA9IGFycmF5Ll9jaGFydGpzO1xuICBpZiAoIXN0dWIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBsaXN0ZW5lcnMgPSBzdHViLmxpc3RlbmVycztcbiAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxuXG4gIGlmIChsaXN0ZW5lcnMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGFycmF5RXZlbnRzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGRlbGV0ZSBhcnJheVtrZXldO1xuICB9KTtcblxuICBkZWxldGUgYXJyYXkuX2NoYXJ0anM7XG59XG5cbi8qKlxuICogQHBhcmFtIGl0ZW1zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYXJyYXlVbmlxdWU8VD4oaXRlbXM6IFRbXSkge1xuICBjb25zdCBzZXQgPSBuZXcgU2V0PFQ+KGl0ZW1zKTtcblxuICBpZiAoc2V0LnNpemUgPT09IGl0ZW1zLmxlbmd0aCkge1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuXG4gIHJldHVybiBBcnJheS5mcm9tKHNldCk7XG59XG4iLCAiaW1wb3J0IHR5cGUge0NoYXJ0TWV0YSwgUG9pbnRFbGVtZW50fSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5cbmltcG9ydCB7X2xpbWl0VmFsdWV9IGZyb20gJy4vaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCB7X2xvb2t1cEJ5S2V5fSBmcm9tICcuL2hlbHBlcnMuY29sbGVjdGlvbi5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBmb250U3RyaW5nKHBpeGVsU2l6ZTogbnVtYmVyLCBmb250U3R5bGU6IHN0cmluZywgZm9udEZhbWlseTogc3RyaW5nKSB7XG4gIHJldHVybiBmb250U3R5bGUgKyAnICcgKyBwaXhlbFNpemUgKyAncHggJyArIGZvbnRGYW1pbHk7XG59XG5cbi8qKlxuKiBSZXF1ZXN0IGFuaW1hdGlvbiBwb2x5ZmlsbFxuKi9cbmV4cG9ydCBjb25zdCByZXF1ZXN0QW5pbUZyYW1lID0gKGZ1bmN0aW9uKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG59KCkpO1xuXG4vKipcbiAqIFRocm90dGxlcyBjYWxsaW5nIGBmbmAgb25jZSBwZXIgYW5pbWF0aW9uIGZyYW1lXG4gKiBMYXRlc3QgYXJndW1lbnRzIGFyZSB1c2VkIG9uIHRoZSBhY3R1YWwgY2FsbFxuICovXG5leHBvcnQgZnVuY3Rpb24gdGhyb3R0bGVkPFRBcmdzIGV4dGVuZHMgQXJyYXk8YW55Pj4oXG4gIGZuOiAoLi4uYXJnczogVEFyZ3MpID0+IHZvaWQsXG4gIHRoaXNBcmc6IGFueSxcbikge1xuICBsZXQgYXJnc1RvVXNlID0gW10gYXMgVEFyZ3M7XG4gIGxldCB0aWNraW5nID0gZmFsc2U7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3M6IFRBcmdzKSB7XG4gICAgLy8gU2F2ZSB0aGUgYXJncyBmb3IgdXNlIGxhdGVyXG4gICAgYXJnc1RvVXNlID0gYXJncztcbiAgICBpZiAoIXRpY2tpbmcpIHtcbiAgICAgIHRpY2tpbmcgPSB0cnVlO1xuICAgICAgcmVxdWVzdEFuaW1GcmFtZS5jYWxsKHdpbmRvdywgKCkgPT4ge1xuICAgICAgICB0aWNraW5nID0gZmFsc2U7XG4gICAgICAgIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3NUb1VzZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogRGVib3VuY2VzIGNhbGxpbmcgYGZuYCBmb3IgYGRlbGF5YCBtc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZGVib3VuY2U8VEFyZ3MgZXh0ZW5kcyBBcnJheTxhbnk+PihmbjogKC4uLmFyZ3M6IFRBcmdzKSA9PiB2b2lkLCBkZWxheTogbnVtYmVyKSB7XG4gIGxldCB0aW1lb3V0O1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJnczogVEFyZ3MpIHtcbiAgICBpZiAoZGVsYXkpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZuLCBkZWxheSwgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gZGVsYXk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgJ3N0YXJ0JyB0byAnbGVmdCcsICdlbmQnIHRvICdyaWdodCcgYW5kIG90aGVycyB0byAnY2VudGVyJ1xuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IF90b0xlZnRSaWdodENlbnRlciA9IChhbGlnbjogJ3N0YXJ0JyB8ICdlbmQnIHwgJ2NlbnRlcicpID0+IGFsaWduID09PSAnc3RhcnQnID8gJ2xlZnQnIDogYWxpZ24gPT09ICdlbmQnID8gJ3JpZ2h0JyA6ICdjZW50ZXInO1xuXG4vKipcbiAqIFJldHVybnMgYHN0YXJ0YCwgYGVuZGAgb3IgYChzdGFydCArIGVuZCkgLyAyYCBkZXBlbmRpbmcgb24gYGFsaWduYC4gRGVmYXVsdHMgdG8gYGNlbnRlcmBcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBfYWxpZ25TdGFydEVuZCA9IChhbGlnbjogJ3N0YXJ0JyB8ICdlbmQnIHwgJ2NlbnRlcicsIHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKSA9PiBhbGlnbiA9PT0gJ3N0YXJ0JyA/IHN0YXJ0IDogYWxpZ24gPT09ICdlbmQnID8gZW5kIDogKHN0YXJ0ICsgZW5kKSAvIDI7XG5cbi8qKlxuICogUmV0dXJucyBgbGVmdGAsIGByaWdodGAgb3IgYChsZWZ0ICsgcmlnaHQpIC8gMmAgZGVwZW5kaW5nIG9uIGBhbGlnbmAuIERlZmF1bHRzIHRvIGBsZWZ0YFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IF90ZXh0WCA9IChhbGlnbjogJ2xlZnQnIHwgJ3JpZ2h0JyB8ICdjZW50ZXInLCBsZWZ0OiBudW1iZXIsIHJpZ2h0OiBudW1iZXIsIHJ0bDogYm9vbGVhbikgPT4ge1xuICBjb25zdCBjaGVjayA9IHJ0bCA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gIHJldHVybiBhbGlnbiA9PT0gY2hlY2sgPyByaWdodCA6IGFsaWduID09PSAnY2VudGVyJyA/IChsZWZ0ICsgcmlnaHQpIC8gMiA6IGxlZnQ7XG59O1xuXG4vKipcbiAqIFJldHVybiBzdGFydCBhbmQgY291bnQgb2YgdmlzaWJsZSBwb2ludHMuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMobWV0YTogQ2hhcnRNZXRhPCdsaW5lJyB8ICdzY2F0dGVyJz4sIHBvaW50czogUG9pbnRFbGVtZW50W10sIGFuaW1hdGlvbnNEaXNhYmxlZDogYm9vbGVhbikge1xuICBjb25zdCBwb2ludENvdW50ID0gcG9pbnRzLmxlbmd0aDtcblxuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgY291bnQgPSBwb2ludENvdW50O1xuXG4gIGlmIChtZXRhLl9zb3J0ZWQpIHtcbiAgICBjb25zdCB7aVNjYWxlLCBfcGFyc2VkfSA9IG1ldGE7XG4gICAgY29uc3QgYXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSBpU2NhbGUuZ2V0VXNlckJvdW5kcygpO1xuXG4gICAgaWYgKG1pbkRlZmluZWQpIHtcbiAgICAgIHN0YXJ0ID0gX2xpbWl0VmFsdWUoTWF0aC5taW4oXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgTmVlZCB0byB0eXBlIF9wYXJzZWRcbiAgICAgICAgX2xvb2t1cEJ5S2V5KF9wYXJzZWQsIGF4aXMsIG1pbikubG8sXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgTmVlZCB0byBmaXggdHlwZXMgb24gX2xvb2t1cEJ5S2V5XG4gICAgICAgIGFuaW1hdGlvbnNEaXNhYmxlZCA/IHBvaW50Q291bnQgOiBfbG9va3VwQnlLZXkocG9pbnRzLCBheGlzLCBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShtaW4pKS5sbyksXG4gICAgICAwLCBwb2ludENvdW50IC0gMSk7XG4gICAgfVxuICAgIGlmIChtYXhEZWZpbmVkKSB7XG4gICAgICBjb3VudCA9IF9saW1pdFZhbHVlKE1hdGgubWF4KFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIE5lZWQgdG8gdHlwZSBfcGFyc2VkXG4gICAgICAgIF9sb29rdXBCeUtleShfcGFyc2VkLCBpU2NhbGUuYXhpcywgbWF4LCB0cnVlKS5oaSArIDEsXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgTmVlZCB0byBmaXggdHlwZXMgb24gX2xvb2t1cEJ5S2V5XG4gICAgICAgIGFuaW1hdGlvbnNEaXNhYmxlZCA/IDAgOiBfbG9va3VwQnlLZXkocG9pbnRzLCBheGlzLCBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShtYXgpLCB0cnVlKS5oaSArIDEpLFxuICAgICAgc3RhcnQsIHBvaW50Q291bnQpIC0gc3RhcnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gcG9pbnRDb3VudCAtIHN0YXJ0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7c3RhcnQsIGNvdW50fTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHNjYWxlIHJhbmdlcyBoYXZlIGNoYW5nZWQuXG4gKiBAcGFyYW0ge29iamVjdH0gbWV0YSAtIGRhdGFzZXQgbWV0YS5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9zY2FsZVJhbmdlc0NoYW5nZWQobWV0YSkge1xuICBjb25zdCB7eFNjYWxlLCB5U2NhbGUsIF9zY2FsZVJhbmdlc30gPSBtZXRhO1xuICBjb25zdCBuZXdSYW5nZXMgPSB7XG4gICAgeG1pbjogeFNjYWxlLm1pbixcbiAgICB4bWF4OiB4U2NhbGUubWF4LFxuICAgIHltaW46IHlTY2FsZS5taW4sXG4gICAgeW1heDogeVNjYWxlLm1heFxuICB9O1xuICBpZiAoIV9zY2FsZVJhbmdlcykge1xuICAgIG1ldGEuX3NjYWxlUmFuZ2VzID0gbmV3UmFuZ2VzO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGNoYW5nZWQgPSBfc2NhbGVSYW5nZXMueG1pbiAhPT0geFNjYWxlLm1pblxuXHRcdHx8IF9zY2FsZVJhbmdlcy54bWF4ICE9PSB4U2NhbGUubWF4XG5cdFx0fHwgX3NjYWxlUmFuZ2VzLnltaW4gIT09IHlTY2FsZS5taW5cblx0XHR8fCBfc2NhbGVSYW5nZXMueW1heCAhPT0geVNjYWxlLm1heDtcblxuICBPYmplY3QuYXNzaWduKF9zY2FsZVJhbmdlcywgbmV3UmFuZ2VzKTtcbiAgcmV0dXJuIGNoYW5nZWQ7XG59XG4iLCAiaW1wb3J0IHtQSSwgVEFVLCBIQUxGX1BJfSBmcm9tICcuL2hlbHBlcnMubWF0aC5qcyc7XG5cbmNvbnN0IGF0RWRnZSA9ICh0OiBudW1iZXIpID0+IHQgPT09IDAgfHwgdCA9PT0gMTtcbmNvbnN0IGVsYXN0aWNJbiA9ICh0OiBudW1iZXIsIHM6IG51bWJlciwgcDogbnVtYmVyKSA9PiAtKE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgLSBzKSAqIFRBVSAvIHApKTtcbmNvbnN0IGVsYXN0aWNPdXQgPSAodDogbnVtYmVyLCBzOiBudW1iZXIsIHA6IG51bWJlcikgPT4gTWF0aC5wb3coMiwgLTEwICogdCkgKiBNYXRoLnNpbigodCAtIHMpICogVEFVIC8gcCkgKyAxO1xuXG4vKipcbiAqIEVhc2luZyBmdW5jdGlvbnMgYWRhcHRlZCBmcm9tIFJvYmVydCBQZW5uZXIncyBlYXNpbmcgZXF1YXRpb25zLlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmVhc2luZy5lZmZlY3RzXG4gKiBAc2VlIGh0dHA6Ly93d3cucm9iZXJ0cGVubmVyLmNvbS9lYXNpbmcvXG4gKi9cbmNvbnN0IGVmZmVjdHMgPSB7XG4gIGxpbmVhcjogKHQ6IG51bWJlcikgPT4gdCxcblxuICBlYXNlSW5RdWFkOiAodDogbnVtYmVyKSA9PiB0ICogdCxcblxuICBlYXNlT3V0UXVhZDogKHQ6IG51bWJlcikgPT4gLXQgKiAodCAtIDIpLFxuXG4gIGVhc2VJbk91dFF1YWQ6ICh0OiBudW1iZXIpID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IDAuNSAqIHQgKiB0XG4gICAgOiAtMC41ICogKCgtLXQpICogKHQgLSAyKSAtIDEpLFxuXG4gIGVhc2VJbkN1YmljOiAodDogbnVtYmVyKSA9PiB0ICogdCAqIHQsXG5cbiAgZWFzZU91dEN1YmljOiAodDogbnVtYmVyKSA9PiAodCAtPSAxKSAqIHQgKiB0ICsgMSxcblxuICBlYXNlSW5PdXRDdWJpYzogKHQ6IG51bWJlcikgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHQgKiB0XG4gICAgOiAwLjUgKiAoKHQgLT0gMikgKiB0ICogdCArIDIpLFxuXG4gIGVhc2VJblF1YXJ0OiAodDogbnVtYmVyKSA9PiB0ICogdCAqIHQgKiB0LFxuXG4gIGVhc2VPdXRRdWFydDogKHQ6IG51bWJlcikgPT4gLSgodCAtPSAxKSAqIHQgKiB0ICogdCAtIDEpLFxuXG4gIGVhc2VJbk91dFF1YXJ0OiAodDogbnVtYmVyKSA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAwLjUgKiB0ICogdCAqIHQgKiB0XG4gICAgOiAtMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0IC0gMiksXG5cbiAgZWFzZUluUXVpbnQ6ICh0OiBudW1iZXIpID0+IHQgKiB0ICogdCAqIHQgKiB0LFxuXG4gIGVhc2VPdXRRdWludDogKHQ6IG51bWJlcikgPT4gKHQgLT0gMSkgKiB0ICogdCAqIHQgKiB0ICsgMSxcblxuICBlYXNlSW5PdXRRdWludDogKHQ6IG51bWJlcikgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHQgKiB0ICogdCAqIHRcbiAgICA6IDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAqIHQgKyAyKSxcblxuICBlYXNlSW5TaW5lOiAodDogbnVtYmVyKSA9PiAtTWF0aC5jb3ModCAqIEhBTEZfUEkpICsgMSxcblxuICBlYXNlT3V0U2luZTogKHQ6IG51bWJlcikgPT4gTWF0aC5zaW4odCAqIEhBTEZfUEkpLFxuXG4gIGVhc2VJbk91dFNpbmU6ICh0OiBudW1iZXIpID0+IC0wLjUgKiAoTWF0aC5jb3MoUEkgKiB0KSAtIDEpLFxuXG4gIGVhc2VJbkV4cG86ICh0OiBudW1iZXIpID0+ICh0ID09PSAwKSA/IDAgOiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpLFxuXG4gIGVhc2VPdXRFeHBvOiAodDogbnVtYmVyKSA9PiAodCA9PT0gMSkgPyAxIDogLU1hdGgucG93KDIsIC0xMCAqIHQpICsgMSxcblxuICBlYXNlSW5PdXRFeHBvOiAodDogbnVtYmVyKSA9PiBhdEVkZ2UodCkgPyB0IDogdCA8IDAuNVxuICAgID8gMC41ICogTWF0aC5wb3coMiwgMTAgKiAodCAqIDIgLSAxKSlcbiAgICA6IDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogKHQgKiAyIC0gMSkpICsgMiksXG5cbiAgZWFzZUluQ2lyYzogKHQ6IG51bWJlcikgPT4gKHQgPj0gMSkgPyB0IDogLShNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpLFxuXG4gIGVhc2VPdXRDaXJjOiAodDogbnVtYmVyKSA9PiBNYXRoLnNxcnQoMSAtICh0IC09IDEpICogdCksXG5cbiAgZWFzZUluT3V0Q2lyYzogKHQ6IG51bWJlcikgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gLTAuNSAqIChNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpXG4gICAgOiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAodCAtPSAyKSAqIHQpICsgMSksXG5cbiAgZWFzZUluRWxhc3RpYzogKHQ6IG51bWJlcikgPT4gYXRFZGdlKHQpID8gdCA6IGVsYXN0aWNJbih0LCAwLjA3NSwgMC4zKSxcblxuICBlYXNlT3V0RWxhc3RpYzogKHQ6IG51bWJlcikgPT4gYXRFZGdlKHQpID8gdCA6IGVsYXN0aWNPdXQodCwgMC4wNzUsIDAuMyksXG5cbiAgZWFzZUluT3V0RWxhc3RpYyh0OiBudW1iZXIpIHtcbiAgICBjb25zdCBzID0gMC4xMTI1O1xuICAgIGNvbnN0IHAgPSAwLjQ1O1xuICAgIHJldHVybiBhdEVkZ2UodCkgPyB0IDpcbiAgICAgIHQgPCAwLjVcbiAgICAgICAgPyAwLjUgKiBlbGFzdGljSW4odCAqIDIsIHMsIHApXG4gICAgICAgIDogMC41ICsgMC41ICogZWxhc3RpY091dCh0ICogMiAtIDEsIHMsIHApO1xuICB9LFxuXG4gIGVhc2VJbkJhY2sodDogbnVtYmVyKSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuIHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG4gIH0sXG5cbiAgZWFzZU91dEJhY2sodDogbnVtYmVyKSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuICh0IC09IDEpICogdCAqICgocyArIDEpICogdCArIHMpICsgMTtcbiAgfSxcblxuICBlYXNlSW5PdXRCYWNrKHQ6IG51bWJlcikge1xuICAgIGxldCBzID0gMS43MDE1ODtcbiAgICBpZiAoKHQgLz0gMC41KSA8IDEpIHtcbiAgICAgIHJldHVybiAwLjUgKiAodCAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0IC0gcykpO1xuICAgIH1cbiAgICByZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgKyBzKSArIDIpO1xuICB9LFxuXG4gIGVhc2VJbkJvdW5jZTogKHQ6IG51bWJlcikgPT4gMSAtIGVmZmVjdHMuZWFzZU91dEJvdW5jZSgxIC0gdCksXG5cbiAgZWFzZU91dEJvdW5jZSh0OiBudW1iZXIpIHtcbiAgICBjb25zdCBtID0gNy41NjI1O1xuICAgIGNvbnN0IGQgPSAyLjc1O1xuICAgIGlmICh0IDwgKDEgLyBkKSkge1xuICAgICAgcmV0dXJuIG0gKiB0ICogdDtcbiAgICB9XG4gICAgaWYgKHQgPCAoMiAvIGQpKSB7XG4gICAgICByZXR1cm4gbSAqICh0IC09ICgxLjUgLyBkKSkgKiB0ICsgMC43NTtcbiAgICB9XG4gICAgaWYgKHQgPCAoMi41IC8gZCkpIHtcbiAgICAgIHJldHVybiBtICogKHQgLT0gKDIuMjUgLyBkKSkgKiB0ICsgMC45Mzc1O1xuICAgIH1cbiAgICByZXR1cm4gbSAqICh0IC09ICgyLjYyNSAvIGQpKSAqIHQgKyAwLjk4NDM3NTtcbiAgfSxcblxuICBlYXNlSW5PdXRCb3VuY2U6ICh0OiBudW1iZXIpID0+ICh0IDwgMC41KVxuICAgID8gZWZmZWN0cy5lYXNlSW5Cb3VuY2UodCAqIDIpICogMC41XG4gICAgOiBlZmZlY3RzLmVhc2VPdXRCb3VuY2UodCAqIDIgLSAxKSAqIDAuNSArIDAuNSxcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCB0eXBlIEVhc2luZ0Z1bmN0aW9uID0ga2V5b2YgdHlwZW9mIGVmZmVjdHNcblxuZXhwb3J0IGRlZmF1bHQgZWZmZWN0cztcbiIsICJpbXBvcnQge0NvbG9yfSBmcm9tICdAa3Vya2xlL2NvbG9yJztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzUGF0dGVybk9yR3JhZGllbnQodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBDYW52YXNQYXR0ZXJuIHwgQ2FudmFzR3JhZGllbnQge1xuICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIGNvbnN0IHR5cGUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIHJldHVybiB0eXBlID09PSAnW29iamVjdCBDYW52YXNQYXR0ZXJuXScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgQ2FudmFzR3JhZGllbnRdJztcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbG9yKHZhbHVlOiBDYW52YXNHcmFkaWVudCk6IENhbnZhc0dyYWRpZW50O1xuZXhwb3J0IGZ1bmN0aW9uIGNvbG9yKHZhbHVlOiBDYW52YXNQYXR0ZXJuKTogQ2FudmFzUGF0dGVybjtcbmV4cG9ydCBmdW5jdGlvbiBjb2xvcihcbiAgdmFsdWU6XG4gIHwgc3RyaW5nXG4gIHwgeyByOiBudW1iZXI7IGc6IG51bWJlcjsgYjogbnVtYmVyOyBhOiBudW1iZXIgfVxuICB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXVxuICB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdXG4pOiBDb2xvcjtcbmV4cG9ydCBmdW5jdGlvbiBjb2xvcih2YWx1ZSkge1xuICByZXR1cm4gaXNQYXR0ZXJuT3JHcmFkaWVudCh2YWx1ZSkgPyB2YWx1ZSA6IG5ldyBDb2xvcih2YWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRIb3ZlckNvbG9yKHZhbHVlOiBDYW52YXNHcmFkaWVudCk6IENhbnZhc0dyYWRpZW50O1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhvdmVyQ29sb3IodmFsdWU6IENhbnZhc1BhdHRlcm4pOiBDYW52YXNQYXR0ZXJuO1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhvdmVyQ29sb3IodmFsdWU6IHN0cmluZyk6IHN0cmluZztcbmV4cG9ydCBmdW5jdGlvbiBnZXRIb3ZlckNvbG9yKHZhbHVlKSB7XG4gIHJldHVybiBpc1BhdHRlcm5PckdyYWRpZW50KHZhbHVlKVxuICAgID8gdmFsdWVcbiAgICA6IG5ldyBDb2xvcih2YWx1ZSkuc2F0dXJhdGUoMC41KS5kYXJrZW4oMC4xKS5oZXhTdHJpbmcoKTtcbn1cbiIsICJjb25zdCBudW1iZXJzID0gWyd4JywgJ3knLCAnYm9yZGVyV2lkdGgnLCAncmFkaXVzJywgJ3RlbnNpb24nXTtcbmNvbnN0IGNvbG9ycyA9IFsnY29sb3InLCAnYm9yZGVyQ29sb3InLCAnYmFja2dyb3VuZENvbG9yJ107XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseUFuaW1hdGlvbnNEZWZhdWx0cyhkZWZhdWx0cykge1xuICBkZWZhdWx0cy5zZXQoJ2FuaW1hdGlvbicsIHtcbiAgICBkZWxheTogdW5kZWZpbmVkLFxuICAgIGR1cmF0aW9uOiAxMDAwLFxuICAgIGVhc2luZzogJ2Vhc2VPdXRRdWFydCcsXG4gICAgZm46IHVuZGVmaW5lZCxcbiAgICBmcm9tOiB1bmRlZmluZWQsXG4gICAgbG9vcDogdW5kZWZpbmVkLFxuICAgIHRvOiB1bmRlZmluZWQsXG4gICAgdHlwZTogdW5kZWZpbmVkLFxuICB9KTtcblxuICBkZWZhdWx0cy5kZXNjcmliZSgnYW5pbWF0aW9uJywge1xuICAgIF9mYWxsYmFjazogZmFsc2UsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnb25Qcm9ncmVzcycgJiYgbmFtZSAhPT0gJ29uQ29tcGxldGUnICYmIG5hbWUgIT09ICdmbicsXG4gIH0pO1xuXG4gIGRlZmF1bHRzLnNldCgnYW5pbWF0aW9ucycsIHtcbiAgICBjb2xvcnM6IHtcbiAgICAgIHR5cGU6ICdjb2xvcicsXG4gICAgICBwcm9wZXJ0aWVzOiBjb2xvcnNcbiAgICB9LFxuICAgIG51bWJlcnM6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgcHJvcGVydGllczogbnVtYmVyc1xuICAgIH0sXG4gIH0pO1xuXG4gIGRlZmF1bHRzLmRlc2NyaWJlKCdhbmltYXRpb25zJywge1xuICAgIF9mYWxsYmFjazogJ2FuaW1hdGlvbicsXG4gIH0pO1xuXG4gIGRlZmF1bHRzLnNldCgndHJhbnNpdGlvbnMnLCB7XG4gICAgYWN0aXZlOiB7XG4gICAgICBhbmltYXRpb246IHtcbiAgICAgICAgZHVyYXRpb246IDQwMFxuICAgICAgfVxuICAgIH0sXG4gICAgcmVzaXplOiB7XG4gICAgICBhbmltYXRpb246IHtcbiAgICAgICAgZHVyYXRpb246IDBcbiAgICAgIH1cbiAgICB9LFxuICAgIHNob3c6IHtcbiAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgY29sb3JzOiB7XG4gICAgICAgICAgZnJvbTogJ3RyYW5zcGFyZW50J1xuICAgICAgICB9LFxuICAgICAgICB2aXNpYmxlOiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgIGR1cmF0aW9uOiAwIC8vIHNob3cgaW1tZWRpYXRlbHlcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICB9LFxuICAgIGhpZGU6IHtcbiAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgY29sb3JzOiB7XG4gICAgICAgICAgdG86ICd0cmFuc3BhcmVudCdcbiAgICAgICAgfSxcbiAgICAgICAgdmlzaWJsZToge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICBlYXNpbmc6ICdsaW5lYXInLFxuICAgICAgICAgIGZuOiB2ID0+IHYgfCAwIC8vIGZvciBrZWVwaW5nIHRoZSBkYXRhc2V0IHZpc2libGUgYWxsIHRoZSB3YXkgdGhyb3VnaCB0aGUgYW5pbWF0aW9uXG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gYXBwbHlMYXlvdXRzRGVmYXVsdHMoZGVmYXVsdHMpIHtcbiAgZGVmYXVsdHMuc2V0KCdsYXlvdXQnLCB7XG4gICAgYXV0b1BhZGRpbmc6IHRydWUsXG4gICAgcGFkZGluZzoge1xuICAgICAgdG9wOiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICBib3R0b206IDAsXG4gICAgICBsZWZ0OiAwXG4gICAgfVxuICB9KTtcbn1cbiIsICJcbmNvbnN0IGludGxDYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBJbnRsLk51bWJlckZvcm1hdD4oKTtcblxuZnVuY3Rpb24gZ2V0TnVtYmVyRm9ybWF0KGxvY2FsZTogc3RyaW5nLCBvcHRpb25zPzogSW50bC5OdW1iZXJGb3JtYXRPcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBjYWNoZUtleSA9IGxvY2FsZSArIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpO1xuICBsZXQgZm9ybWF0dGVyID0gaW50bENhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmICghZm9ybWF0dGVyKSB7XG4gICAgZm9ybWF0dGVyID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxvY2FsZSwgb3B0aW9ucyk7XG4gICAgaW50bENhY2hlLnNldChjYWNoZUtleSwgZm9ybWF0dGVyKTtcbiAgfVxuICByZXR1cm4gZm9ybWF0dGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0TnVtYmVyKG51bTogbnVtYmVyLCBsb2NhbGU6IHN0cmluZywgb3B0aW9ucz86IEludGwuTnVtYmVyRm9ybWF0T3B0aW9ucykge1xuICByZXR1cm4gZ2V0TnVtYmVyRm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0KG51bSk7XG59XG4iLCAiaW1wb3J0IHtpc0FycmF5fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge2Zvcm1hdE51bWJlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmludGwuanMnO1xuaW1wb3J0IHtsb2cxMH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuXG4vKipcbiAqIE5hbWVzcGFjZSB0byBob2xkIGZvcm1hdHRlcnMgZm9yIGRpZmZlcmVudCB0eXBlcyBvZiB0aWNrc1xuICogQG5hbWVzcGFjZSBDaGFydC5UaWNrcy5mb3JtYXR0ZXJzXG4gKi9cbmNvbnN0IGZvcm1hdHRlcnMgPSB7XG4gIC8qKlxuICAgKiBGb3JtYXR0ZXIgZm9yIHZhbHVlIGxhYmVsc1xuICAgKiBAbWV0aG9kIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnMudmFsdWVzXG4gICAqIEBwYXJhbSB2YWx1ZSB0aGUgdmFsdWUgdG8gZGlzcGxheVxuICAgKiBAcmV0dXJuIHtzdHJpbmd8c3RyaW5nW119IHRoZSBsYWJlbCB0byBkaXNwbGF5XG4gICAqL1xuICB2YWx1ZXModmFsdWUpIHtcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgPyAvKiogQHR5cGUge3N0cmluZ1tdfSAqLyAodmFsdWUpIDogJycgKyB2YWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogRm9ybWF0dGVyIGZvciBudW1lcmljIHRpY2tzXG4gICAqIEBtZXRob2QgQ2hhcnQuVGlja3MuZm9ybWF0dGVycy5udW1lcmljXG4gICAqIEBwYXJhbSB0aWNrVmFsdWUge251bWJlcn0gdGhlIHZhbHVlIHRvIGJlIGZvcm1hdHRlZFxuICAgKiBAcGFyYW0gaW5kZXgge251bWJlcn0gdGhlIHBvc2l0aW9uIG9mIHRoZSB0aWNrVmFsdWUgcGFyYW1ldGVyIGluIHRoZSB0aWNrcyBhcnJheVxuICAgKiBAcGFyYW0gdGlja3Mge29iamVjdFtdfSB0aGUgbGlzdCBvZiB0aWNrcyBiZWluZyBjb252ZXJ0ZWRcbiAgICogQHJldHVybiB7c3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRpY2tWYWx1ZSBwYXJhbWV0ZXJcbiAgICovXG4gIG51bWVyaWModGlja1ZhbHVlLCBpbmRleCwgdGlja3MpIHtcbiAgICBpZiAodGlja1ZhbHVlID09PSAwKSB7XG4gICAgICByZXR1cm4gJzAnOyAvLyBuZXZlciBzaG93IGRlY2ltYWwgcGxhY2VzIGZvciAwXG4gICAgfVxuXG4gICAgY29uc3QgbG9jYWxlID0gdGhpcy5jaGFydC5vcHRpb25zLmxvY2FsZTtcbiAgICBsZXQgbm90YXRpb247XG4gICAgbGV0IGRlbHRhID0gdGlja1ZhbHVlOyAvLyBUaGlzIGlzIHVzZWQgd2hlbiB0aGVyZSBhcmUgbGVzcyB0aGFuIDIgdGlja3MgYXMgdGhlIHRpY2sgaW50ZXJ2YWwuXG5cbiAgICBpZiAodGlja3MubGVuZ3RoID4gMSkge1xuICAgICAgLy8gYWxsIHRpY2tzIGFyZSBzbWFsbCBvciB0aGVyZSBodWdlIG51bWJlcnM7IHVzZSBzY2llbnRpZmljIG5vdGF0aW9uXG4gICAgICBjb25zdCBtYXhUaWNrID0gTWF0aC5tYXgoTWF0aC5hYnModGlja3NbMF0udmFsdWUpLCBNYXRoLmFicyh0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZSkpO1xuICAgICAgaWYgKG1heFRpY2sgPCAxZS00IHx8IG1heFRpY2sgPiAxZSsxNSkge1xuICAgICAgICBub3RhdGlvbiA9ICdzY2llbnRpZmljJztcbiAgICAgIH1cblxuICAgICAgZGVsdGEgPSBjYWxjdWxhdGVEZWx0YSh0aWNrVmFsdWUsIHRpY2tzKTtcbiAgICB9XG5cbiAgICBjb25zdCBsb2dEZWx0YSA9IGxvZzEwKE1hdGguYWJzKGRlbHRhKSk7XG5cbiAgICAvLyBXaGVuIGRhdGFzZXRzIGhhdmUgdmFsdWVzIGFwcHJvYWNoaW5nIE51bWJlci5NQVhfVkFMVUUsIHRoZSB0aWNrIGNhbGN1bGF0aW9ucyBtaWdodCByZXN1bHQgaW5cbiAgICAvLyBpbmZpbml0eSBhbmQgZXZlbnR1YWxseSBOYU4uIFBhc3NpbmcgTmFOIGZvciBtaW5pbXVtRnJhY3Rpb25EaWdpdHMgb3IgbWF4aW11bUZyYWN0aW9uRGlnaXRzXG4gICAgLy8gd2lsbCBtYWtlIHRoZSBudW1iZXIgZm9ybWF0dGVyIHRocm93LiBTbyBpbnN0ZWFkIHdlIGNoZWNrIGZvciBpc05hTiBhbmQgdXNlIGEgZmFsbGJhY2sgdmFsdWUuXG4gICAgLy9cbiAgICAvLyB0b0ZpeGVkIGhhcyBhIG1heCBvZiAyMCBkZWNpbWFsIHBsYWNlc1xuICAgIGNvbnN0IG51bURlY2ltYWwgPSBpc05hTihsb2dEZWx0YSkgPyAxIDogTWF0aC5tYXgoTWF0aC5taW4oLTEgKiBNYXRoLmZsb29yKGxvZ0RlbHRhKSwgMjApLCAwKTtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7bm90YXRpb24sIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogbnVtRGVjaW1hbCwgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiBudW1EZWNpbWFsfTtcbiAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHRoaXMub3B0aW9ucy50aWNrcy5mb3JtYXQpO1xuXG4gICAgcmV0dXJuIGZvcm1hdE51bWJlcih0aWNrVmFsdWUsIGxvY2FsZSwgb3B0aW9ucyk7XG4gIH0sXG5cblxuICAvKipcbiAgICogRm9ybWF0dGVyIGZvciBsb2dhcml0aG1pYyB0aWNrc1xuICAgKiBAbWV0aG9kIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnMubG9nYXJpdGhtaWNcbiAgICogQHBhcmFtIHRpY2tWYWx1ZSB7bnVtYmVyfSB0aGUgdmFsdWUgdG8gYmUgZm9ybWF0dGVkXG4gICAqIEBwYXJhbSBpbmRleCB7bnVtYmVyfSB0aGUgcG9zaXRpb24gb2YgdGhlIHRpY2tWYWx1ZSBwYXJhbWV0ZXIgaW4gdGhlIHRpY2tzIGFycmF5XG4gICAqIEBwYXJhbSB0aWNrcyB7b2JqZWN0W119IHRoZSBsaXN0IG9mIHRpY2tzIGJlaW5nIGNvbnZlcnRlZFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGlja1ZhbHVlIHBhcmFtZXRlclxuICAgKi9cbiAgbG9nYXJpdGhtaWModGlja1ZhbHVlLCBpbmRleCwgdGlja3MpIHtcbiAgICBpZiAodGlja1ZhbHVlID09PSAwKSB7XG4gICAgICByZXR1cm4gJzAnO1xuICAgIH1cbiAgICBjb25zdCByZW1haW4gPSB0aWNrc1tpbmRleF0uc2lnbmlmaWNhbmQgfHwgKHRpY2tWYWx1ZSAvIChNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMCh0aWNrVmFsdWUpKSkpKTtcbiAgICBpZiAoWzEsIDIsIDMsIDUsIDEwLCAxNV0uaW5jbHVkZXMocmVtYWluKSB8fCBpbmRleCA+IDAuOCAqIHRpY2tzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcnMubnVtZXJpYy5jYWxsKHRoaXMsIHRpY2tWYWx1ZSwgaW5kZXgsIHRpY2tzKTtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbn07XG5cblxuZnVuY3Rpb24gY2FsY3VsYXRlRGVsdGEodGlja1ZhbHVlLCB0aWNrcykge1xuICAvLyBGaWd1cmUgb3V0IGhvdyBtYW55IGRpZ2l0cyB0byBzaG93XG4gIC8vIFRoZSBzcGFjZSBiZXR3ZWVuIHRoZSBmaXJzdCB0d28gdGlja3MgbWlnaHQgYmUgc21hbGxlciB0aGFuIG5vcm1hbCBzcGFjaW5nXG4gIGxldCBkZWx0YSA9IHRpY2tzLmxlbmd0aCA+IDMgPyB0aWNrc1syXS52YWx1ZSAtIHRpY2tzWzFdLnZhbHVlIDogdGlja3NbMV0udmFsdWUgLSB0aWNrc1swXS52YWx1ZTtcblxuICAvLyBJZiB3ZSBoYXZlIGEgbnVtYmVyIGxpa2UgMi41IGFzIHRoZSBkZWx0YSwgZmlndXJlIG91dCBob3cgbWFueSBkZWNpbWFsIHBsYWNlcyB3ZSBuZWVkXG4gIGlmIChNYXRoLmFicyhkZWx0YSkgPj0gMSAmJiB0aWNrVmFsdWUgIT09IE1hdGguZmxvb3IodGlja1ZhbHVlKSkge1xuICAgIC8vIG5vdCBhbiBpbnRlZ2VyXG4gICAgZGVsdGEgPSB0aWNrVmFsdWUgLSBNYXRoLmZsb29yKHRpY2tWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGRlbHRhO1xufVxuXG4vKipcbiAqIE5hbWVzcGFjZSB0byBob2xkIHN0YXRpYyB0aWNrIGdlbmVyYXRpb24gZnVuY3Rpb25zXG4gKiBAbmFtZXNwYWNlIENoYXJ0LlRpY2tzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtmb3JtYXR0ZXJzfTtcbiIsICJpbXBvcnQgVGlja3MgZnJvbSAnLi9jb3JlLnRpY2tzLmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5U2NhbGVEZWZhdWx0cyhkZWZhdWx0cykge1xuICBkZWZhdWx0cy5zZXQoJ3NjYWxlJywge1xuICAgIGRpc3BsYXk6IHRydWUsXG4gICAgb2Zmc2V0OiBmYWxzZSxcbiAgICByZXZlcnNlOiBmYWxzZSxcbiAgICBiZWdpbkF0WmVybzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBTY2FsZSBib3VuZGFyeSBzdHJhdGVneSAoYnlwYXNzZWQgYnkgbWluL21heCB0aW1lIG9wdGlvbnMpXG4gICAgICogLSBgZGF0YWA6IG1ha2Ugc3VyZSBkYXRhIGFyZSBmdWxseSB2aXNpYmxlLCB0aWNrcyBvdXRzaWRlIGFyZSByZW1vdmVkXG4gICAgICogLSBgdGlja3NgOiBtYWtlIHN1cmUgdGlja3MgYXJlIGZ1bGx5IHZpc2libGUsIGRhdGEgb3V0c2lkZSBhcmUgdHJ1bmNhdGVkXG4gICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzQ1NTZcbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKi9cbiAgICBib3VuZHM6ICd0aWNrcycsXG5cbiAgICBjbGlwOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQWRkaXRpb24gZ3JhY2UgYWRkZWQgdG8gbWF4IGFuZCByZWR1Y2VkIGZyb20gbWluIGRhdGEgdmFsdWUuXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICovXG4gICAgZ3JhY2U6IDAsXG5cbiAgICAvLyBncmlkIGxpbmUgc2V0dGluZ3NcbiAgICBncmlkOiB7XG4gICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgbGluZVdpZHRoOiAxLFxuICAgICAgZHJhd09uQ2hhcnRBcmVhOiB0cnVlLFxuICAgICAgZHJhd1RpY2tzOiB0cnVlLFxuICAgICAgdGlja0xlbmd0aDogOCxcbiAgICAgIHRpY2tXaWR0aDogKF9jdHgsIG9wdGlvbnMpID0+IG9wdGlvbnMubGluZVdpZHRoLFxuICAgICAgdGlja0NvbG9yOiAoX2N0eCwgb3B0aW9ucykgPT4gb3B0aW9ucy5jb2xvcixcbiAgICAgIG9mZnNldDogZmFsc2UsXG4gICAgfSxcblxuICAgIGJvcmRlcjoge1xuICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgIGRhc2g6IFtdLFxuICAgICAgZGFzaE9mZnNldDogMC4wLFxuICAgICAgd2lkdGg6IDFcbiAgICB9LFxuXG4gICAgLy8gc2NhbGUgdGl0bGVcbiAgICB0aXRsZToge1xuICAgICAgLy8gZGlzcGxheSBwcm9wZXJ0eVxuICAgICAgZGlzcGxheTogZmFsc2UsXG5cbiAgICAgIC8vIGFjdHVhbCBsYWJlbFxuICAgICAgdGV4dDogJycsXG5cbiAgICAgIC8vIHRvcC9ib3R0b20gcGFkZGluZ1xuICAgICAgcGFkZGluZzoge1xuICAgICAgICB0b3A6IDQsXG4gICAgICAgIGJvdHRvbTogNFxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBsYWJlbCBzZXR0aW5nc1xuICAgIHRpY2tzOiB7XG4gICAgICBtaW5Sb3RhdGlvbjogMCxcbiAgICAgIG1heFJvdGF0aW9uOiA1MCxcbiAgICAgIG1pcnJvcjogZmFsc2UsXG4gICAgICB0ZXh0U3Ryb2tlV2lkdGg6IDAsXG4gICAgICB0ZXh0U3Ryb2tlQ29sb3I6ICcnLFxuICAgICAgcGFkZGluZzogMyxcbiAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICBhdXRvU2tpcDogdHJ1ZSxcbiAgICAgIGF1dG9Ta2lwUGFkZGluZzogMyxcbiAgICAgIGxhYmVsT2Zmc2V0OiAwLFxuICAgICAgLy8gV2UgcGFzcyB0aHJvdWdoIGFycmF5cyB0byBiZSByZW5kZXJlZCBhcyBtdWx0aWxpbmUgbGFiZWxzLCB3ZSBjb252ZXJ0IE90aGVycyB0byBzdHJpbmdzIGhlcmUuXG4gICAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy52YWx1ZXMsXG4gICAgICBtaW5vcjoge30sXG4gICAgICBtYWpvcjoge30sXG4gICAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgICBjcm9zc0FsaWduOiAnbmVhcicsXG5cbiAgICAgIHNob3dMYWJlbEJhY2tkcm9wOiBmYWxzZSxcbiAgICAgIGJhY2tkcm9wQ29sb3I6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNzUpJyxcbiAgICAgIGJhY2tkcm9wUGFkZGluZzogMixcbiAgICB9XG4gIH0pO1xuXG4gIGRlZmF1bHRzLnJvdXRlKCdzY2FsZS50aWNrcycsICdjb2xvcicsICcnLCAnY29sb3InKTtcbiAgZGVmYXVsdHMucm91dGUoJ3NjYWxlLmdyaWQnLCAnY29sb3InLCAnJywgJ2JvcmRlckNvbG9yJyk7XG4gIGRlZmF1bHRzLnJvdXRlKCdzY2FsZS5ib3JkZXInLCAnY29sb3InLCAnJywgJ2JvcmRlckNvbG9yJyk7XG4gIGRlZmF1bHRzLnJvdXRlKCdzY2FsZS50aXRsZScsICdjb2xvcicsICcnLCAnY29sb3InKTtcblxuICBkZWZhdWx0cy5kZXNjcmliZSgnc2NhbGUnLCB7XG4gICAgX2ZhbGxiYWNrOiBmYWxzZSxcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFuYW1lLnN0YXJ0c1dpdGgoJ2JlZm9yZScpICYmICFuYW1lLnN0YXJ0c1dpdGgoJ2FmdGVyJykgJiYgbmFtZSAhPT0gJ2NhbGxiYWNrJyAmJiBuYW1lICE9PSAncGFyc2VyJyxcbiAgICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JvcmRlckRhc2gnICYmIG5hbWUgIT09ICd0aWNrQm9yZGVyRGFzaCcgJiYgbmFtZSAhPT0gJ2Rhc2gnLFxuICB9KTtcblxuICBkZWZhdWx0cy5kZXNjcmliZSgnc2NhbGVzJywge1xuICAgIF9mYWxsYmFjazogJ3NjYWxlJyxcbiAgfSk7XG5cbiAgZGVmYXVsdHMuZGVzY3JpYmUoJ3NjYWxlLnRpY2tzJywge1xuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JhY2tkcm9wUGFkZGluZycgJiYgbmFtZSAhPT0gJ2NhbGxiYWNrJyxcbiAgICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JhY2tkcm9wUGFkZGluZycsXG4gIH0pO1xufVxuIiwgImltcG9ydCB7Z2V0SG92ZXJDb2xvcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbG9yLmpzJztcbmltcG9ydCB7aXNPYmplY3QsIG1lcmdlLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHthcHBseUFuaW1hdGlvbnNEZWZhdWx0c30gZnJvbSAnLi9jb3JlLmFuaW1hdGlvbnMuZGVmYXVsdHMuanMnO1xuaW1wb3J0IHthcHBseUxheW91dHNEZWZhdWx0c30gZnJvbSAnLi9jb3JlLmxheW91dHMuZGVmYXVsdHMuanMnO1xuaW1wb3J0IHthcHBseVNjYWxlRGVmYXVsdHN9IGZyb20gJy4vY29yZS5zY2FsZS5kZWZhdWx0cy5qcyc7XG5cbmV4cG9ydCBjb25zdCBvdmVycmlkZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZXhwb3J0IGNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRTY29wZShub2RlLCBrZXkpIHtcbiAgaWYgKCFrZXkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBjb25zdCBrZXlzID0ga2V5LnNwbGl0KCcuJyk7XG4gIGZvciAobGV0IGkgPSAwLCBuID0ga2V5cy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBjb25zdCBrID0ga2V5c1tpXTtcbiAgICBub2RlID0gbm9kZVtrXSB8fCAobm9kZVtrXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBzZXQocm9vdCwgc2NvcGUsIHZhbHVlcykge1xuICBpZiAodHlwZW9mIHNjb3BlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBtZXJnZShnZXRTY29wZShyb290LCBzY29wZSksIHZhbHVlcyk7XG4gIH1cbiAgcmV0dXJuIG1lcmdlKGdldFNjb3BlKHJvb3QsICcnKSwgc2NvcGUpO1xufVxuXG4vKipcbiAqIFBsZWFzZSB1c2UgdGhlIG1vZHVsZSdzIGRlZmF1bHQgZXhwb3J0IHdoaWNoIHByb3ZpZGVzIGEgc2luZ2xldG9uIGluc3RhbmNlXG4gKiBOb3RlOiBjbGFzcyBpcyBleHBvcnRlZCBmb3IgdHlwZWRvY1xuICovXG5leHBvcnQgY2xhc3MgRGVmYXVsdHMge1xuICBjb25zdHJ1Y3RvcihfZGVzY3JpcHRvcnMsIF9hcHBsaWVycykge1xuICAgIHRoaXMuYW5pbWF0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoMCwwLDAsMC4xKSc7XG4gICAgdGhpcy5ib3JkZXJDb2xvciA9ICdyZ2JhKDAsMCwwLDAuMSknO1xuICAgIHRoaXMuY29sb3IgPSAnIzY2Nic7XG4gICAgdGhpcy5kYXRhc2V0cyA9IHt9O1xuICAgIHRoaXMuZGV2aWNlUGl4ZWxSYXRpbyA9IChjb250ZXh0KSA9PiBjb250ZXh0LmNoYXJ0LnBsYXRmb3JtLmdldERldmljZVBpeGVsUmF0aW8oKTtcbiAgICB0aGlzLmVsZW1lbnRzID0ge307XG4gICAgdGhpcy5ldmVudHMgPSBbXG4gICAgICAnbW91c2Vtb3ZlJyxcbiAgICAgICdtb3VzZW91dCcsXG4gICAgICAnY2xpY2snLFxuICAgICAgJ3RvdWNoc3RhcnQnLFxuICAgICAgJ3RvdWNobW92ZSdcbiAgICBdO1xuICAgIHRoaXMuZm9udCA9IHtcbiAgICAgIGZhbWlseTogXCInSGVsdmV0aWNhIE5ldWUnLCAnSGVsdmV0aWNhJywgJ0FyaWFsJywgc2Fucy1zZXJpZlwiLFxuICAgICAgc2l6ZTogMTIsXG4gICAgICBzdHlsZTogJ25vcm1hbCcsXG4gICAgICBsaW5lSGVpZ2h0OiAxLjIsXG4gICAgICB3ZWlnaHQ6IG51bGxcbiAgICB9O1xuICAgIHRoaXMuaG92ZXIgPSB7fTtcbiAgICB0aGlzLmhvdmVyQmFja2dyb3VuZENvbG9yID0gKGN0eCwgb3B0aW9ucykgPT4gZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJhY2tncm91bmRDb2xvcik7XG4gICAgdGhpcy5ob3ZlckJvcmRlckNvbG9yID0gKGN0eCwgb3B0aW9ucykgPT4gZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJvcmRlckNvbG9yKTtcbiAgICB0aGlzLmhvdmVyQ29sb3IgPSAoY3R4LCBvcHRpb25zKSA9PiBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuY29sb3IpO1xuICAgIHRoaXMuaW5kZXhBeGlzID0gJ3gnO1xuICAgIHRoaXMuaW50ZXJhY3Rpb24gPSB7XG4gICAgICBtb2RlOiAnbmVhcmVzdCcsXG4gICAgICBpbnRlcnNlY3Q6IHRydWUsXG4gICAgICBpbmNsdWRlSW52aXNpYmxlOiBmYWxzZVxuICAgIH07XG4gICAgdGhpcy5tYWludGFpbkFzcGVjdFJhdGlvID0gdHJ1ZTtcbiAgICB0aGlzLm9uSG92ZXIgPSBudWxsO1xuICAgIHRoaXMub25DbGljayA9IG51bGw7XG4gICAgdGhpcy5wYXJzaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnBsdWdpbnMgPSB7fTtcbiAgICB0aGlzLnJlc3BvbnNpdmUgPSB0cnVlO1xuICAgIHRoaXMuc2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zY2FsZXMgPSB7fTtcbiAgICB0aGlzLnNob3dMaW5lID0gdHJ1ZTtcbiAgICB0aGlzLmRyYXdBY3RpdmVFbGVtZW50c09uVG9wID0gdHJ1ZTtcblxuICAgIHRoaXMuZGVzY3JpYmUoX2Rlc2NyaXB0b3JzKTtcbiAgICB0aGlzLmFwcGx5KF9hcHBsaWVycyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBzY29wZVxuXHQgKiBAcGFyYW0ge29iamVjdH0gW3ZhbHVlc11cblx0ICovXG4gIHNldChzY29wZSwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHNldCh0aGlzLCBzY29wZSwgdmFsdWVzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc2NvcGVcblx0ICovXG4gIGdldChzY29wZSkge1xuICAgIHJldHVybiBnZXRTY29wZSh0aGlzLCBzY29wZSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBzY29wZVxuXHQgKiBAcGFyYW0ge29iamVjdH0gW3ZhbHVlc11cblx0ICovXG4gIGRlc2NyaWJlKHNjb3BlLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gc2V0KGRlc2NyaXB0b3JzLCBzY29wZSwgdmFsdWVzKTtcbiAgfVxuXG4gIG92ZXJyaWRlKHNjb3BlLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gc2V0KG92ZXJyaWRlcywgc2NvcGUsIHZhbHVlcyk7XG4gIH1cblxuICAvKipcblx0ICogUm91dGVzIHRoZSBuYW1lZCBkZWZhdWx0cyB0byBmYWxsYmFjayB0byBhbm90aGVyIHNjb3BlL25hbWUuXG5cdCAqIFRoaXMgcm91dGluZyBpcyB1c2VmdWwgd2hlbiB0aG9zZSB0YXJnZXQgdmFsdWVzLCBsaWtlIGRlZmF1bHRzLmNvbG9yLCBhcmUgY2hhbmdlZCBydW50aW1lLlxuXHQgKiBJZiB0aGUgdmFsdWVzIHdvdWxkIGJlIGNvcGllZCwgdGhlIHJ1bnRpbWUgY2hhbmdlIHdvdWxkIG5vdCB0YWtlIGVmZmVjdC4gQnkgcm91dGluZywgdGhlXG5cdCAqIGZhbGxiYWNrIGlzIGV2YWx1YXRlZCBhdCBlYWNoIGFjY2Vzcywgc28gaXRzIGFsd2F5cyB1cCB0byBkYXRlLlxuXHQgKlxuXHQgKiBFeGFtcGxlOlxuXHQgKlxuXHQgKiBcdGRlZmF1bHRzLnJvdXRlKCdlbGVtZW50cy5hcmMnLCAnYmFja2dyb3VuZENvbG9yJywgJycsICdjb2xvcicpXG5cdCAqICAgLSByZWFkcyB0aGUgYmFja2dyb3VuZENvbG9yIGZyb20gZGVmYXVsdHMuY29sb3Igd2hlbiB1bmRlZmluZWQgbG9jYWxseVxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc2NvcGUgU2NvcGUgdGhpcyByb3V0ZSBhcHBsaWVzIHRvLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBQcm9wZXJ0eSBuYW1lIHRoYXQgc2hvdWxkIGJlIHJvdXRlZCB0byBkaWZmZXJlbnQgbmFtZXNwYWNlIHdoZW4gbm90IGRlZmluZWQgaGVyZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldFNjb3BlIFRoZSBuYW1lc3BhY2Ugd2hlcmUgdGhvc2UgcHJvcGVydGllcyBzaG91bGQgYmUgcm91dGVkIHRvLlxuXHQgKiBFbXB0eSBzdHJpbmcgKCcnKSBpcyB0aGUgcm9vdCBvZiBkZWZhdWx0cy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldE5hbWUgVGhlIHRhcmdldCBuYW1lIGluIHRoZSB0YXJnZXQgc2NvcGUgdGhlIHByb3BlcnR5IHNob3VsZCBiZSByb3V0ZWQgdG8uXG5cdCAqL1xuICByb3V0ZShzY29wZSwgbmFtZSwgdGFyZ2V0U2NvcGUsIHRhcmdldE5hbWUpIHtcbiAgICBjb25zdCBzY29wZU9iamVjdCA9IGdldFNjb3BlKHRoaXMsIHNjb3BlKTtcbiAgICBjb25zdCB0YXJnZXRTY29wZU9iamVjdCA9IGdldFNjb3BlKHRoaXMsIHRhcmdldFNjb3BlKTtcbiAgICBjb25zdCBwcml2YXRlTmFtZSA9ICdfJyArIG5hbWU7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzY29wZU9iamVjdCwge1xuICAgICAgLy8gQSBwcml2YXRlIHByb3BlcnR5IGlzIGRlZmluZWQgdG8gaG9sZCB0aGUgYWN0dWFsIHZhbHVlLCB3aGVuIHRoaXMgcHJvcGVydHkgaXMgc2V0IGluIGl0cyBzY29wZSAoc2V0IGluIHRoZSBzZXR0ZXIpXG4gICAgICBbcHJpdmF0ZU5hbWVdOiB7XG4gICAgICAgIHZhbHVlOiBzY29wZU9iamVjdFtuYW1lXSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0sXG4gICAgICAvLyBUaGUgYWN0dWFsIHByb3BlcnR5IGlzIGRlZmluZWQgYXMgZ2V0dGVyL3NldHRlciBzbyB3ZSBjYW4gZG8gdGhlIHJvdXRpbmcgd2hlbiB2YWx1ZSBpcyBub3QgbG9jYWxseSBzZXQuXG4gICAgICBbbmFtZV06IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIGNvbnN0IGxvY2FsID0gdGhpc1twcml2YXRlTmFtZV07XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0U2NvcGVPYmplY3RbdGFyZ2V0TmFtZV07XG4gICAgICAgICAgaWYgKGlzT2JqZWN0KGxvY2FsKSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRhcmdldCwgbG9jYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWVPckRlZmF1bHQobG9jYWwsIHRhcmdldCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgIHRoaXNbcHJpdmF0ZU5hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGFwcGx5KGFwcGxpZXJzKSB7XG4gICAgYXBwbGllcnMuZm9yRWFjaCgoYXBwbHkpID0+IGFwcGx5KHRoaXMpKTtcbiAgfVxufVxuXG4vLyBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBkZWZhdWx0IC8qICNfX1BVUkVfXyAqLyBuZXcgRGVmYXVsdHMoe1xuICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFuYW1lLnN0YXJ0c1dpdGgoJ29uJyksXG4gIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnZXZlbnRzJyxcbiAgaG92ZXI6IHtcbiAgICBfZmFsbGJhY2s6ICdpbnRlcmFjdGlvbidcbiAgfSxcbiAgaW50ZXJhY3Rpb246IHtcbiAgICBfc2NyaXB0YWJsZTogZmFsc2UsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gIH1cbn0sIFthcHBseUFuaW1hdGlvbnNEZWZhdWx0cywgYXBwbHlMYXlvdXRzRGVmYXVsdHMsIGFwcGx5U2NhbGVEZWZhdWx0c10pO1xuIiwgImltcG9ydCB0eXBlIHtcbiAgQ2hhcnQsXG4gIFBvaW50LFxuICBGb250U3BlYyxcbiAgQ2FudmFzRm9udFNwZWMsXG4gIFBvaW50U3R5bGUsXG4gIFJlbmRlclRleHRPcHRzLFxuICBCYWNrZHJvcE9wdGlvbnNcbn0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuaW1wb3J0IHR5cGUge1xuICBUUkJMLFxuICBTcGxpbmVQb2ludCxcbiAgUm91bmRlZFJlY3QsXG4gIFRSQkxDb3JuZXJzXG59IGZyb20gJy4uL3R5cGVzL2dlb21ldHJpYy5qcyc7XG5pbXBvcnQge2lzQXJyYXksIGlzTnVsbE9yVW5kZWZ9IGZyb20gJy4vaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7UEksIFRBVSwgSEFMRl9QSSwgUVVBUlRFUl9QSSwgVFdPX1RISVJEU19QSSwgUkFEX1BFUl9ERUd9IGZyb20gJy4vaGVscGVycy5tYXRoLmpzJztcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gZm9udCBvYmplY3QgaW50byBhIENTUyBmb250IHN0cmluZy5cbiAqIEBwYXJhbSBmb250IC0gQSBmb250IG9iamVjdC5cbiAqIEByZXR1cm4gVGhlIENTUyBmb250IHN0cmluZy4gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9mb250XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Gb250U3RyaW5nKGZvbnQ6IEZvbnRTcGVjKSB7XG4gIGlmICghZm9udCB8fCBpc051bGxPclVuZGVmKGZvbnQuc2l6ZSkgfHwgaXNOdWxsT3JVbmRlZihmb250LmZhbWlseSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiAoZm9udC5zdHlsZSA/IGZvbnQuc3R5bGUgKyAnICcgOiAnJylcblx0XHQrIChmb250LndlaWdodCA/IGZvbnQud2VpZ2h0ICsgJyAnIDogJycpXG5cdFx0KyBmb250LnNpemUgKyAncHggJ1xuXHRcdCsgZm9udC5mYW1pbHk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9tZWFzdXJlVGV4dChcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIGRhdGE6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4sXG4gIGdjOiBzdHJpbmdbXSxcbiAgbG9uZ2VzdDogbnVtYmVyLFxuICBzdHJpbmc6IHN0cmluZ1xuKSB7XG4gIGxldCB0ZXh0V2lkdGggPSBkYXRhW3N0cmluZ107XG4gIGlmICghdGV4dFdpZHRoKSB7XG4gICAgdGV4dFdpZHRoID0gZGF0YVtzdHJpbmddID0gY3R4Lm1lYXN1cmVUZXh0KHN0cmluZykud2lkdGg7XG4gICAgZ2MucHVzaChzdHJpbmcpO1xuICB9XG4gIGlmICh0ZXh0V2lkdGggPiBsb25nZXN0KSB7XG4gICAgbG9uZ2VzdCA9IHRleHRXaWR0aDtcbiAgfVxuICByZXR1cm4gbG9uZ2VzdDtcbn1cblxudHlwZSBUaGluZyA9IHN0cmluZyB8IHVuZGVmaW5lZCB8IG51bGxcbnR5cGUgVGhpbmdzID0gKFRoaW5nIHwgVGhpbmdbXSlbXVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5leHBvcnQgZnVuY3Rpb24gX2xvbmdlc3RUZXh0KFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgZm9udDogc3RyaW5nLFxuICBhcnJheU9mVGhpbmdzOiBUaGluZ3MsXG4gIGNhY2hlPzoge2RhdGE/OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+LCBnYXJiYWdlQ29sbGVjdD86IHN0cmluZ1tdLCBmb250Pzogc3RyaW5nfVxuKSB7XG4gIGNhY2hlID0gY2FjaGUgfHwge307XG4gIGxldCBkYXRhID0gY2FjaGUuZGF0YSA9IGNhY2hlLmRhdGEgfHwge307XG4gIGxldCBnYyA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0ID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgfHwgW107XG5cbiAgaWYgKGNhY2hlLmZvbnQgIT09IGZvbnQpIHtcbiAgICBkYXRhID0gY2FjaGUuZGF0YSA9IHt9O1xuICAgIGdjID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgPSBbXTtcbiAgICBjYWNoZS5mb250ID0gZm9udDtcbiAgfVxuXG4gIGN0eC5zYXZlKCk7XG5cbiAgY3R4LmZvbnQgPSBmb250O1xuICBsZXQgbG9uZ2VzdCA9IDA7XG4gIGNvbnN0IGlsZW4gPSBhcnJheU9mVGhpbmdzLmxlbmd0aDtcbiAgbGV0IGk6IG51bWJlciwgajogbnVtYmVyLCBqbGVuOiBudW1iZXIsIHRoaW5nOiBUaGluZyB8IFRoaW5nW10sIG5lc3RlZFRoaW5nOiBUaGluZyB8IFRoaW5nW107XG4gIGZvciAoaSA9IDA7IGkgPCBpbGVuOyBpKyspIHtcbiAgICB0aGluZyA9IGFycmF5T2ZUaGluZ3NbaV07XG5cbiAgICAvLyBVbmRlZmluZWQgc3RyaW5ncyBhbmQgYXJyYXlzIHNob3VsZCBub3QgYmUgbWVhc3VyZWRcbiAgICBpZiAodGhpbmcgIT09IHVuZGVmaW5lZCAmJiB0aGluZyAhPT0gbnVsbCAmJiAhaXNBcnJheSh0aGluZykpIHtcbiAgICAgIGxvbmdlc3QgPSBfbWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgdGhpbmcpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh0aGluZykpIHtcbiAgICAgIC8vIGlmIGl0IGlzIGFuIGFycmF5IGxldHMgbWVhc3VyZSBlYWNoIGVsZW1lbnRcbiAgICAgIC8vIHRvIGRvIG1heWJlIHNpbXBsaWZ5IHRoaXMgZnVuY3Rpb24gYSBiaXQgc28gd2UgY2FuIGRvIHRoaXMgbW9yZSByZWN1cnNpdmVseT9cbiAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSB0aGluZy5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgICAgbmVzdGVkVGhpbmcgPSB0aGluZ1tqXTtcbiAgICAgICAgLy8gVW5kZWZpbmVkIHN0cmluZ3MgYW5kIGFycmF5cyBzaG91bGQgbm90IGJlIG1lYXN1cmVkXG4gICAgICAgIGlmIChuZXN0ZWRUaGluZyAhPT0gdW5kZWZpbmVkICYmIG5lc3RlZFRoaW5nICE9PSBudWxsICYmICFpc0FycmF5KG5lc3RlZFRoaW5nKSkge1xuICAgICAgICAgIGxvbmdlc3QgPSBfbWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgbmVzdGVkVGhpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY3R4LnJlc3RvcmUoKTtcblxuICBjb25zdCBnY0xlbiA9IGdjLmxlbmd0aCAvIDI7XG4gIGlmIChnY0xlbiA+IGFycmF5T2ZUaGluZ3MubGVuZ3RoKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGdjTGVuOyBpKyspIHtcbiAgICAgIGRlbGV0ZSBkYXRhW2djW2ldXTtcbiAgICB9XG4gICAgZ2Muc3BsaWNlKDAsIGdjTGVuKTtcbiAgfVxuICByZXR1cm4gbG9uZ2VzdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBhbGlnbmVkIHBpeGVsIHZhbHVlIHRvIGF2b2lkIGFudGktYWxpYXNpbmcgYmx1clxuICogQHBhcmFtIGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlLlxuICogQHBhcmFtIHBpeGVsIC0gQSBwaXhlbCB2YWx1ZS5cbiAqIEBwYXJhbSB3aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgZWxlbWVudC5cbiAqIEByZXR1cm5zIFRoZSBhbGlnbmVkIHBpeGVsIHZhbHVlLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9hbGlnblBpeGVsKGNoYXJ0OiBDaGFydCwgcGl4ZWw6IG51bWJlciwgd2lkdGg6IG51bWJlcikge1xuICBjb25zdCBkZXZpY2VQaXhlbFJhdGlvID0gY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW87XG4gIGNvbnN0IGhhbGZXaWR0aCA9IHdpZHRoICE9PSAwID8gTWF0aC5tYXgod2lkdGggLyAyLCAwLjUpIDogMDtcbiAgcmV0dXJuIE1hdGgucm91bmQoKHBpeGVsIC0gaGFsZldpZHRoKSAqIGRldmljZVBpeGVsUmF0aW8pIC8gZGV2aWNlUGl4ZWxSYXRpbyArIGhhbGZXaWR0aDtcbn1cblxuLyoqXG4gKiBDbGVhcnMgdGhlIGVudGlyZSBjYW52YXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhckNhbnZhcyhjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCBjdHg/OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcbiAgY3R4ID0gY3R4IHx8IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gIGN0eC5zYXZlKCk7XG4gIC8vIGNhbnZhcy53aWR0aCBhbmQgY2FudmFzLmhlaWdodCBkbyBub3QgY29uc2lkZXIgdGhlIGNhbnZhcyB0cmFuc2Zvcm0sXG4gIC8vIHdoaWxlIGNsZWFyUmVjdCBkb2VzXG4gIGN0eC5yZXNldFRyYW5zZm9ybSgpO1xuICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRHJhd1BvaW50T3B0aW9ucyB7XG4gIHBvaW50U3R5bGU6IFBvaW50U3R5bGU7XG4gIHJvdGF0aW9uPzogbnVtYmVyO1xuICByYWRpdXM6IG51bWJlcjtcbiAgYm9yZGVyV2lkdGg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRyYXdQb2ludChcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIG9wdGlvbnM6IERyYXdQb2ludE9wdGlvbnMsXG4gIHg6IG51bWJlcixcbiAgeTogbnVtYmVyXG4pIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICBkcmF3UG9pbnRMZWdlbmQoY3R4LCBvcHRpb25zLCB4LCB5LCBudWxsKTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmV4cG9ydCBmdW5jdGlvbiBkcmF3UG9pbnRMZWdlbmQoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBvcHRpb25zOiBEcmF3UG9pbnRPcHRpb25zLFxuICB4OiBudW1iZXIsXG4gIHk6IG51bWJlcixcbiAgdzogbnVtYmVyXG4pIHtcbiAgbGV0IHR5cGU6IHN0cmluZywgeE9mZnNldDogbnVtYmVyLCB5T2Zmc2V0OiBudW1iZXIsIHNpemU6IG51bWJlciwgY29ybmVyUmFkaXVzOiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIHhPZmZzZXRXOiBudW1iZXIsIHlPZmZzZXRXOiBudW1iZXI7XG4gIGNvbnN0IHN0eWxlID0gb3B0aW9ucy5wb2ludFN0eWxlO1xuICBjb25zdCByb3RhdGlvbiA9IG9wdGlvbnMucm90YXRpb247XG4gIGNvbnN0IHJhZGl1cyA9IG9wdGlvbnMucmFkaXVzO1xuICBsZXQgcmFkID0gKHJvdGF0aW9uIHx8IDApICogUkFEX1BFUl9ERUc7XG5cbiAgaWYgKHN0eWxlICYmIHR5cGVvZiBzdHlsZSA9PT0gJ29iamVjdCcpIHtcbiAgICB0eXBlID0gc3R5bGUudG9TdHJpbmcoKTtcbiAgICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgSFRNTEltYWdlRWxlbWVudF0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IEhUTUxDYW52YXNFbGVtZW50XScpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgY3R4LnJvdGF0ZShyYWQpO1xuICAgICAgY3R4LmRyYXdJbWFnZShzdHlsZSwgLXN0eWxlLndpZHRoIC8gMiwgLXN0eWxlLmhlaWdodCAvIDIsIHN0eWxlLndpZHRoLCBzdHlsZS5oZWlnaHQpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNOYU4ocmFkaXVzKSB8fCByYWRpdXMgPD0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGN0eC5iZWdpblBhdGgoKTtcblxuICBzd2l0Y2ggKHN0eWxlKSB7XG4gIC8vIERlZmF1bHQgaW5jbHVkZXMgY2lyY2xlXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICh3KSB7XG4gICAgICAgIGN0eC5lbGxpcHNlKHgsIHksIHcgLyAyLCByYWRpdXMsIDAsIDAsIFRBVSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHguYXJjKHgsIHksIHJhZGl1cywgMCwgVEFVKTtcbiAgICAgIH1cbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RyaWFuZ2xlJzpcbiAgICAgIHdpZHRoID0gdyA/IHcgLyAyIDogcmFkaXVzO1xuICAgICAgY3R4Lm1vdmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHdpZHRoLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG4gICAgICByYWQgKz0gVFdPX1RISVJEU19QSTtcbiAgICAgIGN0eC5saW5lVG8oeCArIE1hdGguc2luKHJhZCkgKiB3aWR0aCwgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuICAgICAgcmFkICs9IFRXT19USElSRFNfUEk7XG4gICAgICBjdHgubGluZVRvKHggKyBNYXRoLnNpbihyYWQpICogd2lkdGgsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3JlY3RSb3VuZGVkJzpcbiAgICAvLyBOT1RFOiB0aGUgcm91bmRlZCByZWN0IGltcGxlbWVudGF0aW9uIGNoYW5nZWQgdG8gdXNlIGBhcmNgIGluc3RlYWQgb2ZcbiAgICAvLyBgcXVhZHJhdGljQ3VydmVUb2Agc2luY2UgaXQgZ2VuZXJhdGVzIGJldHRlciByZXN1bHRzIHdoZW4gcmVjdCBpc1xuICAgIC8vIGFsbW9zdCBhIGNpcmNsZS4gMC41MTYgKGluc3RlYWQgb2YgMC41KSBwcm9kdWNlcyByZXN1bHRzIHdpdGggdmlzdWFsbHlcbiAgICAvLyBjbG9zZXIgcHJvcG9ydGlvbiB0byB0aGUgcHJldmlvdXMgaW1wbCBhbmQgaXQgaXMgaW5zY3JpYmVkIGluIHRoZVxuICAgIC8vIGNpcmNsZSB3aXRoIGByYWRpdXNgLiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUgdGhlIGZvbGxvd2luZyBQUnM6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzU1OTdcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTg1OFxuICAgICAgY29ybmVyUmFkaXVzID0gcmFkaXVzICogMC41MTY7XG4gICAgICBzaXplID0gcmFkaXVzIC0gY29ybmVyUmFkaXVzO1xuICAgICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCArIFFVQVJURVJfUEkpICogc2l6ZTtcbiAgICAgIHhPZmZzZXRXID0gTWF0aC5jb3MocmFkICsgUVVBUlRFUl9QSSkgKiAodyA/IHcgLyAyIC0gY29ybmVyUmFkaXVzIDogc2l6ZSk7XG4gICAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkICsgUVVBUlRFUl9QSSkgKiBzaXplO1xuICAgICAgeU9mZnNldFcgPSBNYXRoLnNpbihyYWQgKyBRVUFSVEVSX1BJKSAqICh3ID8gdyAvIDIgLSBjb3JuZXJSYWRpdXMgOiBzaXplKTtcbiAgICAgIGN0eC5hcmMoeCAtIHhPZmZzZXRXLCB5IC0geU9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgLSBQSSwgcmFkIC0gSEFMRl9QSSk7XG4gICAgICBjdHguYXJjKHggKyB5T2Zmc2V0VywgeSAtIHhPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkIC0gSEFMRl9QSSwgcmFkKTtcbiAgICAgIGN0eC5hcmMoeCArIHhPZmZzZXRXLCB5ICsgeU9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQsIHJhZCArIEhBTEZfUEkpO1xuICAgICAgY3R4LmFyYyh4IC0geU9mZnNldFcsIHkgKyB4T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCArIEhBTEZfUEksIHJhZCArIFBJKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3JlY3QnOlxuICAgICAgaWYgKCFyb3RhdGlvbikge1xuICAgICAgICBzaXplID0gTWF0aC5TUVJUMV8yICogcmFkaXVzO1xuICAgICAgICB3aWR0aCA9IHcgPyB3IC8gMiA6IHNpemU7XG4gICAgICAgIGN0eC5yZWN0KHggLSB3aWR0aCwgeSAtIHNpemUsIDIgKiB3aWR0aCwgMiAqIHNpemUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJhZCArPSBRVUFSVEVSX1BJO1xuICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlICdyZWN0Um90JzpcbiAgICAgIHhPZmZzZXRXID0gTWF0aC5jb3MocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXRXID0gTWF0aC5zaW4ocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldFcsIHkgLSB5T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHlPZmZzZXRXLCB5IC0geE9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0VywgeSArIHlPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldFcsIHkgKyB4T2Zmc2V0KTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Nyb3NzUm90JzpcbiAgICAgIHJhZCArPSBRVUFSVEVSX1BJO1xuICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlICdjcm9zcyc6XG4gICAgICB4T2Zmc2V0VyA9IE1hdGguY29zKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0VyA9IE1hdGguc2luKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXRXLCB5IC0geU9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0VywgeSArIHlPZmZzZXQpO1xuICAgICAgY3R4Lm1vdmVUbyh4ICsgeU9mZnNldFcsIHkgLSB4T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXRXLCB5ICsgeE9mZnNldCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzdGFyJzpcbiAgICAgIHhPZmZzZXRXID0gTWF0aC5jb3MocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXRXID0gTWF0aC5zaW4ocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldFcsIHkgLSB5T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXRXLCB5ICsgeU9mZnNldCk7XG4gICAgICBjdHgubW92ZVRvKHggKyB5T2Zmc2V0VywgeSAtIHhPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldFcsIHkgKyB4T2Zmc2V0KTtcbiAgICAgIHJhZCArPSBRVUFSVEVSX1BJO1xuICAgICAgeE9mZnNldFcgPSBNYXRoLmNvcyhyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyk7XG4gICAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldFcgPSBNYXRoLnNpbihyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyk7XG4gICAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0VywgeSAtIHlPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldFcsIHkgKyB5T2Zmc2V0KTtcbiAgICAgIGN0eC5tb3ZlVG8oeCArIHlPZmZzZXRXLCB5IC0geE9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0VywgeSArIHhPZmZzZXQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbGluZSc6XG4gICAgICB4T2Zmc2V0ID0gdyA/IHcgLyAyIDogTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGFzaCc6XG4gICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgTWF0aC5jb3MocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpLCB5ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGZhbHNlOlxuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBjdHguZmlsbCgpO1xuICBpZiAob3B0aW9ucy5ib3JkZXJXaWR0aCA+IDApIHtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBvaW50IGlzIGluc2lkZSB0aGUgcmVjdGFuZ2xlXG4gKiBAcGFyYW0gcG9pbnQgLSBUaGUgcG9pbnQgdG8gdGVzdFxuICogQHBhcmFtIGFyZWEgLSBUaGUgcmVjdGFuZ2xlXG4gKiBAcGFyYW0gbWFyZ2luIC0gYWxsb3dlZCBtYXJnaW5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfaXNQb2ludEluQXJlYShcbiAgcG9pbnQ6IFBvaW50LFxuICBhcmVhOiBUUkJMLFxuICBtYXJnaW4/OiBudW1iZXJcbikge1xuICBtYXJnaW4gPSBtYXJnaW4gfHwgMC41OyAvLyBtYXJnaW4gLSBkZWZhdWx0IGlzIHRvIG1hdGNoIHJvdW5kZWQgZGVjaW1hbHNcblxuICByZXR1cm4gIWFyZWEgfHwgKHBvaW50ICYmIHBvaW50LnggPiBhcmVhLmxlZnQgLSBtYXJnaW4gJiYgcG9pbnQueCA8IGFyZWEucmlnaHQgKyBtYXJnaW4gJiZcblx0XHRwb2ludC55ID4gYXJlYS50b3AgLSBtYXJnaW4gJiYgcG9pbnQueSA8IGFyZWEuYm90dG9tICsgbWFyZ2luKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsaXBBcmVhKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBhcmVhOiBUUkJMKSB7XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LnJlY3QoYXJlYS5sZWZ0LCBhcmVhLnRvcCwgYXJlYS5yaWdodCAtIGFyZWEubGVmdCwgYXJlYS5ib3R0b20gLSBhcmVhLnRvcCk7XG4gIGN0eC5jbGlwKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bmNsaXBBcmVhKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9zdGVwcGVkTGluZVRvKFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgcHJldmlvdXM6IFBvaW50LFxuICB0YXJnZXQ6IFBvaW50LFxuICBmbGlwPzogYm9vbGVhbixcbiAgbW9kZT86IHN0cmluZ1xuKSB7XG4gIGlmICghcHJldmlvdXMpIHtcbiAgICByZXR1cm4gY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xuICB9XG4gIGlmIChtb2RlID09PSAnbWlkZGxlJykge1xuICAgIGNvbnN0IG1pZHBvaW50ID0gKHByZXZpb3VzLnggKyB0YXJnZXQueCkgLyAyLjA7XG4gICAgY3R4LmxpbmVUbyhtaWRwb2ludCwgcHJldmlvdXMueSk7XG4gICAgY3R4LmxpbmVUbyhtaWRwb2ludCwgdGFyZ2V0LnkpO1xuICB9IGVsc2UgaWYgKG1vZGUgPT09ICdhZnRlcicgIT09ICEhZmxpcCkge1xuICAgIGN0eC5saW5lVG8ocHJldmlvdXMueCwgdGFyZ2V0LnkpO1xuICB9IGVsc2Uge1xuICAgIGN0eC5saW5lVG8odGFyZ2V0LngsIHByZXZpb3VzLnkpO1xuICB9XG4gIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2JlemllckN1cnZlVG8oXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBwcmV2aW91czogU3BsaW5lUG9pbnQsXG4gIHRhcmdldDogU3BsaW5lUG9pbnQsXG4gIGZsaXA/OiBib29sZWFuXG4pIHtcbiAgaWYgKCFwcmV2aW91cykge1xuICAgIHJldHVybiBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG4gIH1cbiAgY3R4LmJlemllckN1cnZlVG8oXG4gICAgZmxpcCA/IHByZXZpb3VzLmNwMXggOiBwcmV2aW91cy5jcDJ4LFxuICAgIGZsaXAgPyBwcmV2aW91cy5jcDF5IDogcHJldmlvdXMuY3AyeSxcbiAgICBmbGlwID8gdGFyZ2V0LmNwMnggOiB0YXJnZXQuY3AxeCxcbiAgICBmbGlwID8gdGFyZ2V0LmNwMnkgOiB0YXJnZXQuY3AxeSxcbiAgICB0YXJnZXQueCxcbiAgICB0YXJnZXQueSk7XG59XG5cbmZ1bmN0aW9uIHNldFJlbmRlck9wdHMoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIG9wdHM6IFJlbmRlclRleHRPcHRzKSB7XG4gIGlmIChvcHRzLnRyYW5zbGF0aW9uKSB7XG4gICAgY3R4LnRyYW5zbGF0ZShvcHRzLnRyYW5zbGF0aW9uWzBdLCBvcHRzLnRyYW5zbGF0aW9uWzFdKTtcbiAgfVxuXG4gIGlmICghaXNOdWxsT3JVbmRlZihvcHRzLnJvdGF0aW9uKSkge1xuICAgIGN0eC5yb3RhdGUob3B0cy5yb3RhdGlvbik7XG4gIH1cblxuICBpZiAob3B0cy5jb2xvcikge1xuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRzLmNvbG9yO1xuICB9XG5cbiAgaWYgKG9wdHMudGV4dEFsaWduKSB7XG4gICAgY3R4LnRleHRBbGlnbiA9IG9wdHMudGV4dEFsaWduO1xuICB9XG5cbiAgaWYgKG9wdHMudGV4dEJhc2VsaW5lKSB7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9IG9wdHMudGV4dEJhc2VsaW5lO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlY29yYXRlVGV4dChcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIHg6IG51bWJlcixcbiAgeTogbnVtYmVyLFxuICBsaW5lOiBzdHJpbmcsXG4gIG9wdHM6IFJlbmRlclRleHRPcHRzXG4pIHtcbiAgaWYgKG9wdHMuc3RyaWtldGhyb3VnaCB8fCBvcHRzLnVuZGVybGluZSkge1xuICAgIC8qKlxuICAgICAqIE5vdyB0aGF0IElFMTEgc3VwcG9ydCBoYXMgYmVlbiBkcm9wcGVkLCB3ZSBjYW4gdXNlIG1vcmVcbiAgICAgKiBvZiB0aGUgVGV4dE1ldHJpY3Mgb2JqZWN0LiBUaGUgYWN0dWFsIGJvdW5kaW5nIGJveGVzXG4gICAgICogYXJlIHVuZmxhZ2dlZCBpbiBDaHJvbWUsIEZpcmVmb3gsIEVkZ2UsIGFuZCBTYWZhcmkgc28gdGhleVxuICAgICAqIGNhbiBiZSBzYWZlbHkgdXNlZC5cbiAgICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RleHRNZXRyaWNzI0Jyb3dzZXJfY29tcGF0aWJpbGl0eVxuICAgICAqL1xuICAgIGNvbnN0IG1ldHJpY3MgPSBjdHgubWVhc3VyZVRleHQobGluZSk7XG4gICAgY29uc3QgbGVmdCA9IHggLSBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94TGVmdDtcbiAgICBjb25zdCByaWdodCA9IHggKyBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94UmlnaHQ7XG4gICAgY29uc3QgdG9wID0geSAtIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQ7XG4gICAgY29uc3QgYm90dG9tID0geSArIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50O1xuICAgIGNvbnN0IHlEZWNvcmF0aW9uID0gb3B0cy5zdHJpa2V0aHJvdWdoID8gKHRvcCArIGJvdHRvbSkgLyAyIDogYm90dG9tO1xuXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmxpbmVXaWR0aCA9IG9wdHMuZGVjb3JhdGlvbldpZHRoIHx8IDI7XG4gICAgY3R4Lm1vdmVUbyhsZWZ0LCB5RGVjb3JhdGlvbik7XG4gICAgY3R4LmxpbmVUbyhyaWdodCwgeURlY29yYXRpb24pO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3QmFja2Ryb3AoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIG9wdHM6IEJhY2tkcm9wT3B0aW9ucykge1xuICBjb25zdCBvbGRDb2xvciA9IGN0eC5maWxsU3R5bGU7XG5cbiAgY3R4LmZpbGxTdHlsZSA9IG9wdHMuY29sb3IgYXMgc3RyaW5nO1xuICBjdHguZmlsbFJlY3Qob3B0cy5sZWZ0LCBvcHRzLnRvcCwgb3B0cy53aWR0aCwgb3B0cy5oZWlnaHQpO1xuICBjdHguZmlsbFN0eWxlID0gb2xkQ29sb3I7XG59XG5cbi8qKlxuICogUmVuZGVyIHRleHQgb250byB0aGUgY2FudmFzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJUZXh0KFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgdGV4dDogc3RyaW5nIHwgc3RyaW5nW10sXG4gIHg6IG51bWJlcixcbiAgeTogbnVtYmVyLFxuICBmb250OiBDYW52YXNGb250U3BlYyxcbiAgb3B0czogUmVuZGVyVGV4dE9wdHMgPSB7fVxuKSB7XG4gIGNvbnN0IGxpbmVzID0gaXNBcnJheSh0ZXh0KSA/IHRleHQgOiBbdGV4dF07XG4gIGNvbnN0IHN0cm9rZSA9IG9wdHMuc3Ryb2tlV2lkdGggPiAwICYmIG9wdHMuc3Ryb2tlQ29sb3IgIT09ICcnO1xuICBsZXQgaTogbnVtYmVyLCBsaW5lOiBzdHJpbmc7XG5cbiAgY3R4LnNhdmUoKTtcbiAgY3R4LmZvbnQgPSBmb250LnN0cmluZztcbiAgc2V0UmVuZGVyT3B0cyhjdHgsIG9wdHMpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xuICAgIGxpbmUgPSBsaW5lc1tpXTtcblxuICAgIGlmIChvcHRzLmJhY2tkcm9wKSB7XG4gICAgICBkcmF3QmFja2Ryb3AoY3R4LCBvcHRzLmJhY2tkcm9wKTtcbiAgICB9XG5cbiAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICBpZiAob3B0cy5zdHJva2VDb2xvcikge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRzLnN0cm9rZUNvbG9yO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTnVsbE9yVW5kZWYob3B0cy5zdHJva2VXaWR0aCkpIHtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IG9wdHMuc3Ryb2tlV2lkdGg7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zdHJva2VUZXh0KGxpbmUsIHgsIHksIG9wdHMubWF4V2lkdGgpO1xuICAgIH1cblxuICAgIGN0eC5maWxsVGV4dChsaW5lLCB4LCB5LCBvcHRzLm1heFdpZHRoKTtcbiAgICBkZWNvcmF0ZVRleHQoY3R4LCB4LCB5LCBsaW5lLCBvcHRzKTtcblxuICAgIHkgKz0gTnVtYmVyKGZvbnQubGluZUhlaWdodCk7XG4gIH1cblxuICBjdHgucmVzdG9yZSgpO1xufVxuXG4vKipcbiAqIEFkZCBhIHBhdGggb2YgYSByZWN0YW5nbGUgd2l0aCByb3VuZGVkIGNvcm5lcnMgdG8gdGhlIGN1cnJlbnQgc3ViLXBhdGhcbiAqIEBwYXJhbSBjdHggLSBDb250ZXh0XG4gKiBAcGFyYW0gcmVjdCAtIEJvdW5kaW5nIHJlY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFJvdW5kZWRSZWN0UGF0aChcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIHJlY3Q6IFJvdW5kZWRSZWN0ICYgeyByYWRpdXM6IFRSQkxDb3JuZXJzIH1cbikge1xuICBjb25zdCB7eCwgeSwgdywgaCwgcmFkaXVzfSA9IHJlY3Q7XG5cbiAgLy8gdG9wIGxlZnQgYXJjXG4gIGN0eC5hcmMoeCArIHJhZGl1cy50b3BMZWZ0LCB5ICsgcmFkaXVzLnRvcExlZnQsIHJhZGl1cy50b3BMZWZ0LCAxLjUgKiBQSSwgUEksIHRydWUpO1xuXG4gIC8vIGxpbmUgZnJvbSB0b3AgbGVmdCB0byBib3R0b20gbGVmdFxuICBjdHgubGluZVRvKHgsIHkgKyBoIC0gcmFkaXVzLmJvdHRvbUxlZnQpO1xuXG4gIC8vIGJvdHRvbSBsZWZ0IGFyY1xuICBjdHguYXJjKHggKyByYWRpdXMuYm90dG9tTGVmdCwgeSArIGggLSByYWRpdXMuYm90dG9tTGVmdCwgcmFkaXVzLmJvdHRvbUxlZnQsIFBJLCBIQUxGX1BJLCB0cnVlKTtcblxuICAvLyBsaW5lIGZyb20gYm90dG9tIGxlZnQgdG8gYm90dG9tIHJpZ2h0XG4gIGN0eC5saW5lVG8oeCArIHcgLSByYWRpdXMuYm90dG9tUmlnaHQsIHkgKyBoKTtcblxuICAvLyBib3R0b20gcmlnaHQgYXJjXG4gIGN0eC5hcmMoeCArIHcgLSByYWRpdXMuYm90dG9tUmlnaHQsIHkgKyBoIC0gcmFkaXVzLmJvdHRvbVJpZ2h0LCByYWRpdXMuYm90dG9tUmlnaHQsIEhBTEZfUEksIDAsIHRydWUpO1xuXG4gIC8vIGxpbmUgZnJvbSBib3R0b20gcmlnaHQgdG8gdG9wIHJpZ2h0XG4gIGN0eC5saW5lVG8oeCArIHcsIHkgKyByYWRpdXMudG9wUmlnaHQpO1xuXG4gIC8vIHRvcCByaWdodCBhcmNcbiAgY3R4LmFyYyh4ICsgdyAtIHJhZGl1cy50b3BSaWdodCwgeSArIHJhZGl1cy50b3BSaWdodCwgcmFkaXVzLnRvcFJpZ2h0LCAwLCAtSEFMRl9QSSwgdHJ1ZSk7XG5cbiAgLy8gbGluZSBmcm9tIHRvcCByaWdodCB0byB0b3AgbGVmdFxuICBjdHgubGluZVRvKHggKyByYWRpdXMudG9wTGVmdCwgeSk7XG59XG4iLCAiaW1wb3J0IGRlZmF1bHRzIGZyb20gJy4uL2NvcmUvY29yZS5kZWZhdWx0cy5qcyc7XG5pbXBvcnQge2lzQXJyYXksIGlzT2JqZWN0LCB0b0RpbWVuc2lvbiwgdmFsdWVPckRlZmF1bHR9IGZyb20gJy4vaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7dG9Gb250U3RyaW5nfSBmcm9tICcuL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB0eXBlIHtDaGFydEFyZWEsIEZvbnRTcGVjLCBQb2ludH0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuaW1wb3J0IHR5cGUge1RSQkwsIFRSQkxDb3JuZXJzfSBmcm9tICcuLi90eXBlcy9nZW9tZXRyaWMuanMnO1xuXG5jb25zdCBMSU5FX0hFSUdIVCA9IC9eKG5vcm1hbHwoXFxkKyg/OlxcLlxcZCspPykocHh8ZW18JSk/KSQvO1xuY29uc3QgRk9OVF9TVFlMRSA9IC9eKG5vcm1hbHxpdGFsaWN8aW5pdGlhbHxpbmhlcml0fHVuc2V0fChvYmxpcXVlKCAtP1swLTldP1swLTldZGVnKT8pKSQvO1xuXG4vKipcbiAqIEBhbGlhcyBDaGFydC5oZWxwZXJzLm9wdGlvbnNcbiAqIEBuYW1lc3BhY2VcbiAqL1xuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gbGluZSBoZWlnaHQgYHZhbHVlYCBpbiBwaXhlbHMgZm9yIGEgc3BlY2lmaWMgZm9udCBgc2l6ZWAuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbGluZUhlaWdodCB0byBwYXJzZSAoZWcuIDEuNiwgJzE0cHgnLCAnNzUlJywgJzEuNmVtJykuXG4gKiBAcGFyYW0gc2l6ZSAtIFRoZSBmb250IHNpemUgKGluIHBpeGVscykgdXNlZCB0byByZXNvbHZlIHJlbGF0aXZlIGB2YWx1ZWAuXG4gKiBAcmV0dXJucyBUaGUgZWZmZWN0aXZlIGxpbmUgaGVpZ2h0IGluIHBpeGVscyAoc2l6ZSAqIDEuMiBpZiB2YWx1ZSBpcyBpbnZhbGlkKS5cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2xpbmUtaGVpZ2h0XG4gKiBAc2luY2UgMi43LjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvTGluZUhlaWdodCh2YWx1ZTogbnVtYmVyIHwgc3RyaW5nLCBzaXplOiBudW1iZXIpOiBudW1iZXIge1xuICBjb25zdCBtYXRjaGVzID0gKCcnICsgdmFsdWUpLm1hdGNoKExJTkVfSEVJR0hUKTtcbiAgaWYgKCFtYXRjaGVzIHx8IG1hdGNoZXNbMV0gPT09ICdub3JtYWwnKSB7XG4gICAgcmV0dXJuIHNpemUgKiAxLjI7XG4gIH1cblxuICB2YWx1ZSA9ICttYXRjaGVzWzJdO1xuXG4gIHN3aXRjaCAobWF0Y2hlc1szXSkge1xuICAgIGNhc2UgJ3B4JzpcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBjYXNlICclJzpcbiAgICAgIHZhbHVlIC89IDEwMDtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBzaXplICogdmFsdWU7XG59XG5cbmNvbnN0IG51bWJlck9yWmVybyA9ICh2OiB1bmtub3duKSA9PiArdiB8fCAwO1xuXG4vKipcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHBhcmFtIHByb3BzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfcmVhZFZhbHVlVG9Qcm9wczxLIGV4dGVuZHMgc3RyaW5nPih2YWx1ZTogbnVtYmVyIHwgUmVjb3JkPEssIG51bWJlcj4sIHByb3BzOiBLW10pOiBSZWNvcmQ8SywgbnVtYmVyPjtcbmV4cG9ydCBmdW5jdGlvbiBfcmVhZFZhbHVlVG9Qcm9wczxLIGV4dGVuZHMgc3RyaW5nLCBUIGV4dGVuZHMgc3RyaW5nPih2YWx1ZTogbnVtYmVyIHwgUmVjb3JkPEsgJiBULCBudW1iZXI+LCBwcm9wczogUmVjb3JkPFQsIEs+KTogUmVjb3JkPFQsIG51bWJlcj47XG5leHBvcnQgZnVuY3Rpb24gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWU6IG51bWJlciB8IFJlY29yZDxzdHJpbmcsIG51bWJlcj4sIHByb3BzOiBzdHJpbmdbXSB8IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGNvbnN0IG9ialByb3BzID0gaXNPYmplY3QocHJvcHMpO1xuICBjb25zdCBrZXlzID0gb2JqUHJvcHMgPyBPYmplY3Qua2V5cyhwcm9wcykgOiBwcm9wcztcbiAgY29uc3QgcmVhZCA9IGlzT2JqZWN0KHZhbHVlKVxuICAgID8gb2JqUHJvcHNcbiAgICAgID8gcHJvcCA9PiB2YWx1ZU9yRGVmYXVsdCh2YWx1ZVtwcm9wXSwgdmFsdWVbcHJvcHNbcHJvcF1dKVxuICAgICAgOiBwcm9wID0+IHZhbHVlW3Byb3BdXG4gICAgOiAoKSA9PiB2YWx1ZTtcblxuICBmb3IgKGNvbnN0IHByb3Agb2Yga2V5cykge1xuICAgIHJldFtwcm9wXSA9IG51bWJlck9yWmVybyhyZWFkKHByb3ApKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiB2YWx1ZSBpbnRvIGEgVFJCTCBvYmplY3QuXG4gKiBAcGFyYW0gdmFsdWUgLSBJZiBhIG51bWJlciwgc2V0IHRoZSB2YWx1ZSB0byBhbGwgVFJCTCBjb21wb25lbnQsXG4gKiAgZWxzZSwgaWYgYW4gb2JqZWN0LCB1c2UgZGVmaW5lZCBwcm9wZXJ0aWVzIGFuZCBzZXRzIHVuZGVmaW5lZCBvbmVzIHRvIDAuXG4gKiAgeCAvIHkgYXJlIHNob3J0aGFuZHMgZm9yIHNhbWUgdmFsdWUgZm9yIGxlZnQvcmlnaHQgYW5kIHRvcC9ib3R0b20uXG4gKiBAcmV0dXJucyBUaGUgcGFkZGluZyB2YWx1ZXMgKHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdClcbiAqIEBzaW5jZSAzLjAuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9UUkJMKHZhbHVlOiBudW1iZXIgfCBUUkJMIHwgUG9pbnQpIHtcbiAgcmV0dXJuIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlLCB7dG9wOiAneScsIHJpZ2h0OiAneCcsIGJvdHRvbTogJ3knLCBsZWZ0OiAneCd9KTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gdmFsdWUgaW50byBhIFRSQkwgY29ybmVycyBvYmplY3QgKHNpbWlsYXIgd2l0aCBjc3MgYm9yZGVyLXJhZGl1cykuXG4gKiBAcGFyYW0gdmFsdWUgLSBJZiBhIG51bWJlciwgc2V0IHRoZSB2YWx1ZSB0byBhbGwgVFJCTCBjb3JuZXIgY29tcG9uZW50cyxcbiAqICBlbHNlLCBpZiBhbiBvYmplY3QsIHVzZSBkZWZpbmVkIHByb3BlcnRpZXMgYW5kIHNldHMgdW5kZWZpbmVkIG9uZXMgdG8gMC5cbiAqIEByZXR1cm5zIFRoZSBUUkJMIGNvcm5lciB2YWx1ZXMgKHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodClcbiAqIEBzaW5jZSAzLjAuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9UUkJMQ29ybmVycyh2YWx1ZTogbnVtYmVyIHwgVFJCTENvcm5lcnMpIHtcbiAgcmV0dXJuIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlLCBbJ3RvcExlZnQnLCAndG9wUmlnaHQnLCAnYm90dG9tTGVmdCcsICdib3R0b21SaWdodCddKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gdmFsdWUgaW50byBhIHBhZGRpbmcgb2JqZWN0IHdpdGggcHJlLWNvbXB1dGVkIHdpZHRoL2hlaWdodC5cbiAqIEBwYXJhbSB2YWx1ZSAtIElmIGEgbnVtYmVyLCBzZXQgdGhlIHZhbHVlIHRvIGFsbCBUUkJMIGNvbXBvbmVudCxcbiAqICBlbHNlLCBpZiBhbiBvYmplY3QsIHVzZSBkZWZpbmVkIHByb3BlcnRpZXMgYW5kIHNldHMgdW5kZWZpbmVkIG9uZXMgdG8gMC5cbiAqICB4IC8geSBhcmUgc2hvcnRoYW5kcyBmb3Igc2FtZSB2YWx1ZSBmb3IgbGVmdC9yaWdodCBhbmQgdG9wL2JvdHRvbS5cbiAqIEByZXR1cm5zIFRoZSBwYWRkaW5nIHZhbHVlcyAodG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0KVxuICogQHNpbmNlIDIuNy4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1BhZGRpbmcodmFsdWU/OiBudW1iZXIgfCBUUkJMKTogQ2hhcnRBcmVhIHtcbiAgY29uc3Qgb2JqID0gdG9UUkJMKHZhbHVlKSBhcyBDaGFydEFyZWE7XG5cbiAgb2JqLndpZHRoID0gb2JqLmxlZnQgKyBvYmoucmlnaHQ7XG4gIG9iai5oZWlnaHQgPSBvYmoudG9wICsgb2JqLmJvdHRvbTtcblxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIFBhcnNlcyBmb250IG9wdGlvbnMgYW5kIHJldHVybnMgdGhlIGZvbnQgb2JqZWN0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBBIG9iamVjdCB0aGF0IGNvbnRhaW5zIGZvbnQgb3B0aW9ucyB0byBiZSBwYXJzZWQuXG4gKiBAcGFyYW0gZmFsbGJhY2sgLSBBIG9iamVjdCB0aGF0IGNvbnRhaW5zIGZhbGxiYWNrIGZvbnQgb3B0aW9ucy5cbiAqIEByZXR1cm4gVGhlIGZvbnQgb2JqZWN0LlxuICogQHByaXZhdGVcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdG9Gb250KG9wdGlvbnM6IFBhcnRpYWw8Rm9udFNwZWM+LCBmYWxsYmFjaz86IFBhcnRpYWw8Rm9udFNwZWM+KSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBmYWxsYmFjayA9IGZhbGxiYWNrIHx8IGRlZmF1bHRzLmZvbnQgYXMgRm9udFNwZWM7XG5cbiAgbGV0IHNpemUgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnNpemUsIGZhbGxiYWNrLnNpemUpO1xuXG4gIGlmICh0eXBlb2Ygc2l6ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBzaXplID0gcGFyc2VJbnQoc2l6ZSwgMTApO1xuICB9XG4gIGxldCBzdHlsZSA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuc3R5bGUsIGZhbGxiYWNrLnN0eWxlKTtcbiAgaWYgKHN0eWxlICYmICEoJycgKyBzdHlsZSkubWF0Y2goRk9OVF9TVFlMRSkpIHtcbiAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgZm9udCBzdHlsZSBzcGVjaWZpZWQ6IFwiJyArIHN0eWxlICsgJ1wiJyk7XG4gICAgc3R5bGUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBmb250ID0ge1xuICAgIGZhbWlseTogdmFsdWVPckRlZmF1bHQob3B0aW9ucy5mYW1pbHksIGZhbGxiYWNrLmZhbWlseSksXG4gICAgbGluZUhlaWdodDogdG9MaW5lSGVpZ2h0KHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMubGluZUhlaWdodCwgZmFsbGJhY2subGluZUhlaWdodCksIHNpemUpLFxuICAgIHNpemUsXG4gICAgc3R5bGUsXG4gICAgd2VpZ2h0OiB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLndlaWdodCwgZmFsbGJhY2sud2VpZ2h0KSxcbiAgICBzdHJpbmc6ICcnXG4gIH07XG5cbiAgZm9udC5zdHJpbmcgPSB0b0ZvbnRTdHJpbmcoZm9udCk7XG4gIHJldHVybiBmb250O1xufVxuXG4vKipcbiAqIEV2YWx1YXRlcyB0aGUgZ2l2ZW4gYGlucHV0c2Agc2VxdWVudGlhbGx5IGFuZCByZXR1cm5zIHRoZSBmaXJzdCBkZWZpbmVkIHZhbHVlLlxuICogQHBhcmFtIGlucHV0cyAtIEFuIGFycmF5IG9mIHZhbHVlcywgZmFsbGluZyBiYWNrIHRvIHRoZSBsYXN0IHZhbHVlLlxuICogQHBhcmFtIGNvbnRleHQgLSBJZiBkZWZpbmVkIGFuZCB0aGUgY3VycmVudCB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCB0aGUgdmFsdWVcbiAqIGlzIGNhbGxlZCB3aXRoIGBjb250ZXh0YCBhcyBmaXJzdCBhcmd1bWVudCBhbmQgdGhlIHJlc3VsdCBiZWNvbWVzIHRoZSBuZXcgaW5wdXQuXG4gKiBAcGFyYW0gaW5kZXggLSBJZiBkZWZpbmVkIGFuZCB0aGUgY3VycmVudCB2YWx1ZSBpcyBhbiBhcnJheSwgdGhlIHZhbHVlXG4gKiBhdCBgaW5kZXhgIGJlY29tZSB0aGUgbmV3IGlucHV0LlxuICogQHBhcmFtIGluZm8gLSBvYmplY3QgdG8gcmV0dXJuIGluZm9ybWF0aW9uIGFib3V0IHJlc29sdXRpb24gaW5cbiAqIEBwYXJhbSBpbmZvLmNhY2hlYWJsZSAtIFdpbGwgYmUgc2V0IHRvIGBmYWxzZWAgaWYgb3B0aW9uIGlzIG5vdCBjYWNoZWFibGUuXG4gKiBAc2luY2UgMi43LjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmUoaW5wdXRzOiBBcnJheTx1bmtub3duPiwgY29udGV4dD86IG9iamVjdCwgaW5kZXg/OiBudW1iZXIsIGluZm8/OiB7IGNhY2hlYWJsZTogYm9vbGVhbiB9KSB7XG4gIGxldCBjYWNoZWFibGUgPSB0cnVlO1xuICBsZXQgaTogbnVtYmVyLCBpbGVuOiBudW1iZXIsIHZhbHVlOiB1bmtub3duO1xuXG4gIGZvciAoaSA9IDAsIGlsZW4gPSBpbnB1dHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgdmFsdWUgPSBpbnB1dHNbaV07XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoY29udGV4dCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZShjb250ZXh0KTtcbiAgICAgIGNhY2hlYWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCAmJiBpc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZVtpbmRleCAlIHZhbHVlLmxlbmd0aF07XG4gICAgICBjYWNoZWFibGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChpbmZvICYmICFjYWNoZWFibGUpIHtcbiAgICAgICAgaW5mby5jYWNoZWFibGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0gbWlubWF4XG4gKiBAcGFyYW0gZ3JhY2VcbiAqIEBwYXJhbSBiZWdpbkF0WmVyb1xuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9hZGRHcmFjZShtaW5tYXg6IHsgbWluOiBudW1iZXI7IG1heDogbnVtYmVyOyB9LCBncmFjZTogbnVtYmVyIHwgc3RyaW5nLCBiZWdpbkF0WmVybzogYm9vbGVhbikge1xuICBjb25zdCB7bWluLCBtYXh9ID0gbWlubWF4O1xuICBjb25zdCBjaGFuZ2UgPSB0b0RpbWVuc2lvbihncmFjZSwgKG1heCAtIG1pbikgLyAyKTtcbiAgY29uc3Qga2VlcFplcm8gPSAodmFsdWU6IG51bWJlciwgYWRkOiBudW1iZXIpID0+IGJlZ2luQXRaZXJvICYmIHZhbHVlID09PSAwID8gMCA6IHZhbHVlICsgYWRkO1xuICByZXR1cm4ge1xuICAgIG1pbjoga2VlcFplcm8obWluLCAtTWF0aC5hYnMoY2hhbmdlKSksXG4gICAgbWF4OiBrZWVwWmVybyhtYXgsIGNoYW5nZSlcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjb250ZXh0IGluaGVyaXRpbmcgcGFyZW50Q29udGV4dFxuICogQHBhcmFtIHBhcmVudENvbnRleHRcbiAqIEBwYXJhbSBjb250ZXh0XG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29udGV4dDxUIGV4dGVuZHMgb2JqZWN0PihwYXJlbnRDb250ZXh0OiBudWxsLCBjb250ZXh0OiBUKTogVDtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb250ZXh0PFQgZXh0ZW5kcyBvYmplY3QsIFAgZXh0ZW5kcyBUPihwYXJlbnRDb250ZXh0OiBQLCBjb250ZXh0OiBUKTogUCAmIFQ7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29udGV4dChwYXJlbnRDb250ZXh0OiBvYmplY3QsIGNvbnRleHQ6IG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKHBhcmVudENvbnRleHQpLCBjb250ZXh0KTtcbn1cbiIsICIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmUgKi9cbmltcG9ydCB0eXBlIHtBbnlPYmplY3R9IGZyb20gJy4uL3R5cGVzL2Jhc2ljLmpzJztcbmltcG9ydCB0eXBlIHtDaGFydE1ldGF9IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcbmltcG9ydCB0eXBlIHtcbiAgUmVzb2x2ZXJPYmplY3RLZXksXG4gIFJlc29sdmVyQ2FjaGUsXG4gIFJlc29sdmVyUHJveHksXG4gIERlc2NyaXB0b3JEZWZhdWx0cyxcbiAgRGVzY3JpcHRvcixcbiAgQ29udGV4dENhY2hlLFxuICBDb250ZXh0UHJveHlcbn0gZnJvbSAnLi9oZWxwZXJzLmNvbmZpZy50eXBlcy5qcyc7XG5pbXBvcnQge2lzQXJyYXksIGlzRnVuY3Rpb24sIGlzT2JqZWN0LCByZXNvbHZlT2JqZWN0S2V5LCBfY2FwaXRhbGl6ZX0gZnJvbSAnLi9oZWxwZXJzLmNvcmUuanMnO1xuXG5leHBvcnQgKiBmcm9tICcuL2hlbHBlcnMuY29uZmlnLnR5cGVzLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgUHJveHkgZm9yIHJlc29sdmluZyByYXcgdmFsdWVzIGZvciBvcHRpb25zLlxuICogQHBhcmFtIHNjb3BlcyAtIFRoZSBvcHRpb24gc2NvcGVzIHRvIGxvb2sgZm9yIHZhbHVlcywgaW4gcmVzb2x1dGlvbiBvcmRlclxuICogQHBhcmFtIHByZWZpeGVzIC0gVGhlIHByZWZpeGVzIGZvciB2YWx1ZXMsIGluIHJlc29sdXRpb24gb3JkZXIuXG4gKiBAcGFyYW0gcm9vdFNjb3BlcyAtIFRoZSByb290IG9wdGlvbiBzY29wZXNcbiAqIEBwYXJhbSBmYWxsYmFjayAtIFBhcmVudCBzY29wZXMgZmFsbGJhY2tcbiAqIEBwYXJhbSBnZXRUYXJnZXQgLSBjYWxsYmFjayBmb3IgZ2V0dGluZyB0aGUgdGFyZ2V0IGZvciBjaGFuZ2VkIHZhbHVlc1xuICogQHJldHVybnMgUHJveHlcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfY3JlYXRlUmVzb2x2ZXI8XG4gIFQgZXh0ZW5kcyBBbnlPYmplY3RbXSA9IEFueU9iamVjdFtdLFxuICBSIGV4dGVuZHMgQW55T2JqZWN0W10gPSBUXG4+KFxuICBzY29wZXM6IFQsXG4gIHByZWZpeGVzID0gWycnXSxcbiAgcm9vdFNjb3Blcz86IFIsXG4gIGZhbGxiYWNrPzogUmVzb2x2ZXJPYmplY3RLZXksXG4gIGdldFRhcmdldCA9ICgpID0+IHNjb3Blc1swXVxuKSB7XG4gIGNvbnN0IGZpbmFsUm9vdFNjb3BlcyA9IHJvb3RTY29wZXMgfHwgc2NvcGVzO1xuICBpZiAodHlwZW9mIGZhbGxiYWNrID09PSAndW5kZWZpbmVkJykge1xuICAgIGZhbGxiYWNrID0gX3Jlc29sdmUoJ19mYWxsYmFjaycsIHNjb3Blcyk7XG4gIH1cbiAgY29uc3QgY2FjaGU6IFJlc29sdmVyQ2FjaGU8VCwgUj4gPSB7XG4gICAgW1N5bWJvbC50b1N0cmluZ1RhZ106ICdPYmplY3QnLFxuICAgIF9jYWNoZWFibGU6IHRydWUsXG4gICAgX3Njb3Blczogc2NvcGVzLFxuICAgIF9yb290U2NvcGVzOiBmaW5hbFJvb3RTY29wZXMsXG4gICAgX2ZhbGxiYWNrOiBmYWxsYmFjayxcbiAgICBfZ2V0VGFyZ2V0OiBnZXRUYXJnZXQsXG4gICAgb3ZlcnJpZGU6IChzY29wZTogQW55T2JqZWN0KSA9PiBfY3JlYXRlUmVzb2x2ZXIoW3Njb3BlLCAuLi5zY29wZXNdLCBwcmVmaXhlcywgZmluYWxSb290U2NvcGVzLCBmYWxsYmFjayksXG4gIH07XG4gIHJldHVybiBuZXcgUHJveHkoY2FjaGUsIHtcbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIHRoZSBkZWxldGUgb3BlcmF0b3IuXG4gICAgICovXG4gICAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wOiBzdHJpbmcpIHtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbcHJvcF07IC8vIHJlbW92ZSBmcm9tIGNhY2hlXG4gICAgICBkZWxldGUgdGFyZ2V0Ll9rZXlzOyAvLyByZW1vdmUgY2FjaGVkIGtleXNcbiAgICAgIGRlbGV0ZSBzY29wZXNbMF1bcHJvcF07IC8vIHJlbW92ZSBmcm9tIHRvcCBsZXZlbCBzY29wZVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgZ2V0dGluZyBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICovXG4gICAgZ2V0KHRhcmdldCwgcHJvcDogc3RyaW5nKSB7XG4gICAgICByZXR1cm4gX2NhY2hlZCh0YXJnZXQsIHByb3AsXG4gICAgICAgICgpID0+IF9yZXNvbHZlV2l0aFByZWZpeGVzKHByb3AsIHByZWZpeGVzLCBzY29wZXMsIHRhcmdldCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuXG4gICAgICogQWxzbyB1c2VkIGJ5IE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0Ll9zY29wZXNbMF0sIHByb3ApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZi5cbiAgICAgKi9cbiAgICBnZXRQcm90b3R5cGVPZigpIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHNjb3Blc1swXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgdGhlIGluIG9wZXJhdG9yLlxuICAgICAqL1xuICAgIGhhcyh0YXJnZXQsIHByb3A6IHN0cmluZykge1xuICAgICAgcmV0dXJuIGdldEtleXNGcm9tQWxsU2NvcGVzKHRhcmdldCkuaW5jbHVkZXMocHJvcCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgYW5kIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMuXG4gICAgICovXG4gICAgb3duS2V5cyh0YXJnZXQpIHtcbiAgICAgIHJldHVybiBnZXRLZXlzRnJvbUFsbFNjb3Blcyh0YXJnZXQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIHNldHRpbmcgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqL1xuICAgIHNldCh0YXJnZXQsIHByb3A6IHN0cmluZywgdmFsdWUpIHtcbiAgICAgIGNvbnN0IHN0b3JhZ2UgPSB0YXJnZXQuX3N0b3JhZ2UgfHwgKHRhcmdldC5fc3RvcmFnZSA9IGdldFRhcmdldCgpKTtcbiAgICAgIHRhcmdldFtwcm9wXSA9IHN0b3JhZ2VbcHJvcF0gPSB2YWx1ZTsgLy8gc2V0IHRvIHRvcCBsZXZlbCBzY29wZSArIGNhY2hlXG4gICAgICBkZWxldGUgdGFyZ2V0Ll9rZXlzOyAvLyByZW1vdmUgY2FjaGVkIGtleXNcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSkgYXMgUmVzb2x2ZXJQcm94eTxULCBSPjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIFByb3h5IGZvciByZXNvbHZpbmcgb3B0aW9uIHZhbHVlcyB3aXRoIGNvbnRleHQuXG4gKiBAcGFyYW0gcHJveHkgLSBUaGUgUHJveHkgcmV0dXJuZWQgYnkgYF9jcmVhdGVSZXNvbHZlcmBcbiAqIEBwYXJhbSBjb250ZXh0IC0gQ29udGV4dCBvYmplY3QgZm9yIHNjcmlwdGFibGUvaW5kZXhhYmxlIG9wdGlvbnNcbiAqIEBwYXJhbSBzdWJQcm94eSAtIFRoZSBwcm94eSBwcm92aWRlZCBmb3Igc2NyaXB0YWJsZSBvcHRpb25zXG4gKiBAcGFyYW0gZGVzY3JpcHRvckRlZmF1bHRzIC0gRGVmYXVsdHMgZm9yIGRlc2NyaXB0b3JzXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2F0dGFjaENvbnRleHQ8XG4gIFQgZXh0ZW5kcyBBbnlPYmplY3RbXSA9IEFueU9iamVjdFtdLFxuICBSIGV4dGVuZHMgQW55T2JqZWN0W10gPSBUXG4+KFxuICBwcm94eTogUmVzb2x2ZXJQcm94eTxULCBSPixcbiAgY29udGV4dDogQW55T2JqZWN0LFxuICBzdWJQcm94eT86IFJlc29sdmVyUHJveHk8VCwgUj4sXG4gIGRlc2NyaXB0b3JEZWZhdWx0cz86IERlc2NyaXB0b3JEZWZhdWx0c1xuKSB7XG4gIGNvbnN0IGNhY2hlOiBDb250ZXh0Q2FjaGU8VCwgUj4gPSB7XG4gICAgX2NhY2hlYWJsZTogZmFsc2UsXG4gICAgX3Byb3h5OiBwcm94eSxcbiAgICBfY29udGV4dDogY29udGV4dCxcbiAgICBfc3ViUHJveHk6IHN1YlByb3h5LFxuICAgIF9zdGFjazogbmV3IFNldCgpLFxuICAgIF9kZXNjcmlwdG9yczogX2Rlc2NyaXB0b3JzKHByb3h5LCBkZXNjcmlwdG9yRGVmYXVsdHMpLFxuICAgIHNldENvbnRleHQ6IChjdHg6IEFueU9iamVjdCkgPT4gX2F0dGFjaENvbnRleHQocHJveHksIGN0eCwgc3ViUHJveHksIGRlc2NyaXB0b3JEZWZhdWx0cyksXG4gICAgb3ZlcnJpZGU6IChzY29wZTogQW55T2JqZWN0KSA9PiBfYXR0YWNoQ29udGV4dChwcm94eS5vdmVycmlkZShzY29wZSksIGNvbnRleHQsIHN1YlByb3h5LCBkZXNjcmlwdG9yRGVmYXVsdHMpXG4gIH07XG4gIHJldHVybiBuZXcgUHJveHkoY2FjaGUsIHtcbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIHRoZSBkZWxldGUgb3BlcmF0b3IuXG4gICAgICovXG4gICAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wKSB7XG4gICAgICBkZWxldGUgdGFyZ2V0W3Byb3BdOyAvLyByZW1vdmUgZnJvbSBjYWNoZVxuICAgICAgZGVsZXRlIHByb3h5W3Byb3BdOyAvLyByZW1vdmUgZnJvbSBwcm94eVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgZ2V0dGluZyBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICovXG4gICAgZ2V0KHRhcmdldCwgcHJvcDogc3RyaW5nLCByZWNlaXZlcikge1xuICAgICAgcmV0dXJuIF9jYWNoZWQodGFyZ2V0LCBwcm9wLFxuICAgICAgICAoKSA9PiBfcmVzb2x2ZVdpdGhDb250ZXh0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLlxuICAgICAqIEFsc28gdXNlZCBieSBPYmplY3QuaGFzT3duUHJvcGVydHkuXG4gICAgICovXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcCkge1xuICAgICAgcmV0dXJuIHRhcmdldC5fZGVzY3JpcHRvcnMuYWxsS2V5c1xuICAgICAgICA/IFJlZmxlY3QuaGFzKHByb3h5LCBwcm9wKSA/IHtlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9IDogdW5kZWZpbmVkXG4gICAgICAgIDogUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJveHksIHByb3ApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZi5cbiAgICAgKi9cbiAgICBnZXRQcm90b3R5cGVPZigpIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHByb3h5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciB0aGUgaW4gb3BlcmF0b3IuXG4gICAgICovXG4gICAgaGFzKHRhcmdldCwgcHJvcCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHByb3h5LCBwcm9wKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyBhbmQgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scy5cbiAgICAgKi9cbiAgICBvd25LZXlzKCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyhwcm94eSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3Igc2V0dGluZyBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICovXG4gICAgc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgIHByb3h5W3Byb3BdID0gdmFsdWU7IC8vIHNldCB0byBwcm94eVxuICAgICAgZGVsZXRlIHRhcmdldFtwcm9wXTsgLy8gcmVtb3ZlIGZyb20gY2FjaGVcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSkgYXMgQ29udGV4dFByb3h5PFQsIFI+O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZGVzY3JpcHRvcnMoXG4gIHByb3h5OiBSZXNvbHZlckNhY2hlLFxuICBkZWZhdWx0czogRGVzY3JpcHRvckRlZmF1bHRzID0ge3NjcmlwdGFibGU6IHRydWUsIGluZGV4YWJsZTogdHJ1ZX1cbik6IERlc2NyaXB0b3Ige1xuICBjb25zdCB7X3NjcmlwdGFibGUgPSBkZWZhdWx0cy5zY3JpcHRhYmxlLCBfaW5kZXhhYmxlID0gZGVmYXVsdHMuaW5kZXhhYmxlLCBfYWxsS2V5cyA9IGRlZmF1bHRzLmFsbEtleXN9ID0gcHJveHk7XG4gIHJldHVybiB7XG4gICAgYWxsS2V5czogX2FsbEtleXMsXG4gICAgc2NyaXB0YWJsZTogX3NjcmlwdGFibGUsXG4gICAgaW5kZXhhYmxlOiBfaW5kZXhhYmxlLFxuICAgIGlzU2NyaXB0YWJsZTogaXNGdW5jdGlvbihfc2NyaXB0YWJsZSkgPyBfc2NyaXB0YWJsZSA6ICgpID0+IF9zY3JpcHRhYmxlLFxuICAgIGlzSW5kZXhhYmxlOiBpc0Z1bmN0aW9uKF9pbmRleGFibGUpID8gX2luZGV4YWJsZSA6ICgpID0+IF9pbmRleGFibGVcbiAgfTtcbn1cblxuY29uc3QgcmVhZEtleSA9IChwcmVmaXg6IHN0cmluZywgbmFtZTogc3RyaW5nKSA9PiBwcmVmaXggPyBwcmVmaXggKyBfY2FwaXRhbGl6ZShuYW1lKSA6IG5hbWU7XG5jb25zdCBuZWVkc1N1YlJlc29sdmVyID0gKHByb3A6IHN0cmluZywgdmFsdWU6IHVua25vd24pID0+IGlzT2JqZWN0KHZhbHVlKSAmJiBwcm9wICE9PSAnYWRhcHRlcnMnICYmXG4gIChPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBudWxsIHx8IHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3QpO1xuXG5mdW5jdGlvbiBfY2FjaGVkKFxuICB0YXJnZXQ6IEFueU9iamVjdCxcbiAgcHJvcDogc3RyaW5nLFxuICByZXNvbHZlOiAoKSA9PiB1bmtub3duXG4pIHtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIHByb3ApKSB7XG4gICAgcmV0dXJuIHRhcmdldFtwcm9wXTtcbiAgfVxuXG4gIGNvbnN0IHZhbHVlID0gcmVzb2x2ZSgpO1xuICAvLyBjYWNoZSB0aGUgcmVzb2x2ZWQgdmFsdWVcbiAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gX3Jlc29sdmVXaXRoQ29udGV4dChcbiAgdGFyZ2V0OiBDb250ZXh0Q2FjaGUsXG4gIHByb3A6IHN0cmluZyxcbiAgcmVjZWl2ZXI6IEFueU9iamVjdFxuKSB7XG4gIGNvbnN0IHtfcHJveHksIF9jb250ZXh0LCBfc3ViUHJveHksIF9kZXNjcmlwdG9yczogZGVzY3JpcHRvcnN9ID0gdGFyZ2V0O1xuICBsZXQgdmFsdWUgPSBfcHJveHlbcHJvcF07IC8vIHJlc29sdmUgZnJvbSBwcm94eVxuXG4gIC8vIHJlc29sdmUgd2l0aCBjb250ZXh0XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSAmJiBkZXNjcmlwdG9ycy5pc1NjcmlwdGFibGUocHJvcCkpIHtcbiAgICB2YWx1ZSA9IF9yZXNvbHZlU2NyaXB0YWJsZShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCByZWNlaXZlcik7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCkge1xuICAgIHZhbHVlID0gX3Jlc29sdmVBcnJheShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCBkZXNjcmlwdG9ycy5pc0luZGV4YWJsZSk7XG4gIH1cbiAgaWYgKG5lZWRzU3ViUmVzb2x2ZXIocHJvcCwgdmFsdWUpKSB7XG4gICAgLy8gaWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzIGFuIG9iamVjdCwgY3JlYXRlIGEgc3ViIHJlc29sdmVyIGZvciBpdFxuICAgIHZhbHVlID0gX2F0dGFjaENvbnRleHQodmFsdWUsIF9jb250ZXh0LCBfc3ViUHJveHkgJiYgX3N1YlByb3h5W3Byb3BdLCBkZXNjcmlwdG9ycyk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBfcmVzb2x2ZVNjcmlwdGFibGUoXG4gIHByb3A6IHN0cmluZyxcbiAgZ2V0VmFsdWU6IChjdHg6IEFueU9iamVjdCwgc3ViOiBBbnlPYmplY3QpID0+IHVua25vd24sXG4gIHRhcmdldDogQ29udGV4dENhY2hlLFxuICByZWNlaXZlcjogQW55T2JqZWN0XG4pIHtcbiAgY29uc3Qge19wcm94eSwgX2NvbnRleHQsIF9zdWJQcm94eSwgX3N0YWNrfSA9IHRhcmdldDtcbiAgaWYgKF9zdGFjay5oYXMocHJvcCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlY3Vyc2lvbiBkZXRlY3RlZDogJyArIEFycmF5LmZyb20oX3N0YWNrKS5qb2luKCctPicpICsgJy0+JyArIHByb3ApO1xuICB9XG4gIF9zdGFjay5hZGQocHJvcCk7XG4gIGxldCB2YWx1ZSA9IGdldFZhbHVlKF9jb250ZXh0LCBfc3ViUHJveHkgfHwgcmVjZWl2ZXIpO1xuICBfc3RhY2suZGVsZXRlKHByb3ApO1xuICBpZiAobmVlZHNTdWJSZXNvbHZlcihwcm9wLCB2YWx1ZSkpIHtcbiAgICAvLyBXaGVuIHNjcmlwdGFibGUgb3B0aW9uIHJldHVybnMgYW4gb2JqZWN0LCBjcmVhdGUgYSByZXNvbHZlciBvbiB0aGF0LlxuICAgIHZhbHVlID0gY3JlYXRlU3ViUmVzb2x2ZXIoX3Byb3h5Ll9zY29wZXMsIF9wcm94eSwgcHJvcCwgdmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gX3Jlc29sdmVBcnJheShcbiAgcHJvcDogc3RyaW5nLFxuICB2YWx1ZTogdW5rbm93bltdLFxuICB0YXJnZXQ6IENvbnRleHRDYWNoZSxcbiAgaXNJbmRleGFibGU6IChrZXk6IHN0cmluZykgPT4gYm9vbGVhblxuKSB7XG4gIGNvbnN0IHtfcHJveHksIF9jb250ZXh0LCBfc3ViUHJveHksIF9kZXNjcmlwdG9yczogZGVzY3JpcHRvcnN9ID0gdGFyZ2V0O1xuXG4gIGlmICh0eXBlb2YgX2NvbnRleHQuaW5kZXggIT09ICd1bmRlZmluZWQnICYmIGlzSW5kZXhhYmxlKHByb3ApKSB7XG4gICAgcmV0dXJuIHZhbHVlW19jb250ZXh0LmluZGV4ICUgdmFsdWUubGVuZ3RoXTtcbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZVswXSkpIHtcbiAgICAvLyBBcnJheSBvZiBvYmplY3RzLCByZXR1cm4gYXJyYXkgb3IgcmVzb2x2ZXJzXG4gICAgY29uc3QgYXJyID0gdmFsdWU7XG4gICAgY29uc3Qgc2NvcGVzID0gX3Byb3h5Ll9zY29wZXMuZmlsdGVyKHMgPT4gcyAhPT0gYXJyKTtcbiAgICB2YWx1ZSA9IFtdO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIHtcbiAgICAgIGNvbnN0IHJlc29sdmVyID0gY3JlYXRlU3ViUmVzb2x2ZXIoc2NvcGVzLCBfcHJveHksIHByb3AsIGl0ZW0pO1xuICAgICAgdmFsdWUucHVzaChfYXR0YWNoQ29udGV4dChyZXNvbHZlciwgX2NvbnRleHQsIF9zdWJQcm94eSAmJiBfc3ViUHJveHlbcHJvcF0sIGRlc2NyaXB0b3JzKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUZhbGxiYWNrKFxuICBmYWxsYmFjazogUmVzb2x2ZXJPYmplY3RLZXkgfCAoKHByb3A6IFJlc29sdmVyT2JqZWN0S2V5LCB2YWx1ZTogdW5rbm93bikgPT4gUmVzb2x2ZXJPYmplY3RLZXkpLFxuICBwcm9wOiBSZXNvbHZlck9iamVjdEtleSxcbiAgdmFsdWU6IHVua25vd25cbikge1xuICByZXR1cm4gaXNGdW5jdGlvbihmYWxsYmFjaykgPyBmYWxsYmFjayhwcm9wLCB2YWx1ZSkgOiBmYWxsYmFjaztcbn1cblxuY29uc3QgZ2V0U2NvcGUgPSAoa2V5OiBSZXNvbHZlck9iamVjdEtleSwgcGFyZW50OiBBbnlPYmplY3QpID0+IGtleSA9PT0gdHJ1ZSA/IHBhcmVudFxuICA6IHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnID8gcmVzb2x2ZU9iamVjdEtleShwYXJlbnQsIGtleSkgOiB1bmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGFkZFNjb3BlcyhcbiAgc2V0OiBTZXQ8QW55T2JqZWN0PixcbiAgcGFyZW50U2NvcGVzOiBBbnlPYmplY3RbXSxcbiAga2V5OiBSZXNvbHZlck9iamVjdEtleSxcbiAgcGFyZW50RmFsbGJhY2s6IFJlc29sdmVyT2JqZWN0S2V5LFxuICB2YWx1ZTogdW5rbm93blxuKSB7XG4gIGZvciAoY29uc3QgcGFyZW50IG9mIHBhcmVudFNjb3Blcykge1xuICAgIGNvbnN0IHNjb3BlID0gZ2V0U2NvcGUoa2V5LCBwYXJlbnQpO1xuICAgIGlmIChzY29wZSkge1xuICAgICAgc2V0LmFkZChzY29wZSk7XG4gICAgICBjb25zdCBmYWxsYmFjayA9IHJlc29sdmVGYWxsYmFjayhzY29wZS5fZmFsbGJhY2ssIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKHR5cGVvZiBmYWxsYmFjayAhPT0gJ3VuZGVmaW5lZCcgJiYgZmFsbGJhY2sgIT09IGtleSAmJiBmYWxsYmFjayAhPT0gcGFyZW50RmFsbGJhY2spIHtcbiAgICAgICAgLy8gV2hlbiB3ZSByZWFjaCB0aGUgZGVzY3JpcHRvciB0aGF0IGRlZmluZXMgYSBuZXcgX2ZhbGxiYWNrLCByZXR1cm4gdGhhdC5cbiAgICAgICAgLy8gVGhlIGZhbGxiYWNrIHdpbGwgcmVzdW1lIHRvIHRoYXQgbmV3IHNjb3BlLlxuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzY29wZSA9PT0gZmFsc2UgJiYgdHlwZW9mIHBhcmVudEZhbGxiYWNrICE9PSAndW5kZWZpbmVkJyAmJiBrZXkgIT09IHBhcmVudEZhbGxiYWNrKSB7XG4gICAgICAvLyBGYWxsYmFjayB0byBgZmFsc2VgIHJlc3VsdHMgdG8gYGZhbHNlYCwgd2hlbiBmYWxsaW5nIGJhY2sgdG8gZGlmZmVyZW50IGtleS5cbiAgICAgIC8vIEZvciBleGFtcGxlIGBpbnRlcmFjdGlvbmAgZnJvbSBgaG92ZXJgIG9yIGBwbHVnaW5zLnRvb2x0aXBgIGFuZCBgYW5pbWF0aW9uYCBmcm9tIGBhbmltYXRpb25zYFxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU3ViUmVzb2x2ZXIoXG4gIHBhcmVudFNjb3BlczogQW55T2JqZWN0W10sXG4gIHJlc29sdmVyOiBSZXNvbHZlckNhY2hlLFxuICBwcm9wOiBSZXNvbHZlck9iamVjdEtleSxcbiAgdmFsdWU6IHVua25vd25cbikge1xuICBjb25zdCByb290U2NvcGVzID0gcmVzb2x2ZXIuX3Jvb3RTY29wZXM7XG4gIGNvbnN0IGZhbGxiYWNrID0gcmVzb2x2ZUZhbGxiYWNrKHJlc29sdmVyLl9mYWxsYmFjaywgcHJvcCwgdmFsdWUpO1xuICBjb25zdCBhbGxTY29wZXMgPSBbLi4ucGFyZW50U2NvcGVzLCAuLi5yb290U2NvcGVzXTtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldDxBbnlPYmplY3Q+KCk7XG4gIHNldC5hZGQodmFsdWUpO1xuICBsZXQga2V5ID0gYWRkU2NvcGVzRnJvbUtleShzZXQsIGFsbFNjb3BlcywgcHJvcCwgZmFsbGJhY2sgfHwgcHJvcCwgdmFsdWUpO1xuICBpZiAoa2V5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgZmFsbGJhY2sgIT09ICd1bmRlZmluZWQnICYmIGZhbGxiYWNrICE9PSBwcm9wKSB7XG4gICAga2V5ID0gYWRkU2NvcGVzRnJvbUtleShzZXQsIGFsbFNjb3BlcywgZmFsbGJhY2ssIGtleSwgdmFsdWUpO1xuICAgIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVSZXNvbHZlcihBcnJheS5mcm9tKHNldCksIFsnJ10sIHJvb3RTY29wZXMsIGZhbGxiYWNrLFxuICAgICgpID0+IHN1YkdldFRhcmdldChyZXNvbHZlciwgcHJvcCBhcyBzdHJpbmcsIHZhbHVlKSk7XG59XG5cbmZ1bmN0aW9uIGFkZFNjb3Blc0Zyb21LZXkoXG4gIHNldDogU2V0PEFueU9iamVjdD4sXG4gIGFsbFNjb3BlczogQW55T2JqZWN0W10sXG4gIGtleTogUmVzb2x2ZXJPYmplY3RLZXksXG4gIGZhbGxiYWNrOiBSZXNvbHZlck9iamVjdEtleSxcbiAgaXRlbTogdW5rbm93blxuKSB7XG4gIHdoaWxlIChrZXkpIHtcbiAgICBrZXkgPSBhZGRTY29wZXMoc2V0LCBhbGxTY29wZXMsIGtleSwgZmFsbGJhY2ssIGl0ZW0pO1xuICB9XG4gIHJldHVybiBrZXk7XG59XG5cbmZ1bmN0aW9uIHN1YkdldFRhcmdldChcbiAgcmVzb2x2ZXI6IFJlc29sdmVyQ2FjaGUsXG4gIHByb3A6IHN0cmluZyxcbiAgdmFsdWU6IHVua25vd25cbikge1xuICBjb25zdCBwYXJlbnQgPSByZXNvbHZlci5fZ2V0VGFyZ2V0KCk7XG4gIGlmICghKHByb3AgaW4gcGFyZW50KSkge1xuICAgIHBhcmVudFtwcm9wXSA9IHt9O1xuICB9XG4gIGNvbnN0IHRhcmdldCA9IHBhcmVudFtwcm9wXTtcbiAgaWYgKGlzQXJyYXkodGFyZ2V0KSAmJiBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAvLyBGb3IgYXJyYXkgb2Ygb2JqZWN0cywgdGhlIG9iamVjdCBpcyB1c2VkIHRvIHN0b3JlIHVwZGF0ZWQgdmFsdWVzXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiB0YXJnZXQgfHwge307XG59XG5cbmZ1bmN0aW9uIF9yZXNvbHZlV2l0aFByZWZpeGVzKFxuICBwcm9wOiBzdHJpbmcsXG4gIHByZWZpeGVzOiBzdHJpbmdbXSxcbiAgc2NvcGVzOiBBbnlPYmplY3RbXSxcbiAgcHJveHk6IFJlc29sdmVyUHJveHlcbikge1xuICBsZXQgdmFsdWU6IHVua25vd247XG4gIGZvciAoY29uc3QgcHJlZml4IG9mIHByZWZpeGVzKSB7XG4gICAgdmFsdWUgPSBfcmVzb2x2ZShyZWFkS2V5KHByZWZpeCwgcHJvcCksIHNjb3Blcyk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZWVkc1N1YlJlc29sdmVyKHByb3AsIHZhbHVlKVxuICAgICAgICA/IGNyZWF0ZVN1YlJlc29sdmVyKHNjb3BlcywgcHJveHksIHByb3AsIHZhbHVlKVxuICAgICAgICA6IHZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBfcmVzb2x2ZShrZXk6IHN0cmluZywgc2NvcGVzOiBBbnlPYmplY3RbXSkge1xuICBmb3IgKGNvbnN0IHNjb3BlIG9mIHNjb3Blcykge1xuICAgIGlmICghc2NvcGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHNjb3BlW2tleV07XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0S2V5c0Zyb21BbGxTY29wZXModGFyZ2V0OiBSZXNvbHZlckNhY2hlKSB7XG4gIGxldCBrZXlzID0gdGFyZ2V0Ll9rZXlzO1xuICBpZiAoIWtleXMpIHtcbiAgICBrZXlzID0gdGFyZ2V0Ll9rZXlzID0gcmVzb2x2ZUtleXNGcm9tQWxsU2NvcGVzKHRhcmdldC5fc2NvcGVzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUtleXNGcm9tQWxsU2NvcGVzKHNjb3BlczogQW55T2JqZWN0W10pIHtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIGZvciAoY29uc3Qgc2NvcGUgb2Ygc2NvcGVzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NvcGUpLmZpbHRlcihrID0+ICFrLnN0YXJ0c1dpdGgoJ18nKSkpIHtcbiAgICAgIHNldC5hZGQoa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20oc2V0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZShcbiAgbWV0YTogQ2hhcnRNZXRhPCdsaW5lJyB8ICdzY2F0dGVyJz4sXG4gIGRhdGE6IEFueU9iamVjdFtdLFxuICBzdGFydDogbnVtYmVyLFxuICBjb3VudDogbnVtYmVyXG4pIHtcbiAgY29uc3Qge2lTY2FsZX0gPSBtZXRhO1xuICBjb25zdCB7a2V5ID0gJ3InfSA9IHRoaXMuX3BhcnNpbmc7XG4gIGNvbnN0IHBhcnNlZCA9IG5ldyBBcnJheTx7cjogdW5rbm93bn0+KGNvdW50KTtcbiAgbGV0IGk6IG51bWJlciwgaWxlbjogbnVtYmVyLCBpbmRleDogbnVtYmVyLCBpdGVtOiBBbnlPYmplY3Q7XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgaW5kZXggPSBpICsgc3RhcnQ7XG4gICAgaXRlbSA9IGRhdGFbaW5kZXhdO1xuICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgIHI6IGlTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KGl0ZW0sIGtleSksIGluZGV4KVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn1cbiIsICJpbXBvcnQge2FsbW9zdEVxdWFscywgZGlzdGFuY2VCZXR3ZWVuUG9pbnRzLCBzaWdufSBmcm9tICcuL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge19pc1BvaW50SW5BcmVhfSBmcm9tICcuL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB0eXBlIHtDaGFydEFyZWF9IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcbmltcG9ydCB0eXBlIHtTcGxpbmVQb2ludH0gZnJvbSAnLi4vdHlwZXMvZ2VvbWV0cmljLmpzJztcblxuY29uc3QgRVBTSUxPTiA9IE51bWJlci5FUFNJTE9OIHx8IDFlLTE0O1xuXG50eXBlIE9wdGlvbmFsU3BsaW5lUG9pbnQgPSBTcGxpbmVQb2ludCB8IGZhbHNlXG5jb25zdCBnZXRQb2ludCA9IChwb2ludHM6IFNwbGluZVBvaW50W10sIGk6IG51bWJlcik6IE9wdGlvbmFsU3BsaW5lUG9pbnQgPT4gaSA8IHBvaW50cy5sZW5ndGggJiYgIXBvaW50c1tpXS5za2lwICYmIHBvaW50c1tpXTtcbmNvbnN0IGdldFZhbHVlQXhpcyA9IChpbmRleEF4aXM6ICd4JyB8ICd5JykgPT4gaW5kZXhBeGlzID09PSAneCcgPyAneScgOiAneCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzcGxpbmVDdXJ2ZShcbiAgZmlyc3RQb2ludDogU3BsaW5lUG9pbnQsXG4gIG1pZGRsZVBvaW50OiBTcGxpbmVQb2ludCxcbiAgYWZ0ZXJQb2ludDogU3BsaW5lUG9pbnQsXG4gIHQ6IG51bWJlclxuKToge1xuICAgIHByZXZpb3VzOiBTcGxpbmVQb2ludFxuICAgIG5leHQ6IFNwbGluZVBvaW50XG4gIH0ge1xuICAvLyBQcm9wcyB0byBSb2IgU3BlbmNlciBhdCBzY2FsZWQgaW5ub3ZhdGlvbiBmb3IgaGlzIHBvc3Qgb24gc3BsaW5pbmcgYmV0d2VlbiBwb2ludHNcbiAgLy8gaHR0cDovL3NjYWxlZGlubm92YXRpb24uY29tL2FuYWx5dGljcy9zcGxpbmVzL2Fib3V0U3BsaW5lcy5odG1sXG5cbiAgLy8gVGhpcyBmdW5jdGlvbiBtdXN0IGFsc28gcmVzcGVjdCBcInNraXBwZWRcIiBwb2ludHNcblxuICBjb25zdCBwcmV2aW91cyA9IGZpcnN0UG9pbnQuc2tpcCA/IG1pZGRsZVBvaW50IDogZmlyc3RQb2ludDtcbiAgY29uc3QgY3VycmVudCA9IG1pZGRsZVBvaW50O1xuICBjb25zdCBuZXh0ID0gYWZ0ZXJQb2ludC5za2lwID8gbWlkZGxlUG9pbnQgOiBhZnRlclBvaW50O1xuICBjb25zdCBkMDEgPSBkaXN0YW5jZUJldHdlZW5Qb2ludHMoY3VycmVudCwgcHJldmlvdXMpO1xuICBjb25zdCBkMTIgPSBkaXN0YW5jZUJldHdlZW5Qb2ludHMobmV4dCwgY3VycmVudCk7XG5cbiAgbGV0IHMwMSA9IGQwMSAvIChkMDEgKyBkMTIpO1xuICBsZXQgczEyID0gZDEyIC8gKGQwMSArIGQxMik7XG5cbiAgLy8gSWYgYWxsIHBvaW50cyBhcmUgdGhlIHNhbWUsIHMwMSAmIHMwMiB3aWxsIGJlIGluZlxuICBzMDEgPSBpc05hTihzMDEpID8gMCA6IHMwMTtcbiAgczEyID0gaXNOYU4oczEyKSA/IDAgOiBzMTI7XG5cbiAgY29uc3QgZmEgPSB0ICogczAxOyAvLyBzY2FsaW5nIGZhY3RvciBmb3IgdHJpYW5nbGUgVGFcbiAgY29uc3QgZmIgPSB0ICogczEyO1xuXG4gIHJldHVybiB7XG4gICAgcHJldmlvdXM6IHtcbiAgICAgIHg6IGN1cnJlbnQueCAtIGZhICogKG5leHQueCAtIHByZXZpb3VzLngpLFxuICAgICAgeTogY3VycmVudC55IC0gZmEgKiAobmV4dC55IC0gcHJldmlvdXMueSlcbiAgICB9LFxuICAgIG5leHQ6IHtcbiAgICAgIHg6IGN1cnJlbnQueCArIGZiICogKG5leHQueCAtIHByZXZpb3VzLngpLFxuICAgICAgeTogY3VycmVudC55ICsgZmIgKiAobmV4dC55IC0gcHJldmlvdXMueSlcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQWRqdXN0IHRhbmdlbnRzIHRvIGVuc3VyZSBtb25vdG9uaWMgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtb25vdG9uZUFkanVzdChwb2ludHM6IFNwbGluZVBvaW50W10sIGRlbHRhSzogbnVtYmVyW10sIG1LOiBudW1iZXJbXSkge1xuICBjb25zdCBwb2ludHNMZW4gPSBwb2ludHMubGVuZ3RoO1xuXG4gIGxldCBhbHBoYUs6IG51bWJlciwgYmV0YUs6IG51bWJlciwgdGF1SzogbnVtYmVyLCBzcXVhcmVkTWFnbml0dWRlOiBudW1iZXIsIHBvaW50Q3VycmVudDogT3B0aW9uYWxTcGxpbmVQb2ludDtcbiAgbGV0IHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIDApO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50c0xlbiAtIDE7ICsraSkge1xuICAgIHBvaW50Q3VycmVudCA9IHBvaW50QWZ0ZXI7XG4gICAgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgaSArIDEpO1xuICAgIGlmICghcG9pbnRDdXJyZW50IHx8ICFwb2ludEFmdGVyKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoYWxtb3N0RXF1YWxzKGRlbHRhS1tpXSwgMCwgRVBTSUxPTikpIHtcbiAgICAgIG1LW2ldID0gbUtbaSArIDFdID0gMDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGFscGhhSyA9IG1LW2ldIC8gZGVsdGFLW2ldO1xuICAgIGJldGFLID0gbUtbaSArIDFdIC8gZGVsdGFLW2ldO1xuICAgIHNxdWFyZWRNYWduaXR1ZGUgPSBNYXRoLnBvdyhhbHBoYUssIDIpICsgTWF0aC5wb3coYmV0YUssIDIpO1xuICAgIGlmIChzcXVhcmVkTWFnbml0dWRlIDw9IDkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHRhdUsgPSAzIC8gTWF0aC5zcXJ0KHNxdWFyZWRNYWduaXR1ZGUpO1xuICAgIG1LW2ldID0gYWxwaGFLICogdGF1SyAqIGRlbHRhS1tpXTtcbiAgICBtS1tpICsgMV0gPSBiZXRhSyAqIHRhdUsgKiBkZWx0YUtbaV07XG4gIH1cbn1cblxuZnVuY3Rpb24gbW9ub3RvbmVDb21wdXRlKHBvaW50czogU3BsaW5lUG9pbnRbXSwgbUs6IG51bWJlcltdLCBpbmRleEF4aXM6ICd4JyB8ICd5JyA9ICd4Jykge1xuICBjb25zdCB2YWx1ZUF4aXMgPSBnZXRWYWx1ZUF4aXMoaW5kZXhBeGlzKTtcbiAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgbGV0IGRlbHRhOiBudW1iZXIsIHBvaW50QmVmb3JlOiBPcHRpb25hbFNwbGluZVBvaW50LCBwb2ludEN1cnJlbnQ6IE9wdGlvbmFsU3BsaW5lUG9pbnQ7XG4gIGxldCBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCAwKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50c0xlbjsgKytpKSB7XG4gICAgcG9pbnRCZWZvcmUgPSBwb2ludEN1cnJlbnQ7XG4gICAgcG9pbnRDdXJyZW50ID0gcG9pbnRBZnRlcjtcbiAgICBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCBpICsgMSk7XG4gICAgaWYgKCFwb2ludEN1cnJlbnQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGlQaXhlbCA9IHBvaW50Q3VycmVudFtpbmRleEF4aXNdO1xuICAgIGNvbnN0IHZQaXhlbCA9IHBvaW50Q3VycmVudFt2YWx1ZUF4aXNdO1xuICAgIGlmIChwb2ludEJlZm9yZSkge1xuICAgICAgZGVsdGEgPSAoaVBpeGVsIC0gcG9pbnRCZWZvcmVbaW5kZXhBeGlzXSkgLyAzO1xuICAgICAgcG9pbnRDdXJyZW50W2BjcDEke2luZGV4QXhpc31gXSA9IGlQaXhlbCAtIGRlbHRhO1xuICAgICAgcG9pbnRDdXJyZW50W2BjcDEke3ZhbHVlQXhpc31gXSA9IHZQaXhlbCAtIGRlbHRhICogbUtbaV07XG4gICAgfVxuICAgIGlmIChwb2ludEFmdGVyKSB7XG4gICAgICBkZWx0YSA9IChwb2ludEFmdGVyW2luZGV4QXhpc10gLSBpUGl4ZWwpIC8gMztcbiAgICAgIHBvaW50Q3VycmVudFtgY3AyJHtpbmRleEF4aXN9YF0gPSBpUGl4ZWwgKyBkZWx0YTtcbiAgICAgIHBvaW50Q3VycmVudFtgY3AyJHt2YWx1ZUF4aXN9YF0gPSB2UGl4ZWwgKyBkZWx0YSAqIG1LW2ldO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyBCw6l6aWVyIGNvbnRyb2wgcG9pbnRzIGluIGEgc2ltaWxhciB3YXkgdGhhbiB8c3BsaW5lQ3VydmV8LFxuICogYnV0IHByZXNlcnZlcyBtb25vdG9uaWNpdHkgb2YgdGhlIHByb3ZpZGVkIGRhdGEgYW5kIGVuc3VyZXMgbm8gbG9jYWwgZXh0cmVtdW1zIGFyZSBhZGRlZFxuICogYmV0d2VlbiB0aGUgZGF0YXNldCBkaXNjcmV0ZSBwb2ludHMgZHVlIHRvIHRoZSBpbnRlcnBvbGF0aW9uLlxuICogU2VlIDogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9ub3RvbmVfY3ViaWNfaW50ZXJwb2xhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gc3BsaW5lQ3VydmVNb25vdG9uZShwb2ludHM6IFNwbGluZVBvaW50W10sIGluZGV4QXhpczogJ3gnIHwgJ3knID0gJ3gnKSB7XG4gIGNvbnN0IHZhbHVlQXhpcyA9IGdldFZhbHVlQXhpcyhpbmRleEF4aXMpO1xuICBjb25zdCBwb2ludHNMZW4gPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCBkZWx0YUs6IG51bWJlcltdID0gQXJyYXkocG9pbnRzTGVuKS5maWxsKDApO1xuICBjb25zdCBtSzogbnVtYmVyW10gPSBBcnJheShwb2ludHNMZW4pO1xuXG4gIC8vIENhbGN1bGF0ZSBzbG9wZXMgKGRlbHRhSykgYW5kIGluaXRpYWxpemUgdGFuZ2VudHMgKG1LKVxuICBsZXQgaSwgcG9pbnRCZWZvcmU6IE9wdGlvbmFsU3BsaW5lUG9pbnQsIHBvaW50Q3VycmVudDogT3B0aW9uYWxTcGxpbmVQb2ludDtcbiAgbGV0IHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIDApO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBwb2ludHNMZW47ICsraSkge1xuICAgIHBvaW50QmVmb3JlID0gcG9pbnRDdXJyZW50O1xuICAgIHBvaW50Q3VycmVudCA9IHBvaW50QWZ0ZXI7XG4gICAgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgaSArIDEpO1xuICAgIGlmICghcG9pbnRDdXJyZW50KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAocG9pbnRBZnRlcikge1xuICAgICAgY29uc3Qgc2xvcGVEZWx0YSA9IHBvaW50QWZ0ZXJbaW5kZXhBeGlzXSAtIHBvaW50Q3VycmVudFtpbmRleEF4aXNdO1xuXG4gICAgICAvLyBJbiB0aGUgY2FzZSBvZiB0d28gcG9pbnRzIHRoYXQgYXBwZWFyIGF0IHRoZSBzYW1lIHggcGl4ZWwsIHNsb3BlRGVsdGFYIGlzIDBcbiAgICAgIGRlbHRhS1tpXSA9IHNsb3BlRGVsdGEgIT09IDAgPyAocG9pbnRBZnRlclt2YWx1ZUF4aXNdIC0gcG9pbnRDdXJyZW50W3ZhbHVlQXhpc10pIC8gc2xvcGVEZWx0YSA6IDA7XG4gICAgfVxuICAgIG1LW2ldID0gIXBvaW50QmVmb3JlID8gZGVsdGFLW2ldXG4gICAgICA6ICFwb2ludEFmdGVyID8gZGVsdGFLW2kgLSAxXVxuICAgICAgICA6IChzaWduKGRlbHRhS1tpIC0gMV0pICE9PSBzaWduKGRlbHRhS1tpXSkpID8gMFxuICAgICAgICAgIDogKGRlbHRhS1tpIC0gMV0gKyBkZWx0YUtbaV0pIC8gMjtcbiAgfVxuXG4gIG1vbm90b25lQWRqdXN0KHBvaW50cywgZGVsdGFLLCBtSyk7XG5cbiAgbW9ub3RvbmVDb21wdXRlKHBvaW50cywgbUssIGluZGV4QXhpcyk7XG59XG5cbmZ1bmN0aW9uIGNhcENvbnRyb2xQb2ludChwdDogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIpIHtcbiAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHB0LCBtYXgpLCBtaW4pO1xufVxuXG5mdW5jdGlvbiBjYXBCZXppZXJQb2ludHMocG9pbnRzOiBTcGxpbmVQb2ludFtdLCBhcmVhOiBDaGFydEFyZWEpIHtcbiAgbGV0IGksIGlsZW4sIHBvaW50LCBpbkFyZWEsIGluQXJlYVByZXY7XG4gIGxldCBpbkFyZWFOZXh0ID0gX2lzUG9pbnRJbkFyZWEocG9pbnRzWzBdLCBhcmVhKTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBpbkFyZWFQcmV2ID0gaW5BcmVhO1xuICAgIGluQXJlYSA9IGluQXJlYU5leHQ7XG4gICAgaW5BcmVhTmV4dCA9IGkgPCBpbGVuIC0gMSAmJiBfaXNQb2ludEluQXJlYShwb2ludHNbaSArIDFdLCBhcmVhKTtcbiAgICBpZiAoIWluQXJlYSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgIGlmIChpbkFyZWFQcmV2KSB7XG4gICAgICBwb2ludC5jcDF4ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMXgsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG4gICAgICBwb2ludC5jcDF5ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMXksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG4gICAgfVxuICAgIGlmIChpbkFyZWFOZXh0KSB7XG4gICAgICBwb2ludC5jcDJ4ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMngsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG4gICAgICBwb2ludC5jcDJ5ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMnksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzKFxuICBwb2ludHM6IFNwbGluZVBvaW50W10sXG4gIG9wdGlvbnMsXG4gIGFyZWE6IENoYXJ0QXJlYSxcbiAgbG9vcDogYm9vbGVhbixcbiAgaW5kZXhBeGlzOiAneCcgfCAneSdcbikge1xuICBsZXQgaTogbnVtYmVyLCBpbGVuOiBudW1iZXIsIHBvaW50OiBTcGxpbmVQb2ludCwgY29udHJvbFBvaW50czogUmV0dXJuVHlwZTx0eXBlb2Ygc3BsaW5lQ3VydmU+O1xuXG4gIC8vIE9ubHkgY29uc2lkZXIgcG9pbnRzIHRoYXQgYXJlIGRyYXduIGluIGNhc2UgdGhlIHNwYW5HYXBzIG9wdGlvbiBpcyB1c2VkXG4gIGlmIChvcHRpb25zLnNwYW5HYXBzKSB7XG4gICAgcG9pbnRzID0gcG9pbnRzLmZpbHRlcigocHQpID0+ICFwdC5za2lwKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcbiAgICBzcGxpbmVDdXJ2ZU1vbm90b25lKHBvaW50cywgaW5kZXhBeGlzKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgcHJldiA9IGxvb3AgPyBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdIDogcG9pbnRzWzBdO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnRyb2xQb2ludHMgPSBzcGxpbmVDdXJ2ZShcbiAgICAgICAgcHJldixcbiAgICAgICAgcG9pbnQsXG4gICAgICAgIHBvaW50c1tNYXRoLm1pbihpICsgMSwgaWxlbiAtIChsb29wID8gMCA6IDEpKSAlIGlsZW5dLFxuICAgICAgICBvcHRpb25zLnRlbnNpb25cbiAgICAgICk7XG4gICAgICBwb2ludC5jcDF4ID0gY29udHJvbFBvaW50cy5wcmV2aW91cy54O1xuICAgICAgcG9pbnQuY3AxeSA9IGNvbnRyb2xQb2ludHMucHJldmlvdXMueTtcbiAgICAgIHBvaW50LmNwMnggPSBjb250cm9sUG9pbnRzLm5leHQueDtcbiAgICAgIHBvaW50LmNwMnkgPSBjb250cm9sUG9pbnRzLm5leHQueTtcbiAgICAgIHByZXYgPSBwb2ludDtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0aW9ucy5jYXBCZXppZXJQb2ludHMpIHtcbiAgICBjYXBCZXppZXJQb2ludHMocG9pbnRzLCBhcmVhKTtcbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHtDaGFydEFyZWEsIFNjYWxlfSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5pbXBvcnQgdHlwZSBDaGFydCBmcm9tICcuLi9jb3JlL2NvcmUuY29udHJvbGxlci5qcyc7XG5pbXBvcnQgdHlwZSB7Q2hhcnRFdmVudH0gZnJvbSAnLi4vdHlwZXMuanMnO1xuaW1wb3J0IHtJTkZJTklUWX0gZnJvbSAnLi9oZWxwZXJzLm1hdGguanMnO1xuXG4vKipcbiAqIE5vdGU6IHR5cGVkZWZzIGFyZSBhdXRvLWV4cG9ydGVkLCBzbyB1c2UgYSBtYWRlLXVwIGBkb21gIG5hbWVzcGFjZSB3aGVyZVxuICogbmVjZXNzYXJ5IHRvIGF2b2lkIGR1cGxpY2F0ZXMgd2l0aCBgZXhwb3J0ICogZnJvbSAnLi9oZWxwZXJzYDsgc2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzQ2MDExXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vY29yZS9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gZG9tLkNoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vdHlwZXMnKS5DaGFydEV2ZW50IH0gQ2hhcnRFdmVudFxuICovXG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9pc0RvbVN1cHBvcnRlZCgpOiBib29sZWFuIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9nZXRQYXJlbnROb2RlKGRvbU5vZGU6IEhUTUxDYW52YXNFbGVtZW50KTogSFRNTENhbnZhc0VsZW1lbnQge1xuICBsZXQgcGFyZW50ID0gZG9tTm9kZS5wYXJlbnROb2RlO1xuICBpZiAocGFyZW50ICYmIHBhcmVudC50b1N0cmluZygpID09PSAnW29iamVjdCBTaGFkb3dSb290XScpIHtcbiAgICBwYXJlbnQgPSAocGFyZW50IGFzIFNoYWRvd1Jvb3QpLmhvc3Q7XG4gIH1cbiAgcmV0dXJuIHBhcmVudCBhcyBIVE1MQ2FudmFzRWxlbWVudDtcbn1cblxuLyoqXG4gKiBjb252ZXJ0IG1heC13aWR0aC9tYXgtaGVpZ2h0IHZhbHVlcyB0aGF0IG1heSBiZSBwZXJjZW50YWdlcyBpbnRvIGEgbnVtYmVyXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlTWF4U3R5bGUoc3R5bGVWYWx1ZTogc3RyaW5nIHwgbnVtYmVyLCBub2RlOiBIVE1MRWxlbWVudCwgcGFyZW50UHJvcGVydHk6IHN0cmluZykge1xuICBsZXQgdmFsdWVJblBpeGVsczogbnVtYmVyO1xuICBpZiAodHlwZW9mIHN0eWxlVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWVJblBpeGVscyA9IHBhcnNlSW50KHN0eWxlVmFsdWUsIDEwKTtcblxuICAgIGlmIChzdHlsZVZhbHVlLmluZGV4T2YoJyUnKSAhPT0gLTEpIHtcbiAgICAgIC8vIHBlcmNlbnRhZ2UgKiBzaXplIGluIGRpbWVuc2lvblxuICAgICAgdmFsdWVJblBpeGVscyA9ICh2YWx1ZUluUGl4ZWxzIC8gMTAwKSAqIG5vZGUucGFyZW50Tm9kZVtwYXJlbnRQcm9wZXJ0eV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbHVlSW5QaXhlbHMgPSBzdHlsZVZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlSW5QaXhlbHM7XG59XG5cbmNvbnN0IGdldENvbXB1dGVkU3R5bGUgPSAoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBDU1NTdHlsZURlY2xhcmF0aW9uID0+XG4gIGVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3R5bGUoZWw6IEhUTUxFbGVtZW50LCBwcm9wZXJ0eTogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWwpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpO1xufVxuXG5jb25zdCBwb3NpdGlvbnMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xuZnVuY3Rpb24gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlczogQ1NTU3R5bGVEZWNsYXJhdGlvbiwgc3R5bGU6IHN0cmluZywgc3VmZml4Pzogc3RyaW5nKTogQ2hhcnRBcmVhIHtcbiAgY29uc3QgcmVzdWx0ID0ge30gYXMgQ2hhcnRBcmVhO1xuICBzdWZmaXggPSBzdWZmaXggPyAnLScgKyBzdWZmaXggOiAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBjb25zdCBwb3MgPSBwb3NpdGlvbnNbaV07XG4gICAgcmVzdWx0W3Bvc10gPSBwYXJzZUZsb2F0KHN0eWxlc1tzdHlsZSArICctJyArIHBvcyArIHN1ZmZpeF0pIHx8IDA7XG4gIH1cbiAgcmVzdWx0LndpZHRoID0gcmVzdWx0LmxlZnQgKyByZXN1bHQucmlnaHQ7XG4gIHJlc3VsdC5oZWlnaHQgPSByZXN1bHQudG9wICsgcmVzdWx0LmJvdHRvbTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuY29uc3QgdXNlT2Zmc2V0UG9zID0gKHg6IG51bWJlciwgeTogbnVtYmVyLCB0YXJnZXQ6IEhUTUxFbGVtZW50IHwgRXZlbnRUYXJnZXQpID0+XG4gICh4ID4gMCB8fCB5ID4gMCkgJiYgKCF0YXJnZXQgfHwgISh0YXJnZXQgYXMgSFRNTEVsZW1lbnQpLnNoYWRvd1Jvb3QpO1xuXG4vKipcbiAqIEBwYXJhbSBlXG4gKiBAcGFyYW0gY2FudmFzXG4gKiBAcmV0dXJucyBDYW52YXMgcG9zaXRpb25cbiAqL1xuZnVuY3Rpb24gZ2V0Q2FudmFzUG9zaXRpb24oXG4gIGU6IEV2ZW50IHwgVG91Y2hFdmVudCB8IE1vdXNlRXZlbnQsXG4gIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnRcbik6IHtcbiAgICB4OiBudW1iZXI7XG4gICAgeTogbnVtYmVyO1xuICAgIGJveDogYm9vbGVhbjtcbiAgfSB7XG4gIGNvbnN0IHRvdWNoZXMgPSAoZSBhcyBUb3VjaEV2ZW50KS50b3VjaGVzO1xuICBjb25zdCBzb3VyY2UgPSAodG91Y2hlcyAmJiB0b3VjaGVzLmxlbmd0aCA/IHRvdWNoZXNbMF0gOiBlKSBhcyBNb3VzZUV2ZW50O1xuICBjb25zdCB7b2Zmc2V0WCwgb2Zmc2V0WX0gPSBzb3VyY2UgYXMgTW91c2VFdmVudDtcbiAgbGV0IGJveCA9IGZhbHNlO1xuICBsZXQgeCwgeTtcbiAgaWYgKHVzZU9mZnNldFBvcyhvZmZzZXRYLCBvZmZzZXRZLCBlLnRhcmdldCkpIHtcbiAgICB4ID0gb2Zmc2V0WDtcbiAgICB5ID0gb2Zmc2V0WTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHggPSBzb3VyY2UuY2xpZW50WCAtIHJlY3QubGVmdDtcbiAgICB5ID0gc291cmNlLmNsaWVudFkgLSByZWN0LnRvcDtcbiAgICBib3ggPSB0cnVlO1xuICB9XG4gIHJldHVybiB7eCwgeSwgYm94fTtcbn1cblxuLyoqXG4gKiBHZXRzIGFuIGV2ZW50J3MgeCwgeSBjb29yZGluYXRlcywgcmVsYXRpdmUgdG8gdGhlIGNoYXJ0IGFyZWFcbiAqIEBwYXJhbSBldmVudFxuICogQHBhcmFtIGNoYXJ0XG4gKiBAcmV0dXJucyB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBldmVudFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZWxhdGl2ZVBvc2l0aW9uKFxuICBldmVudDogRXZlbnQgfCBDaGFydEV2ZW50IHwgVG91Y2hFdmVudCB8IE1vdXNlRXZlbnQsXG4gIGNoYXJ0OiBDaGFydFxuKTogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9IHtcbiAgaWYgKCduYXRpdmUnIGluIGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG5cbiAgY29uc3Qge2NhbnZhcywgY3VycmVudERldmljZVBpeGVsUmF0aW99ID0gY2hhcnQ7XG4gIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjYW52YXMpO1xuICBjb25zdCBib3JkZXJCb3ggPSBzdHlsZS5ib3hTaXppbmcgPT09ICdib3JkZXItYm94JztcbiAgY29uc3QgcGFkZGluZ3MgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdwYWRkaW5nJyk7XG4gIGNvbnN0IGJvcmRlcnMgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdib3JkZXInLCAnd2lkdGgnKTtcbiAgY29uc3Qge3gsIHksIGJveH0gPSBnZXRDYW52YXNQb3NpdGlvbihldmVudCwgY2FudmFzKTtcbiAgY29uc3QgeE9mZnNldCA9IHBhZGRpbmdzLmxlZnQgKyAoYm94ICYmIGJvcmRlcnMubGVmdCk7XG4gIGNvbnN0IHlPZmZzZXQgPSBwYWRkaW5ncy50b3AgKyAoYm94ICYmIGJvcmRlcnMudG9wKTtcblxuICBsZXQge3dpZHRoLCBoZWlnaHR9ID0gY2hhcnQ7XG4gIGlmIChib3JkZXJCb3gpIHtcbiAgICB3aWR0aCAtPSBwYWRkaW5ncy53aWR0aCArIGJvcmRlcnMud2lkdGg7XG4gICAgaGVpZ2h0IC09IHBhZGRpbmdzLmhlaWdodCArIGJvcmRlcnMuaGVpZ2h0O1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogTWF0aC5yb3VuZCgoeCAtIHhPZmZzZXQpIC8gd2lkdGggKiBjYW52YXMud2lkdGggLyBjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyksXG4gICAgeTogTWF0aC5yb3VuZCgoeSAtIHlPZmZzZXQpIC8gaGVpZ2h0ICogY2FudmFzLmhlaWdodCAvIGN1cnJlbnREZXZpY2VQaXhlbFJhdGlvKVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDb250YWluZXJTaXplKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogUGFydGlhbDxTY2FsZT4ge1xuICBsZXQgbWF4V2lkdGg6IG51bWJlciwgbWF4SGVpZ2h0OiBudW1iZXI7XG5cbiAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQgfHwgaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBfZ2V0UGFyZW50Tm9kZShjYW52YXMpO1xuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICB3aWR0aCA9IGNhbnZhcy5jbGllbnRXaWR0aDtcbiAgICAgIGhlaWdodCA9IGNhbnZhcy5jbGllbnRIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIHRoaXMgaXMgdGhlIGJvcmRlciBib3ggb2YgdGhlIGNvbnRhaW5lclxuICAgICAgY29uc3QgY29udGFpbmVyU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcik7XG4gICAgICBjb25zdCBjb250YWluZXJCb3JkZXIgPSBnZXRQb3NpdGlvbmVkU3R5bGUoY29udGFpbmVyU3R5bGUsICdib3JkZXInLCAnd2lkdGgnKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lclBhZGRpbmcgPSBnZXRQb3NpdGlvbmVkU3R5bGUoY29udGFpbmVyU3R5bGUsICdwYWRkaW5nJyk7XG4gICAgICB3aWR0aCA9IHJlY3Qud2lkdGggLSBjb250YWluZXJQYWRkaW5nLndpZHRoIC0gY29udGFpbmVyQm9yZGVyLndpZHRoO1xuICAgICAgaGVpZ2h0ID0gcmVjdC5oZWlnaHQgLSBjb250YWluZXJQYWRkaW5nLmhlaWdodCAtIGNvbnRhaW5lckJvcmRlci5oZWlnaHQ7XG4gICAgICBtYXhXaWR0aCA9IHBhcnNlTWF4U3R5bGUoY29udGFpbmVyU3R5bGUubWF4V2lkdGgsIGNvbnRhaW5lciwgJ2NsaWVudFdpZHRoJyk7XG4gICAgICBtYXhIZWlnaHQgPSBwYXJzZU1heFN0eWxlKGNvbnRhaW5lclN0eWxlLm1heEhlaWdodCwgY29udGFpbmVyLCAnY2xpZW50SGVpZ2h0Jyk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIG1heFdpZHRoOiBtYXhXaWR0aCB8fCBJTkZJTklUWSxcbiAgICBtYXhIZWlnaHQ6IG1heEhlaWdodCB8fCBJTkZJTklUWVxuICB9O1xufVxuXG5jb25zdCByb3VuZDEgPSAodjogbnVtYmVyKSA9PiBNYXRoLnJvdW5kKHYgKiAxMCkgLyAxMDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXhpbXVtU2l6ZShcbiAgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCxcbiAgYmJXaWR0aD86IG51bWJlcixcbiAgYmJIZWlnaHQ/OiBudW1iZXIsXG4gIGFzcGVjdFJhdGlvPzogbnVtYmVyXG4pOiB7IHdpZHRoOiBudW1iZXI7IGhlaWdodDogbnVtYmVyIH0ge1xuICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY2FudmFzKTtcbiAgY29uc3QgbWFyZ2lucyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ21hcmdpbicpO1xuICBjb25zdCBtYXhXaWR0aCA9IHBhcnNlTWF4U3R5bGUoc3R5bGUubWF4V2lkdGgsIGNhbnZhcywgJ2NsaWVudFdpZHRoJykgfHwgSU5GSU5JVFk7XG4gIGNvbnN0IG1heEhlaWdodCA9IHBhcnNlTWF4U3R5bGUoc3R5bGUubWF4SGVpZ2h0LCBjYW52YXMsICdjbGllbnRIZWlnaHQnKSB8fCBJTkZJTklUWTtcbiAgY29uc3QgY29udGFpbmVyU2l6ZSA9IGdldENvbnRhaW5lclNpemUoY2FudmFzLCBiYldpZHRoLCBiYkhlaWdodCk7XG4gIGxldCB7d2lkdGgsIGhlaWdodH0gPSBjb250YWluZXJTaXplO1xuXG4gIGlmIChzdHlsZS5ib3hTaXppbmcgPT09ICdjb250ZW50LWJveCcpIHtcbiAgICBjb25zdCBib3JkZXJzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAnYm9yZGVyJywgJ3dpZHRoJyk7XG4gICAgY29uc3QgcGFkZGluZ3MgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdwYWRkaW5nJyk7XG4gICAgd2lkdGggLT0gcGFkZGluZ3Mud2lkdGggKyBib3JkZXJzLndpZHRoO1xuICAgIGhlaWdodCAtPSBwYWRkaW5ncy5oZWlnaHQgKyBib3JkZXJzLmhlaWdodDtcbiAgfVxuICB3aWR0aCA9IE1hdGgubWF4KDAsIHdpZHRoIC0gbWFyZ2lucy53aWR0aCk7XG4gIGhlaWdodCA9IE1hdGgubWF4KDAsIGFzcGVjdFJhdGlvID8gd2lkdGggLyBhc3BlY3RSYXRpbyA6IGhlaWdodCAtIG1hcmdpbnMuaGVpZ2h0KTtcbiAgd2lkdGggPSByb3VuZDEoTWF0aC5taW4od2lkdGgsIG1heFdpZHRoLCBjb250YWluZXJTaXplLm1heFdpZHRoKSk7XG4gIGhlaWdodCA9IHJvdW5kMShNYXRoLm1pbihoZWlnaHQsIG1heEhlaWdodCwgY29udGFpbmVyU2l6ZS5tYXhIZWlnaHQpKTtcbiAgaWYgKHdpZHRoICYmICFoZWlnaHQpIHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDY1OVxuICAgIC8vIElmIHRoZSBjYW52YXMgaGFzIHdpZHRoLCBidXQgbm8gaGVpZ2h0LCBkZWZhdWx0IHRvIGFzcGVjdFJhdGlvIG9mIDIgKGNhbnZhcyBkZWZhdWx0KVxuICAgIGhlaWdodCA9IHJvdW5kMSh3aWR0aCAvIDIpO1xuICB9XG5cbiAgY29uc3QgbWFpbnRhaW5IZWlnaHQgPSBiYldpZHRoICE9PSB1bmRlZmluZWQgfHwgYmJIZWlnaHQgIT09IHVuZGVmaW5lZDtcblxuICBpZiAobWFpbnRhaW5IZWlnaHQgJiYgYXNwZWN0UmF0aW8gJiYgY29udGFpbmVyU2l6ZS5oZWlnaHQgJiYgaGVpZ2h0ID4gY29udGFpbmVyU2l6ZS5oZWlnaHQpIHtcbiAgICBoZWlnaHQgPSBjb250YWluZXJTaXplLmhlaWdodDtcbiAgICB3aWR0aCA9IHJvdW5kMShNYXRoLmZsb29yKGhlaWdodCAqIGFzcGVjdFJhdGlvKSk7XG4gIH1cblxuICByZXR1cm4ge3dpZHRoLCBoZWlnaHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSBjaGFydFxuICogQHBhcmFtIGZvcmNlUmF0aW9cbiAqIEBwYXJhbSBmb3JjZVN0eWxlXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBjYW52YXMgY29udGV4dCBzaXplIG9yIHRyYW5zZm9ybWF0aW9uIGhhcyBjaGFuZ2VkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmV0aW5hU2NhbGUoXG4gIGNoYXJ0OiBDaGFydCxcbiAgZm9yY2VSYXRpbzogbnVtYmVyLFxuICBmb3JjZVN0eWxlPzogYm9vbGVhblxuKTogYm9vbGVhbiB8IHZvaWQge1xuICBjb25zdCBwaXhlbFJhdGlvID0gZm9yY2VSYXRpbyB8fCAxO1xuICBjb25zdCBkZXZpY2VIZWlnaHQgPSBNYXRoLmZsb29yKGNoYXJ0LmhlaWdodCAqIHBpeGVsUmF0aW8pO1xuICBjb25zdCBkZXZpY2VXaWR0aCA9IE1hdGguZmxvb3IoY2hhcnQud2lkdGggKiBwaXhlbFJhdGlvKTtcblxuICBjaGFydC5oZWlnaHQgPSBNYXRoLmZsb29yKGNoYXJ0LmhlaWdodCk7XG4gIGNoYXJ0LndpZHRoID0gTWF0aC5mbG9vcihjaGFydC53aWR0aCk7XG5cbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuXG4gIC8vIElmIG5vIHN0eWxlIGhhcyBiZWVuIHNldCBvbiB0aGUgY2FudmFzLCB0aGUgcmVuZGVyIHNpemUgaXMgdXNlZCBhcyBkaXNwbGF5IHNpemUsXG4gIC8vIG1ha2luZyB0aGUgY2hhcnQgdmlzdWFsbHkgYmlnZ2VyLCBzbyBsZXQncyBlbmZvcmNlIGl0IHRvIHRoZSBcImNvcnJlY3RcIiB2YWx1ZXMuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMzU3NVxuICBpZiAoY2FudmFzLnN0eWxlICYmIChmb3JjZVN0eWxlIHx8ICghY2FudmFzLnN0eWxlLmhlaWdodCAmJiAhY2FudmFzLnN0eWxlLndpZHRoKSkpIHtcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gYCR7Y2hhcnQuaGVpZ2h0fXB4YDtcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSBgJHtjaGFydC53aWR0aH1weGA7XG4gIH1cblxuICBpZiAoY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8gIT09IHBpeGVsUmF0aW9cbiAgICAgIHx8IGNhbnZhcy5oZWlnaHQgIT09IGRldmljZUhlaWdodFxuICAgICAgfHwgY2FudmFzLndpZHRoICE9PSBkZXZpY2VXaWR0aCkge1xuICAgIGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcbiAgICBjYW52YXMuaGVpZ2h0ID0gZGV2aWNlSGVpZ2h0O1xuICAgIGNhbnZhcy53aWR0aCA9IGRldmljZVdpZHRoO1xuICAgIGNoYXJ0LmN0eC5zZXRUcmFuc2Zvcm0ocGl4ZWxSYXRpbywgMCwgMCwgcGl4ZWxSYXRpbywgMCwgMCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIERldGVjdHMgc3VwcG9ydCBmb3Igb3B0aW9ucyBvYmplY3QgYXJndW1lbnQgaW4gYWRkRXZlbnRMaXN0ZW5lci5cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9hZGRFdmVudExpc3RlbmVyI1NhZmVseV9kZXRlY3Rpbmdfb3B0aW9uX3N1cHBvcnRcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zID0gKGZ1bmN0aW9uKCkge1xuICBsZXQgcGFzc2l2ZVN1cHBvcnRlZCA9IGZhbHNlO1xuICB0cnkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBnZXQgcGFzc2l2ZSgpIHsgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBicm93c2VyIGF0dGVtcHRzIHRvIGFjY2VzcyB0aGUgcGFzc2l2ZSBwcm9wZXJ0eS5cbiAgICAgICAgcGFzc2l2ZVN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGFzIEV2ZW50TGlzdGVuZXJPcHRpb25zO1xuXG4gICAgaWYgKF9pc0RvbVN1cHBvcnRlZCgpKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdGlvbnMpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRpb25zKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBjb250aW51ZSByZWdhcmRsZXNzIG9mIGVycm9yXG4gIH1cbiAgcmV0dXJuIHBhc3NpdmVTdXBwb3J0ZWQ7XG59KCkpO1xuXG4vKipcbiAqIFRoZSBcInVzZWRcIiBzaXplIGlzIHRoZSBmaW5hbCB2YWx1ZSBvZiBhIGRpbWVuc2lvbiBwcm9wZXJ0eSBhZnRlciBhbGwgY2FsY3VsYXRpb25zIGhhdmVcbiAqIGJlZW4gcGVyZm9ybWVkLiBUaGlzIG1ldGhvZCB1c2VzIHRoZSBjb21wdXRlZCBzdHlsZSBvZiBgZWxlbWVudGAgYnV0IHJldHVybnMgdW5kZWZpbmVkXG4gKiBpZiB0aGUgY29tcHV0ZWQgc3R5bGUgaXMgbm90IGV4cHJlc3NlZCBpbiBwaXhlbHMuIFRoYXQgY2FuIGhhcHBlbiBpbiBzb21lIGNhc2VzIHdoZXJlXG4gKiBgZWxlbWVudGAgaGFzIGEgc2l6ZSByZWxhdGl2ZSB0byBpdHMgcGFyZW50IGFuZCB0aGlzIGxhc3Qgb25lIGlzIG5vdCB5ZXQgZGlzcGxheWVkLFxuICogZm9yIGV4YW1wbGUgYmVjYXVzZSBvZiBgZGlzcGxheTogbm9uZWAgb24gYSBwYXJlbnQgbm9kZS5cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3VzZWRfdmFsdWVcbiAqIEByZXR1cm5zIFNpemUgaW4gcGl4ZWxzIG9yIHVuZGVmaW5lZCBpZiB1bmtub3duLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByZWFkVXNlZFNpemUoXG4gIGVsZW1lbnQ6IEhUTUxFbGVtZW50LFxuICBwcm9wZXJ0eTogJ3dpZHRoJyB8ICdoZWlnaHQnXG4pOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICBjb25zdCB2YWx1ZSA9IGdldFN0eWxlKGVsZW1lbnQsIHByb3BlcnR5KTtcbiAgY29uc3QgbWF0Y2hlcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKC9eKFxcZCspKFxcLlxcZCspP3B4JC8pO1xuICByZXR1cm4gbWF0Y2hlcyA/ICttYXRjaGVzWzFdIDogdW5kZWZpbmVkO1xufVxuIiwgImltcG9ydCB0eXBlIHtQb2ludCwgU3BsaW5lUG9pbnR9IGZyb20gJy4uL3R5cGVzL2dlb21ldHJpYy5qcyc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9wb2ludEluTGluZShwMTogUG9pbnQsIHAyOiBQb2ludCwgdDogbnVtYmVyLCBtb2RlPykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICByZXR1cm4ge1xuICAgIHg6IHAxLnggKyB0ICogKHAyLnggLSBwMS54KSxcbiAgICB5OiBwMS55ICsgdCAqIChwMi55IC0gcDEueSlcbiAgfTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX3N0ZXBwZWRJbnRlcnBvbGF0aW9uKFxuICBwMTogUG9pbnQsXG4gIHAyOiBQb2ludCxcbiAgdDogbnVtYmVyLCBtb2RlOiAnbWlkZGxlJyB8ICdhZnRlcicgfCB1bmtub3duXG4pIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBwMS54ICsgdCAqIChwMi54IC0gcDEueCksXG4gICAgeTogbW9kZSA9PT0gJ21pZGRsZScgPyB0IDwgMC41ID8gcDEueSA6IHAyLnlcbiAgICAgIDogbW9kZSA9PT0gJ2FmdGVyJyA/IHQgPCAxID8gcDEueSA6IHAyLnlcbiAgICAgICAgOiB0ID4gMCA/IHAyLnkgOiBwMS55XG4gIH07XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9iZXppZXJJbnRlcnBvbGF0aW9uKHAxOiBTcGxpbmVQb2ludCwgcDI6IFNwbGluZVBvaW50LCB0OiBudW1iZXIsIG1vZGU/KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIGNvbnN0IGNwMSA9IHt4OiBwMS5jcDJ4LCB5OiBwMS5jcDJ5fTtcbiAgY29uc3QgY3AyID0ge3g6IHAyLmNwMXgsIHk6IHAyLmNwMXl9O1xuICBjb25zdCBhID0gX3BvaW50SW5MaW5lKHAxLCBjcDEsIHQpO1xuICBjb25zdCBiID0gX3BvaW50SW5MaW5lKGNwMSwgY3AyLCB0KTtcbiAgY29uc3QgYyA9IF9wb2ludEluTGluZShjcDIsIHAyLCB0KTtcbiAgY29uc3QgZCA9IF9wb2ludEluTGluZShhLCBiLCB0KTtcbiAgY29uc3QgZSA9IF9wb2ludEluTGluZShiLCBjLCB0KTtcbiAgcmV0dXJuIF9wb2ludEluTGluZShkLCBlLCB0KTtcbn1cbiIsICJleHBvcnQgaW50ZXJmYWNlIFJUTEFkYXB0ZXIge1xuICB4KHg6IG51bWJlcik6IG51bWJlcjtcbiAgc2V0V2lkdGgodzogbnVtYmVyKTogdm9pZDtcbiAgdGV4dEFsaWduKGFsaWduOiAnY2VudGVyJyB8ICdsZWZ0JyB8ICdyaWdodCcpOiAnY2VudGVyJyB8ICdsZWZ0JyB8ICdyaWdodCc7XG4gIHhQbHVzKHg6IG51bWJlciwgdmFsdWU6IG51bWJlcik6IG51bWJlcjtcbiAgbGVmdEZvckx0cih4OiBudW1iZXIsIGl0ZW1XaWR0aDogbnVtYmVyKTogbnVtYmVyO1xufVxuXG5jb25zdCBnZXRSaWdodFRvTGVmdEFkYXB0ZXIgPSBmdW5jdGlvbihyZWN0WDogbnVtYmVyLCB3aWR0aDogbnVtYmVyKTogUlRMQWRhcHRlciB7XG4gIHJldHVybiB7XG4gICAgeCh4KSB7XG4gICAgICByZXR1cm4gcmVjdFggKyByZWN0WCArIHdpZHRoIC0geDtcbiAgICB9LFxuICAgIHNldFdpZHRoKHcpIHtcbiAgICAgIHdpZHRoID0gdztcbiAgICB9LFxuICAgIHRleHRBbGlnbihhbGlnbikge1xuICAgICAgaWYgKGFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICByZXR1cm4gYWxpZ247XG4gICAgICB9XG4gICAgICByZXR1cm4gYWxpZ24gPT09ICdyaWdodCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgIH0sXG4gICAgeFBsdXMoeCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB4IC0gdmFsdWU7XG4gICAgfSxcbiAgICBsZWZ0Rm9yTHRyKHgsIGl0ZW1XaWR0aCkge1xuICAgICAgcmV0dXJuIHggLSBpdGVtV2lkdGg7XG4gICAgfSxcbiAgfTtcbn07XG5cbmNvbnN0IGdldExlZnRUb1JpZ2h0QWRhcHRlciA9IGZ1bmN0aW9uKCk6IFJUTEFkYXB0ZXIge1xuICByZXR1cm4ge1xuICAgIHgoeCkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfSxcbiAgICBzZXRXaWR0aCh3KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB9LFxuICAgIHRleHRBbGlnbihhbGlnbikge1xuICAgICAgcmV0dXJuIGFsaWduO1xuICAgIH0sXG4gICAgeFBsdXMoeCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB4ICsgdmFsdWU7XG4gICAgfSxcbiAgICBsZWZ0Rm9yTHRyKHgsIF9pdGVtV2lkdGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiB4O1xuICAgIH0sXG4gIH07XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UnRsQWRhcHRlcihydGw6IGJvb2xlYW4sIHJlY3RYOiBudW1iZXIsIHdpZHRoOiBudW1iZXIpIHtcbiAgcmV0dXJuIHJ0bCA/IGdldFJpZ2h0VG9MZWZ0QWRhcHRlcihyZWN0WCwgd2lkdGgpIDogZ2V0TGVmdFRvUmlnaHRBZGFwdGVyKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvdmVycmlkZVRleHREaXJlY3Rpb24oY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGRpcmVjdGlvbjogJ2x0cicgfCAncnRsJykge1xuICBsZXQgc3R5bGU6IENTU1N0eWxlRGVjbGFyYXRpb24sIG9yaWdpbmFsOiBbc3RyaW5nLCBzdHJpbmddO1xuICBpZiAoZGlyZWN0aW9uID09PSAnbHRyJyB8fCBkaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgc3R5bGUgPSBjdHguY2FudmFzLnN0eWxlO1xuICAgIG9yaWdpbmFsID0gW1xuICAgICAgc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnZGlyZWN0aW9uJyksXG4gICAgICBzdHlsZS5nZXRQcm9wZXJ0eVByaW9yaXR5KCdkaXJlY3Rpb24nKSxcbiAgICBdO1xuXG4gICAgc3R5bGUuc2V0UHJvcGVydHkoJ2RpcmVjdGlvbicsIGRpcmVjdGlvbiwgJ2ltcG9ydGFudCcpO1xuICAgIChjdHggYXMgeyBwcmV2VGV4dERpcmVjdGlvbj86IFtzdHJpbmcsIHN0cmluZ10gfSkucHJldlRleHREaXJlY3Rpb24gPSBvcmlnaW5hbDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzdG9yZVRleHREaXJlY3Rpb24oY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIG9yaWdpbmFsPzogW3N0cmluZywgc3RyaW5nXSkge1xuICBpZiAob3JpZ2luYWwgIT09IHVuZGVmaW5lZCkge1xuICAgIGRlbGV0ZSAoY3R4IGFzIHsgcHJldlRleHREaXJlY3Rpb24/OiBbc3RyaW5nLCBzdHJpbmddIH0pLnByZXZUZXh0RGlyZWN0aW9uO1xuICAgIGN0eC5jYW52YXMuc3R5bGUuc2V0UHJvcGVydHkoJ2RpcmVjdGlvbicsIG9yaWdpbmFsWzBdLCBvcmlnaW5hbFsxXSk7XG4gIH1cbn1cbiIsICJpbXBvcnQge19hbmdsZUJldHdlZW4sIF9hbmdsZURpZmYsIF9pc0JldHdlZW4sIF9ub3JtYWxpemVBbmdsZX0gZnJvbSAnLi9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtjcmVhdGVDb250ZXh0fSBmcm9tICcuL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5pbXBvcnQge2lzUGF0dGVybk9yR3JhZGllbnR9IGZyb20gJy4vaGVscGVycy5jb2xvci5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL2VsZW1lbnRzL2VsZW1lbnQubGluZS5qcycpLmRlZmF1bHQgfSBMaW5lRWxlbWVudFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL2VsZW1lbnRzL2VsZW1lbnQucG9pbnQuanMnKS5kZWZhdWx0IH0gUG9pbnRFbGVtZW50XG4gKiBAdHlwZWRlZiB7e3N0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyLCBsb29wOiBib29sZWFuLCBzdHlsZT86IGFueX19IFNlZ21lbnRcbiAqL1xuXG5mdW5jdGlvbiBwcm9wZXJ0eUZuKHByb3BlcnR5KSB7XG4gIGlmIChwcm9wZXJ0eSA9PT0gJ2FuZ2xlJykge1xuICAgIHJldHVybiB7XG4gICAgICBiZXR3ZWVuOiBfYW5nbGVCZXR3ZWVuLFxuICAgICAgY29tcGFyZTogX2FuZ2xlRGlmZixcbiAgICAgIG5vcm1hbGl6ZTogX25vcm1hbGl6ZUFuZ2xlLFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBiZXR3ZWVuOiBfaXNCZXR3ZWVuLFxuICAgIGNvbXBhcmU6IChhLCBiKSA9PiBhIC0gYixcbiAgICBub3JtYWxpemU6IHggPT4geFxuICB9O1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTZWdtZW50KHtzdGFydCwgZW5kLCBjb3VudCwgbG9vcCwgc3R5bGV9KSB7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0ICUgY291bnQsXG4gICAgZW5kOiBlbmQgJSBjb3VudCxcbiAgICBsb29wOiBsb29wICYmIChlbmQgLSBzdGFydCArIDEpICUgY291bnQgPT09IDAsXG4gICAgc3R5bGVcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0U2VnbWVudChzZWdtZW50LCBwb2ludHMsIGJvdW5kcykge1xuICBjb25zdCB7cHJvcGVydHksIHN0YXJ0OiBzdGFydEJvdW5kLCBlbmQ6IGVuZEJvdW5kfSA9IGJvdW5kcztcbiAgY29uc3Qge2JldHdlZW4sIG5vcm1hbGl6ZX0gPSBwcm9wZXJ0eUZuKHByb3BlcnR5KTtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gIGxldCB7c3RhcnQsIGVuZCwgbG9vcH0gPSBzZWdtZW50O1xuICBsZXQgaSwgaWxlbjtcblxuICBpZiAobG9vcCkge1xuICAgIHN0YXJ0ICs9IGNvdW50O1xuICAgIGVuZCArPSBjb3VudDtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGlmICghYmV0d2Vlbihub3JtYWxpemUocG9pbnRzW3N0YXJ0ICUgY291bnRdW3Byb3BlcnR5XSksIHN0YXJ0Qm91bmQsIGVuZEJvdW5kKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXJ0LS07XG4gICAgICBlbmQtLTtcbiAgICB9XG4gICAgc3RhcnQgJT0gY291bnQ7XG4gICAgZW5kICU9IGNvdW50O1xuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgZW5kICs9IGNvdW50O1xuICB9XG4gIHJldHVybiB7c3RhcnQsIGVuZCwgbG9vcCwgc3R5bGU6IHNlZ21lbnQuc3R5bGV9O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHN1Yi1zZWdtZW50KHMpIG9mIGEgbGluZSBzZWdtZW50IHRoYXQgZmFsbCBpbiB0aGUgZ2l2ZW4gYm91bmRzXG4gKiBAcGFyYW0ge29iamVjdH0gc2VnbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnQuc3RhcnQgLSBzdGFydCBpbmRleCBvZiB0aGUgc2VnbWVudCwgcmVmZXJyaW5nIHRoZSBwb2ludHMgYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LmVuZCAtIGVuZCBpbmRleCBvZiB0aGUgc2VnbWVudCwgcmVmZXJyaW5nIHRoZSBwb2ludHMgYXJyYXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VnbWVudC5sb29wIC0gaW5kaWNhdGVzIHRoYXQgdGhlIHNlZ21lbnQgaXMgYSBsb29wXG4gKiBAcGFyYW0ge29iamVjdH0gW3NlZ21lbnQuc3R5bGVdIC0gc2VnbWVudCBzdHlsZVxuICogQHBhcmFtIHtQb2ludEVsZW1lbnRbXX0gcG9pbnRzIC0gdGhlIHBvaW50cyB0aGF0IHRoaXMgc2VnbWVudCByZWZlcnMgdG9cbiAqIEBwYXJhbSB7b2JqZWN0fSBbYm91bmRzXVxuICogQHBhcmFtIHtzdHJpbmd9IGJvdW5kcy5wcm9wZXJ0eSAtIHRoZSBwcm9wZXJ0eSBvZiBhIGBQb2ludEVsZW1lbnRgIHdlIGFyZSBib3VuZGluZy4gYHhgLCBgeWAgb3IgYGFuZ2xlYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3VuZHMuc3RhcnQgLSBzdGFydCB2YWx1ZSBvZiB0aGUgcHJvcGVydHlcbiAqIEBwYXJhbSB7bnVtYmVyfSBib3VuZHMuZW5kIC0gZW5kIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuICogQHByaXZhdGVcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBfYm91bmRTZWdtZW50KHNlZ21lbnQsIHBvaW50cywgYm91bmRzKSB7XG4gIGlmICghYm91bmRzKSB7XG4gICAgcmV0dXJuIFtzZWdtZW50XTtcbiAgfVxuXG4gIGNvbnN0IHtwcm9wZXJ0eSwgc3RhcnQ6IHN0YXJ0Qm91bmQsIGVuZDogZW5kQm91bmR9ID0gYm91bmRzO1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IHtjb21wYXJlLCBiZXR3ZWVuLCBub3JtYWxpemV9ID0gcHJvcGVydHlGbihwcm9wZXJ0eSk7XG4gIGNvbnN0IHtzdGFydCwgZW5kLCBsb29wLCBzdHlsZX0gPSBnZXRTZWdtZW50KHNlZ21lbnQsIHBvaW50cywgYm91bmRzKTtcblxuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGluc2lkZSA9IGZhbHNlO1xuICBsZXQgc3ViU3RhcnQgPSBudWxsO1xuICBsZXQgdmFsdWUsIHBvaW50LCBwcmV2VmFsdWU7XG5cbiAgY29uc3Qgc3RhcnRJc0JlZm9yZSA9ICgpID0+IGJldHdlZW4oc3RhcnRCb3VuZCwgcHJldlZhbHVlLCB2YWx1ZSkgJiYgY29tcGFyZShzdGFydEJvdW5kLCBwcmV2VmFsdWUpICE9PSAwO1xuICBjb25zdCBlbmRJc0JlZm9yZSA9ICgpID0+IGNvbXBhcmUoZW5kQm91bmQsIHZhbHVlKSA9PT0gMCB8fCBiZXR3ZWVuKGVuZEJvdW5kLCBwcmV2VmFsdWUsIHZhbHVlKTtcbiAgY29uc3Qgc2hvdWxkU3RhcnQgPSAoKSA9PiBpbnNpZGUgfHwgc3RhcnRJc0JlZm9yZSgpO1xuICBjb25zdCBzaG91bGRTdG9wID0gKCkgPT4gIWluc2lkZSB8fCBlbmRJc0JlZm9yZSgpO1xuXG4gIGZvciAobGV0IGkgPSBzdGFydCwgcHJldiA9IHN0YXJ0OyBpIDw9IGVuZDsgKytpKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbaSAlIGNvdW50XTtcblxuICAgIGlmIChwb2ludC5za2lwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YWx1ZSA9IG5vcm1hbGl6ZShwb2ludFtwcm9wZXJ0eV0pO1xuXG4gICAgaWYgKHZhbHVlID09PSBwcmV2VmFsdWUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGluc2lkZSA9IGJldHdlZW4odmFsdWUsIHN0YXJ0Qm91bmQsIGVuZEJvdW5kKTtcblxuICAgIGlmIChzdWJTdGFydCA9PT0gbnVsbCAmJiBzaG91bGRTdGFydCgpKSB7XG4gICAgICBzdWJTdGFydCA9IGNvbXBhcmUodmFsdWUsIHN0YXJ0Qm91bmQpID09PSAwID8gaSA6IHByZXY7XG4gICAgfVxuXG4gICAgaWYgKHN1YlN0YXJ0ICE9PSBudWxsICYmIHNob3VsZFN0b3AoKSkge1xuICAgICAgcmVzdWx0LnB1c2gobm9ybWFsaXplU2VnbWVudCh7c3RhcnQ6IHN1YlN0YXJ0LCBlbmQ6IGksIGxvb3AsIGNvdW50LCBzdHlsZX0pKTtcbiAgICAgIHN1YlN0YXJ0ID0gbnVsbDtcbiAgICB9XG4gICAgcHJldiA9IGk7XG4gICAgcHJldlZhbHVlID0gdmFsdWU7XG4gIH1cblxuICBpZiAoc3ViU3RhcnQgIT09IG51bGwpIHtcbiAgICByZXN1bHQucHVzaChub3JtYWxpemVTZWdtZW50KHtzdGFydDogc3ViU3RhcnQsIGVuZCwgbG9vcCwgY291bnQsIHN0eWxlfSkpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNlZ21lbnRzIG9mIHRoZSBsaW5lIHRoYXQgYXJlIGluc2lkZSBnaXZlbiBib3VuZHNcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmVcbiAqIEBwYXJhbSB7b2JqZWN0fSBbYm91bmRzXVxuICogQHBhcmFtIHtzdHJpbmd9IGJvdW5kcy5wcm9wZXJ0eSAtIHRoZSBwcm9wZXJ0eSB3ZSBhcmUgYm91bmRpbmcgd2l0aC4gYHhgLCBgeWAgb3IgYGFuZ2xlYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3VuZHMuc3RhcnQgLSBzdGFydCB2YWx1ZSBvZiB0aGUgYHByb3BlcnR5YFxuICogQHBhcmFtIHtudW1iZXJ9IGJvdW5kcy5lbmQgLSBlbmQgdmFsdWUgb2YgdGhlIGBwcm9wZXJ0eWBcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYm91bmRTZWdtZW50cyhsaW5lLCBib3VuZHMpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc3ViID0gX2JvdW5kU2VnbWVudChzZWdtZW50c1tpXSwgbGluZS5wb2ludHMsIGJvdW5kcyk7XG4gICAgaWYgKHN1Yi5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdC5wdXNoKC4uLnN1Yik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRmluZCBzdGFydCBhbmQgZW5kIGluZGV4IG9mIGEgbGluZS5cbiAqL1xuZnVuY3Rpb24gZmluZFN0YXJ0QW5kRW5kKHBvaW50cywgY291bnQsIGxvb3AsIHNwYW5HYXBzKSB7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBlbmQgPSBjb3VudCAtIDE7XG5cbiAgaWYgKGxvb3AgJiYgIXNwYW5HYXBzKSB7XG4gICAgLy8gbG9vcCBhbmQgbm90IHNwYW5uaW5nIGdhcHMsIGZpcnN0IGZpbmQgYSBnYXAgdG8gc3RhcnQgZnJvbVxuICAgIHdoaWxlIChzdGFydCA8IGNvdW50ICYmICFwb2ludHNbc3RhcnRdLnNraXApIHtcbiAgICAgIHN0YXJ0Kys7XG4gICAgfVxuICB9XG5cbiAgLy8gZmluZCBmaXJzdCBub24gc2tpcHBlZCBwb2ludCAoYWZ0ZXIgdGhlIGZpcnN0IGdhcCBwb3NzaWJseSlcbiAgd2hpbGUgKHN0YXJ0IDwgY291bnQgJiYgcG9pbnRzW3N0YXJ0XS5za2lwKSB7XG4gICAgc3RhcnQrKztcbiAgfVxuXG4gIC8vIGlmIHdlIGxvb3BlZCB0byBjb3VudCwgc3RhcnQgbmVlZHMgdG8gYmUgMFxuICBzdGFydCAlPSBjb3VudDtcblxuICBpZiAobG9vcCkge1xuICAgIC8vIGxvb3Agd2lsbCBnbyBwYXN0IGNvdW50LCBpZiBzdGFydCA+IDBcbiAgICBlbmQgKz0gc3RhcnQ7XG4gIH1cblxuICB3aGlsZSAoZW5kID4gc3RhcnQgJiYgcG9pbnRzW2VuZCAlIGNvdW50XS5za2lwKSB7XG4gICAgZW5kLS07XG4gIH1cblxuICAvLyBlbmQgY291bGQgYmUgbW9yZSB0aGFuIGNvdW50LCBub3JtYWxpemVcbiAgZW5kICU9IGNvdW50O1xuXG4gIHJldHVybiB7c3RhcnQsIGVuZH07XG59XG5cbi8qKlxuICogQ29tcHV0ZSBzb2xpZCBzZWdtZW50cyBmcm9tIFBvaW50cywgd2hlbiBzcGFuR2FwcyA9PT0gZmFsc2VcbiAqIEBwYXJhbSB7UG9pbnRFbGVtZW50W119IHBvaW50cyAtIHRoZSBwb2ludHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIHN0YXJ0IGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IC0gbWF4IGluZGV4IChjYW4gZ28gcGFzdCBjb3VudCBvbiBhIGxvb3ApXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxvb3AgLSBib29sZWFuIGluZGljYXRpbmcgdGhhdCB0aGlzIHdvdWxkIGJlIGEgbG9vcCBpZiBubyBnYXBzIGFyZSBmb3VuZFxuICovXG5mdW5jdGlvbiBzb2xpZFNlZ21lbnRzKHBvaW50cywgc3RhcnQsIG1heCwgbG9vcCkge1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgbGFzdCA9IHN0YXJ0O1xuICBsZXQgcHJldiA9IHBvaW50c1tzdGFydF07XG4gIGxldCBlbmQ7XG5cbiAgZm9yIChlbmQgPSBzdGFydCArIDE7IGVuZCA8PSBtYXg7ICsrZW5kKSB7XG4gICAgY29uc3QgY3VyID0gcG9pbnRzW2VuZCAlIGNvdW50XTtcbiAgICBpZiAoY3VyLnNraXAgfHwgY3VyLnN0b3ApIHtcbiAgICAgIGlmICghcHJldi5za2lwKSB7XG4gICAgICAgIGxvb3AgPSBmYWxzZTtcbiAgICAgICAgcmVzdWx0LnB1c2goe3N0YXJ0OiBzdGFydCAlIGNvdW50LCBlbmQ6IChlbmQgLSAxKSAlIGNvdW50LCBsb29wfSk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgc3RhcnQgPSBsYXN0ID0gY3VyLnN0b3AgPyBlbmQgOiBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0ID0gZW5kO1xuICAgICAgaWYgKHByZXYuc2tpcCkge1xuICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcHJldiA9IGN1cjtcbiAgfVxuXG4gIGlmIChsYXN0ICE9PSBudWxsKSB7XG4gICAgcmVzdWx0LnB1c2goe3N0YXJ0OiBzdGFydCAlIGNvdW50LCBlbmQ6IGxhc3QgJSBjb3VudCwgbG9vcH0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb21wdXRlIHRoZSBjb250aW51b3VzIHNlZ21lbnRzIHRoYXQgZGVmaW5lIHRoZSB3aG9sZSBsaW5lXG4gKiBUaGVyZSBjYW4gYmUgc2tpcHBlZCBwb2ludHMgd2l0aGluIGEgc2VnbWVudCwgaWYgc3BhbkdhcHMgaXMgdHJ1ZS5cbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmVcbiAqIEBwYXJhbSB7b2JqZWN0fSBbc2VnbWVudE9wdGlvbnNdXG4gKiBAcmV0dXJuIHtTZWdtZW50W119XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2NvbXB1dGVTZWdtZW50cyhsaW5lLCBzZWdtZW50T3B0aW9ucykge1xuICBjb25zdCBwb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3Qgc3BhbkdhcHMgPSBsaW5lLm9wdGlvbnMuc3BhbkdhcHM7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcblxuICBpZiAoIWNvdW50KSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3QgbG9vcCA9ICEhbGluZS5fbG9vcDtcbiAgY29uc3Qge3N0YXJ0LCBlbmR9ID0gZmluZFN0YXJ0QW5kRW5kKHBvaW50cywgY291bnQsIGxvb3AsIHNwYW5HYXBzKTtcblxuICBpZiAoc3BhbkdhcHMgPT09IHRydWUpIHtcbiAgICByZXR1cm4gc3BsaXRCeVN0eWxlcyhsaW5lLCBbe3N0YXJ0LCBlbmQsIGxvb3B9XSwgcG9pbnRzLCBzZWdtZW50T3B0aW9ucyk7XG4gIH1cblxuICBjb25zdCBtYXggPSBlbmQgPCBzdGFydCA/IGVuZCArIGNvdW50IDogZW5kO1xuICBjb25zdCBjb21wbGV0ZUxvb3AgPSAhIWxpbmUuX2Z1bGxMb29wICYmIHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gY291bnQgLSAxO1xuICByZXR1cm4gc3BsaXRCeVN0eWxlcyhsaW5lLCBzb2xpZFNlZ21lbnRzKHBvaW50cywgc3RhcnQsIG1heCwgY29tcGxldGVMb29wKSwgcG9pbnRzLCBzZWdtZW50T3B0aW9ucyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTZWdtZW50W119IHNlZ21lbnRzXG4gKiBAcGFyYW0ge1BvaW50RWxlbWVudFtdfSBwb2ludHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBbc2VnbWVudE9wdGlvbnNdXG4gKiBAcmV0dXJuIHtTZWdtZW50W119XG4gKi9cbmZ1bmN0aW9uIHNwbGl0QnlTdHlsZXMobGluZSwgc2VnbWVudHMsIHBvaW50cywgc2VnbWVudE9wdGlvbnMpIHtcbiAgaWYgKCFzZWdtZW50T3B0aW9ucyB8fCAhc2VnbWVudE9wdGlvbnMuc2V0Q29udGV4dCB8fCAhcG9pbnRzKSB7XG4gICAgcmV0dXJuIHNlZ21lbnRzO1xuICB9XG4gIHJldHVybiBkb1NwbGl0QnlTdHlsZXMobGluZSwgc2VnbWVudHMsIHBvaW50cywgc2VnbWVudE9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmVcbiAqIEBwYXJhbSB7U2VnbWVudFtdfSBzZWdtZW50c1xuICogQHBhcmFtIHtQb2ludEVsZW1lbnRbXX0gcG9pbnRzXG4gKiBAcGFyYW0ge29iamVjdH0gW3NlZ21lbnRPcHRpb25zXVxuICogQHJldHVybiB7U2VnbWVudFtdfVxuICovXG5mdW5jdGlvbiBkb1NwbGl0QnlTdHlsZXMobGluZSwgc2VnbWVudHMsIHBvaW50cywgc2VnbWVudE9wdGlvbnMpIHtcbiAgY29uc3QgY2hhcnRDb250ZXh0ID0gbGluZS5fY2hhcnQuZ2V0Q29udGV4dCgpO1xuICBjb25zdCBiYXNlU3R5bGUgPSByZWFkU3R5bGUobGluZS5vcHRpb25zKTtcbiAgY29uc3Qge19kYXRhc2V0SW5kZXg6IGRhdGFzZXRJbmRleCwgb3B0aW9uczoge3NwYW5HYXBzfX0gPSBsaW5lO1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgcHJldlN0eWxlID0gYmFzZVN0eWxlO1xuICBsZXQgc3RhcnQgPSBzZWdtZW50c1swXS5zdGFydDtcbiAgbGV0IGkgPSBzdGFydDtcblxuICBmdW5jdGlvbiBhZGRTdHlsZShzLCBlLCBsLCBzdCkge1xuICAgIGNvbnN0IGRpciA9IHNwYW5HYXBzID8gLTEgOiAxO1xuICAgIGlmIChzID09PSBlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFN0eWxlIGNhbiBub3Qgc3RhcnQvZW5kIG9uIGEgc2tpcHBlZCBwb2ludCwgYWRqdXN0IGluZGljZXMgYWNjb3JkaW5nbHlcbiAgICBzICs9IGNvdW50O1xuICAgIHdoaWxlIChwb2ludHNbcyAlIGNvdW50XS5za2lwKSB7XG4gICAgICBzIC09IGRpcjtcbiAgICB9XG4gICAgd2hpbGUgKHBvaW50c1tlICUgY291bnRdLnNraXApIHtcbiAgICAgIGUgKz0gZGlyO1xuICAgIH1cbiAgICBpZiAocyAlIGNvdW50ICE9PSBlICUgY291bnQpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHtzdGFydDogcyAlIGNvdW50LCBlbmQ6IGUgJSBjb3VudCwgbG9vcDogbCwgc3R5bGU6IHN0fSk7XG4gICAgICBwcmV2U3R5bGUgPSBzdDtcbiAgICAgIHN0YXJ0ID0gZSAlIGNvdW50O1xuICAgIH1cbiAgfVxuXG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgIHN0YXJ0ID0gc3BhbkdhcHMgPyBzdGFydCA6IHNlZ21lbnQuc3RhcnQ7XG4gICAgbGV0IHByZXYgPSBwb2ludHNbc3RhcnQgJSBjb3VudF07XG4gICAgbGV0IHN0eWxlO1xuICAgIGZvciAoaSA9IHN0YXJ0ICsgMTsgaSA8PSBzZWdtZW50LmVuZDsgaSsrKSB7XG4gICAgICBjb25zdCBwdCA9IHBvaW50c1tpICUgY291bnRdO1xuICAgICAgc3R5bGUgPSByZWFkU3R5bGUoc2VnbWVudE9wdGlvbnMuc2V0Q29udGV4dChjcmVhdGVDb250ZXh0KGNoYXJ0Q29udGV4dCwge1xuICAgICAgICB0eXBlOiAnc2VnbWVudCcsXG4gICAgICAgIHAwOiBwcmV2LFxuICAgICAgICBwMTogcHQsXG4gICAgICAgIHAwRGF0YUluZGV4OiAoaSAtIDEpICUgY291bnQsXG4gICAgICAgIHAxRGF0YUluZGV4OiBpICUgY291bnQsXG4gICAgICAgIGRhdGFzZXRJbmRleFxuICAgICAgfSkpKTtcbiAgICAgIGlmIChzdHlsZUNoYW5nZWQoc3R5bGUsIHByZXZTdHlsZSkpIHtcbiAgICAgICAgYWRkU3R5bGUoc3RhcnQsIGkgLSAxLCBzZWdtZW50Lmxvb3AsIHByZXZTdHlsZSk7XG4gICAgICB9XG4gICAgICBwcmV2ID0gcHQ7XG4gICAgICBwcmV2U3R5bGUgPSBzdHlsZTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0IDwgaSAtIDEpIHtcbiAgICAgIGFkZFN0eWxlKHN0YXJ0LCBpIC0gMSwgc2VnbWVudC5sb29wLCBwcmV2U3R5bGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHJlYWRTdHlsZShvcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcbiAgICBib3JkZXJDYXBTdHlsZTogb3B0aW9ucy5ib3JkZXJDYXBTdHlsZSxcbiAgICBib3JkZXJEYXNoOiBvcHRpb25zLmJvcmRlckRhc2gsXG4gICAgYm9yZGVyRGFzaE9mZnNldDogb3B0aW9ucy5ib3JkZXJEYXNoT2Zmc2V0LFxuICAgIGJvcmRlckpvaW5TdHlsZTogb3B0aW9ucy5ib3JkZXJKb2luU3R5bGUsXG4gICAgYm9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG4gICAgYm9yZGVyQ29sb3I6IG9wdGlvbnMuYm9yZGVyQ29sb3JcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVDaGFuZ2VkKHN0eWxlLCBwcmV2U3R5bGUpIHtcbiAgaWYgKCFwcmV2U3R5bGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgY2FjaGUgPSBbXTtcbiAgY29uc3QgcmVwbGFjZXIgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgaWYgKCFpc1BhdHRlcm5PckdyYWRpZW50KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoIWNhY2hlLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgICAgY2FjaGUucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZS5pbmRleE9mKHZhbHVlKTtcbiAgfTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0eWxlLCByZXBsYWNlcikgIT09IEpTT04uc3RyaW5naWZ5KHByZXZTdHlsZSwgcmVwbGFjZXIpO1xufVxuIiwgImltcG9ydCB7cmVxdWVzdEFuaW1GcmFtZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmV4dHJhcy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vY29yZS5hbmltYXRpb24uanMnKS5kZWZhdWx0IH0gQW5pbWF0aW9uXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqL1xuXG4vKipcbiAqIFBsZWFzZSB1c2UgdGhlIG1vZHVsZSdzIGRlZmF1bHQgZXhwb3J0IHdoaWNoIHByb3ZpZGVzIGEgc2luZ2xldG9uIGluc3RhbmNlXG4gKiBOb3RlOiBjbGFzcyBpcyBleHBvcnQgZm9yIHR5cGVkb2NcbiAqL1xuZXhwb3J0IGNsYXNzIEFuaW1hdG9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fcmVxdWVzdCA9IG51bGw7XG4gICAgdGhpcy5fY2hhcnRzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9sYXN0RGF0ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX25vdGlmeShjaGFydCwgYW5pbXMsIGRhdGUsIHR5cGUpIHtcbiAgICBjb25zdCBjYWxsYmFja3MgPSBhbmltcy5saXN0ZW5lcnNbdHlwZV07XG4gICAgY29uc3QgbnVtU3RlcHMgPSBhbmltcy5kdXJhdGlvbjtcblxuICAgIGNhbGxiYWNrcy5mb3JFYWNoKGZuID0+IGZuKHtcbiAgICAgIGNoYXJ0LFxuICAgICAgaW5pdGlhbDogYW5pbXMuaW5pdGlhbCxcbiAgICAgIG51bVN0ZXBzLFxuICAgICAgY3VycmVudFN0ZXA6IE1hdGgubWluKGRhdGUgLSBhbmltcy5zdGFydCwgbnVtU3RlcHMpXG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVmcmVzaCgpIHtcbiAgICBpZiAodGhpcy5fcmVxdWVzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcblxuICAgIHRoaXMuX3JlcXVlc3QgPSByZXF1ZXN0QW5pbUZyYW1lLmNhbGwod2luZG93LCAoKSA9PiB7XG4gICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgIHRoaXMuX3JlcXVlc3QgPSBudWxsO1xuXG4gICAgICBpZiAodGhpcy5fcnVubmluZykge1xuICAgICAgICB0aGlzLl9yZWZyZXNoKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGUoZGF0ZSA9IERhdGUubm93KCkpIHtcbiAgICBsZXQgcmVtYWluaW5nID0gMDtcblxuICAgIHRoaXMuX2NoYXJ0cy5mb3JFYWNoKChhbmltcywgY2hhcnQpID0+IHtcbiAgICAgIGlmICghYW5pbXMucnVubmluZyB8fCAhYW5pbXMuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGl0ZW1zID0gYW5pbXMuaXRlbXM7XG4gICAgICBsZXQgaSA9IGl0ZW1zLmxlbmd0aCAtIDE7XG4gICAgICBsZXQgZHJhdyA9IGZhbHNlO1xuICAgICAgbGV0IGl0ZW07XG5cbiAgICAgIGZvciAoOyBpID49IDA7IC0taSkge1xuICAgICAgICBpdGVtID0gaXRlbXNbaV07XG5cbiAgICAgICAgaWYgKGl0ZW0uX2FjdGl2ZSkge1xuICAgICAgICAgIGlmIChpdGVtLl90b3RhbCA+IGFuaW1zLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgYW5pbWF0aW9uIGhhcyBiZWVuIHVwZGF0ZWQgYW5kIGl0cyBkdXJhdGlvbiBwcm9sb25nZWQsXG4gICAgICAgICAgICAvLyB1cGRhdGUgdG8gdG90YWwgZHVyYXRpb24gb2YgY3VycmVudCBhbmltYXRpb25zIHJ1biAoZm9yIHByb2dyZXNzIGV2ZW50KVxuICAgICAgICAgICAgYW5pbXMuZHVyYXRpb24gPSBpdGVtLl90b3RhbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXRlbS50aWNrKGRhdGUpO1xuICAgICAgICAgIGRyYXcgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlbW92ZSB0aGUgaXRlbSBieSByZXBsYWNpbmcgaXQgd2l0aCBsYXN0IGl0ZW0gYW5kIHJlbW92aW5nIHRoZSBsYXN0XG4gICAgICAgICAgLy8gQSBsb3QgZmFzdGVyIHRoYW4gc3BsaWNlLlxuICAgICAgICAgIGl0ZW1zW2ldID0gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaXRlbXMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGRyYXcpIHtcbiAgICAgICAgY2hhcnQuZHJhdygpO1xuICAgICAgICB0aGlzLl9ub3RpZnkoY2hhcnQsIGFuaW1zLCBkYXRlLCAncHJvZ3Jlc3MnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgYW5pbXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9ub3RpZnkoY2hhcnQsIGFuaW1zLCBkYXRlLCAnY29tcGxldGUnKTtcbiAgICAgICAgYW5pbXMuaW5pdGlhbCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZW1haW5pbmcgKz0gaXRlbXMubGVuZ3RoO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fbGFzdERhdGUgPSBkYXRlO1xuXG4gICAgaWYgKHJlbWFpbmluZyA9PT0gMCkge1xuICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldEFuaW1zKGNoYXJ0KSB7XG4gICAgY29uc3QgY2hhcnRzID0gdGhpcy5fY2hhcnRzO1xuICAgIGxldCBhbmltcyA9IGNoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMpIHtcbiAgICAgIGFuaW1zID0ge1xuICAgICAgICBydW5uaW5nOiBmYWxzZSxcbiAgICAgICAgaW5pdGlhbDogdHJ1ZSxcbiAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICAgICBjb21wbGV0ZTogW10sXG4gICAgICAgICAgcHJvZ3Jlc3M6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjaGFydHMuc2V0KGNoYXJ0LCBhbmltcyk7XG4gICAgfVxuICAgIHJldHVybiBhbmltcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgLSBldmVudCBuYW1lXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gY2FsbGJhY2tcblx0ICovXG4gIGxpc3RlbihjaGFydCwgZXZlbnQsIGNiKSB7XG4gICAgdGhpcy5fZ2V0QW5pbXMoY2hhcnQpLmxpc3RlbmVyc1tldmVudF0ucHVzaChjYik7XG4gIH1cblxuICAvKipcblx0ICogQWRkIGFuaW1hdGlvbnNcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICogQHBhcmFtIHtBbmltYXRpb25bXX0gaXRlbXMgLSBhbmltYXRpb25zXG5cdCAqL1xuICBhZGQoY2hhcnQsIGl0ZW1zKSB7XG4gICAgaWYgKCFpdGVtcyB8fCAhaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2dldEFuaW1zKGNoYXJ0KS5pdGVtcy5wdXNoKC4uLml0ZW1zKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBDb3VudHMgbnVtYmVyIG9mIGFjdGl2ZSBhbmltYXRpb25zIGZvciB0aGUgY2hhcnRcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICovXG4gIGhhcyhjaGFydCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRBbmltcyhjaGFydCkuaXRlbXMubGVuZ3RoID4gMDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBTdGFydCBhbmltYXRpbmcgKGFsbCBjaGFydHMpXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqL1xuICBzdGFydChjaGFydCkge1xuICAgIGNvbnN0IGFuaW1zID0gdGhpcy5fY2hhcnRzLmdldChjaGFydCk7XG4gICAgaWYgKCFhbmltcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhbmltcy5ydW5uaW5nID0gdHJ1ZTtcbiAgICBhbmltcy5zdGFydCA9IERhdGUubm93KCk7XG4gICAgYW5pbXMuZHVyYXRpb24gPSBhbmltcy5pdGVtcy5yZWR1Y2UoKGFjYywgY3VyKSA9PiBNYXRoLm1heChhY2MsIGN1ci5fZHVyYXRpb24pLCAwKTtcbiAgICB0aGlzLl9yZWZyZXNoKCk7XG4gIH1cblxuICBydW5uaW5nKGNoYXJ0KSB7XG4gICAgaWYgKCF0aGlzLl9ydW5uaW5nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGFuaW1zID0gdGhpcy5fY2hhcnRzLmdldChjaGFydCk7XG4gICAgaWYgKCFhbmltcyB8fCAhYW5pbXMucnVubmluZyB8fCAhYW5pbXMuaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG5cdCAqIFN0b3AgYWxsIGFuaW1hdGlvbnMgZm9yIHRoZSBjaGFydFxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKi9cbiAgc3RvcChjaGFydCkge1xuICAgIGNvbnN0IGFuaW1zID0gdGhpcy5fY2hhcnRzLmdldChjaGFydCk7XG4gICAgaWYgKCFhbmltcyB8fCAhYW5pbXMuaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGl0ZW1zID0gYW5pbXMuaXRlbXM7XG4gICAgbGV0IGkgPSBpdGVtcy5sZW5ndGggLSAxO1xuXG4gICAgZm9yICg7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBpdGVtc1tpXS5jYW5jZWwoKTtcbiAgICB9XG4gICAgYW5pbXMuaXRlbXMgPSBbXTtcbiAgICB0aGlzLl9ub3RpZnkoY2hhcnQsIGFuaW1zLCBEYXRlLm5vdygpLCAnY29tcGxldGUnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZW1vdmUgY2hhcnQgZnJvbSBBbmltYXRvclxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKi9cbiAgcmVtb3ZlKGNoYXJ0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYXJ0cy5kZWxldGUoY2hhcnQpO1xuICB9XG59XG5cbi8vIHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGRlZmF1bHQgLyogI19fUFVSRV9fICovIG5ldyBBbmltYXRvcigpO1xuIiwgImltcG9ydCBlZmZlY3RzIGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5lYXNpbmcuanMnO1xuaW1wb3J0IHtyZXNvbHZlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5pbXBvcnQge2NvbG9yIGFzIGhlbHBlcnNDb2xvcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbG9yLmpzJztcblxuY29uc3QgdHJhbnNwYXJlbnQgPSAndHJhbnNwYXJlbnQnO1xuY29uc3QgaW50ZXJwb2xhdG9ycyA9IHtcbiAgYm9vbGVhbihmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgcmV0dXJuIGZhY3RvciA+IDAuNSA/IHRvIDogZnJvbTtcbiAgfSxcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b1xuICAgKiBAcGFyYW0ge251bWJlcn0gZmFjdG9yXG4gICAqL1xuICBjb2xvcihmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgY29uc3QgYzAgPSBoZWxwZXJzQ29sb3IoZnJvbSB8fCB0cmFuc3BhcmVudCk7XG4gICAgY29uc3QgYzEgPSBjMC52YWxpZCAmJiBoZWxwZXJzQ29sb3IodG8gfHwgdHJhbnNwYXJlbnQpO1xuICAgIHJldHVybiBjMSAmJiBjMS52YWxpZFxuICAgICAgPyBjMS5taXgoYzAsIGZhY3RvcikuaGV4U3RyaW5nKClcbiAgICAgIDogdG87XG4gIH0sXG4gIG51bWJlcihmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgcmV0dXJuIGZyb20gKyAodG8gLSBmcm9tKSAqIGZhY3RvcjtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbWF0aW9uIHtcbiAgY29uc3RydWN0b3IoY2ZnLCB0YXJnZXQsIHByb3AsIHRvKSB7XG4gICAgY29uc3QgY3VycmVudFZhbHVlID0gdGFyZ2V0W3Byb3BdO1xuXG4gICAgdG8gPSByZXNvbHZlKFtjZmcudG8sIHRvLCBjdXJyZW50VmFsdWUsIGNmZy5mcm9tXSk7XG4gICAgY29uc3QgZnJvbSA9IHJlc29sdmUoW2NmZy5mcm9tLCBjdXJyZW50VmFsdWUsIHRvXSk7XG5cbiAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuX2ZuID0gY2ZnLmZuIHx8IGludGVycG9sYXRvcnNbY2ZnLnR5cGUgfHwgdHlwZW9mIGZyb21dO1xuICAgIHRoaXMuX2Vhc2luZyA9IGVmZmVjdHNbY2ZnLmVhc2luZ10gfHwgZWZmZWN0cy5saW5lYXI7XG4gICAgdGhpcy5fc3RhcnQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgKyAoY2ZnLmRlbGF5IHx8IDApKTtcbiAgICB0aGlzLl9kdXJhdGlvbiA9IHRoaXMuX3RvdGFsID0gTWF0aC5mbG9vcihjZmcuZHVyYXRpb24pO1xuICAgIHRoaXMuX2xvb3AgPSAhIWNmZy5sb29wO1xuICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLl9wcm9wID0gcHJvcDtcbiAgICB0aGlzLl9mcm9tID0gZnJvbTtcbiAgICB0aGlzLl90byA9IHRvO1xuICAgIHRoaXMuX3Byb21pc2VzID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gIH1cblxuICB1cGRhdGUoY2ZnLCB0bywgZGF0ZSkge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMuX25vdGlmeShmYWxzZSk7XG5cbiAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRoaXMuX3RhcmdldFt0aGlzLl9wcm9wXTtcbiAgICAgIGNvbnN0IGVsYXBzZWQgPSBkYXRlIC0gdGhpcy5fc3RhcnQ7XG4gICAgICBjb25zdCByZW1haW4gPSB0aGlzLl9kdXJhdGlvbiAtIGVsYXBzZWQ7XG4gICAgICB0aGlzLl9zdGFydCA9IGRhdGU7XG4gICAgICB0aGlzLl9kdXJhdGlvbiA9IE1hdGguZmxvb3IoTWF0aC5tYXgocmVtYWluLCBjZmcuZHVyYXRpb24pKTtcbiAgICAgIHRoaXMuX3RvdGFsICs9IGVsYXBzZWQ7XG4gICAgICB0aGlzLl9sb29wID0gISFjZmcubG9vcDtcbiAgICAgIHRoaXMuX3RvID0gcmVzb2x2ZShbY2ZnLnRvLCB0bywgY3VycmVudFZhbHVlLCBjZmcuZnJvbV0pO1xuICAgICAgdGhpcy5fZnJvbSA9IHJlc29sdmUoW2NmZy5mcm9tLCBjdXJyZW50VmFsdWUsIHRvXSk7XG4gICAgfVxuICB9XG5cbiAgY2FuY2VsKCkge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIC8vIHVwZGF0ZSBjdXJyZW50IGV2YWx1YXRlZCB2YWx1ZSwgZm9yIHNtb290aGVyIGFuaW1hdGlvbnNcbiAgICAgIHRoaXMudGljayhEYXRlLm5vdygpKTtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5fbm90aWZ5KGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICB0aWNrKGRhdGUpIHtcbiAgICBjb25zdCBlbGFwc2VkID0gZGF0ZSAtIHRoaXMuX3N0YXJ0O1xuICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb247XG4gICAgY29uc3QgcHJvcCA9IHRoaXMuX3Byb3A7XG4gICAgY29uc3QgZnJvbSA9IHRoaXMuX2Zyb207XG4gICAgY29uc3QgbG9vcCA9IHRoaXMuX2xvb3A7XG4gICAgY29uc3QgdG8gPSB0aGlzLl90bztcbiAgICBsZXQgZmFjdG9yO1xuXG4gICAgdGhpcy5fYWN0aXZlID0gZnJvbSAhPT0gdG8gJiYgKGxvb3AgfHwgKGVsYXBzZWQgPCBkdXJhdGlvbikpO1xuXG4gICAgaWYgKCF0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMuX3RhcmdldFtwcm9wXSA9IHRvO1xuICAgICAgdGhpcy5fbm90aWZ5KHRydWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlbGFwc2VkIDwgMCkge1xuICAgICAgdGhpcy5fdGFyZ2V0W3Byb3BdID0gZnJvbTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmYWN0b3IgPSAoZWxhcHNlZCAvIGR1cmF0aW9uKSAlIDI7XG4gICAgZmFjdG9yID0gbG9vcCAmJiBmYWN0b3IgPiAxID8gMiAtIGZhY3RvciA6IGZhY3RvcjtcbiAgICBmYWN0b3IgPSB0aGlzLl9lYXNpbmcoTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgZmFjdG9yKSkpO1xuXG4gICAgdGhpcy5fdGFyZ2V0W3Byb3BdID0gdGhpcy5fZm4oZnJvbSwgdG8sIGZhY3Rvcik7XG4gIH1cblxuICB3YWl0KCkge1xuICAgIGNvbnN0IHByb21pc2VzID0gdGhpcy5fcHJvbWlzZXMgfHwgKHRoaXMuX3Byb21pc2VzID0gW10pO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgIHByb21pc2VzLnB1c2goe3JlcywgcmVqfSk7XG4gICAgfSk7XG4gIH1cblxuICBfbm90aWZ5KHJlc29sdmVkKSB7XG4gICAgY29uc3QgbWV0aG9kID0gcmVzb2x2ZWQgPyAncmVzJyA6ICdyZWonO1xuICAgIGNvbnN0IHByb21pc2VzID0gdGhpcy5fcHJvbWlzZXMgfHwgW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9taXNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgcHJvbWlzZXNbaV1bbWV0aG9kXSgpO1xuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCBhbmltYXRvciBmcm9tICcuL2NvcmUuYW5pbWF0b3IuanMnO1xuaW1wb3J0IEFuaW1hdGlvbiBmcm9tICcuL2NvcmUuYW5pbWF0aW9uLmpzJztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICcuL2NvcmUuZGVmYXVsdHMuanMnO1xuaW1wb3J0IHtpc0FycmF5LCBpc09iamVjdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmltYXRpb25zIHtcbiAgY29uc3RydWN0b3IoY2hhcnQsIGNvbmZpZykge1xuICAgIHRoaXMuX2NoYXJ0ID0gY2hhcnQ7XG4gICAgdGhpcy5fcHJvcGVydGllcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmNvbmZpZ3VyZShjb25maWcpO1xuICB9XG5cbiAgY29uZmlndXJlKGNvbmZpZykge1xuICAgIGlmICghaXNPYmplY3QoY29uZmlnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBPYmplY3Qua2V5cyhkZWZhdWx0cy5hbmltYXRpb24pO1xuICAgIGNvbnN0IGFuaW1hdGVkUHJvcHMgPSB0aGlzLl9wcm9wZXJ0aWVzO1xuXG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY29uZmlnKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBjZmcgPSBjb25maWdba2V5XTtcbiAgICAgIGlmICghaXNPYmplY3QoY2ZnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByZXNvbHZlZCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgYW5pbWF0aW9uT3B0aW9ucykge1xuICAgICAgICByZXNvbHZlZFtvcHRpb25dID0gY2ZnW29wdGlvbl07XG4gICAgICB9XG5cbiAgICAgIChpc0FycmF5KGNmZy5wcm9wZXJ0aWVzKSAmJiBjZmcucHJvcGVydGllcyB8fCBba2V5XSkuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICBpZiAocHJvcCA9PT0ga2V5IHx8ICFhbmltYXRlZFByb3BzLmhhcyhwcm9wKSkge1xuICAgICAgICAgIGFuaW1hdGVkUHJvcHMuc2V0KHByb3AsIHJlc29sdmVkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcblx0ICogVXRpbGl0eSB0byBoYW5kbGUgYW5pbWF0aW9uIG9mIGBvcHRpb25zYC5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9hbmltYXRlT3B0aW9ucyh0YXJnZXQsIHZhbHVlcykge1xuICAgIGNvbnN0IG5ld09wdGlvbnMgPSB2YWx1ZXMub3B0aW9ucztcbiAgICBjb25zdCBvcHRpb25zID0gcmVzb2x2ZVRhcmdldE9wdGlvbnModGFyZ2V0LCBuZXdPcHRpb25zKTtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBhbmltYXRpb25zID0gdGhpcy5fY3JlYXRlQW5pbWF0aW9ucyhvcHRpb25zLCBuZXdPcHRpb25zKTtcbiAgICBpZiAobmV3T3B0aW9ucy4kc2hhcmVkKSB7XG4gICAgICAvLyBHb2luZyB0byBzaGFyZWQgb3B0aW9uczpcbiAgICAgIC8vIEFmdGVyIGFsbCBhbmltYXRpb25zIGFyZSBkb25lLCBhc3NpZ24gdGhlIHNoYXJlZCBvcHRpb25zIG9iamVjdCB0byB0aGUgZWxlbWVudFxuICAgICAgLy8gU28gYW55IG5ldyB1cGRhdGVzIHRvIHRoZSBzaGFyZWQgb3B0aW9ucyBhcmUgb2JzZXJ2ZWRcbiAgICAgIGF3YWl0QWxsKHRhcmdldC5vcHRpb25zLiRhbmltYXRpb25zLCBuZXdPcHRpb25zKS50aGVuKCgpID0+IHtcbiAgICAgICAgdGFyZ2V0Lm9wdGlvbnMgPSBuZXdPcHRpb25zO1xuICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAvLyByZWplY3RlZCwgbm9vcFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jcmVhdGVBbmltYXRpb25zKHRhcmdldCwgdmFsdWVzKSB7XG4gICAgY29uc3QgYW5pbWF0ZWRQcm9wcyA9IHRoaXMuX3Byb3BlcnRpZXM7XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IFtdO1xuICAgIGNvbnN0IHJ1bm5pbmcgPSB0YXJnZXQuJGFuaW1hdGlvbnMgfHwgKHRhcmdldC4kYW5pbWF0aW9ucyA9IHt9KTtcbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5rZXlzKHZhbHVlcyk7XG4gICAgY29uc3QgZGF0ZSA9IERhdGUubm93KCk7XG4gICAgbGV0IGk7XG5cbiAgICBmb3IgKGkgPSBwcm9wcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3QgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHByb3AuY2hhckF0KDApID09PSAnJCcpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wID09PSAnb3B0aW9ucycpIHtcbiAgICAgICAgYW5pbWF0aW9ucy5wdXNoKC4uLnRoaXMuX2FuaW1hdGVPcHRpb25zKHRhcmdldCwgdmFsdWVzKSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbcHJvcF07XG4gICAgICBsZXQgYW5pbWF0aW9uID0gcnVubmluZ1twcm9wXTtcbiAgICAgIGNvbnN0IGNmZyA9IGFuaW1hdGVkUHJvcHMuZ2V0KHByb3ApO1xuXG4gICAgICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICAgIGlmIChjZmcgJiYgYW5pbWF0aW9uLmFjdGl2ZSgpKSB7XG4gICAgICAgICAgLy8gVGhlcmUgaXMgYW4gZXhpc3RpbmcgYWN0aXZlIGFuaW1hdGlvbiwgbGV0J3MgdXBkYXRlIHRoYXRcbiAgICAgICAgICBhbmltYXRpb24udXBkYXRlKGNmZywgdmFsdWUsIGRhdGUpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFuaW1hdGlvbi5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFjZmcgfHwgIWNmZy5kdXJhdGlvbikge1xuICAgICAgICAvLyBub3QgYW5pbWF0ZWQsIHNldCBkaXJlY3RseSB0byBuZXcgdmFsdWVcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBydW5uaW5nW3Byb3BdID0gYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbihjZmcsIHRhcmdldCwgcHJvcCwgdmFsdWUpO1xuICAgICAgYW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBhbmltYXRpb25zO1xuICB9XG5cblxuICAvKipcblx0ICogVXBkYXRlIGB0YXJnZXRgIHByb3BlcnRpZXMgdG8gbmV3IHZhbHVlcywgdXNpbmcgY29uZmlndXJlZCBhbmltYXRpb25zXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgLSBvYmplY3QgdG8gdXBkYXRlXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgLSBuZXcgdGFyZ2V0IHByb3BlcnRpZXNcblx0ICogQHJldHVybnMge2Jvb2xlYW58dW5kZWZpbmVkfSAtIGB0cnVlYCBpZiBhbmltYXRpb25zIHdlcmUgc3RhcnRlZFxuXHQgKiovXG4gIHVwZGF0ZSh0YXJnZXQsIHZhbHVlcykge1xuICAgIGlmICh0aGlzLl9wcm9wZXJ0aWVzLnNpemUgPT09IDApIHtcbiAgICAgIC8vIE5vdGhpbmcgaXMgYW5pbWF0ZWQsIGp1c3QgYXBwbHkgdGhlIG5ldyB2YWx1ZXMuXG4gICAgICBPYmplY3QuYXNzaWduKHRhcmdldCwgdmFsdWVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhbmltYXRpb25zID0gdGhpcy5fY3JlYXRlQW5pbWF0aW9ucyh0YXJnZXQsIHZhbHVlcyk7XG5cbiAgICBpZiAoYW5pbWF0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGFuaW1hdG9yLmFkZCh0aGlzLl9jaGFydCwgYW5pbWF0aW9ucyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXdhaXRBbGwoYW5pbWF0aW9ucywgcHJvcGVydGllcykge1xuICBjb25zdCBydW5uaW5nID0gW107XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYW5pbSA9IGFuaW1hdGlvbnNba2V5c1tpXV07XG4gICAgaWYgKGFuaW0gJiYgYW5pbS5hY3RpdmUoKSkge1xuICAgICAgcnVubmluZy5wdXNoKGFuaW0ud2FpdCgpKTtcbiAgICB9XG4gIH1cbiAgLy8gQHRzLWlnbm9yZVxuICByZXR1cm4gUHJvbWlzZS5hbGwocnVubmluZyk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVUYXJnZXRPcHRpb25zKHRhcmdldCwgbmV3T3B0aW9ucykge1xuICBpZiAoIW5ld09wdGlvbnMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IG9wdGlvbnMgPSB0YXJnZXQub3B0aW9ucztcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgdGFyZ2V0Lm9wdGlvbnMgPSBuZXdPcHRpb25zO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAob3B0aW9ucy4kc2hhcmVkKSB7XG4gICAgLy8gR29pbmcgZnJvbSBzaGFyZWQgb3B0aW9ucyB0byBkaXN0aW5jdCBvbmU6XG4gICAgLy8gQ3JlYXRlIG5ldyBvcHRpb25zIG9iamVjdCBjb250YWluaW5nIHRoZSBvbGQgc2hhcmVkIHZhbHVlcyBhbmQgc3RhcnQgdXBkYXRpbmcgdGhhdC5cbiAgICB0YXJnZXQub3B0aW9ucyA9IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7JHNoYXJlZDogZmFsc2UsICRhbmltYXRpb25zOiB7fX0pO1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuIiwgImltcG9ydCBBbmltYXRpb25zIGZyb20gJy4vY29yZS5hbmltYXRpb25zLmpzJztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICcuL2NvcmUuZGVmYXVsdHMuanMnO1xuaW1wb3J0IHtpc0FycmF5LCBpc0Zpbml0ZSwgaXNPYmplY3QsIHZhbHVlT3JEZWZhdWx0LCByZXNvbHZlT2JqZWN0S2V5LCBkZWZpbmVkfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge2xpc3RlbkFycmF5RXZlbnRzLCB1bmxpc3RlbkFycmF5RXZlbnRzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29sbGVjdGlvbi5qcyc7XG5pbXBvcnQge2NyZWF0ZUNvbnRleHQsIHNpZ259IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vY29yZS5zY2FsZS5qcycpLmRlZmF1bHQgfSBTY2FsZVxuICovXG5cbmZ1bmN0aW9uIHNjYWxlQ2xpcChzY2FsZSwgYWxsb3dlZE92ZXJmbG93KSB7XG4gIGNvbnN0IG9wdHMgPSBzY2FsZSAmJiBzY2FsZS5vcHRpb25zIHx8IHt9O1xuICBjb25zdCByZXZlcnNlID0gb3B0cy5yZXZlcnNlO1xuICBjb25zdCBtaW4gPSBvcHRzLm1pbiA9PT0gdW5kZWZpbmVkID8gYWxsb3dlZE92ZXJmbG93IDogMDtcbiAgY29uc3QgbWF4ID0gb3B0cy5tYXggPT09IHVuZGVmaW5lZCA/IGFsbG93ZWRPdmVyZmxvdyA6IDA7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHJldmVyc2UgPyBtYXggOiBtaW4sXG4gICAgZW5kOiByZXZlcnNlID8gbWluIDogbWF4XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDbGlwKHhTY2FsZSwgeVNjYWxlLCBhbGxvd2VkT3ZlcmZsb3cpIHtcbiAgaWYgKGFsbG93ZWRPdmVyZmxvdyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgeCA9IHNjYWxlQ2xpcCh4U2NhbGUsIGFsbG93ZWRPdmVyZmxvdyk7XG4gIGNvbnN0IHkgPSBzY2FsZUNsaXAoeVNjYWxlLCBhbGxvd2VkT3ZlcmZsb3cpO1xuXG4gIHJldHVybiB7XG4gICAgdG9wOiB5LmVuZCxcbiAgICByaWdodDogeC5lbmQsXG4gICAgYm90dG9tOiB5LnN0YXJ0LFxuICAgIGxlZnQ6IHguc3RhcnRcbiAgfTtcbn1cblxuZnVuY3Rpb24gdG9DbGlwKHZhbHVlKSB7XG4gIGxldCB0LCByLCBiLCBsO1xuXG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB0ID0gdmFsdWUudG9wO1xuICAgIHIgPSB2YWx1ZS5yaWdodDtcbiAgICBiID0gdmFsdWUuYm90dG9tO1xuICAgIGwgPSB2YWx1ZS5sZWZ0O1xuICB9IGVsc2Uge1xuICAgIHQgPSByID0gYiA9IGwgPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9wOiB0LFxuICAgIHJpZ2h0OiByLFxuICAgIGJvdHRvbTogYixcbiAgICBsZWZ0OiBsLFxuICAgIGRpc2FibGVkOiB2YWx1ZSA9PT0gZmFsc2VcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0U29ydGVkRGF0YXNldEluZGljZXMoY2hhcnQsIGZpbHRlclZpc2libGUpIHtcbiAgY29uc3Qga2V5cyA9IFtdO1xuICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0Ll9nZXRTb3J0ZWREYXRhc2V0TWV0YXMoZmlsdGVyVmlzaWJsZSk7XG4gIGxldCBpLCBpbGVuO1xuXG4gIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBrZXlzLnB1c2gobWV0YXNldHNbaV0uaW5kZXgpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBhcHBseVN0YWNrKHN0YWNrLCB2YWx1ZSwgZHNJbmRleCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGtleXMgPSBzdGFjay5rZXlzO1xuICBjb25zdCBzaW5nbGVNb2RlID0gb3B0aW9ucy5tb2RlID09PSAnc2luZ2xlJztcbiAgbGV0IGksIGlsZW4sIGRhdGFzZXRJbmRleCwgb3RoZXJWYWx1ZTtcblxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBkYXRhc2V0SW5kZXggPSAra2V5c1tpXTtcbiAgICBpZiAoZGF0YXNldEluZGV4ID09PSBkc0luZGV4KSB7XG4gICAgICBpZiAob3B0aW9ucy5hbGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb3RoZXJWYWx1ZSA9IHN0YWNrLnZhbHVlc1tkYXRhc2V0SW5kZXhdO1xuICAgIGlmIChpc0Zpbml0ZShvdGhlclZhbHVlKSAmJiAoc2luZ2xlTW9kZSB8fCAodmFsdWUgPT09IDAgfHwgc2lnbih2YWx1ZSkgPT09IHNpZ24ob3RoZXJWYWx1ZSkpKSkge1xuICAgICAgdmFsdWUgKz0gb3RoZXJWYWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0T2JqZWN0RGF0YVRvQXJyYXkoZGF0YSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIGNvbnN0IGFkYXRhID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgbGV0IGksIGlsZW4sIGtleTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICBhZGF0YVtpXSA9IHtcbiAgICAgIHg6IGtleSxcbiAgICAgIHk6IGRhdGFba2V5XVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGFkYXRhO1xufVxuXG5mdW5jdGlvbiBpc1N0YWNrZWQoc2NhbGUsIG1ldGEpIHtcbiAgY29uc3Qgc3RhY2tlZCA9IHNjYWxlICYmIHNjYWxlLm9wdGlvbnMuc3RhY2tlZDtcbiAgcmV0dXJuIHN0YWNrZWQgfHwgKHN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBtZXRhLnN0YWNrICE9PSB1bmRlZmluZWQpO1xufVxuXG5mdW5jdGlvbiBnZXRTdGFja0tleShpbmRleFNjYWxlLCB2YWx1ZVNjYWxlLCBtZXRhKSB7XG4gIHJldHVybiBgJHtpbmRleFNjYWxlLmlkfS4ke3ZhbHVlU2NhbGUuaWR9LiR7bWV0YS5zdGFjayB8fCBtZXRhLnR5cGV9YDtcbn1cblxuZnVuY3Rpb24gZ2V0VXNlckJvdW5kcyhzY2FsZSkge1xuICBjb25zdCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gc2NhbGUuZ2V0VXNlckJvdW5kcygpO1xuICByZXR1cm4ge1xuICAgIG1pbjogbWluRGVmaW5lZCA/IG1pbiA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcbiAgICBtYXg6IG1heERlZmluZWQgPyBtYXggOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0T3JDcmVhdGVTdGFjayhzdGFja3MsIHN0YWNrS2V5LCBpbmRleFZhbHVlKSB7XG4gIGNvbnN0IHN1YlN0YWNrID0gc3RhY2tzW3N0YWNrS2V5XSB8fCAoc3RhY2tzW3N0YWNrS2V5XSA9IHt9KTtcbiAgcmV0dXJuIHN1YlN0YWNrW2luZGV4VmFsdWVdIHx8IChzdWJTdGFja1tpbmRleFZhbHVlXSA9IHt9KTtcbn1cblxuZnVuY3Rpb24gZ2V0TGFzdEluZGV4SW5TdGFjayhzdGFjaywgdlNjYWxlLCBwb3NpdGl2ZSwgdHlwZSkge1xuICBmb3IgKGNvbnN0IG1ldGEgb2YgdlNjYWxlLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHR5cGUpLnJldmVyc2UoKSkge1xuICAgIGNvbnN0IHZhbHVlID0gc3RhY2tbbWV0YS5pbmRleF07XG4gICAgaWYgKChwb3NpdGl2ZSAmJiB2YWx1ZSA+IDApIHx8ICghcG9zaXRpdmUgJiYgdmFsdWUgPCAwKSkge1xuICAgICAgcmV0dXJuIG1ldGEuaW5kZXg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0YWNrcyhjb250cm9sbGVyLCBwYXJzZWQpIHtcbiAgY29uc3Qge2NoYXJ0LCBfY2FjaGVkTWV0YTogbWV0YX0gPSBjb250cm9sbGVyO1xuICBjb25zdCBzdGFja3MgPSBjaGFydC5fc3RhY2tzIHx8IChjaGFydC5fc3RhY2tzID0ge30pOyAvLyBtYXAgc3RydWN0dXJlIGlzIHtzdGFja0tleToge2RhdGFzZXRJbmRleDogdmFsdWV9fVxuICBjb25zdCB7aVNjYWxlLCB2U2NhbGUsIGluZGV4OiBkYXRhc2V0SW5kZXh9ID0gbWV0YTtcbiAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgY29uc3Qga2V5ID0gZ2V0U3RhY2tLZXkoaVNjYWxlLCB2U2NhbGUsIG1ldGEpO1xuICBjb25zdCBpbGVuID0gcGFyc2VkLmxlbmd0aDtcbiAgbGV0IHN0YWNrO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY29uc3QgaXRlbSA9IHBhcnNlZFtpXTtcbiAgICBjb25zdCB7W2lBeGlzXTogaW5kZXgsIFt2QXhpc106IHZhbHVlfSA9IGl0ZW07XG4gICAgY29uc3QgaXRlbVN0YWNrcyA9IGl0ZW0uX3N0YWNrcyB8fCAoaXRlbS5fc3RhY2tzID0ge30pO1xuICAgIHN0YWNrID0gaXRlbVN0YWNrc1t2QXhpc10gPSBnZXRPckNyZWF0ZVN0YWNrKHN0YWNrcywga2V5LCBpbmRleCk7XG4gICAgc3RhY2tbZGF0YXNldEluZGV4XSA9IHZhbHVlO1xuXG4gICAgc3RhY2suX3RvcCA9IGdldExhc3RJbmRleEluU3RhY2soc3RhY2ssIHZTY2FsZSwgdHJ1ZSwgbWV0YS50eXBlKTtcbiAgICBzdGFjay5fYm90dG9tID0gZ2V0TGFzdEluZGV4SW5TdGFjayhzdGFjaywgdlNjYWxlLCBmYWxzZSwgbWV0YS50eXBlKTtcblxuICAgIGNvbnN0IHZpc3VhbFZhbHVlcyA9IHN0YWNrLl92aXN1YWxWYWx1ZXMgfHwgKHN0YWNrLl92aXN1YWxWYWx1ZXMgPSB7fSk7XG4gICAgdmlzdWFsVmFsdWVzW2RhdGFzZXRJbmRleF0gPSB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsIGF4aXMpIHtcbiAgY29uc3Qgc2NhbGVzID0gY2hhcnQuc2NhbGVzO1xuICByZXR1cm4gT2JqZWN0LmtleXMoc2NhbGVzKS5maWx0ZXIoa2V5ID0+IHNjYWxlc1trZXldLmF4aXMgPT09IGF4aXMpLnNoaWZ0KCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURhdGFzZXRDb250ZXh0KHBhcmVudCwgaW5kZXgpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LFxuICAgIHtcbiAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICBkYXRhc2V0OiB1bmRlZmluZWQsXG4gICAgICBkYXRhc2V0SW5kZXg6IGluZGV4LFxuICAgICAgaW5kZXgsXG4gICAgICBtb2RlOiAnZGVmYXVsdCcsXG4gICAgICB0eXBlOiAnZGF0YXNldCdcbiAgICB9XG4gICk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURhdGFDb250ZXh0KHBhcmVudCwgaW5kZXgsIGVsZW1lbnQpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgYWN0aXZlOiBmYWxzZSxcbiAgICBkYXRhSW5kZXg6IGluZGV4LFxuICAgIHBhcnNlZDogdW5kZWZpbmVkLFxuICAgIHJhdzogdW5kZWZpbmVkLFxuICAgIGVsZW1lbnQsXG4gICAgaW5kZXgsXG4gICAgbW9kZTogJ2RlZmF1bHQnLFxuICAgIHR5cGU6ICdkYXRhJ1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY2xlYXJTdGFja3MobWV0YSwgaXRlbXMpIHtcbiAgLy8gTm90IHVzaW5nIG1ldGEuaW5kZXggaGVyZSwgYmVjYXVzZSBpdCBtaWdodCBiZSBhbHJlYWR5IHVwZGF0ZWQgaWYgdGhlIGRhdGFzZXQgY2hhbmdlZCBsb2NhdGlvblxuICBjb25zdCBkYXRhc2V0SW5kZXggPSBtZXRhLmNvbnRyb2xsZXIuaW5kZXg7XG4gIGNvbnN0IGF4aXMgPSBtZXRhLnZTY2FsZSAmJiBtZXRhLnZTY2FsZS5heGlzO1xuICBpZiAoIWF4aXMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpdGVtcyA9IGl0ZW1zIHx8IG1ldGEuX3BhcnNlZDtcbiAgZm9yIChjb25zdCBwYXJzZWQgb2YgaXRlbXMpIHtcbiAgICBjb25zdCBzdGFja3MgPSBwYXJzZWQuX3N0YWNrcztcbiAgICBpZiAoIXN0YWNrcyB8fCBzdGFja3NbYXhpc10gPT09IHVuZGVmaW5lZCB8fCBzdGFja3NbYXhpc11bZGF0YXNldEluZGV4XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlbGV0ZSBzdGFja3NbYXhpc11bZGF0YXNldEluZGV4XTtcbiAgICBpZiAoc3RhY2tzW2F4aXNdLl92aXN1YWxWYWx1ZXMgIT09IHVuZGVmaW5lZCAmJiBzdGFja3NbYXhpc10uX3Zpc3VhbFZhbHVlc1tkYXRhc2V0SW5kZXhdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlbGV0ZSBzdGFja3NbYXhpc10uX3Zpc3VhbFZhbHVlc1tkYXRhc2V0SW5kZXhdO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBpc0RpcmVjdFVwZGF0ZU1vZGUgPSAobW9kZSkgPT4gbW9kZSA9PT0gJ3Jlc2V0JyB8fCBtb2RlID09PSAnbm9uZSc7XG5jb25zdCBjbG9uZUlmTm90U2hhcmVkID0gKGNhY2hlZCwgc2hhcmVkKSA9PiBzaGFyZWQgPyBjYWNoZWQgOiBPYmplY3QuYXNzaWduKHt9LCBjYWNoZWQpO1xuY29uc3QgY3JlYXRlU3RhY2sgPSAoY2FuU3RhY2ssIG1ldGEsIGNoYXJ0KSA9PiBjYW5TdGFjayAmJiAhbWV0YS5oaWRkZW4gJiYgbWV0YS5fc3RhY2tlZFxuICAmJiB7a2V5czogZ2V0U29ydGVkRGF0YXNldEluZGljZXMoY2hhcnQsIHRydWUpLCB2YWx1ZXM6IG51bGx9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7fTtcblxuICAvKipcbiAgICogRWxlbWVudCB0eXBlIHVzZWQgdG8gZ2VuZXJhdGUgYSBtZXRhIGRhdGFzZXQgKGUuZy4gQ2hhcnQuZWxlbWVudC5MaW5lRWxlbWVudCkuXG4gICAqL1xuICBzdGF0aWMgZGF0YXNldEVsZW1lbnRUeXBlID0gbnVsbDtcblxuICAvKipcbiAgICogRWxlbWVudCB0eXBlIHVzZWQgdG8gZ2VuZXJhdGUgYSBtZXRhIGRhdGEgKGUuZy4gQ2hhcnQuZWxlbWVudC5Qb2ludEVsZW1lbnQpLlxuICAgKi9cbiAgc3RhdGljIGRhdGFFbGVtZW50VHlwZSA9IG51bGw7XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhc2V0SW5kZXhcblx0ICovXG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcbiAgICB0aGlzLmNoYXJ0ID0gY2hhcnQ7XG4gICAgdGhpcy5fY3R4ID0gY2hhcnQuY3R4O1xuICAgIHRoaXMuaW5kZXggPSBkYXRhc2V0SW5kZXg7XG4gICAgdGhpcy5fY2FjaGVkRGF0YU9wdHMgPSB7fTtcbiAgICB0aGlzLl9jYWNoZWRNZXRhID0gdGhpcy5nZXRNZXRhKCk7XG4gICAgdGhpcy5fdHlwZSA9IHRoaXMuX2NhY2hlZE1ldGEudHlwZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtib29sZWFuIHwgb2JqZWN0fSAqL1xuICAgIHRoaXMuX3BhcnNpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9kYXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX29iamVjdERhdGEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc2hhcmVkT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kcmF3U3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZHJhd0NvdW50ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IGZhbHNlO1xuICAgIHRoaXMuc3VwcG9ydHNEZWNpbWF0aW9uID0gZmFsc2U7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zeW5jTGlzdCA9IFtdO1xuICAgIHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlID0gbmV3LnRhcmdldC5kYXRhc2V0RWxlbWVudFR5cGU7XG4gICAgdGhpcy5kYXRhRWxlbWVudFR5cGUgPSBuZXcudGFyZ2V0LmRhdGFFbGVtZW50VHlwZTtcblxuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICB9XG5cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLmNvbmZpZ3VyZSgpO1xuICAgIHRoaXMubGlua1NjYWxlcygpO1xuICAgIG1ldGEuX3N0YWNrZWQgPSBpc1N0YWNrZWQobWV0YS52U2NhbGUsIG1ldGEpO1xuICAgIHRoaXMuYWRkRWxlbWVudHMoKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZmlsbCAmJiAhdGhpcy5jaGFydC5pc1BsdWdpbkVuYWJsZWQoJ2ZpbGxlcicpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJUcmllZCB0byB1c2UgdGhlICdmaWxsJyBvcHRpb24gd2l0aG91dCB0aGUgJ0ZpbGxlcicgcGx1Z2luIGVuYWJsZWQuIFBsZWFzZSBpbXBvcnQgYW5kIHJlZ2lzdGVyIHRoZSAnRmlsbGVyJyBwbHVnaW4gYW5kIG1ha2Ugc3VyZSBpdCBpcyBub3QgZGlzYWJsZWQgaW4gdGhlIG9wdGlvbnNcIik7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlSW5kZXgoZGF0YXNldEluZGV4KSB7XG4gICAgaWYgKHRoaXMuaW5kZXggIT09IGRhdGFzZXRJbmRleCkge1xuICAgICAgY2xlYXJTdGFja3ModGhpcy5fY2FjaGVkTWV0YSk7XG4gICAgfVxuICAgIHRoaXMuaW5kZXggPSBkYXRhc2V0SW5kZXg7XG4gIH1cblxuICBsaW5rU2NhbGVzKCkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG5cbiAgICBjb25zdCBjaG9vc2VJZCA9IChheGlzLCB4LCB5LCByKSA9PiBheGlzID09PSAneCcgPyB4IDogYXhpcyA9PT0gJ3InID8gciA6IHk7XG5cbiAgICBjb25zdCB4aWQgPSBtZXRhLnhBeGlzSUQgPSB2YWx1ZU9yRGVmYXVsdChkYXRhc2V0LnhBeGlzSUQsIGdldEZpcnN0U2NhbGVJZChjaGFydCwgJ3gnKSk7XG4gICAgY29uc3QgeWlkID0gbWV0YS55QXhpc0lEID0gdmFsdWVPckRlZmF1bHQoZGF0YXNldC55QXhpc0lELCBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsICd5JykpO1xuICAgIGNvbnN0IHJpZCA9IG1ldGEuckF4aXNJRCA9IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQuckF4aXNJRCwgZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCAncicpKTtcbiAgICBjb25zdCBpbmRleEF4aXMgPSBtZXRhLmluZGV4QXhpcztcbiAgICBjb25zdCBpaWQgPSBtZXRhLmlBeGlzSUQgPSBjaG9vc2VJZChpbmRleEF4aXMsIHhpZCwgeWlkLCByaWQpO1xuICAgIGNvbnN0IHZpZCA9IG1ldGEudkF4aXNJRCA9IGNob29zZUlkKGluZGV4QXhpcywgeWlkLCB4aWQsIHJpZCk7XG4gICAgbWV0YS54U2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQoeGlkKTtcbiAgICBtZXRhLnlTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZCh5aWQpO1xuICAgIG1ldGEuclNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKHJpZCk7XG4gICAgbWV0YS5pU2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQoaWlkKTtcbiAgICBtZXRhLnZTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZCh2aWQpO1xuICB9XG5cbiAgZ2V0RGF0YXNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW3RoaXMuaW5kZXhdO1xuICB9XG5cbiAgZ2V0TWV0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YSh0aGlzLmluZGV4KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc2NhbGVJRFxuXHQgKiBAcmV0dXJuIHtTY2FsZX1cblx0ICovXG4gIGdldFNjYWxlRm9ySWQoc2NhbGVJRCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LnNjYWxlc1tzY2FsZUlEXTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldE90aGVyU2NhbGUoc2NhbGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICByZXR1cm4gc2NhbGUgPT09IG1ldGEuaVNjYWxlXG4gICAgICA/IG1ldGEudlNjYWxlXG4gICAgICA6IG1ldGEuaVNjYWxlO1xuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5fdXBkYXRlKCdyZXNldCcpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZGVzdHJveSgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBpZiAodGhpcy5fZGF0YSkge1xuICAgICAgdW5saXN0ZW5BcnJheUV2ZW50cyh0aGlzLl9kYXRhLCB0aGlzKTtcbiAgICB9XG4gICAgaWYgKG1ldGEuX3N0YWNrZWQpIHtcbiAgICAgIGNsZWFyU3RhY2tzKG1ldGEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2RhdGFDaGVjaygpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgY29uc3QgZGF0YSA9IGRhdGFzZXQuZGF0YSB8fCAoZGF0YXNldC5kYXRhID0gW10pO1xuICAgIGNvbnN0IF9kYXRhID0gdGhpcy5fZGF0YTtcblxuICAgIC8vIEluIG9yZGVyIHRvIGNvcnJlY3RseSBoYW5kbGUgZGF0YSBhZGRpdGlvbi9kZWxldGlvbiBhbmltYXRpb24gKGFuZCB0aHVzIHNpbXVsYXRlXG4gICAgLy8gcmVhbC10aW1lIGNoYXJ0cyksIHdlIG5lZWQgdG8gbW9uaXRvciB0aGVzZSBkYXRhIG1vZGlmaWNhdGlvbnMgYW5kIHN5bmNocm9uaXplXG4gICAgLy8gdGhlIGludGVybmFsIG1ldGFkYXRhIGFjY29yZGluZ2x5LlxuXG4gICAgaWYgKGlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICB0aGlzLl9kYXRhID0gY29udmVydE9iamVjdERhdGFUb0FycmF5KGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoX2RhdGEgIT09IGRhdGEpIHtcbiAgICAgIGlmIChfZGF0YSkge1xuICAgICAgICAvLyBUaGlzIGNhc2UgaGFwcGVucyB3aGVuIHRoZSB1c2VyIHJlcGxhY2VkIHRoZSBkYXRhIGFycmF5IGluc3RhbmNlLlxuICAgICAgICB1bmxpc3RlbkFycmF5RXZlbnRzKF9kYXRhLCB0aGlzKTtcbiAgICAgICAgLy8gRGlzY2FyZCBvbGQgcGFyc2VkIGRhdGEgYW5kIHN0YWNrc1xuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgICAgY2xlYXJTdGFja3MobWV0YSk7XG4gICAgICAgIG1ldGEuX3BhcnNlZCA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShkYXRhKSkge1xuICAgICAgICBsaXN0ZW5BcnJheUV2ZW50cyhkYXRhLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XG4gICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICB9XG4gIH1cblxuICBhZGRFbGVtZW50cygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcblxuICAgIHRoaXMuX2RhdGFDaGVjaygpO1xuXG4gICAgaWYgKHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlKSB7XG4gICAgICBtZXRhLmRhdGFzZXQgPSBuZXcgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUoKTtcbiAgICB9XG4gIH1cblxuICBidWlsZE9yVXBkYXRlRWxlbWVudHMocmVzZXROZXdFbGVtZW50cykge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcbiAgICBsZXQgc3RhY2tDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICB0aGlzLl9kYXRhQ2hlY2soKTtcblxuICAgIC8vIG1ha2Ugc3VyZSBjYWNoZWQgX3N0YWNrZWQgc3RhdHVzIGlzIGN1cnJlbnRcbiAgICBjb25zdCBvbGRTdGFja2VkID0gbWV0YS5fc3RhY2tlZDtcbiAgICBtZXRhLl9zdGFja2VkID0gaXNTdGFja2VkKG1ldGEudlNjYWxlLCBtZXRhKTtcblxuICAgIC8vIGRldGVjdCBjaGFuZ2UgaW4gc3RhY2sgb3B0aW9uXG4gICAgaWYgKG1ldGEuc3RhY2sgIT09IGRhdGFzZXQuc3RhY2spIHtcbiAgICAgIHN0YWNrQ2hhbmdlZCA9IHRydWU7XG4gICAgICAvLyByZW1vdmUgdmFsdWVzIGZyb20gb2xkIHN0YWNrXG4gICAgICBjbGVhclN0YWNrcyhtZXRhKTtcbiAgICAgIG1ldGEuc3RhY2sgPSBkYXRhc2V0LnN0YWNrO1xuICAgIH1cblxuICAgIC8vIFJlLXN5bmMgbWV0YSBkYXRhIGluIGNhc2UgdGhlIHVzZXIgcmVwbGFjZWQgdGhlIGRhdGEgYXJyYXkgb3IgaWYgd2UgbWlzc2VkXG4gICAgLy8gYW55IHVwZGF0ZXMgYW5kIHNvIG1ha2Ugc3VyZSB0aGF0IHdlIGhhbmRsZSBudW1iZXIgb2YgZGF0YXBvaW50cyBjaGFuZ2luZy5cbiAgICB0aGlzLl9yZXN5bmNFbGVtZW50cyhyZXNldE5ld0VsZW1lbnRzKTtcblxuICAgIC8vIGlmIHN0YWNrIGNoYW5nZWQsIHVwZGF0ZSBzdGFjayB2YWx1ZXMgZm9yIHRoZSB3aG9sZSBkYXRhc2V0XG4gICAgaWYgKHN0YWNrQ2hhbmdlZCB8fCBvbGRTdGFja2VkICE9PSBtZXRhLl9zdGFja2VkKSB7XG4gICAgICB1cGRhdGVTdGFja3ModGhpcywgbWV0YS5fcGFyc2VkKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogTWVyZ2VzIHVzZXItc3VwcGxpZWQgYW5kIGRlZmF1bHQgZGF0YXNldC1sZXZlbCBvcHRpb25zXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBjb25maWd1cmUoKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jaGFydC5jb25maWc7XG4gICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRTY29wZUtleXModGhpcy5fdHlwZSk7XG4gICAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3Blcyh0aGlzLmdldERhdGFzZXQoKSwgc2NvcGVLZXlzLCB0cnVlKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgdGhpcy5fcGFyc2luZyA9IHRoaXMub3B0aW9ucy5wYXJzaW5nO1xuICAgIHRoaXMuX2NhY2hlZERhdGFPcHRzID0ge307XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuXHQgKi9cbiAgcGFyc2Uoc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge19jYWNoZWRNZXRhOiBtZXRhLCBfZGF0YTogZGF0YX0gPSB0aGlzO1xuICAgIGNvbnN0IHtpU2NhbGUsIF9zdGFja2VkfSA9IG1ldGE7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcblxuICAgIGxldCBzb3J0ZWQgPSBzdGFydCA9PT0gMCAmJiBjb3VudCA9PT0gZGF0YS5sZW5ndGggPyB0cnVlIDogbWV0YS5fc29ydGVkO1xuICAgIGxldCBwcmV2ID0gc3RhcnQgPiAwICYmIG1ldGEuX3BhcnNlZFtzdGFydCAtIDFdO1xuICAgIGxldCBpLCBjdXIsIHBhcnNlZDtcblxuICAgIGlmICh0aGlzLl9wYXJzaW5nID09PSBmYWxzZSkge1xuICAgICAgbWV0YS5fcGFyc2VkID0gZGF0YTtcbiAgICAgIG1ldGEuX3NvcnRlZCA9IHRydWU7XG4gICAgICBwYXJzZWQgPSBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNBcnJheShkYXRhW3N0YXJ0XSkpIHtcbiAgICAgICAgcGFyc2VkID0gdGhpcy5wYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChkYXRhW3N0YXJ0XSkpIHtcbiAgICAgICAgcGFyc2VkID0gdGhpcy5wYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZCA9IHRoaXMucGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlzTm90SW5PcmRlckNvbXBhcmVkVG9QcmV2ID0gKCkgPT4gY3VyW2lBeGlzXSA9PT0gbnVsbCB8fCAocHJldiAmJiBjdXJbaUF4aXNdIDwgcHJldltpQXhpc10pO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgbWV0YS5fcGFyc2VkW2kgKyBzdGFydF0gPSBjdXIgPSBwYXJzZWRbaV07XG4gICAgICAgIGlmIChzb3J0ZWQpIHtcbiAgICAgICAgICBpZiAoaXNOb3RJbk9yZGVyQ29tcGFyZWRUb1ByZXYoKSkge1xuICAgICAgICAgICAgc29ydGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByZXYgPSBjdXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1ldGEuX3NvcnRlZCA9IHNvcnRlZDtcbiAgICB9XG5cbiAgICBpZiAoX3N0YWNrZWQpIHtcbiAgICAgIHVwZGF0ZVN0YWNrcyh0aGlzLCBwYXJzZWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBQYXJzZSBhcnJheSBvZiBwcmltaXRpdmUgdmFsdWVzXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBtZXRhIC0gZGF0YXNldCBtZXRhXG5cdCAqIEBwYXJhbSB7YXJyYXl9IGRhdGEgLSBkYXRhIGFycmF5LiBFeGFtcGxlIFsxLDMsNF1cblx0ICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gc3RhcnQgaW5kZXhcblx0ICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IC0gbnVtYmVyIG9mIGl0ZW1zIHRvIHBhcnNlXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IHBhcnNlZCBpdGVtIC0gaXRlbSBjb250YWluaW5nIGluZGV4IGFuZCBhIHBhcnNlZCB2YWx1ZVxuXHQgKiBmb3IgZWFjaCBzY2FsZSBpZC5cblx0ICogRXhhbXBsZToge3hTY2FsZTA6IDAsIHlTY2FsZTA6IDF9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgY29uc3QgbGFiZWxzID0gaVNjYWxlLmdldExhYmVscygpO1xuICAgIGNvbnN0IHNpbmdsZVNjYWxlID0gaVNjYWxlID09PSB2U2NhbGU7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXg7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgICAgcGFyc2VkW2ldID0ge1xuICAgICAgICBbaUF4aXNdOiBzaW5nbGVTY2FsZSB8fCBpU2NhbGUucGFyc2UobGFiZWxzW2luZGV4XSwgaW5kZXgpLFxuICAgICAgICBbdkF4aXNdOiB2U2NhbGUucGFyc2UoZGF0YVtpbmRleF0sIGluZGV4KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBQYXJzZSBhcnJheSBvZiBhcnJheXNcblx0ICogQHBhcmFtIHtvYmplY3R9IG1ldGEgLSBkYXRhc2V0IG1ldGFcblx0ICogQHBhcmFtIHthcnJheX0gZGF0YSAtIGRhdGEgYXJyYXkuIEV4YW1wbGUgW1sxLDJdLFszLDRdXVxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBzdGFydCBpbmRleFxuXHQgKiBAcGFyYW0ge251bWJlcn0gY291bnQgLSBudW1iZXIgb2YgaXRlbXMgdG8gcGFyc2Vcblx0ICogQHJldHVybnMge29iamVjdH0gcGFyc2VkIGl0ZW0gLSBpdGVtIGNvbnRhaW5pbmcgaW5kZXggYW5kIGEgcGFyc2VkIHZhbHVlXG5cdCAqIGZvciBlYWNoIHNjYWxlIGlkLlxuXHQgKiBFeGFtcGxlOiB7eDogMCwgeTogMX1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXgsIGl0ZW07XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgICAgaXRlbSA9IGRhdGFbaW5kZXhdO1xuICAgICAgcGFyc2VkW2ldID0ge1xuICAgICAgICB4OiB4U2NhbGUucGFyc2UoaXRlbVswXSwgaW5kZXgpLFxuICAgICAgICB5OiB5U2NhbGUucGFyc2UoaXRlbVsxXSwgaW5kZXgpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIFBhcnNlIGFycmF5IG9mIG9iamVjdHNcblx0ICogQHBhcmFtIHtvYmplY3R9IG1ldGEgLSBkYXRhc2V0IG1ldGFcblx0ICogQHBhcmFtIHthcnJheX0gZGF0YSAtIGRhdGEgYXJyYXkuIEV4YW1wbGUgW3t4OjEsIHk6NX0sIHt4OjIsIHk6MTB9XVxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBzdGFydCBpbmRleFxuXHQgKiBAcGFyYW0ge251bWJlcn0gY291bnQgLSBudW1iZXIgb2YgaXRlbXMgdG8gcGFyc2Vcblx0ICogQHJldHVybnMge29iamVjdH0gcGFyc2VkIGl0ZW0gLSBpdGVtIGNvbnRhaW5pbmcgaW5kZXggYW5kIGEgcGFyc2VkIHZhbHVlXG5cdCAqIGZvciBlYWNoIHNjYWxlIGlkLiBfY3VzdG9tIGlzIG9wdGlvbmFsXG5cdCAqIEV4YW1wbGU6IHt4U2NhbGUwOiAwLCB5U2NhbGUwOiAxLCBfY3VzdG9tOiB7cjogMTAsIGZvbzogJ2Jhcid9fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3Qge3hBeGlzS2V5ID0gJ3gnLCB5QXhpc0tleSA9ICd5J30gPSB0aGlzLl9wYXJzaW5nO1xuICAgIGNvbnN0IHBhcnNlZCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgbGV0IGksIGlsZW4sIGluZGV4LCBpdGVtO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpbmRleCA9IGkgKyBzdGFydDtcbiAgICAgIGl0ZW0gPSBkYXRhW2luZGV4XTtcbiAgICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgICAgeDogeFNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkoaXRlbSwgeEF4aXNLZXkpLCBpbmRleCksXG4gICAgICAgIHk6IHlTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KGl0ZW0sIHlBeGlzS2V5KSwgaW5kZXgpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldFBhcnNlZChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWRNZXRhLl9wYXJzZWRbaW5kZXhdO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldERhdGFFbGVtZW50KGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZE1ldGEuZGF0YVtpbmRleF07XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgYXBwbHlTdGFjayhzY2FsZSwgcGFyc2VkLCBtb2RlKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHZhbHVlID0gcGFyc2VkW3NjYWxlLmF4aXNdO1xuICAgIGNvbnN0IHN0YWNrID0ge1xuICAgICAga2V5czogZ2V0U29ydGVkRGF0YXNldEluZGljZXMoY2hhcnQsIHRydWUpLFxuICAgICAgdmFsdWVzOiBwYXJzZWQuX3N0YWNrc1tzY2FsZS5heGlzXS5fdmlzdWFsVmFsdWVzXG4gICAgfTtcbiAgICByZXR1cm4gYXBwbHlTdGFjayhzdGFjaywgdmFsdWUsIG1ldGEuaW5kZXgsIHttb2RlfSk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgdXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjaykge1xuICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gcGFyc2VkW3NjYWxlLmF4aXNdO1xuICAgIGxldCB2YWx1ZSA9IHBhcnNlZFZhbHVlID09PSBudWxsID8gTmFOIDogcGFyc2VkVmFsdWU7XG4gICAgY29uc3QgdmFsdWVzID0gc3RhY2sgJiYgcGFyc2VkLl9zdGFja3Nbc2NhbGUuYXhpc107XG4gICAgaWYgKHN0YWNrICYmIHZhbHVlcykge1xuICAgICAgc3RhY2sudmFsdWVzID0gdmFsdWVzO1xuICAgICAgdmFsdWUgPSBhcHBseVN0YWNrKHN0YWNrLCBwYXJzZWRWYWx1ZSwgdGhpcy5fY2FjaGVkTWV0YS5pbmRleCk7XG4gICAgfVxuICAgIHJhbmdlLm1pbiA9IE1hdGgubWluKHJhbmdlLm1pbiwgdmFsdWUpO1xuICAgIHJhbmdlLm1heCA9IE1hdGgubWF4KHJhbmdlLm1heCwgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldE1pbk1heChzY2FsZSwgY2FuU3RhY2spIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBfcGFyc2VkID0gbWV0YS5fcGFyc2VkO1xuICAgIGNvbnN0IHNvcnRlZCA9IG1ldGEuX3NvcnRlZCAmJiBzY2FsZSA9PT0gbWV0YS5pU2NhbGU7XG4gICAgY29uc3QgaWxlbiA9IF9wYXJzZWQubGVuZ3RoO1xuICAgIGNvbnN0IG90aGVyU2NhbGUgPSB0aGlzLl9nZXRPdGhlclNjYWxlKHNjYWxlKTtcbiAgICBjb25zdCBzdGFjayA9IGNyZWF0ZVN0YWNrKGNhblN0YWNrLCBtZXRhLCB0aGlzLmNoYXJ0KTtcbiAgICBjb25zdCByYW5nZSA9IHttaW46IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgbWF4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFl9O1xuICAgIGNvbnN0IHttaW46IG90aGVyTWluLCBtYXg6IG90aGVyTWF4fSA9IGdldFVzZXJCb3VuZHMob3RoZXJTY2FsZSk7XG4gICAgbGV0IGksIHBhcnNlZDtcblxuICAgIGZ1bmN0aW9uIF9za2lwKCkge1xuICAgICAgcGFyc2VkID0gX3BhcnNlZFtpXTtcbiAgICAgIGNvbnN0IG90aGVyVmFsdWUgPSBwYXJzZWRbb3RoZXJTY2FsZS5heGlzXTtcbiAgICAgIHJldHVybiAhaXNGaW5pdGUocGFyc2VkW3NjYWxlLmF4aXNdKSB8fCBvdGhlck1pbiA+IG90aGVyVmFsdWUgfHwgb3RoZXJNYXggPCBvdGhlclZhbHVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGlmIChfc2tpcCgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKTtcbiAgICAgIGlmIChzb3J0ZWQpIHtcbiAgICAgICAgLy8gaWYgdGhlIGRhdGEgaXMgc29ydGVkLCB3ZSBkb24ndCBuZWVkIHRvIGNoZWNrIGZ1cnRoZXIgZnJvbSB0aGlzIGVuZCBvZiBhcnJheVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNvcnRlZCkge1xuICAgICAgLy8gaW4gdGhlIHNvcnRlZCBjYXNlLCBmaW5kIGZpcnN0IG5vbi1za2lwcGVkIHZhbHVlIGZyb20gb3RoZXIgZW5kIG9mIGFycmF5XG4gICAgICBmb3IgKGkgPSBpbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaWYgKF9za2lwKCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9XG5cbiAgZ2V0QWxsUGFyc2VkVmFsdWVzKHNjYWxlKSB7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5fY2FjaGVkTWV0YS5fcGFyc2VkO1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCB2YWx1ZTtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBwYXJzZWQubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB2YWx1ZSA9IHBhcnNlZFtpXVtzY2FsZS5heGlzXTtcbiAgICAgIGlmIChpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge251bWJlcnxib29sZWFufVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGlTY2FsZSA9IG1ldGEuaVNjYWxlO1xuICAgIGNvbnN0IHZTY2FsZSA9IG1ldGEudlNjYWxlO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGlTY2FsZSA/ICcnICsgaVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW2lTY2FsZS5heGlzXSkgOiAnJyxcbiAgICAgIHZhbHVlOiB2U2NhbGUgPyAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pIDogJydcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLnVwZGF0ZShtb2RlIHx8ICdkZWZhdWx0Jyk7XG4gICAgbWV0YS5fY2xpcCA9IHRvQ2xpcCh2YWx1ZU9yRGVmYXVsdCh0aGlzLm9wdGlvbnMuY2xpcCwgZGVmYXVsdENsaXAobWV0YS54U2NhbGUsIG1ldGEueVNjYWxlLCB0aGlzLmdldE1heE92ZXJmbG93KCkpKSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IG1vZGVcblx0ICovXG4gIHVwZGF0ZShtb2RlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgZHJhdygpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLl9jdHg7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgIGNvbnN0IGFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgY29uc3QgYWN0aXZlID0gW107XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9kcmF3U3RhcnQgfHwgMDtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMuX2RyYXdDb3VudCB8fCAoZWxlbWVudHMubGVuZ3RoIC0gc3RhcnQpO1xuICAgIGNvbnN0IGRyYXdBY3RpdmVFbGVtZW50c09uVG9wID0gdGhpcy5vcHRpb25zLmRyYXdBY3RpdmVFbGVtZW50c09uVG9wO1xuICAgIGxldCBpO1xuXG4gICAgaWYgKG1ldGEuZGF0YXNldCkge1xuICAgICAgbWV0YS5kYXRhc2V0LmRyYXcoY3R4LCBhcmVhLCBzdGFydCwgY291bnQpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICBpZiAoZWxlbWVudC5oaWRkZW4pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudC5hY3RpdmUgJiYgZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3ApIHtcbiAgICAgICAgYWN0aXZlLnB1c2goZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LmRyYXcoY3R4LCBhcmVhKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgYWN0aXZlLmxlbmd0aDsgKytpKSB7XG4gICAgICBhY3RpdmVbaV0uZHJhdyhjdHgsIGFyZWEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIGEgc2V0IG9mIHByZWRlZmluZWQgc3R5bGUgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlcHJlc2VudCB0aGUgZGF0YXNldFxuXHQgKiBvciB0aGUgZGF0YSBpZiB0aGUgaW5kZXggaXMgc3BlY2lmaWVkXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIGRhdGEgaW5kZXhcblx0ICogQHBhcmFtIHtib29sZWFufSBbYWN0aXZlXSAtIHRydWUgaWYgaG92ZXJcblx0ICogQHJldHVybiB7b2JqZWN0fSBzdHlsZSBvYmplY3Rcblx0ICovXG4gIGdldFN0eWxlKGluZGV4LCBhY3RpdmUpIHtcbiAgICBjb25zdCBtb2RlID0gYWN0aXZlID8gJ2FjdGl2ZScgOiAnZGVmYXVsdCc7XG4gICAgcmV0dXJuIGluZGV4ID09PSB1bmRlZmluZWQgJiYgdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0XG4gICAgICA/IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKVxuICAgICAgOiB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXggfHwgMCwgbW9kZSk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0Q29udGV4dChpbmRleCwgYWN0aXZlLCBtb2RlKSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuICAgIGxldCBjb250ZXh0O1xuICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fY2FjaGVkTWV0YS5kYXRhLmxlbmd0aCkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YVtpbmRleF07XG4gICAgICBjb250ZXh0ID0gZWxlbWVudC4kY29udGV4dCB8fFxuICAgICAgICAoZWxlbWVudC4kY29udGV4dCA9IGNyZWF0ZURhdGFDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpLCBpbmRleCwgZWxlbWVudCkpO1xuICAgICAgY29udGV4dC5wYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgICBjb250ZXh0LnJhdyA9IGRhdGFzZXQuZGF0YVtpbmRleF07XG4gICAgICBjb250ZXh0LmluZGV4ID0gY29udGV4dC5kYXRhSW5kZXggPSBpbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dCA9IHRoaXMuJGNvbnRleHQgfHxcbiAgICAgICAgKHRoaXMuJGNvbnRleHQgPSBjcmVhdGVEYXRhc2V0Q29udGV4dCh0aGlzLmNoYXJ0LmdldENvbnRleHQoKSwgdGhpcy5pbmRleCkpO1xuICAgICAgY29udGV4dC5kYXRhc2V0ID0gZGF0YXNldDtcbiAgICAgIGNvbnRleHQuaW5kZXggPSBjb250ZXh0LmRhdGFzZXRJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgfVxuXG4gICAgY29udGV4dC5hY3RpdmUgPSAhIWFjdGl2ZTtcbiAgICBjb250ZXh0Lm1vZGUgPSBtb2RlO1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbbW9kZV1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVFbGVtZW50T3B0aW9ucyh0aGlzLmRhdGFzZXRFbGVtZW50VHlwZS5pZCwgbW9kZSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbbW9kZV1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlRWxlbWVudE9wdGlvbnModGhpcy5kYXRhRWxlbWVudFR5cGUuaWQsIG1vZGUsIGluZGV4KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3Jlc29sdmVFbGVtZW50T3B0aW9ucyhlbGVtZW50VHlwZSwgbW9kZSA9ICdkZWZhdWx0JywgaW5kZXgpIHtcbiAgICBjb25zdCBhY3RpdmUgPSBtb2RlID09PSAnYWN0aXZlJztcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2NhY2hlZERhdGFPcHRzO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gZWxlbWVudFR5cGUgKyAnLScgKyBtb2RlO1xuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICBjb25zdCBzaGFyaW5nID0gdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nICYmIGRlZmluZWQoaW5kZXgpO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjbG9uZUlmTm90U2hhcmVkKGNhY2hlZCwgc2hhcmluZyk7XG4gICAgfVxuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY2hhcnQuY29uZmlnO1xuICAgIGNvbnN0IHNjb3BlS2V5cyA9IGNvbmZpZy5kYXRhc2V0RWxlbWVudFNjb3BlS2V5cyh0aGlzLl90eXBlLCBlbGVtZW50VHlwZSk7XG4gICAgY29uc3QgcHJlZml4ZXMgPSBhY3RpdmUgPyBbYCR7ZWxlbWVudFR5cGV9SG92ZXJgLCAnaG92ZXInLCBlbGVtZW50VHlwZSwgJyddIDogW2VsZW1lbnRUeXBlLCAnJ107XG4gICAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3Blcyh0aGlzLmdldERhdGFzZXQoKSwgc2NvcGVLZXlzKTtcbiAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKGRlZmF1bHRzLmVsZW1lbnRzW2VsZW1lbnRUeXBlXSk7XG4gICAgLy8gY29udGV4dCBpcyBwcm92aWRlZCBhcyBhIGZ1bmN0aW9uLCBhbmQgaXMgY2FsbGVkIG9ubHkgaWYgbmVlZGVkLFxuICAgIC8vIHNvIHdlIGRvbid0IGNyZWF0ZSBhIGNvbnRleHQgZm9yIGVhY2ggZWxlbWVudCBpZiBub3QgbmVlZGVkLlxuICAgIGNvbnN0IGNvbnRleHQgPSAoKSA9PiB0aGlzLmdldENvbnRleHQoaW5kZXgsIGFjdGl2ZSwgbW9kZSk7XG4gICAgY29uc3QgdmFsdWVzID0gY29uZmlnLnJlc29sdmVOYW1lZE9wdGlvbnMoc2NvcGVzLCBuYW1lcywgY29udGV4dCwgcHJlZml4ZXMpO1xuXG4gICAgaWYgKHZhbHVlcy4kc2hhcmVkKSB7XG4gICAgICAvLyBgJHNoYXJlZGAgaW5kaWNhdGVzIHRoaXMgc2V0IG9mIG9wdGlvbnMgY2FuIGJlIHNoYXJlZCBiZXR3ZWVuIG11bHRpcGxlIGVsZW1lbnRzLlxuICAgICAgLy8gU2hhcmluZyBpcyB1c2VkIHRvIHJlZHVjZSBudW1iZXIgb2YgcHJvcGVydGllcyB0byBjaGFuZ2UgZHVyaW5nIGFuaW1hdGlvbi5cbiAgICAgIHZhbHVlcy4kc2hhcmVkID0gc2hhcmluZztcblxuICAgICAgLy8gV2UgY2FjaGUgb3B0aW9ucyBieSBgbW9kZWAsIHdoaWNoIGNhbiBiZSAnYWN0aXZlJyBmb3IgZXhhbXBsZS4gVGhpcyBlbmFibGVzIHVzXG4gICAgICAvLyB0byBoYXZlIHRoZSAnYWN0aXZlJyBlbGVtZW50IG9wdGlvbnMgYW5kICdkZWZhdWx0JyBvcHRpb25zIHRvIHN3aXRjaCBiZXR3ZWVuXG4gICAgICAvLyB3aGVuIGludGVyYWN0aW5nLlxuICAgICAgY2FjaGVbY2FjaGVLZXldID0gT2JqZWN0LmZyZWV6ZShjbG9uZUlmTm90U2hhcmVkKHZhbHVlcywgc2hhcmluZykpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cblxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCB0cmFuc2l0aW9uLCBhY3RpdmUpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLl9jYWNoZWREYXRhT3B0cztcbiAgICBjb25zdCBjYWNoZUtleSA9IGBhbmltYXRpb24tJHt0cmFuc2l0aW9ufWA7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGVbY2FjaGVLZXldO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuICAgIGxldCBvcHRpb25zO1xuICAgIGlmIChjaGFydC5vcHRpb25zLmFuaW1hdGlvbiAhPT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY2hhcnQuY29uZmlnO1xuICAgICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRBbmltYXRpb25TY29wZUtleXModGhpcy5fdHlwZSwgdHJhbnNpdGlvbik7XG4gICAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBzY29wZUtleXMpO1xuICAgICAgb3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIHRoaXMuZ2V0Q29udGV4dChpbmRleCwgYWN0aXZlLCB0cmFuc2l0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBuZXcgQW5pbWF0aW9ucyhjaGFydCwgb3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGlvbnMpO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2NhY2hlYWJsZSkge1xuICAgICAgY2FjaGVbY2FjaGVLZXldID0gT2JqZWN0LmZyZWV6ZShhbmltYXRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cblxuICAvKipcblx0ICogVXRpbGl0eSBmb3IgZ2V0dGluZyB0aGUgb3B0aW9ucyBvYmplY3Qgc2hhcmVkIGJldHdlZW4gZWxlbWVudHNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0U2hhcmVkT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLiRzaGFyZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NoYXJlZE9wdGlvbnMgfHwgKHRoaXMuX3NoYXJlZE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSk7XG4gIH1cblxuICAvKipcblx0ICogVXRpbGl0eSBmb3IgZGV0ZXJtaW5pbmcgaWYgYG9wdGlvbnNgIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgdXBkYXRlZCBwcm9wZXJ0aWVzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGluY2x1ZGVPcHRpb25zKG1vZGUsIHNoYXJlZE9wdGlvbnMpIHtcbiAgICByZXR1cm4gIXNoYXJlZE9wdGlvbnMgfHwgaXNEaXJlY3RVcGRhdGVNb2RlKG1vZGUpIHx8IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdG9kbyB2NCwgcmVuYW1lIHRvIGdldFNoYXJlZE9wdGlvbnMgYW5kIHJlbW92ZSBleGNlc3MgZnVuY3Rpb25zXG4gICAqL1xuICBfZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSkge1xuICAgIGNvbnN0IGZpcnN0T3B0cyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3QgcHJldmlvdXNseVNoYXJlZE9wdGlvbnMgPSB0aGlzLl9zaGFyZWRPcHRpb25zO1xuICAgIGNvbnN0IHNoYXJlZE9wdGlvbnMgPSB0aGlzLmdldFNoYXJlZE9wdGlvbnMoZmlyc3RPcHRzKTtcbiAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IHRoaXMuaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucykgfHwgKHNoYXJlZE9wdGlvbnMgIT09IHByZXZpb3VzbHlTaGFyZWRPcHRpb25zKTtcbiAgICB0aGlzLnVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgZmlyc3RPcHRzKTtcbiAgICByZXR1cm4ge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVdGlsaXR5IGZvciB1cGRhdGluZyBhbiBlbGVtZW50IHdpdGggbmV3IHByb3BlcnRpZXMsIHVzaW5nIGFuaW1hdGlvbnMgd2hlbiBhcHByb3ByaWF0ZS5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgdXBkYXRlRWxlbWVudChlbGVtZW50LCBpbmRleCwgcHJvcGVydGllcywgbW9kZSkge1xuICAgIGlmIChpc0RpcmVjdFVwZGF0ZU1vZGUobW9kZSkpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudCwgcHJvcGVydGllcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCBtb2RlKS51cGRhdGUoZWxlbWVudCwgcHJvcGVydGllcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIFV0aWxpdHkgdG8gYW5pbWF0ZSB0aGUgc2hhcmVkIG9wdGlvbnMsIHRoYXQgYXJlIHBvdGVudGlhbGx5IGFmZmVjdGluZyBtdWx0aXBsZSBlbGVtZW50cy5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgdXBkYXRlU2hhcmVkT3B0aW9ucyhzaGFyZWRPcHRpb25zLCBtb2RlLCBuZXdPcHRpb25zKSB7XG4gICAgaWYgKHNoYXJlZE9wdGlvbnMgJiYgIWlzRGlyZWN0VXBkYXRlTW9kZShtb2RlKSkge1xuICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnModW5kZWZpbmVkLCBtb2RlKS51cGRhdGUoc2hhcmVkT3B0aW9ucywgbmV3T3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfc2V0U3R5bGUoZWxlbWVudCwgaW5kZXgsIG1vZGUsIGFjdGl2ZSkge1xuICAgIGVsZW1lbnQuYWN0aXZlID0gYWN0aXZlO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmdldFN0eWxlKGluZGV4LCBhY3RpdmUpO1xuICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCBtb2RlLCBhY3RpdmUpLnVwZGF0ZShlbGVtZW50LCB7XG4gICAgICAvLyBXaGVuIGdvaW5nIGZyb20gYWN0aXZlIHRvIGluYWN0aXZlLCB3ZSBuZWVkIHRvIHVwZGF0ZSB0byB0aGUgc2hhcmVkIG9wdGlvbnMuXG4gICAgICAvLyBUaGlzIHdheSB0aGUgb25jZSBob3ZlcmVkIGVsZW1lbnQgd2lsbCBlbmQgdXAgd2l0aCB0aGUgc2FtZSBvcmlnaW5hbCBzaGFyZWQgb3B0aW9ucyBpbnN0YW5jZSwgYWZ0ZXIgYW5pbWF0aW9uLlxuICAgICAgb3B0aW9uczogKCFhY3RpdmUgJiYgdGhpcy5nZXRTaGFyZWRPcHRpb25zKG9wdGlvbnMpKSB8fCBvcHRpb25zXG4gICAgfSk7XG4gIH1cblxuICByZW1vdmVIb3ZlclN0eWxlKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICB0aGlzLl9zZXRTdHlsZShlbGVtZW50LCBpbmRleCwgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgfVxuXG4gIHNldEhvdmVyU3R5bGUoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIGluZGV4LCAnYWN0aXZlJywgdHJ1ZSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9yZW1vdmVEYXRhc2V0SG92ZXJTdHlsZSgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0O1xuXG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIHVuZGVmaW5lZCwgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9zZXREYXRhc2V0SG92ZXJTdHlsZSgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0O1xuXG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIHVuZGVmaW5lZCwgJ2FjdGl2ZScsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3Jlc3luY0VsZW1lbnRzKHJlc2V0TmV3RWxlbWVudHMpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcblxuICAgIC8vIEFwcGx5IGNoYW5nZXMgZGV0ZWN0ZWQgdGhyb3VnaCBhcnJheSBsaXN0ZW5lcnNcbiAgICBmb3IgKGNvbnN0IFttZXRob2QsIGFyZzEsIGFyZzJdIG9mIHRoaXMuX3N5bmNMaXN0KSB7XG4gICAgICB0aGlzW21ldGhvZF0oYXJnMSwgYXJnMik7XG4gICAgfVxuICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XG5cbiAgICBjb25zdCBudW1NZXRhID0gZWxlbWVudHMubGVuZ3RoO1xuICAgIGNvbnN0IG51bURhdGEgPSBkYXRhLmxlbmd0aDtcbiAgICBjb25zdCBjb3VudCA9IE1hdGgubWluKG51bURhdGEsIG51bU1ldGEpO1xuXG4gICAgaWYgKGNvdW50KSB7XG4gICAgICAvLyBUT0RPOiBJdCBpcyBub3Qgb3B0aW1hbCB0byBhbHdheXMgcGFyc2UgdGhlIG9sZCBkYXRhXG4gICAgICAvLyBUaGlzIGlzIGRvbmUgYmVjYXVzZSB3ZSBhcmUgbm90IGRldGVjdGluZyBkaXJlY3QgYXNzaWdubWVudHM6XG4gICAgICAvLyBjaGFydC5kYXRhLmRhdGFzZXRzWzBdLmRhdGFbNV0gPSAxMDtcbiAgICAgIC8vIGNoYXJ0LmRhdGEuZGF0YXNldHNbMF0uZGF0YVs1XS55ID0gMTA7XG4gICAgICB0aGlzLnBhcnNlKDAsIGNvdW50KTtcbiAgICB9XG5cbiAgICBpZiAobnVtRGF0YSA+IG51bU1ldGEpIHtcbiAgICAgIHRoaXMuX2luc2VydEVsZW1lbnRzKG51bU1ldGEsIG51bURhdGEgLSBudW1NZXRhLCByZXNldE5ld0VsZW1lbnRzKTtcbiAgICB9IGVsc2UgaWYgKG51bURhdGEgPCBudW1NZXRhKSB7XG4gICAgICB0aGlzLl9yZW1vdmVFbGVtZW50cyhudW1EYXRhLCBudW1NZXRhIC0gbnVtRGF0YSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfaW5zZXJ0RWxlbWVudHMoc3RhcnQsIGNvdW50LCByZXNldE5ld0VsZW1lbnRzID0gdHJ1ZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGEgPSBtZXRhLmRhdGE7XG4gICAgY29uc3QgZW5kID0gc3RhcnQgKyBjb3VudDtcbiAgICBsZXQgaTtcblxuICAgIGNvbnN0IG1vdmUgPSAoYXJyKSA9PiB7XG4gICAgICBhcnIubGVuZ3RoICs9IGNvdW50O1xuICAgICAgZm9yIChpID0gYXJyLmxlbmd0aCAtIDE7IGkgPj0gZW5kOyBpLS0pIHtcbiAgICAgICAgYXJyW2ldID0gYXJyW2kgLSBjb3VudF07XG4gICAgICB9XG4gICAgfTtcbiAgICBtb3ZlKGRhdGEpO1xuXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgZGF0YVtpXSA9IG5ldyB0aGlzLmRhdGFFbGVtZW50VHlwZSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9wYXJzaW5nKSB7XG4gICAgICBtb3ZlKG1ldGEuX3BhcnNlZCk7XG4gICAgfVxuICAgIHRoaXMucGFyc2Uoc3RhcnQsIGNvdW50KTtcblxuICAgIGlmIChyZXNldE5ld0VsZW1lbnRzKSB7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKGRhdGEsIHN0YXJ0LCBjb3VudCwgJ3Jlc2V0Jyk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMoZWxlbWVudCwgc3RhcnQsIGNvdW50LCBtb2RlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVtb3ZlRWxlbWVudHMoc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcbiAgICAgIGNvbnN0IHJlbW92ZWQgPSBtZXRhLl9wYXJzZWQuc3BsaWNlKHN0YXJ0LCBjb3VudCk7XG4gICAgICBpZiAobWV0YS5fc3RhY2tlZCkge1xuICAgICAgICBjbGVhclN0YWNrcyhtZXRhLCByZW1vdmVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWV0YS5kYXRhLnNwbGljZShzdGFydCwgY291bnQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG4gICAqL1xuICBfc3luYyhhcmdzKSB7XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcbiAgICAgIHRoaXMuX3N5bmNMaXN0LnB1c2goYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IFttZXRob2QsIGFyZzEsIGFyZzJdID0gYXJncztcbiAgICAgIHRoaXNbbWV0aG9kXShhcmcxLCBhcmcyKTtcbiAgICB9XG4gICAgdGhpcy5jaGFydC5fZGF0YUNoYW5nZXMucHVzaChbdGhpcy5pbmRleCwgLi4uYXJnc10pO1xuICB9XG5cbiAgX29uRGF0YVB1c2goKSB7XG4gICAgY29uc3QgY291bnQgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHRoaXMuX3N5bmMoWydfaW5zZXJ0RWxlbWVudHMnLCB0aGlzLmdldERhdGFzZXQoKS5kYXRhLmxlbmd0aCAtIGNvdW50LCBjb3VudF0pO1xuICB9XG5cbiAgX29uRGF0YVBvcCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX3JlbW92ZUVsZW1lbnRzJywgdGhpcy5fY2FjaGVkTWV0YS5kYXRhLmxlbmd0aCAtIDEsIDFdKTtcbiAgfVxuXG4gIF9vbkRhdGFTaGlmdCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX3JlbW92ZUVsZW1lbnRzJywgMCwgMV0pO1xuICB9XG5cbiAgX29uRGF0YVNwbGljZShzdGFydCwgY291bnQpIHtcbiAgICBpZiAoY291bnQpIHtcbiAgICAgIHRoaXMuX3N5bmMoWydfcmVtb3ZlRWxlbWVudHMnLCBzdGFydCwgY291bnRdKTtcbiAgICB9XG4gICAgY29uc3QgbmV3Q291bnQgPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgICBpZiAobmV3Q291bnQpIHtcbiAgICAgIHRoaXMuX3N5bmMoWydfaW5zZXJ0RWxlbWVudHMnLCBzdGFydCwgbmV3Q291bnRdKTtcbiAgICB9XG4gIH1cblxuICBfb25EYXRhVW5zaGlmdCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX2luc2VydEVsZW1lbnRzJywgMCwgYXJndW1lbnRzLmxlbmd0aF0pO1xuICB9XG59XG4iLCAiaW1wb3J0IERhdGFzZXRDb250cm9sbGVyIGZyb20gJy4uL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyc7XG5pbXBvcnQge1xuICBfYXJyYXlVbmlxdWUsIGlzQXJyYXksIGlzTnVsbE9yVW5kZWYsXG4gIHZhbHVlT3JEZWZhdWx0LCByZXNvbHZlT2JqZWN0S2V5LCBzaWduLCBkZWZpbmVkXG59IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG5mdW5jdGlvbiBnZXRBbGxTY2FsZVZhbHVlcyhzY2FsZSwgdHlwZSkge1xuICBpZiAoIXNjYWxlLl9jYWNoZS4kYmFyKSB7XG4gICAgY29uc3QgdmlzaWJsZU1ldGFzID0gc2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModHlwZSk7XG4gICAgbGV0IHZhbHVlcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSB2aXNpYmxlTWV0YXMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHZpc2libGVNZXRhc1tpXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyhzY2FsZSkpO1xuICAgIH1cbiAgICBzY2FsZS5fY2FjaGUuJGJhciA9IF9hcnJheVVuaXF1ZSh2YWx1ZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpKTtcbiAgfVxuICByZXR1cm4gc2NhbGUuX2NhY2hlLiRiYXI7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIFwib3B0aW1hbFwiIHNhbXBsZSBzaXplIHRvIG1haW50YWluIGJhcnMgZXF1YWxseSBzaXplZCB3aGlsZSBwcmV2ZW50aW5nIG92ZXJsYXAuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb21wdXRlTWluU2FtcGxlU2l6ZShtZXRhKSB7XG4gIGNvbnN0IHNjYWxlID0gbWV0YS5pU2NhbGU7XG4gIGNvbnN0IHZhbHVlcyA9IGdldEFsbFNjYWxlVmFsdWVzKHNjYWxlLCBtZXRhLnR5cGUpO1xuICBsZXQgbWluID0gc2NhbGUuX2xlbmd0aDtcbiAgbGV0IGksIGlsZW4sIGN1cnIsIHByZXY7XG4gIGNvbnN0IHVwZGF0ZU1pbkFuZFByZXYgPSAoKSA9PiB7XG4gICAgaWYgKGN1cnIgPT09IDMyNzY3IHx8IGN1cnIgPT09IC0zMjc2OCkge1xuICAgICAgLy8gSWdub3JlIHRydW5jYXRlZCBwaXhlbHNcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRlZmluZWQocHJldikpIHtcbiAgICAgIC8vIGN1cnIgLSBwcmV2ID09PSAwIGlzIGlnbm9yZWRcbiAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgTWF0aC5hYnMoY3VyciAtIHByZXYpIHx8IG1pbik7XG4gICAgfVxuICAgIHByZXYgPSBjdXJyO1xuICB9O1xuXG4gIGZvciAoaSA9IDAsIGlsZW4gPSB2YWx1ZXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY3VyciA9IHNjYWxlLmdldFBpeGVsRm9yVmFsdWUodmFsdWVzW2ldKTtcbiAgICB1cGRhdGVNaW5BbmRQcmV2KCk7XG4gIH1cblxuICBwcmV2ID0gdW5kZWZpbmVkO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gc2NhbGUudGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY3VyciA9IHNjYWxlLmdldFBpeGVsRm9yVGljayhpKTtcbiAgICB1cGRhdGVNaW5BbmRQcmV2KCk7XG4gIH1cblxuICByZXR1cm4gbWluO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIGFuIFwiaWRlYWxcIiBjYXRlZ29yeSBiYXNlZCBvbiB0aGUgYWJzb2x1dGUgYmFyIHRoaWNrbmVzcyBvciwgaWYgdW5kZWZpbmVkIG9yIG51bGwsXG4gKiB1c2VzIHRoZSBzbWFsbGVzdCBpbnRlcnZhbCAoc2VlIGNvbXB1dGVNaW5TYW1wbGVTaXplKSB0aGF0IHByZXZlbnRzIGJhciBvdmVybGFwcGluZy4gVGhpc1xuICogbW9kZSBjdXJyZW50bHkgYWx3YXlzIGdlbmVyYXRlcyBiYXJzIGVxdWFsbHkgc2l6ZWQgKHVudGlsIHdlIGludHJvZHVjZSBzY3JpcHRhYmxlIG9wdGlvbnM/KS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpIHtcbiAgY29uc3QgdGhpY2tuZXNzID0gb3B0aW9ucy5iYXJUaGlja25lc3M7XG4gIGxldCBzaXplLCByYXRpbztcblxuICBpZiAoaXNOdWxsT3JVbmRlZih0aGlja25lc3MpKSB7XG4gICAgc2l6ZSA9IHJ1bGVyLm1pbiAqIG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xuICAgIHJhdGlvID0gb3B0aW9ucy5iYXJQZXJjZW50YWdlO1xuICB9IGVsc2Uge1xuICAgIC8vIFdoZW4gYmFyIHRoaWNrbmVzcyBpcyBlbmZvcmNlZCwgY2F0ZWdvcnkgYW5kIGJhciBwZXJjZW50YWdlcyBhcmUgaWdub3JlZC5cbiAgICAvLyBOb3RlKFNCKTogd2UgY291bGQgYWRkIHN1cHBvcnQgZm9yIHJlbGF0aXZlIGJhciB0aGlja25lc3MgKGUuZy4gYmFyVGhpY2tuZXNzOiAnNTAlJylcbiAgICAvLyBhbmQgZGVwcmVjYXRlIGJhclBlcmNlbnRhZ2Ugc2luY2UgdGhpcyB2YWx1ZSBpcyBpZ25vcmVkIHdoZW4gdGhpY2tuZXNzIGlzIGFic29sdXRlLlxuICAgIHNpemUgPSB0aGlja25lc3MgKiBzdGFja0NvdW50O1xuICAgIHJhdGlvID0gMTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY2h1bms6IHNpemUgLyBzdGFja0NvdW50LFxuICAgIHJhdGlvLFxuICAgIHN0YXJ0OiBydWxlci5waXhlbHNbaW5kZXhdIC0gKHNpemUgLyAyKVxuICB9O1xufVxuXG4vKipcbiAqIENvbXB1dGVzIGFuIFwib3B0aW1hbFwiIGNhdGVnb3J5IHRoYXQgZ2xvYmFsbHkgYXJyYW5nZXMgYmFycyBzaWRlIGJ5IHNpZGUgKG5vIGdhcCB3aGVuXG4gKiBwZXJjZW50YWdlIG9wdGlvbnMgYXJlIDEpLCBiYXNlZCBvbiB0aGUgcHJldmlvdXMgYW5kIGZvbGxvd2luZyBjYXRlZ29yaWVzLiBUaGlzIG1vZGVcbiAqIGdlbmVyYXRlcyBiYXJzIHdpdGggZGlmZmVyZW50IHdpZHRocyB3aGVuIGRhdGEgYXJlIG5vdCBldmVubHkgc3BhY2VkLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpIHtcbiAgY29uc3QgcGl4ZWxzID0gcnVsZXIucGl4ZWxzO1xuICBjb25zdCBjdXJyID0gcGl4ZWxzW2luZGV4XTtcbiAgbGV0IHByZXYgPSBpbmRleCA+IDAgPyBwaXhlbHNbaW5kZXggLSAxXSA6IG51bGw7XG4gIGxldCBuZXh0ID0gaW5kZXggPCBwaXhlbHMubGVuZ3RoIC0gMSA/IHBpeGVsc1tpbmRleCArIDFdIDogbnVsbDtcbiAgY29uc3QgcGVyY2VudCA9IG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xuXG4gIGlmIChwcmV2ID09PSBudWxsKSB7XG4gICAgLy8gZmlyc3QgZGF0YTogaXRzIHNpemUgaXMgZG91YmxlIGJhc2VkIG9uIHRoZSBuZXh0IHBvaW50IG9yLFxuICAgIC8vIGlmIGl0J3MgYWxzbyB0aGUgbGFzdCBkYXRhLCB3ZSB1c2UgdGhlIHNjYWxlIHNpemUuXG4gICAgcHJldiA9IGN1cnIgLSAobmV4dCA9PT0gbnVsbCA/IHJ1bGVyLmVuZCAtIHJ1bGVyLnN0YXJ0IDogbmV4dCAtIGN1cnIpO1xuICB9XG5cbiAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAvLyBsYXN0IGRhdGE6IGl0cyBzaXplIGlzIGFsc28gZG91YmxlIGJhc2VkIG9uIHRoZSBwcmV2aW91cyBwb2ludC5cbiAgICBuZXh0ID0gY3VyciArIGN1cnIgLSBwcmV2O1xuICB9XG5cbiAgY29uc3Qgc3RhcnQgPSBjdXJyIC0gKGN1cnIgLSBNYXRoLm1pbihwcmV2LCBuZXh0KSkgLyAyICogcGVyY2VudDtcbiAgY29uc3Qgc2l6ZSA9IE1hdGguYWJzKG5leHQgLSBwcmV2KSAvIDIgKiBwZXJjZW50O1xuXG4gIHJldHVybiB7XG4gICAgY2h1bms6IHNpemUgLyBzdGFja0NvdW50LFxuICAgIHJhdGlvOiBvcHRpb25zLmJhclBlcmNlbnRhZ2UsXG4gICAgc3RhcnRcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VGbG9hdEJhcihlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKSB7XG4gIGNvbnN0IHN0YXJ0VmFsdWUgPSB2U2NhbGUucGFyc2UoZW50cnlbMF0sIGkpO1xuICBjb25zdCBlbmRWYWx1ZSA9IHZTY2FsZS5wYXJzZShlbnRyeVsxXSwgaSk7XG4gIGNvbnN0IG1pbiA9IE1hdGgubWluKHN0YXJ0VmFsdWUsIGVuZFZhbHVlKTtcbiAgY29uc3QgbWF4ID0gTWF0aC5tYXgoc3RhcnRWYWx1ZSwgZW5kVmFsdWUpO1xuICBsZXQgYmFyU3RhcnQgPSBtaW47XG4gIGxldCBiYXJFbmQgPSBtYXg7XG5cbiAgaWYgKE1hdGguYWJzKG1pbikgPiBNYXRoLmFicyhtYXgpKSB7XG4gICAgYmFyU3RhcnQgPSBtYXg7XG4gICAgYmFyRW5kID0gbWluO1xuICB9XG5cbiAgLy8gU3RvcmUgYGJhckVuZGAgKGZ1cnRoZXN0IGF3YXkgZnJvbSBvcmlnaW4pIGFzIHBhcnNlZCB2YWx1ZSxcbiAgLy8gdG8gbWFrZSBzdGFja2luZyBzdHJhaWdodCBmb3J3YXJkXG4gIGl0ZW1bdlNjYWxlLmF4aXNdID0gYmFyRW5kO1xuXG4gIGl0ZW0uX2N1c3RvbSA9IHtcbiAgICBiYXJTdGFydCxcbiAgICBiYXJFbmQsXG4gICAgc3RhcnQ6IHN0YXJ0VmFsdWUsXG4gICAgZW5kOiBlbmRWYWx1ZSxcbiAgICBtaW4sXG4gICAgbWF4XG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlVmFsdWUoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSkge1xuICBpZiAoaXNBcnJheShlbnRyeSkpIHtcbiAgICBwYXJzZUZsb2F0QmFyKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpO1xuICB9IGVsc2Uge1xuICAgIGl0ZW1bdlNjYWxlLmF4aXNdID0gdlNjYWxlLnBhcnNlKGVudHJ5LCBpKTtcbiAgfVxuICByZXR1cm4gaXRlbTtcbn1cblxuZnVuY3Rpb24gcGFyc2VBcnJheU9yUHJpbWl0aXZlKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICBjb25zdCBpU2NhbGUgPSBtZXRhLmlTY2FsZTtcbiAgY29uc3QgdlNjYWxlID0gbWV0YS52U2NhbGU7XG4gIGNvbnN0IGxhYmVscyA9IGlTY2FsZS5nZXRMYWJlbHMoKTtcbiAgY29uc3Qgc2luZ2xlU2NhbGUgPSBpU2NhbGUgPT09IHZTY2FsZTtcbiAgY29uc3QgcGFyc2VkID0gW107XG4gIGxldCBpLCBpbGVuLCBpdGVtLCBlbnRyeTtcblxuICBmb3IgKGkgPSBzdGFydCwgaWxlbiA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBlbnRyeSA9IGRhdGFbaV07XG4gICAgaXRlbSA9IHt9O1xuICAgIGl0ZW1baVNjYWxlLmF4aXNdID0gc2luZ2xlU2NhbGUgfHwgaVNjYWxlLnBhcnNlKGxhYmVsc1tpXSwgaSk7XG4gICAgcGFyc2VkLnB1c2gocGFyc2VWYWx1ZShlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn1cblxuZnVuY3Rpb24gaXNGbG9hdEJhcihjdXN0b20pIHtcbiAgcmV0dXJuIGN1c3RvbSAmJiBjdXN0b20uYmFyU3RhcnQgIT09IHVuZGVmaW5lZCAmJiBjdXN0b20uYmFyRW5kICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGJhclNpZ24oc2l6ZSwgdlNjYWxlLCBhY3R1YWxCYXNlKSB7XG4gIGlmIChzaXplICE9PSAwKSB7XG4gICAgcmV0dXJuIHNpZ24oc2l6ZSk7XG4gIH1cbiAgcmV0dXJuICh2U2NhbGUuaXNIb3Jpem9udGFsKCkgPyAxIDogLTEpICogKHZTY2FsZS5taW4gPj0gYWN0dWFsQmFzZSA/IDEgOiAtMSk7XG59XG5cbmZ1bmN0aW9uIGJvcmRlclByb3BzKHByb3BlcnRpZXMpIHtcbiAgbGV0IHJldmVyc2UsIHN0YXJ0LCBlbmQsIHRvcCwgYm90dG9tO1xuICBpZiAocHJvcGVydGllcy5ob3Jpem9udGFsKSB7XG4gICAgcmV2ZXJzZSA9IHByb3BlcnRpZXMuYmFzZSA+IHByb3BlcnRpZXMueDtcbiAgICBzdGFydCA9ICdsZWZ0JztcbiAgICBlbmQgPSAncmlnaHQnO1xuICB9IGVsc2Uge1xuICAgIHJldmVyc2UgPSBwcm9wZXJ0aWVzLmJhc2UgPCBwcm9wZXJ0aWVzLnk7XG4gICAgc3RhcnQgPSAnYm90dG9tJztcbiAgICBlbmQgPSAndG9wJztcbiAgfVxuICBpZiAocmV2ZXJzZSkge1xuICAgIHRvcCA9ICdlbmQnO1xuICAgIGJvdHRvbSA9ICdzdGFydCc7XG4gIH0gZWxzZSB7XG4gICAgdG9wID0gJ3N0YXJ0JztcbiAgICBib3R0b20gPSAnZW5kJztcbiAgfVxuICByZXR1cm4ge3N0YXJ0LCBlbmQsIHJldmVyc2UsIHRvcCwgYm90dG9tfTtcbn1cblxuZnVuY3Rpb24gc2V0Qm9yZGVyU2tpcHBlZChwcm9wZXJ0aWVzLCBvcHRpb25zLCBzdGFjaywgaW5kZXgpIHtcbiAgbGV0IGVkZ2UgPSBvcHRpb25zLmJvcmRlclNraXBwZWQ7XG4gIGNvbnN0IHJlcyA9IHt9O1xuXG4gIGlmICghZWRnZSkge1xuICAgIHByb3BlcnRpZXMuYm9yZGVyU2tpcHBlZCA9IHJlcztcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZWRnZSA9PT0gdHJ1ZSkge1xuICAgIHByb3BlcnRpZXMuYm9yZGVyU2tpcHBlZCA9IHt0b3A6IHRydWUsIHJpZ2h0OiB0cnVlLCBib3R0b206IHRydWUsIGxlZnQ6IHRydWV9O1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHtzdGFydCwgZW5kLCByZXZlcnNlLCB0b3AsIGJvdHRvbX0gPSBib3JkZXJQcm9wcyhwcm9wZXJ0aWVzKTtcblxuICBpZiAoZWRnZSA9PT0gJ21pZGRsZScgJiYgc3RhY2spIHtcbiAgICBwcm9wZXJ0aWVzLmVuYWJsZUJvcmRlclJhZGl1cyA9IHRydWU7XG4gICAgaWYgKChzdGFjay5fdG9wIHx8IDApID09PSBpbmRleCkge1xuICAgICAgZWRnZSA9IHRvcDtcbiAgICB9IGVsc2UgaWYgKChzdGFjay5fYm90dG9tIHx8IDApID09PSBpbmRleCkge1xuICAgICAgZWRnZSA9IGJvdHRvbTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW3BhcnNlRWRnZShib3R0b20sIHN0YXJ0LCBlbmQsIHJldmVyc2UpXSA9IHRydWU7XG4gICAgICBlZGdlID0gdG9wO1xuICAgIH1cbiAgfVxuXG4gIHJlc1twYXJzZUVkZ2UoZWRnZSwgc3RhcnQsIGVuZCwgcmV2ZXJzZSldID0gdHJ1ZTtcbiAgcHJvcGVydGllcy5ib3JkZXJTa2lwcGVkID0gcmVzO1xufVxuXG5mdW5jdGlvbiBwYXJzZUVkZ2UoZWRnZSwgYSwgYiwgcmV2ZXJzZSkge1xuICBpZiAocmV2ZXJzZSkge1xuICAgIGVkZ2UgPSBzd2FwKGVkZ2UsIGEsIGIpO1xuICAgIGVkZ2UgPSBzdGFydEVuZChlZGdlLCBiLCBhKTtcbiAgfSBlbHNlIHtcbiAgICBlZGdlID0gc3RhcnRFbmQoZWRnZSwgYSwgYik7XG4gIH1cbiAgcmV0dXJuIGVkZ2U7XG59XG5cbmZ1bmN0aW9uIHN3YXAob3JpZywgdjEsIHYyKSB7XG4gIHJldHVybiBvcmlnID09PSB2MSA/IHYyIDogb3JpZyA9PT0gdjIgPyB2MSA6IG9yaWc7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0RW5kKHYsIHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIHYgPT09ICdzdGFydCcgPyBzdGFydCA6IHYgPT09ICdlbmQnID8gZW5kIDogdjtcbn1cblxuZnVuY3Rpb24gc2V0SW5mbGF0ZUFtb3VudChwcm9wZXJ0aWVzLCB7aW5mbGF0ZUFtb3VudH0sIHJhdGlvKSB7XG4gIHByb3BlcnRpZXMuaW5mbGF0ZUFtb3VudCA9IGluZmxhdGVBbW91bnQgPT09ICdhdXRvJ1xuICAgID8gcmF0aW8gPT09IDEgPyAwLjMzIDogMFxuICAgIDogaW5mbGF0ZUFtb3VudDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFyQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcblxuICBzdGF0aWMgaWQgPSAnYmFyJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICAgIGRhdGFFbGVtZW50VHlwZTogJ2JhcicsXG5cbiAgICBjYXRlZ29yeVBlcmNlbnRhZ2U6IDAuOCxcbiAgICBiYXJQZXJjZW50YWdlOiAwLjksXG4gICAgZ3JvdXBlZDogdHJ1ZSxcblxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ2Jhc2UnLCAnd2lkdGgnLCAnaGVpZ2h0J11cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuICAgIHNjYWxlczoge1xuICAgICAgX2luZGV4Xzoge1xuICAgICAgICB0eXBlOiAnY2F0ZWdvcnknLFxuICAgICAgICBvZmZzZXQ6IHRydWUsXG4gICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICBvZmZzZXQ6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF92YWx1ZV86IHtcbiAgICAgICAgdHlwZTogJ2xpbmVhcicsXG4gICAgICAgIGJlZ2luQXRaZXJvOiB0cnVlLFxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuXHQgKiBPdmVycmlkaW5nIHByaW1pdGl2ZSBkYXRhIHBhcnNpbmcgc2luY2Ugd2Ugc3VwcG9ydCBtaXhlZCBwcmltaXRpdmUvYXJyYXlcblx0ICogZGF0YSBmb3IgZmxvYXQgYmFyc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgcmV0dXJuIHBhcnNlQXJyYXlPclByaW1pdGl2ZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIE92ZXJyaWRpbmcgYXJyYXkgZGF0YSBwYXJzaW5nIHNpbmNlIHdlIHN1cHBvcnQgbWl4ZWQgcHJpbWl0aXZlL2FycmF5XG5cdCAqIGRhdGEgZm9yIGZsb2F0IGJhcnNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgcmV0dXJuIHBhcnNlQXJyYXlPclByaW1pdGl2ZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIE92ZXJyaWRpbmcgb2JqZWN0IGRhdGEgcGFyc2luZyBzaW5jZSB3ZSBzdXBwb3J0IG1peGVkIHByaW1pdGl2ZS9hcnJheVxuXHQgKiB2YWx1ZS1zY2FsZSBkYXRhIGZvciBmbG9hdCBiYXJzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCB7eEF4aXNLZXkgPSAneCcsIHlBeGlzS2V5ID0gJ3knfSA9IHRoaXMuX3BhcnNpbmc7XG4gICAgY29uc3QgaUF4aXNLZXkgPSBpU2NhbGUuYXhpcyA9PT0gJ3gnID8geEF4aXNLZXkgOiB5QXhpc0tleTtcbiAgICBjb25zdCB2QXhpc0tleSA9IHZTY2FsZS5heGlzID09PSAneCcgPyB4QXhpc0tleSA6IHlBeGlzS2V5O1xuICAgIGNvbnN0IHBhcnNlZCA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCBpdGVtLCBvYmo7XG4gICAgZm9yIChpID0gc3RhcnQsIGlsZW4gPSBzdGFydCArIGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBvYmogPSBkYXRhW2ldO1xuICAgICAgaXRlbSA9IHt9O1xuICAgICAgaXRlbVtpU2NhbGUuYXhpc10gPSBpU2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShvYmosIGlBeGlzS2V5KSwgaSk7XG4gICAgICBwYXJzZWQucHVzaChwYXJzZVZhbHVlKHJlc29sdmVPYmplY3RLZXkob2JqLCB2QXhpc0tleSksIGl0ZW0sIHZTY2FsZSwgaSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spIHtcbiAgICBzdXBlci51cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKTtcbiAgICBjb25zdCBjdXN0b20gPSBwYXJzZWQuX2N1c3RvbTtcbiAgICBpZiAoY3VzdG9tICYmIHNjYWxlID09PSB0aGlzLl9jYWNoZWRNZXRhLnZTY2FsZSkge1xuICAgICAgLy8gZmxvYXQgYmFyOiBvbmx5IG9uZSBlbmQgb2YgdGhlIGJhciBpcyBjb25zaWRlcmVkIGJ5IGBzdXBlcmBcbiAgICAgIHJhbmdlLm1pbiA9IE1hdGgubWluKHJhbmdlLm1pbiwgY3VzdG9tLm1pbik7XG4gICAgICByYW5nZS5tYXggPSBNYXRoLm1heChyYW5nZS5tYXgsIGN1c3RvbS5tYXgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ8Ym9vbGVhbn1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICBjb25zdCBjdXN0b20gPSBwYXJzZWQuX2N1c3RvbTtcbiAgICBjb25zdCB2YWx1ZSA9IGlzRmxvYXRCYXIoY3VzdG9tKVxuICAgICAgPyAnWycgKyBjdXN0b20uc3RhcnQgKyAnLCAnICsgY3VzdG9tLmVuZCArICddJ1xuICAgICAgOiAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiAnJyArIGlTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFtpU2NhbGUuYXhpc10pLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG5cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuXG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuXG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgbWV0YS5zdGFjayA9IHRoaXMuZ2V0RGF0YXNldCgpLnN0YWNrO1xuICB9XG5cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKG1ldGEuZGF0YSwgMCwgbWV0YS5kYXRhLmxlbmd0aCwgbW9kZSk7XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhiYXJzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3Qge2luZGV4LCBfY2FjaGVkTWV0YToge3ZTY2FsZX19ID0gdGhpcztcbiAgICBjb25zdCBiYXNlID0gdlNjYWxlLmdldEJhc2VQaXhlbCgpO1xuICAgIGNvbnN0IGhvcml6b250YWwgPSB2U2NhbGUuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgcnVsZXIgPSB0aGlzLl9nZXRSdWxlcigpO1xuICAgIGNvbnN0IHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc30gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcblxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICBjb25zdCB2cGl4ZWxzID0gcmVzZXQgfHwgaXNOdWxsT3JVbmRlZihwYXJzZWRbdlNjYWxlLmF4aXNdKSA/IHtiYXNlLCBoZWFkOiBiYXNlfSA6IHRoaXMuX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKGkpO1xuICAgICAgY29uc3QgaXBpeGVscyA9IHRoaXMuX2NhbGN1bGF0ZUJhckluZGV4UGl4ZWxzKGksIHJ1bGVyKTtcbiAgICAgIGNvbnN0IHN0YWNrID0gKHBhcnNlZC5fc3RhY2tzIHx8IHt9KVt2U2NhbGUuYXhpc107XG5cbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIGhvcml6b250YWwsXG4gICAgICAgIGJhc2U6IHZwaXhlbHMuYmFzZSxcbiAgICAgICAgZW5hYmxlQm9yZGVyUmFkaXVzOiAhc3RhY2sgfHwgaXNGbG9hdEJhcihwYXJzZWQuX2N1c3RvbSkgfHwgKGluZGV4ID09PSBzdGFjay5fdG9wIHx8IGluZGV4ID09PSBzdGFjay5fYm90dG9tKSxcbiAgICAgICAgeDogaG9yaXpvbnRhbCA/IHZwaXhlbHMuaGVhZCA6IGlwaXhlbHMuY2VudGVyLFxuICAgICAgICB5OiBob3Jpem9udGFsID8gaXBpeGVscy5jZW50ZXIgOiB2cGl4ZWxzLmhlYWQsXG4gICAgICAgIGhlaWdodDogaG9yaXpvbnRhbCA/IGlwaXhlbHMuc2l6ZSA6IE1hdGguYWJzKHZwaXhlbHMuc2l6ZSksXG4gICAgICAgIHdpZHRoOiBob3Jpem9udGFsID8gTWF0aC5hYnModnBpeGVscy5zaXplKSA6IGlwaXhlbHMuc2l6ZVxuICAgICAgfTtcblxuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIGJhcnNbaV0uYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBwcm9wZXJ0aWVzLm9wdGlvbnMgfHwgYmFyc1tpXS5vcHRpb25zO1xuICAgICAgc2V0Qm9yZGVyU2tpcHBlZChwcm9wZXJ0aWVzLCBvcHRpb25zLCBzdGFjaywgaW5kZXgpO1xuICAgICAgc2V0SW5mbGF0ZUFtb3VudChwcm9wZXJ0aWVzLCBvcHRpb25zLCBydWxlci5yYXRpbyk7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoYmFyc1tpXSwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIHN0YWNrcyBiYXNlZCBvbiBncm91cHMgYW5kIGJhciB2aXNpYmlsaXR5LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2xhc3RdIC0gVGhlIGRhdGFzZXQgaW5kZXhcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtkYXRhSW5kZXhdIC0gVGhlIGRhdGEgaW5kZXggb2YgdGhlIHJ1bGVyXG5cdCAqIEByZXR1cm5zIHtzdHJpbmdbXX0gVGhlIGxpc3Qgb2Ygc3RhY2sgSURzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0U3RhY2tzKGxhc3QsIGRhdGFJbmRleCkge1xuICAgIGNvbnN0IHtpU2NhbGV9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBtZXRhc2V0cyA9IGlTY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0aGlzLl90eXBlKVxuICAgICAgLmZpbHRlcihtZXRhID0+IG1ldGEuY29udHJvbGxlci5vcHRpb25zLmdyb3VwZWQpO1xuICAgIGNvbnN0IHN0YWNrZWQgPSBpU2NhbGUub3B0aW9ucy5zdGFja2VkO1xuICAgIGNvbnN0IHN0YWNrcyA9IFtdO1xuXG4gICAgY29uc3Qgc2tpcE51bGwgPSAobWV0YSkgPT4ge1xuICAgICAgY29uc3QgcGFyc2VkID0gbWV0YS5jb250cm9sbGVyLmdldFBhcnNlZChkYXRhSW5kZXgpO1xuICAgICAgY29uc3QgdmFsID0gcGFyc2VkICYmIHBhcnNlZFttZXRhLnZTY2FsZS5heGlzXTtcblxuICAgICAgaWYgKGlzTnVsbE9yVW5kZWYodmFsKSB8fCBpc05hTih2YWwpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKGNvbnN0IG1ldGEgb2YgbWV0YXNldHMpIHtcbiAgICAgIGlmIChkYXRhSW5kZXggIT09IHVuZGVmaW5lZCAmJiBza2lwTnVsbChtZXRhKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gc3RhY2tlZCAgIHwgbWV0YS5zdGFja1xuICAgICAgLy8gICAgICAgICAgIHwgZm91bmQgfCBub3QgZm91bmQgfCB1bmRlZmluZWRcbiAgICAgIC8vIGZhbHNlICAgICB8ICAgeCAgIHwgICAgIHggICAgIHwgICAgIHhcbiAgICAgIC8vIHRydWUgICAgICB8ICAgICAgIHwgICAgIHggICAgIHxcbiAgICAgIC8vIHVuZGVmaW5lZCB8ICAgICAgIHwgICAgIHggICAgIHwgICAgIHhcbiAgICAgIGlmIChzdGFja2VkID09PSBmYWxzZSB8fCBzdGFja3MuaW5kZXhPZihtZXRhLnN0YWNrKSA9PT0gLTEgfHxcblx0XHRcdFx0KHN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBtZXRhLnN0YWNrID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHN0YWNrcy5wdXNoKG1ldGEuc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKG1ldGEuaW5kZXggPT09IGxhc3QpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm8gc3RhY2tzPyB0aGF0IG1lYW5zIHRoZXJlIGlzIG5vIHZpc2libGUgZGF0YS4gTGV0J3Mgc3RpbGwgaW5pdGlhbGl6ZSBhbiBgdW5kZWZpbmVkYFxuICAgIC8vIHN0YWNrIHdoZXJlIHBvc3NpYmxlIGludmlzaWJsZSBiYXJzIHdpbGwgYmUgbG9jYXRlZC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNjM2OFxuICAgIGlmICghc3RhY2tzLmxlbmd0aCkge1xuICAgICAgc3RhY2tzLnB1c2godW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhY2tzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIGVmZmVjdGl2ZSBudW1iZXIgb2Ygc3RhY2tzIGJhc2VkIG9uIGdyb3VwcyBhbmQgYmFyIHZpc2liaWxpdHkuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0U3RhY2tDb3VudChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTdGFja3ModW5kZWZpbmVkLCBpbmRleCkubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIHN0YWNrIGluZGV4IGZvciB0aGUgZ2l2ZW4gZGF0YXNldCBiYXNlZCBvbiBncm91cHMgYW5kIGJhciB2aXNpYmlsaXR5LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2RhdGFzZXRJbmRleF0gLSBUaGUgZGF0YXNldCBpbmRleFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdIC0gVGhlIHN0YWNrIG5hbWUgdG8gZmluZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RhdGFJbmRleF1cblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIHN0YWNrIGluZGV4XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0U3RhY2tJbmRleChkYXRhc2V0SW5kZXgsIG5hbWUsIGRhdGFJbmRleCkge1xuICAgIGNvbnN0IHN0YWNrcyA9IHRoaXMuX2dldFN0YWNrcyhkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCk7XG4gICAgY29uc3QgaW5kZXggPSAobmFtZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgPyBzdGFja3MuaW5kZXhPZihuYW1lKVxuICAgICAgOiAtMTsgLy8gaW5kZXhPZiByZXR1cm5zIC0xIGlmIGVsZW1lbnQgaXMgbm90IHByZXNlbnRcblxuICAgIHJldHVybiAoaW5kZXggPT09IC0xKVxuICAgICAgPyBzdGFja3MubGVuZ3RoIC0gMVxuICAgICAgOiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFJ1bGVyKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgaVNjYWxlID0gbWV0YS5pU2NhbGU7XG4gICAgY29uc3QgcGl4ZWxzID0gW107XG4gICAgbGV0IGksIGlsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YS5kYXRhLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgcGl4ZWxzLnB1c2goaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRQYXJzZWQoaSlbaVNjYWxlLmF4aXNdLCBpKSk7XG4gICAgfVxuXG4gICAgY29uc3QgYmFyVGhpY2tuZXNzID0gb3B0cy5iYXJUaGlja25lc3M7XG4gICAgY29uc3QgbWluID0gYmFyVGhpY2tuZXNzIHx8IGNvbXB1dGVNaW5TYW1wbGVTaXplKG1ldGEpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbixcbiAgICAgIHBpeGVscyxcbiAgICAgIHN0YXJ0OiBpU2NhbGUuX3N0YXJ0UGl4ZWwsXG4gICAgICBlbmQ6IGlTY2FsZS5fZW5kUGl4ZWwsXG4gICAgICBzdGFja0NvdW50OiB0aGlzLl9nZXRTdGFja0NvdW50KCksXG4gICAgICBzY2FsZTogaVNjYWxlLFxuICAgICAgZ3JvdXBlZDogb3B0cy5ncm91cGVkLFxuICAgICAgLy8gYmFyIHRoaWNrbmVzcyByYXRpbyB1c2VkIGZvciBub24tZ3JvdXBlZCBiYXJzXG4gICAgICByYXRpbzogYmFyVGhpY2tuZXNzID8gMSA6IG9wdHMuY2F0ZWdvcnlQZXJjZW50YWdlICogb3B0cy5iYXJQZXJjZW50YWdlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBOb3RlOiBwaXhlbCB2YWx1ZXMgYXJlIG5vdCBjbGFtcGVkIHRvIHRoZSBzY2FsZSBhcmVhLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKGluZGV4KSB7XG4gICAgY29uc3Qge19jYWNoZWRNZXRhOiB7dlNjYWxlLCBfc3RhY2tlZCwgaW5kZXg6IGRhdGFzZXRJbmRleH0sIG9wdGlvbnM6IHtiYXNlOiBiYXNlVmFsdWUsIG1pbkJhckxlbmd0aH19ID0gdGhpcztcbiAgICBjb25zdCBhY3R1YWxCYXNlID0gYmFzZVZhbHVlIHx8IDA7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IGN1c3RvbSA9IHBhcnNlZC5fY3VzdG9tO1xuICAgIGNvbnN0IGZsb2F0aW5nID0gaXNGbG9hdEJhcihjdXN0b20pO1xuICAgIGxldCB2YWx1ZSA9IHBhcnNlZFt2U2NhbGUuYXhpc107XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgbGVuZ3RoID0gX3N0YWNrZWQgPyB0aGlzLmFwcGx5U3RhY2sodlNjYWxlLCBwYXJzZWQsIF9zdGFja2VkKSA6IHZhbHVlO1xuICAgIGxldCBoZWFkLCBzaXplO1xuXG4gICAgaWYgKGxlbmd0aCAhPT0gdmFsdWUpIHtcbiAgICAgIHN0YXJ0ID0gbGVuZ3RoIC0gdmFsdWU7XG4gICAgICBsZW5ndGggPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoZmxvYXRpbmcpIHtcbiAgICAgIHZhbHVlID0gY3VzdG9tLmJhclN0YXJ0O1xuICAgICAgbGVuZ3RoID0gY3VzdG9tLmJhckVuZCAtIGN1c3RvbS5iYXJTdGFydDtcbiAgICAgIC8vIGJhcnMgY3Jvc3Npbmcgb3JpZ2luIGFyZSBub3Qgc3RhY2tlZFxuICAgICAgaWYgKHZhbHVlICE9PSAwICYmIHNpZ24odmFsdWUpICE9PSBzaWduKGN1c3RvbS5iYXJFbmQpKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ICs9IHZhbHVlO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0VmFsdWUgPSAhaXNOdWxsT3JVbmRlZihiYXNlVmFsdWUpICYmICFmbG9hdGluZyA/IGJhc2VWYWx1ZSA6IHN0YXJ0O1xuICAgIGxldCBiYXNlID0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoc3RhcnRWYWx1ZSk7XG5cbiAgICBpZiAodGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleCkpIHtcbiAgICAgIGhlYWQgPSB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdGFydCArIGxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdoZW4gbm90IHZpc2libGUsIG5vIGhlaWdodFxuICAgICAgaGVhZCA9IGJhc2U7XG4gICAgfVxuXG4gICAgc2l6ZSA9IGhlYWQgLSBiYXNlO1xuXG4gICAgaWYgKE1hdGguYWJzKHNpemUpIDwgbWluQmFyTGVuZ3RoKSB7XG4gICAgICBzaXplID0gYmFyU2lnbihzaXplLCB2U2NhbGUsIGFjdHVhbEJhc2UpICogbWluQmFyTGVuZ3RoO1xuICAgICAgaWYgKHZhbHVlID09PSBhY3R1YWxCYXNlKSB7XG4gICAgICAgIGJhc2UgLT0gc2l6ZSAvIDI7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGFydFBpeGVsID0gdlNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgwKTtcbiAgICAgIGNvbnN0IGVuZFBpeGVsID0gdlNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgxKTtcbiAgICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKHN0YXJ0UGl4ZWwsIGVuZFBpeGVsKTtcbiAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHN0YXJ0UGl4ZWwsIGVuZFBpeGVsKTtcbiAgICAgIGJhc2UgPSBNYXRoLm1heChNYXRoLm1pbihiYXNlLCBtYXgpLCBtaW4pO1xuICAgICAgaGVhZCA9IGJhc2UgKyBzaXplO1xuXG4gICAgICBpZiAoX3N0YWNrZWQgJiYgIWZsb2F0aW5nKSB7XG4gICAgICAgIC8vIHZpc3VhbCBkYXRhIGNvb3JkaW5hdGVzIGFmdGVyIGFwcGx5aW5nIG1pbkJhckxlbmd0aFxuICAgICAgICBwYXJzZWQuX3N0YWNrc1t2U2NhbGUuYXhpc10uX3Zpc3VhbFZhbHVlc1tkYXRhc2V0SW5kZXhdID0gdlNjYWxlLmdldFZhbHVlRm9yUGl4ZWwoaGVhZCkgLSB2U2NhbGUuZ2V0VmFsdWVGb3JQaXhlbChiYXNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoYWN0dWFsQmFzZSkpIHtcbiAgICAgIGNvbnN0IGhhbGZHcmlkID0gc2lnbihzaXplKSAqIHZTY2FsZS5nZXRMaW5lV2lkdGhGb3JWYWx1ZShhY3R1YWxCYXNlKSAvIDI7XG4gICAgICBiYXNlICs9IGhhbGZHcmlkO1xuICAgICAgc2l6ZSAtPSBoYWxmR3JpZDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc2l6ZSxcbiAgICAgIGJhc2UsXG4gICAgICBoZWFkLFxuICAgICAgY2VudGVyOiBoZWFkICsgc2l6ZSAvIDJcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY2FsY3VsYXRlQmFySW5kZXhQaXhlbHMoaW5kZXgsIHJ1bGVyKSB7XG4gICAgY29uc3Qgc2NhbGUgPSBydWxlci5zY2FsZTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHNraXBOdWxsID0gb3B0aW9ucy5za2lwTnVsbDtcbiAgICBjb25zdCBtYXhCYXJUaGlja25lc3MgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLm1heEJhclRoaWNrbmVzcywgSW5maW5pdHkpO1xuICAgIGxldCBjZW50ZXIsIHNpemU7XG4gICAgaWYgKHJ1bGVyLmdyb3VwZWQpIHtcbiAgICAgIGNvbnN0IHN0YWNrQ291bnQgPSBza2lwTnVsbCA/IHRoaXMuX2dldFN0YWNrQ291bnQoaW5kZXgpIDogcnVsZXIuc3RhY2tDb3VudDtcbiAgICAgIGNvbnN0IHJhbmdlID0gb3B0aW9ucy5iYXJUaGlja25lc3MgPT09ICdmbGV4J1xuICAgICAgICA/IGNvbXB1dGVGbGV4Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50KVxuICAgICAgICA6IGNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpO1xuXG4gICAgICBjb25zdCBzdGFja0luZGV4ID0gdGhpcy5fZ2V0U3RhY2tJbmRleCh0aGlzLmluZGV4LCB0aGlzLl9jYWNoZWRNZXRhLnN0YWNrLCBza2lwTnVsbCA/IGluZGV4IDogdW5kZWZpbmVkKTtcbiAgICAgIGNlbnRlciA9IHJhbmdlLnN0YXJ0ICsgKHJhbmdlLmNodW5rICogc3RhY2tJbmRleCkgKyAocmFuZ2UuY2h1bmsgLyAyKTtcbiAgICAgIHNpemUgPSBNYXRoLm1pbihtYXhCYXJUaGlja25lc3MsIHJhbmdlLmNodW5rICogcmFuZ2UucmF0aW8pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3Igbm9uLWdyb3VwZWQgYmFyIGNoYXJ0cywgZXhhY3QgcGl4ZWwgdmFsdWVzIGFyZSB1c2VkXG4gICAgICBjZW50ZXIgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0UGFyc2VkKGluZGV4KVtzY2FsZS5heGlzXSwgaW5kZXgpO1xuICAgICAgc2l6ZSA9IE1hdGgubWluKG1heEJhclRoaWNrbmVzcywgcnVsZXIubWluICogcnVsZXIucmF0aW8pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBiYXNlOiBjZW50ZXIgLSBzaXplIC8gMixcbiAgICAgIGhlYWQ6IGNlbnRlciArIHNpemUgLyAyLFxuICAgICAgY2VudGVyLFxuICAgICAgc2l6ZVxuICAgIH07XG4gIH1cblxuICBkcmF3KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHZTY2FsZSA9IG1ldGEudlNjYWxlO1xuICAgIGNvbnN0IHJlY3RzID0gbWV0YS5kYXRhO1xuICAgIGNvbnN0IGlsZW4gPSByZWN0cy5sZW5ndGg7XG4gICAgbGV0IGkgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGlmICh0aGlzLmdldFBhcnNlZChpKVt2U2NhbGUuYXhpc10gIT09IG51bGwpIHtcbiAgICAgICAgcmVjdHNbaV0uZHJhdyh0aGlzLl9jdHgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59XG4iLCAiaW1wb3J0IERhdGFzZXRDb250cm9sbGVyIGZyb20gJy4uL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyc7XG5pbXBvcnQge3ZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJ1YmJsZUNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ2J1YmJsZSc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcbiAgICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG5cbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBudW1iZXJzOiB7XG4gICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICdib3JkZXJXaWR0aCcsICdyYWRpdXMnXVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBvdmVycmlkZXMgPSB7XG4gICAgc2NhbGVzOiB7XG4gICAgICB4OiB7XG4gICAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgICB9LFxuICAgICAgeToge1xuICAgICAgICB0eXBlOiAnbGluZWFyJ1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBpbml0aWFsaXplKCkge1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFBhcnNlIGFycmF5IG9mIHByaW1pdGl2ZSB2YWx1ZXNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHN1cGVyLnBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwYXJzZWRbaV0uX2N1c3RvbSA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpICsgc3RhcnQpLnJhZGl1cztcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBQYXJzZSBhcnJheSBvZiBhcnJheXNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgcGFyc2VkID0gc3VwZXIucGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IGRhdGFbc3RhcnQgKyBpXTtcbiAgICAgIHBhcnNlZFtpXS5fY3VzdG9tID0gdmFsdWVPckRlZmF1bHQoaXRlbVsyXSwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkgKyBzdGFydCkucmFkaXVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBQYXJzZSBhcnJheSBvZiBvYmplY3RzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdXBlci5wYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IGRhdGFbc3RhcnQgKyBpXTtcbiAgICAgIHBhcnNlZFtpXS5fY3VzdG9tID0gdmFsdWVPckRlZmF1bHQoaXRlbSAmJiBpdGVtLnIgJiYgK2l0ZW0uciwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkgKyBzdGFydCkucmFkaXVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuXG4gICAgbGV0IG1heCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgZGF0YVtpXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKSkgLyAyKTtcbiAgICB9XG4gICAgcmV0dXJuIG1heCA+IDAgJiYgbWF4O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmNoYXJ0LmRhdGEubGFiZWxzIHx8IFtdO1xuICAgIGNvbnN0IHt4U2NhbGUsIHlTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICBjb25zdCB4ID0geFNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkLngpO1xuICAgIGNvbnN0IHkgPSB5U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWQueSk7XG4gICAgY29uc3QgciA9IHBhcnNlZC5fY3VzdG9tO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBsYWJlbHNbaW5kZXhdIHx8ICcnLFxuICAgICAgdmFsdWU6ICcoJyArIHggKyAnLCAnICsgeSArIChyID8gJywgJyArIHIgOiAnJykgKyAnKSdcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGE7XG5cbiAgICAvLyBVcGRhdGUgUG9pbnRzXG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIDAsIHBvaW50cy5sZW5ndGgsIG1vZGUpO1xuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlfSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfSA9IHRoaXMuX2dldFNoYXJlZE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcblxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBwYXJzZWQgPSAhcmVzZXQgJiYgdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge307XG4gICAgICBjb25zdCBpUGl4ZWwgPSBwcm9wZXJ0aWVzW2lBeGlzXSA9IHJlc2V0ID8gaVNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgwLjUpIDogaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW2lBeGlzXSk7XG4gICAgICBjb25zdCB2UGl4ZWwgPSBwcm9wZXJ0aWVzW3ZBeGlzXSA9IHJlc2V0ID8gdlNjYWxlLmdldEJhc2VQaXhlbCgpIDogdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW3ZBeGlzXSk7XG5cbiAgICAgIHByb3BlcnRpZXMuc2tpcCA9IGlzTmFOKGlQaXhlbCkgfHwgaXNOYU4odlBpeGVsKTtcblxuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG5cbiAgICAgICAgaWYgKHJlc2V0KSB7XG4gICAgICAgICAgcHJvcGVydGllcy5vcHRpb25zLnJhZGl1cyA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbbW9kZV1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICBsZXQgdmFsdWVzID0gc3VwZXIucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSk7XG5cbiAgICAvLyBJbiBjYXNlIHZhbHVlcyB3ZXJlIGNhY2hlZCAoYW5kIHRodXMgZnJvemVuKSwgd2UgbmVlZCB0byBjbG9uZSB0aGUgdmFsdWVzXG4gICAgaWYgKHZhbHVlcy4kc2hhcmVkKSB7XG4gICAgICB2YWx1ZXMgPSBPYmplY3QuYXNzaWduKHt9LCB2YWx1ZXMsIHskc2hhcmVkOiBmYWxzZX0pO1xuICAgIH1cblxuICAgIC8vIEN1c3RvbSByYWRpdXMgcmVzb2x1dGlvblxuICAgIGNvbnN0IHJhZGl1cyA9IHZhbHVlcy5yYWRpdXM7XG4gICAgaWYgKG1vZGUgIT09ICdhY3RpdmUnKSB7XG4gICAgICB2YWx1ZXMucmFkaXVzID0gMDtcbiAgICB9XG4gICAgdmFsdWVzLnJhZGl1cyArPSB2YWx1ZU9yRGVmYXVsdChwYXJzZWQgJiYgcGFyc2VkLl9jdXN0b20sIHJhZGl1cyk7XG5cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG59XG4iLCAiaW1wb3J0IERhdGFzZXRDb250cm9sbGVyIGZyb20gJy4uL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyc7XG5pbXBvcnQge2lzT2JqZWN0LCByZXNvbHZlT2JqZWN0S2V5LCB0b1BlcmNlbnRhZ2UsIHRvRGltZW5zaW9uLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtmb3JtYXROdW1iZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5pbnRsLmpzJztcbmltcG9ydCB7dG9SYWRpYW5zLCBQSSwgVEFVLCBIQUxGX1BJLCBfYW5nbGVCZXR3ZWVufSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL2NvcmUvY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKi9cblxuZnVuY3Rpb24gZ2V0UmF0aW9BbmRPZmZzZXQocm90YXRpb24sIGNpcmN1bWZlcmVuY2UsIGN1dG91dCkge1xuICBsZXQgcmF0aW9YID0gMTtcbiAgbGV0IHJhdGlvWSA9IDE7XG4gIGxldCBvZmZzZXRYID0gMDtcbiAgbGV0IG9mZnNldFkgPSAwO1xuICAvLyBJZiB0aGUgY2hhcnQncyBjaXJjdW1mZXJlbmNlIGlzbid0IGEgZnVsbCBjaXJjbGUsIGNhbGN1bGF0ZSBzaXplIGFzIGEgcmF0aW8gb2YgdGhlIHdpZHRoL2hlaWdodCBvZiB0aGUgYXJjXG4gIGlmIChjaXJjdW1mZXJlbmNlIDwgVEFVKSB7XG4gICAgY29uc3Qgc3RhcnRBbmdsZSA9IHJvdGF0aW9uO1xuICAgIGNvbnN0IGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2U7XG4gICAgY29uc3Qgc3RhcnRYID0gTWF0aC5jb3Moc3RhcnRBbmdsZSk7XG4gICAgY29uc3Qgc3RhcnRZID0gTWF0aC5zaW4oc3RhcnRBbmdsZSk7XG4gICAgY29uc3QgZW5kWCA9IE1hdGguY29zKGVuZEFuZ2xlKTtcbiAgICBjb25zdCBlbmRZID0gTWF0aC5zaW4oZW5kQW5nbGUpO1xuICAgIGNvbnN0IGNhbGNNYXggPSAoYW5nbGUsIGEsIGIpID0+IF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCB0cnVlKSA/IDEgOiBNYXRoLm1heChhLCBhICogY3V0b3V0LCBiLCBiICogY3V0b3V0KTtcbiAgICBjb25zdCBjYWxjTWluID0gKGFuZ2xlLCBhLCBiKSA9PiBfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgdHJ1ZSkgPyAtMSA6IE1hdGgubWluKGEsIGEgKiBjdXRvdXQsIGIsIGIgKiBjdXRvdXQpO1xuICAgIGNvbnN0IG1heFggPSBjYWxjTWF4KDAsIHN0YXJ0WCwgZW5kWCk7XG4gICAgY29uc3QgbWF4WSA9IGNhbGNNYXgoSEFMRl9QSSwgc3RhcnRZLCBlbmRZKTtcbiAgICBjb25zdCBtaW5YID0gY2FsY01pbihQSSwgc3RhcnRYLCBlbmRYKTtcbiAgICBjb25zdCBtaW5ZID0gY2FsY01pbihQSSArIEhBTEZfUEksIHN0YXJ0WSwgZW5kWSk7XG4gICAgcmF0aW9YID0gKG1heFggLSBtaW5YKSAvIDI7XG4gICAgcmF0aW9ZID0gKG1heFkgLSBtaW5ZKSAvIDI7XG4gICAgb2Zmc2V0WCA9IC0obWF4WCArIG1pblgpIC8gMjtcbiAgICBvZmZzZXRZID0gLShtYXhZICsgbWluWSkgLyAyO1xuICB9XG4gIHJldHVybiB7cmF0aW9YLCByYXRpb1ksIG9mZnNldFgsIG9mZnNldFl9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEb3VnaG51dENvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ2RvdWdobnV0JztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICAgIGRhdGFFbGVtZW50VHlwZTogJ2FyYycsXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICAvLyBCb29sZWFuIC0gV2hldGhlciB3ZSBhbmltYXRlIHRoZSByb3RhdGlvbiBvZiB0aGUgRG91Z2hudXRcbiAgICAgIGFuaW1hdGVSb3RhdGU6IHRydWUsXG4gICAgICAvLyBCb29sZWFuIC0gV2hldGhlciB3ZSBhbmltYXRlIHNjYWxpbmcgdGhlIERvdWdobnV0IGZyb20gdGhlIGNlbnRyZVxuICAgICAgYW5pbWF0ZVNjYWxlOiBmYWxzZVxuICAgIH0sXG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgbnVtYmVyczoge1xuICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgcHJvcGVydGllczogWydjaXJjdW1mZXJlbmNlJywgJ2VuZEFuZ2xlJywgJ2lubmVyUmFkaXVzJywgJ291dGVyUmFkaXVzJywgJ3N0YXJ0QW5nbGUnLCAneCcsICd5JywgJ29mZnNldCcsICdib3JkZXJXaWR0aCcsICdzcGFjaW5nJ11cbiAgICAgIH0sXG4gICAgfSxcbiAgICAvLyBUaGUgcGVyY2VudGFnZSBvZiB0aGUgY2hhcnQgdGhhdCB3ZSBjdXQgb3V0IG9mIHRoZSBtaWRkbGUuXG4gICAgY3V0b3V0OiAnNTAlJyxcblxuICAgIC8vIFRoZSByb3RhdGlvbiBvZiB0aGUgY2hhcnQsIHdoZXJlIHRoZSBmaXJzdCBkYXRhIGFyYyBiZWdpbnMuXG4gICAgcm90YXRpb246IDAsXG5cbiAgICAvLyBUaGUgdG90YWwgY2lyY3VtZmVyZW5jZSBvZiB0aGUgY2hhcnQuXG4gICAgY2lyY3VtZmVyZW5jZTogMzYwLFxuXG4gICAgLy8gVGhlIG91dGVyIHJhZGl1cyBvZiB0aGUgY2hhcnRcbiAgICByYWRpdXM6ICcxMDAlJyxcblxuICAgIC8vIFNwYWNpbmcgYmV0d2VlbiBhcmNzXG4gICAgc3BhY2luZzogMCxcblxuICAgIGluZGV4QXhpczogJ3InLFxuICB9O1xuXG4gIHN0YXRpYyBkZXNjcmlwdG9ycyA9IHtcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdzcGFjaW5nJyxcbiAgICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ3NwYWNpbmcnICYmICFuYW1lLnN0YXJ0c1dpdGgoJ2JvcmRlckRhc2gnKSAmJiAhbmFtZS5zdGFydHNXaXRoKCdob3ZlckJvcmRlckRhc2gnKSxcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBvdmVycmlkZXMgPSB7XG4gICAgYXNwZWN0UmF0aW86IDEsXG5cbiAgICAvLyBOZWVkIHRvIG92ZXJyaWRlIHRoZXNlIHRvIGdpdmUgYSBuaWNlIGRlZmF1bHRcbiAgICBwbHVnaW5zOiB7XG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgZ2VuZXJhdGVMYWJlbHMoY2hhcnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBjaGFydC5kYXRhO1xuICAgICAgICAgICAgaWYgKGRhdGEubGFiZWxzLmxlbmd0aCAmJiBkYXRhLmRhdGFzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBjb25zdCB7bGFiZWxzOiB7cG9pbnRTdHlsZSwgY29sb3J9fSA9IGNoYXJ0LmxlZ2VuZC5vcHRpb25zO1xuXG4gICAgICAgICAgICAgIHJldHVybiBkYXRhLmxhYmVscy5tYXAoKGxhYmVsLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKGkpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHRleHQ6IGxhYmVsLFxuICAgICAgICAgICAgICAgICAgZmlsbFN0eWxlOiBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogc3R5bGUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgICBmb250Q29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgICAgbGluZVdpZHRoOiBzdHlsZS5ib3JkZXJXaWR0aCxcbiAgICAgICAgICAgICAgICAgIHBvaW50U3R5bGU6IHBvaW50U3R5bGUsXG4gICAgICAgICAgICAgICAgICBoaWRkZW46ICFjaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSxcblxuICAgICAgICAgICAgICAgICAgLy8gRXh0cmEgZGF0YSB1c2VkIGZvciB0b2dnbGluZyB0aGUgY29ycmVjdCBpdGVtXG4gICAgICAgICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvbkNsaWNrKGUsIGxlZ2VuZEl0ZW0sIGxlZ2VuZCkge1xuICAgICAgICAgIGxlZ2VuZC5jaGFydC50b2dnbGVEYXRhVmlzaWJpbGl0eShsZWdlbmRJdGVtLmluZGV4KTtcbiAgICAgICAgICBsZWdlbmQuY2hhcnQudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY29uc3RydWN0b3IoY2hhcnQsIGRhdGFzZXRJbmRleCkge1xuICAgIHN1cGVyKGNoYXJ0LCBkYXRhc2V0SW5kZXgpO1xuXG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vZmZzZXRYID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub2Zmc2V0WSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGxpbmtTY2FsZXMoKSB7fVxuXG4gIC8qKlxuXHQgKiBPdmVycmlkZSBkYXRhIHBhcnNpbmcsIHNpbmNlIHdlIGFyZSBub3QgdXNpbmcgc2NhbGVzXG5cdCAqL1xuICBwYXJzZShzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5nZXREYXRhc2V0KCkuZGF0YTtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcblxuICAgIGlmICh0aGlzLl9wYXJzaW5nID09PSBmYWxzZSkge1xuICAgICAgbWV0YS5fcGFyc2VkID0gZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGdldHRlciA9IChpKSA9PiArZGF0YVtpXTtcblxuICAgICAgaWYgKGlzT2JqZWN0KGRhdGFbc3RhcnRdKSkge1xuICAgICAgICBjb25zdCB7a2V5ID0gJ3ZhbHVlJ30gPSB0aGlzLl9wYXJzaW5nO1xuICAgICAgICBnZXR0ZXIgPSAoaSkgPT4gK3Jlc29sdmVPYmplY3RLZXkoZGF0YVtpXSwga2V5KTtcbiAgICAgIH1cblxuICAgICAgbGV0IGksIGlsZW47XG4gICAgICBmb3IgKGkgPSBzdGFydCwgaWxlbiA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgICAgbWV0YS5fcGFyc2VkW2ldID0gZ2V0dGVyKGkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFJvdGF0aW9uKCkge1xuICAgIHJldHVybiB0b1JhZGlhbnModGhpcy5vcHRpb25zLnJvdGF0aW9uIC0gOTApO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0Q2lyY3VtZmVyZW5jZSgpIHtcbiAgICByZXR1cm4gdG9SYWRpYW5zKHRoaXMub3B0aW9ucy5jaXJjdW1mZXJlbmNlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXQgdGhlIG1heGltYWwgcm90YXRpb24gJiBjaXJjdW1mZXJlbmNlIGV4dGVudHNcblx0ICogYWNyb3NzIGFsbCB2aXNpYmxlIGRhdGFzZXRzLlxuXHQgKi9cbiAgX2dldFJvdGF0aW9uRXh0ZW50cygpIHtcbiAgICBsZXQgbWluID0gVEFVO1xuICAgIGxldCBtYXggPSAtVEFVO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmICh0aGlzLmNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkgJiYgdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YShpKS50eXBlID09PSB0aGlzLl90eXBlKSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKGkpLmNvbnRyb2xsZXI7XG4gICAgICAgIGNvbnN0IHJvdGF0aW9uID0gY29udHJvbGxlci5fZ2V0Um90YXRpb24oKTtcbiAgICAgICAgY29uc3QgY2lyY3VtZmVyZW5jZSA9IGNvbnRyb2xsZXIuX2dldENpcmN1bWZlcmVuY2UoKTtcblxuICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHJvdGF0aW9uKTtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCByb3RhdGlvbiArIGNpcmN1bWZlcmVuY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICByb3RhdGlvbjogbWluLFxuICAgICAgY2lyY3VtZmVyZW5jZTogbWF4IC0gbWluLFxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IG1vZGVcblx0ICovXG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IHtjaGFydEFyZWF9ID0gY2hhcnQ7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgYXJjcyA9IG1ldGEuZGF0YTtcbiAgICBjb25zdCBzcGFjaW5nID0gdGhpcy5nZXRNYXhCb3JkZXJXaWR0aCgpICsgdGhpcy5nZXRNYXhPZmZzZXQoYXJjcykgKyB0aGlzLm9wdGlvbnMuc3BhY2luZztcbiAgICBjb25zdCBtYXhTaXplID0gTWF0aC5tYXgoKE1hdGgubWluKGNoYXJ0QXJlYS53aWR0aCwgY2hhcnRBcmVhLmhlaWdodCkgLSBzcGFjaW5nKSAvIDIsIDApO1xuICAgIGNvbnN0IGN1dG91dCA9IE1hdGgubWluKHRvUGVyY2VudGFnZSh0aGlzLm9wdGlvbnMuY3V0b3V0LCBtYXhTaXplKSwgMSk7XG4gICAgY29uc3QgY2hhcnRXZWlnaHQgPSB0aGlzLl9nZXRSaW5nV2VpZ2h0KHRoaXMuaW5kZXgpO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgbWF4aW1hbCByb3RhdGlvbiAmIGNpcmN1bWZlcmVuY2UgbGltaXRzLlxuICAgIC8vIElmIHdlIG9ubHkgY29uc2lkZXIgb3VyIGRhdGFzZXQsIHRoaXMgY2FuIGNhdXNlIHByb2JsZW1zIHdoZW4gdHdvIGRhdGFzZXRzXG4gICAgLy8gYXJlIGJvdGggbGVzcyB0aGFuIGEgY2lyY2xlIHdpdGggZGlmZmVyZW50IHJvdGF0aW9ucyAoc3RhcnRpbmcgYW5nbGVzKVxuICAgIGNvbnN0IHtjaXJjdW1mZXJlbmNlLCByb3RhdGlvbn0gPSB0aGlzLl9nZXRSb3RhdGlvbkV4dGVudHMoKTtcbiAgICBjb25zdCB7cmF0aW9YLCByYXRpb1ksIG9mZnNldFgsIG9mZnNldFl9ID0gZ2V0UmF0aW9BbmRPZmZzZXQocm90YXRpb24sIGNpcmN1bWZlcmVuY2UsIGN1dG91dCk7XG4gICAgY29uc3QgbWF4V2lkdGggPSAoY2hhcnRBcmVhLndpZHRoIC0gc3BhY2luZykgLyByYXRpb1g7XG4gICAgY29uc3QgbWF4SGVpZ2h0ID0gKGNoYXJ0QXJlYS5oZWlnaHQgLSBzcGFjaW5nKSAvIHJhdGlvWTtcbiAgICBjb25zdCBtYXhSYWRpdXMgPSBNYXRoLm1heChNYXRoLm1pbihtYXhXaWR0aCwgbWF4SGVpZ2h0KSAvIDIsIDApO1xuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gdG9EaW1lbnNpb24odGhpcy5vcHRpb25zLnJhZGl1cywgbWF4UmFkaXVzKTtcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IE1hdGgubWF4KG91dGVyUmFkaXVzICogY3V0b3V0LCAwKTtcbiAgICBjb25zdCByYWRpdXNMZW5ndGggPSAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyB0aGlzLl9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsKCk7XG4gICAgdGhpcy5vZmZzZXRYID0gb2Zmc2V0WCAqIG91dGVyUmFkaXVzO1xuICAgIHRoaXMub2Zmc2V0WSA9IG9mZnNldFkgKiBvdXRlclJhZGl1cztcblxuICAgIG1ldGEudG90YWwgPSB0aGlzLmNhbGN1bGF0ZVRvdGFsKCk7XG5cbiAgICB0aGlzLm91dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSByYWRpdXNMZW5ndGggKiB0aGlzLl9nZXRSaW5nV2VpZ2h0T2Zmc2V0KHRoaXMuaW5kZXgpO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSBNYXRoLm1heCh0aGlzLm91dGVyUmFkaXVzIC0gcmFkaXVzTGVuZ3RoICogY2hhcnRXZWlnaHQsIDApO1xuXG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhhcmNzLCAwLCBhcmNzLmxlbmd0aCwgbW9kZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jaXJjdW1mZXJlbmNlKGksIHJlc2V0KSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBjaXJjdW1mZXJlbmNlID0gdGhpcy5fZ2V0Q2lyY3VtZmVyZW5jZSgpO1xuICAgIGlmICgocmVzZXQgJiYgb3B0cy5hbmltYXRpb24uYW5pbWF0ZVJvdGF0ZSkgfHwgIXRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkgfHwgbWV0YS5fcGFyc2VkW2ldID09PSBudWxsIHx8IG1ldGEuZGF0YVtpXS5oaWRkZW4pIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jYWxjdWxhdGVDaXJjdW1mZXJlbmNlKG1ldGEuX3BhcnNlZFtpXSAqIGNpcmN1bWZlcmVuY2UgLyBUQVUpO1xuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMoYXJjcywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBjaGFydEFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgY29uc3Qgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG4gICAgY29uc3QgYW5pbWF0aW9uT3B0cyA9IG9wdHMuYW5pbWF0aW9uO1xuICAgIGNvbnN0IGNlbnRlclggPSAoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMjtcbiAgICBjb25zdCBjZW50ZXJZID0gKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDI7XG4gICAgY29uc3QgYW5pbWF0ZVNjYWxlID0gcmVzZXQgJiYgYW5pbWF0aW9uT3B0cy5hbmltYXRlU2NhbGU7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSBhbmltYXRlU2NhbGUgPyAwIDogdGhpcy5pbm5lclJhZGl1cztcbiAgICBjb25zdCBvdXRlclJhZGl1cyA9IGFuaW1hdGVTY2FsZSA/IDAgOiB0aGlzLm91dGVyUmFkaXVzO1xuICAgIGNvbnN0IHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc30gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBsZXQgc3RhcnRBbmdsZSA9IHRoaXMuX2dldFJvdGF0aW9uKCk7XG4gICAgbGV0IGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhcnQ7ICsraSkge1xuICAgICAgc3RhcnRBbmdsZSArPSB0aGlzLl9jaXJjdW1mZXJlbmNlKGksIHJlc2V0KTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgICAgY29uc3QgY2lyY3VtZmVyZW5jZSA9IHRoaXMuX2NpcmN1bWZlcmVuY2UoaSwgcmVzZXQpO1xuICAgICAgY29uc3QgYXJjID0gYXJjc1tpXTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIHg6IGNlbnRlclggKyB0aGlzLm9mZnNldFgsXG4gICAgICAgIHk6IGNlbnRlclkgKyB0aGlzLm9mZnNldFksXG4gICAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICAgIGVuZEFuZ2xlOiBzdGFydEFuZ2xlICsgY2lyY3VtZmVyZW5jZSxcbiAgICAgICAgY2lyY3VtZmVyZW5jZSxcbiAgICAgICAgb3V0ZXJSYWRpdXMsXG4gICAgICAgIGlubmVyUmFkaXVzXG4gICAgICB9O1xuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIGFyYy5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgfVxuICAgICAgc3RhcnRBbmdsZSArPSBjaXJjdW1mZXJlbmNlO1xuXG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoYXJjLCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cblxuICBjYWxjdWxhdGVUb3RhbCgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBtZXRhRGF0YSA9IG1ldGEuZGF0YTtcbiAgICBsZXQgdG90YWwgPSAwO1xuICAgIGxldCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG1ldGFEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG1ldGEuX3BhcnNlZFtpXTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiAhaXNOYU4odmFsdWUpICYmIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkgJiYgIW1ldGFEYXRhW2ldLmhpZGRlbikge1xuICAgICAgICB0b3RhbCArPSBNYXRoLmFicyh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvdGFsO1xuICB9XG5cbiAgY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZSh2YWx1ZSkge1xuICAgIGNvbnN0IHRvdGFsID0gdGhpcy5fY2FjaGVkTWV0YS50b3RhbDtcbiAgICBpZiAodG90YWwgPiAwICYmICFpc05hTih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBUQVUgKiAoTWF0aC5hYnModmFsdWUpIC8gdG90YWwpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbGFiZWxzID0gY2hhcnQuZGF0YS5sYWJlbHMgfHwgW107XG4gICAgY29uc3QgdmFsdWUgPSBmb3JtYXROdW1iZXIobWV0YS5fcGFyc2VkW2luZGV4XSwgY2hhcnQub3B0aW9ucy5sb2NhbGUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBsYWJlbHNbaW5kZXhdIHx8ICcnLFxuICAgICAgdmFsdWUsXG4gICAgfTtcbiAgfVxuXG4gIGdldE1heEJvcmRlcldpZHRoKGFyY3MpIHtcbiAgICBsZXQgbWF4ID0gMDtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgbGV0IGksIGlsZW4sIG1ldGEsIGNvbnRyb2xsZXIsIG9wdGlvbnM7XG5cbiAgICBpZiAoIWFyY3MpIHtcbiAgICAgIC8vIEZpbmQgdGhlIG91dG1vc3QgdmlzaWJsZSBkYXRhc2V0XG4gICAgICBmb3IgKGkgPSAwLCBpbGVuID0gY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgICAgaWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcbiAgICAgICAgICBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICAgICAgYXJjcyA9IG1ldGEuZGF0YTtcbiAgICAgICAgICBjb250cm9sbGVyID0gbWV0YS5jb250cm9sbGVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFhcmNzKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIG9wdGlvbnMgPSBjb250cm9sbGVyLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSk7XG4gICAgICBpZiAob3B0aW9ucy5ib3JkZXJBbGlnbiAhPT0gJ2lubmVyJykge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIG9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMCwgb3B0aW9ucy5ob3ZlckJvcmRlcldpZHRoIHx8IDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF4O1xuICB9XG5cbiAgZ2V0TWF4T2Zmc2V0KGFyY3MpIHtcbiAgICBsZXQgbWF4ID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSk7XG4gICAgICBtYXggPSBNYXRoLm1heChtYXgsIG9wdGlvbnMub2Zmc2V0IHx8IDAsIG9wdGlvbnMuaG92ZXJPZmZzZXQgfHwgMCk7XG4gICAgfVxuICAgIHJldHVybiBtYXg7XG4gIH1cblxuICAvKipcblx0ICogR2V0IHJhZGl1cyBsZW5ndGggb2Zmc2V0IG9mIHRoZSBkYXRhc2V0IGluIHJlbGF0aW9uIHRvIHRoZSB2aXNpYmxlIGRhdGFzZXRzIHdlaWdodHMuIFRoaXMgYWxsb3dzIGRldGVybWluaW5nIHRoZSBpbm5lciBhbmQgb3V0ZXIgcmFkaXVzIGNvcnJlY3RseVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFJpbmdXZWlnaHRPZmZzZXQoZGF0YXNldEluZGV4KSB7XG4gICAgbGV0IHJpbmdXZWlnaHRPZmZzZXQgPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhc2V0SW5kZXg7ICsraSkge1xuICAgICAgaWYgKHRoaXMuY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuICAgICAgICByaW5nV2VpZ2h0T2Zmc2V0ICs9IHRoaXMuX2dldFJpbmdXZWlnaHQoaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJpbmdXZWlnaHRPZmZzZXQ7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRSaW5nV2VpZ2h0KGRhdGFzZXRJbmRleCkge1xuICAgIHJldHVybiBNYXRoLm1heCh2YWx1ZU9yRGVmYXVsdCh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS53ZWlnaHQsIDEpLCAwKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzdW0gb2YgYWxsIHZpc2libGUgZGF0YSBzZXQgd2VpZ2h0cy5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRSaW5nV2VpZ2h0T2Zmc2V0KHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHx8IDE7XG4gIH1cbn1cbiIsICJpbXBvcnQgRGF0YXNldENvbnRyb2xsZXIgZnJvbSAnLi4vY29yZS9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzJztcbmltcG9ydCB7aXNOdWxsT3JVbmRlZn0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge2lzTnVtYmVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge19nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzLCBfc2NhbGVSYW5nZXNDaGFuZ2VkfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZUNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ2xpbmUnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGRhdGFzZXRFbGVtZW50VHlwZTogJ2xpbmUnLFxuICAgIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcblxuICAgIHNob3dMaW5lOiB0cnVlLFxuICAgIHNwYW5HYXBzOiBmYWxzZSxcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBvdmVycmlkZXMgPSB7XG4gICAgc2NhbGVzOiB7XG4gICAgICBfaW5kZXhfOiB7XG4gICAgICAgIHR5cGU6ICdjYXRlZ29yeScsXG4gICAgICB9LFxuICAgICAgX3ZhbHVlXzoge1xuICAgICAgICB0eXBlOiAnbGluZWFyJyxcbiAgICAgIH0sXG4gICAgfVxuICB9O1xuXG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnN1cHBvcnRzRGVjaW1hdGlvbiA9IHRydWU7XG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICB9XG5cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7ZGF0YXNldDogbGluZSwgZGF0YTogcG9pbnRzID0gW10sIF9kYXRhc2V0fSA9IG1ldGE7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGFuaW1hdGlvbnNEaXNhYmxlZCA9IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZDtcbiAgICBsZXQge3N0YXJ0LCBjb3VudH0gPSBfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyhtZXRhLCBwb2ludHMsIGFuaW1hdGlvbnNEaXNhYmxlZCk7XG5cbiAgICB0aGlzLl9kcmF3U3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLl9kcmF3Q291bnQgPSBjb3VudDtcblxuICAgIGlmIChfc2NhbGVSYW5nZXNDaGFuZ2VkKG1ldGEpKSB7XG4gICAgICBzdGFydCA9IDA7XG4gICAgICBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIExpbmVcbiAgICBsaW5lLl9jaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgbGluZS5fZGF0YXNldEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICBsaW5lLl9kZWNpbWF0ZWQgPSAhIV9kYXRhc2V0Ll9kZWNpbWF0ZWQ7XG4gICAgbGluZS5wb2ludHMgPSBwb2ludHM7XG5cbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpO1xuICAgIGlmICghdGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG4gICAgICBvcHRpb25zLmJvcmRlcldpZHRoID0gMDtcbiAgICB9XG4gICAgb3B0aW9ucy5zZWdtZW50ID0gdGhpcy5vcHRpb25zLnNlZ21lbnQ7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50KGxpbmUsIHVuZGVmaW5lZCwge1xuICAgICAgYW5pbWF0ZWQ6ICFhbmltYXRpb25zRGlzYWJsZWQsXG4gICAgICBvcHRpb25zXG4gICAgfSwgbW9kZSk7XG5cbiAgICAvLyBVcGRhdGUgUG9pbnRzXG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSk7XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGUsIF9zdGFja2VkLCBfZGF0YXNldH0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc30gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgY29uc3Qge3NwYW5HYXBzLCBzZWdtZW50fSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBtYXhHYXBMZW5ndGggPSBpc051bWJlcihzcGFuR2FwcykgPyBzcGFuR2FwcyA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBjb25zdCBkaXJlY3RVcGRhdGUgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQgfHwgcmVzZXQgfHwgbW9kZSA9PT0gJ25vbmUnO1xuICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgY291bnQ7XG4gICAgY29uc3QgcG9pbnRzQ291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAgIGxldCBwcmV2UGFyc2VkID0gc3RhcnQgPiAwICYmIHRoaXMuZ2V0UGFyc2VkKHN0YXJ0IC0gMSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50c0NvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IGRpcmVjdFVwZGF0ZSA/IHBvaW50IDoge307XG5cbiAgICAgIGlmIChpIDwgc3RhcnQgfHwgaSA+PSBlbmQpIHtcbiAgICAgICAgcHJvcGVydGllcy5za2lwID0gdHJ1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGkpO1xuICAgICAgY29uc3QgbnVsbERhdGEgPSBpc051bGxPclVuZGVmKHBhcnNlZFt2QXhpc10pO1xuICAgICAgY29uc3QgaVBpeGVsID0gcHJvcGVydGllc1tpQXhpc10gPSBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbaUF4aXNdLCBpKTtcbiAgICAgIGNvbnN0IHZQaXhlbCA9IHByb3BlcnRpZXNbdkF4aXNdID0gcmVzZXQgfHwgbnVsbERhdGEgPyB2U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShfc3RhY2tlZCA/IHRoaXMuYXBwbHlTdGFjayh2U2NhbGUsIHBhcnNlZCwgX3N0YWNrZWQpIDogcGFyc2VkW3ZBeGlzXSwgaSk7XG5cbiAgICAgIHByb3BlcnRpZXMuc2tpcCA9IGlzTmFOKGlQaXhlbCkgfHwgaXNOYU4odlBpeGVsKSB8fCBudWxsRGF0YTtcbiAgICAgIHByb3BlcnRpZXMuc3RvcCA9IGkgPiAwICYmIChNYXRoLmFicyhwYXJzZWRbaUF4aXNdIC0gcHJldlBhcnNlZFtpQXhpc10pKSA+IG1heEdhcExlbmd0aDtcbiAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgIHByb3BlcnRpZXMucGFyc2VkID0gcGFyc2VkO1xuICAgICAgICBwcm9wZXJ0aWVzLnJhdyA9IF9kYXRhc2V0LmRhdGFbaV07XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRpcmVjdFVwZGF0ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgICAgfVxuXG4gICAgICBwcmV2UGFyc2VkID0gcGFyc2VkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhc2V0ID0gbWV0YS5kYXRhc2V0O1xuICAgIGNvbnN0IGJvcmRlciA9IGRhdGFzZXQub3B0aW9ucyAmJiBkYXRhc2V0Lm9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMDtcbiAgICBjb25zdCBkYXRhID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBib3JkZXI7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBkYXRhWzBdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKDApKTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoZGF0YS5sZW5ndGggLSAxKSk7XG4gICAgcmV0dXJuIE1hdGgubWF4KGJvcmRlciwgZmlyc3RQb2ludCwgbGFzdFBvaW50KSAvIDI7XG4gIH1cblxuICBkcmF3KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIG1ldGEuZGF0YXNldC51cGRhdGVDb250cm9sUG9pbnRzKHRoaXMuY2hhcnQuY2hhcnRBcmVhLCBtZXRhLmlTY2FsZS5heGlzKTtcbiAgICBzdXBlci5kcmF3KCk7XG4gIH1cbn1cbiIsICJpbXBvcnQgRGF0YXNldENvbnRyb2xsZXIgZnJvbSAnLi4vY29yZS9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzJztcbmltcG9ydCB7dG9SYWRpYW5zLCBQSSwgZm9ybWF0TnVtYmVyLCBfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGV9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2xhckFyZWFDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuXG4gIHN0YXRpYyBpZCA9ICdwb2xhckFyZWEnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGRhdGFFbGVtZW50VHlwZTogJ2FyYycsXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBhbmltYXRlUm90YXRlOiB0cnVlLFxuICAgICAgYW5pbWF0ZVNjYWxlOiB0cnVlXG4gICAgfSxcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBudW1iZXJzOiB7XG4gICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICdzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJywgJ2lubmVyUmFkaXVzJywgJ291dGVyUmFkaXVzJ11cbiAgICAgIH0sXG4gICAgfSxcbiAgICBpbmRleEF4aXM6ICdyJyxcbiAgICBzdGFydEFuZ2xlOiAwLFxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIG92ZXJyaWRlcyA9IHtcbiAgICBhc3BlY3RSYXRpbzogMSxcblxuICAgIHBsdWdpbnM6IHtcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICBnZW5lcmF0ZUxhYmVscyhjaGFydCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGNoYXJ0LmRhdGE7XG4gICAgICAgICAgICBpZiAoZGF0YS5sYWJlbHMubGVuZ3RoICYmIGRhdGEuZGF0YXNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHtsYWJlbHM6IHtwb2ludFN0eWxlLCBjb2xvcn19ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGRhdGEubGFiZWxzLm1hcCgobGFiZWwsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUoaSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgdGV4dDogbGFiZWwsXG4gICAgICAgICAgICAgICAgICBmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgICAgICAgIHN0cm9rZVN0eWxlOiBzdHlsZS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICAgIGZvbnRDb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IHN0eWxlLmJvcmRlcldpZHRoLFxuICAgICAgICAgICAgICAgICAgcG9pbnRTdHlsZTogcG9pbnRTdHlsZSxcbiAgICAgICAgICAgICAgICAgIGhpZGRlbjogIWNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpLFxuXG4gICAgICAgICAgICAgICAgICAvLyBFeHRyYSBkYXRhIHVzZWQgZm9yIHRvZ2dsaW5nIHRoZSBjb3JyZWN0IGl0ZW1cbiAgICAgICAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ2xpY2soZSwgbGVnZW5kSXRlbSwgbGVnZW5kKSB7XG4gICAgICAgICAgbGVnZW5kLmNoYXJ0LnRvZ2dsZURhdGFWaXNpYmlsaXR5KGxlZ2VuZEl0ZW0uaW5kZXgpO1xuICAgICAgICAgIGxlZ2VuZC5jaGFydC51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzY2FsZXM6IHtcbiAgICAgIHI6IHtcbiAgICAgICAgdHlwZTogJ3JhZGlhbExpbmVhcicsXG4gICAgICAgIGFuZ2xlTGluZXM6IHtcbiAgICAgICAgICBkaXNwbGF5OiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBiZWdpbkF0WmVybzogdHJ1ZSxcbiAgICAgICAgZ3JpZDoge1xuICAgICAgICAgIGNpcmN1bGFyOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50TGFiZWxzOiB7XG4gICAgICAgICAgZGlzcGxheTogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgc3RhcnRBbmdsZTogMFxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjb25zdHJ1Y3RvcihjaGFydCwgZGF0YXNldEluZGV4KSB7XG4gICAgc3VwZXIoY2hhcnQsIGRhdGFzZXRJbmRleCk7XG5cbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGxhYmVscyA9IGNoYXJ0LmRhdGEubGFiZWxzIHx8IFtdO1xuICAgIGNvbnN0IHZhbHVlID0gZm9ybWF0TnVtYmVyKG1ldGEuX3BhcnNlZFtpbmRleF0uciwgY2hhcnQub3B0aW9ucy5sb2NhbGUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBsYWJlbHNbaW5kZXhdIHx8ICcnLFxuICAgICAgdmFsdWUsXG4gICAgfTtcbiAgfVxuXG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICByZXR1cm4gX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlLmJpbmQodGhpcykobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgfVxuXG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgYXJjcyA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcblxuICAgIHRoaXMuX3VwZGF0ZVJhZGl1cygpO1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMoYXJjcywgMCwgYXJjcy5sZW5ndGgsIG1vZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGdldE1pbk1heCgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCByYW5nZSA9IHttaW46IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgbWF4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFl9O1xuXG4gICAgbWV0YS5kYXRhLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCkucjtcblxuICAgICAgaWYgKCFpc05hTihwYXJzZWQpICYmIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpKSB7XG4gICAgICAgIGlmIChwYXJzZWQgPCByYW5nZS5taW4pIHtcbiAgICAgICAgICByYW5nZS5taW4gPSBwYXJzZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyc2VkID4gcmFuZ2UubWF4KSB7XG4gICAgICAgICAgcmFuZ2UubWF4ID0gcGFyc2VkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVSYWRpdXMoKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICBjb25zdCBvcHRzID0gY2hhcnQub3B0aW9ucztcbiAgICBjb25zdCBtaW5TaXplID0gTWF0aC5taW4oY2hhcnRBcmVhLnJpZ2h0IC0gY2hhcnRBcmVhLmxlZnQsIGNoYXJ0QXJlYS5ib3R0b20gLSBjaGFydEFyZWEudG9wKTtcblxuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gTWF0aC5tYXgobWluU2l6ZSAvIDIsIDApO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gTWF0aC5tYXgob3B0cy5jdXRvdXRQZXJjZW50YWdlID8gKG91dGVyUmFkaXVzIC8gMTAwKSAqIChvcHRzLmN1dG91dFBlcmNlbnRhZ2UpIDogMSwgMCk7XG4gICAgY29uc3QgcmFkaXVzTGVuZ3RoID0gKG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMpIC8gY2hhcnQuZ2V0VmlzaWJsZURhdGFzZXRDb3VudCgpO1xuXG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzIC0gKHJhZGl1c0xlbmd0aCAqIHRoaXMuaW5kZXgpO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB0aGlzLm91dGVyUmFkaXVzIC0gcmFkaXVzTGVuZ3RoO1xuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMoYXJjcywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBvcHRzID0gY2hhcnQub3B0aW9ucztcbiAgICBjb25zdCBhbmltYXRpb25PcHRzID0gb3B0cy5hbmltYXRpb247XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLl9jYWNoZWRNZXRhLnJTY2FsZTtcbiAgICBjb25zdCBjZW50ZXJYID0gc2NhbGUueENlbnRlcjtcbiAgICBjb25zdCBjZW50ZXJZID0gc2NhbGUueUNlbnRlcjtcbiAgICBjb25zdCBkYXRhc2V0U3RhcnRBbmdsZSA9IHNjYWxlLmdldEluZGV4QW5nbGUoMCkgLSAwLjUgKiBQSTtcbiAgICBsZXQgYW5nbGUgPSBkYXRhc2V0U3RhcnRBbmdsZTtcbiAgICBsZXQgaTtcblxuICAgIGNvbnN0IGRlZmF1bHRBbmdsZSA9IDM2MCAvIHRoaXMuY291bnRWaXNpYmxlRWxlbWVudHMoKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzdGFydDsgKytpKSB7XG4gICAgICBhbmdsZSArPSB0aGlzLl9jb21wdXRlQW5nbGUoaSwgbW9kZSwgZGVmYXVsdEFuZ2xlKTtcbiAgICB9XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGFyYyA9IGFyY3NbaV07XG4gICAgICBsZXQgc3RhcnRBbmdsZSA9IGFuZ2xlO1xuICAgICAgbGV0IGVuZEFuZ2xlID0gYW5nbGUgKyB0aGlzLl9jb21wdXRlQW5nbGUoaSwgbW9kZSwgZGVmYXVsdEFuZ2xlKTtcbiAgICAgIGxldCBvdXRlclJhZGl1cyA9IGNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpID8gc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodGhpcy5nZXRQYXJzZWQoaSkucikgOiAwO1xuICAgICAgYW5nbGUgPSBlbmRBbmdsZTtcblxuICAgICAgaWYgKHJlc2V0KSB7XG4gICAgICAgIGlmIChhbmltYXRpb25PcHRzLmFuaW1hdGVTY2FsZSkge1xuICAgICAgICAgIG91dGVyUmFkaXVzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5pbWF0aW9uT3B0cy5hbmltYXRlUm90YXRlKSB7XG4gICAgICAgICAgc3RhcnRBbmdsZSA9IGVuZEFuZ2xlID0gZGF0YXNldFN0YXJ0QW5nbGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgeDogY2VudGVyWCxcbiAgICAgICAgeTogY2VudGVyWSxcbiAgICAgICAgaW5uZXJSYWRpdXM6IDAsXG4gICAgICAgIG91dGVyUmFkaXVzLFxuICAgICAgICBzdGFydEFuZ2xlLFxuICAgICAgICBlbmRBbmdsZSxcbiAgICAgICAgb3B0aW9uczogdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIGFyYy5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoYXJjLCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cblxuICBjb3VudFZpc2libGVFbGVtZW50cygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBsZXQgY291bnQgPSAwO1xuXG4gICAgbWV0YS5kYXRhLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoIWlzTmFOKHRoaXMuZ2V0UGFyc2VkKGluZGV4KS5yKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KSkge1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvdW50O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY29tcHV0ZUFuZ2xlKGluZGV4LCBtb2RlLCBkZWZhdWx0QW5nbGUpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleClcbiAgICAgID8gdG9SYWRpYW5zKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSkuYW5nbGUgfHwgZGVmYXVsdEFuZ2xlKVxuICAgICAgOiAwO1xuICB9XG59XG4iLCAiaW1wb3J0IERvdWdobnV0Q29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIuZG91Z2hudXQuanMnO1xuXG4vLyBQaWUgY2hhcnRzIGFyZSBEb3VnaG51dCBjaGFydCB3aXRoIGRpZmZlcmVudCBkZWZhdWx0c1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGllQ29udHJvbGxlciBleHRlbmRzIERvdWdobnV0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ3BpZSc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgLy8gVGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIGNoYXJ0IHRoYXQgd2UgY3V0IG91dCBvZiB0aGUgbWlkZGxlLlxuICAgIGN1dG91dDogMCxcblxuICAgIC8vIFRoZSByb3RhdGlvbiBvZiB0aGUgY2hhcnQsIHdoZXJlIHRoZSBmaXJzdCBkYXRhIGFyYyBiZWdpbnMuXG4gICAgcm90YXRpb246IDAsXG5cbiAgICAvLyBUaGUgdG90YWwgY2lyY3VtZmVyZW5jZSBvZiB0aGUgY2hhcnQuXG4gICAgY2lyY3VtZmVyZW5jZTogMzYwLFxuXG4gICAgLy8gVGhlIG91dGVyIHJhZGl1cyBvZiB0aGUgY2hhcnRcbiAgICByYWRpdXM6ICcxMDAlJ1xuICB9O1xufVxuIiwgImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuLi9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHtfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGV9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSYWRhckNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ3JhZGFyJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkYXRhc2V0RWxlbWVudFR5cGU6ICdsaW5lJyxcbiAgICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG4gICAgaW5kZXhBeGlzOiAncicsXG4gICAgc2hvd0xpbmU6IHRydWUsXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIGxpbmU6IHtcbiAgICAgICAgZmlsbDogJ3N0YXJ0J1xuICAgICAgfVxuICAgIH0sXG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuICAgIGFzcGVjdFJhdGlvOiAxLFxuXG4gICAgc2NhbGVzOiB7XG4gICAgICByOiB7XG4gICAgICAgIHR5cGU6ICdyYWRpYWxMaW5lYXInLFxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IHZTY2FsZSA9IHRoaXMuX2NhY2hlZE1ldGEudlNjYWxlO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcblxuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogdlNjYWxlLmdldExhYmVscygpW2luZGV4XSxcbiAgICAgIHZhbHVlOiAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pXG4gICAgfTtcbiAgfVxuXG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICByZXR1cm4gX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlLmJpbmQodGhpcykobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgfVxuXG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgbGluZSA9IG1ldGEuZGF0YXNldDtcbiAgICBjb25zdCBwb2ludHMgPSBtZXRhLmRhdGEgfHwgW107XG4gICAgY29uc3QgbGFiZWxzID0gbWV0YS5pU2NhbGUuZ2V0TGFiZWxzKCk7XG5cbiAgICAvLyBVcGRhdGUgTGluZVxuICAgIGxpbmUucG9pbnRzID0gcG9pbnRzO1xuICAgIC8vIEluIHJlc2l6ZSBtb2RlIG9ubHkgcG9pbnQgbG9jYXRpb25zIGNoYW5nZSwgc28gbm8gbmVlZCB0byBzZXQgdGhlIHBvaW50cyBvciBvcHRpb25zLlxuICAgIGlmIChtb2RlICE9PSAncmVzaXplJykge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKTtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG4gICAgICAgIG9wdGlvbnMuYm9yZGVyV2lkdGggPSAwO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBfbG9vcDogdHJ1ZSxcbiAgICAgICAgX2Z1bGxMb29wOiBsYWJlbHMubGVuZ3RoID09PSBwb2ludHMubGVuZ3RoLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQobGluZSwgdW5kZWZpbmVkLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgUG9pbnRzXG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIDAsIHBvaW50cy5sZW5ndGgsIG1vZGUpO1xuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuX2NhY2hlZE1ldGEuclNjYWxlO1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcblxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICBjb25zdCBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGksIHRoaXMuZ2V0UGFyc2VkKGkpLnIpO1xuXG4gICAgICBjb25zdCB4ID0gcmVzZXQgPyBzY2FsZS54Q2VudGVyIDogcG9pbnRQb3NpdGlvbi54O1xuICAgICAgY29uc3QgeSA9IHJlc2V0ID8gc2NhbGUueUNlbnRlciA6IHBvaW50UG9zaXRpb24ueTtcblxuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgYW5nbGU6IHBvaW50UG9zaXRpb24uYW5nbGUsXG4gICAgICAgIHNraXA6IGlzTmFOKHgpIHx8IGlzTmFOKHkpLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuLi9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHtpc051bGxPclVuZGVmfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7aXNOdW1iZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCB7X2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMsIF9zY2FsZVJhbmdlc0NoYW5nZWR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY2F0dGVyQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcblxuICBzdGF0aWMgaWQgPSAnc2NhdHRlcic7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcbiAgICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG4gICAgc2hvd0xpbmU6IGZhbHNlLFxuICAgIGZpbGw6IGZhbHNlXG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuXG4gICAgaW50ZXJhY3Rpb246IHtcbiAgICAgIG1vZGU6ICdwb2ludCdcbiAgICB9LFxuXG4gICAgc2NhbGVzOiB7XG4gICAgICB4OiB7XG4gICAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgICB9LFxuICAgICAgeToge1xuICAgICAgICB0eXBlOiAnbGluZWFyJ1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuY2hhcnQuZGF0YS5sYWJlbHMgfHwgW107XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IHggPSB4U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWQueCk7XG4gICAgY29uc3QgeSA9IHlTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZC55KTtcblxuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogbGFiZWxzW2luZGV4XSB8fCAnJyxcbiAgICAgIHZhbHVlOiAnKCcgKyB4ICsgJywgJyArIHkgKyAnKSdcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7ZGF0YTogcG9pbnRzID0gW119ID0gbWV0YTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgYW5pbWF0aW9uc0Rpc2FibGVkID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkO1xuICAgIGxldCB7c3RhcnQsIGNvdW50fSA9IF9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzKG1ldGEsIHBvaW50cywgYW5pbWF0aW9uc0Rpc2FibGVkKTtcblxuICAgIHRoaXMuX2RyYXdTdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuX2RyYXdDb3VudCA9IGNvdW50O1xuXG4gICAgaWYgKF9zY2FsZVJhbmdlc0NoYW5nZWQobWV0YSkpIHtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8xMTMzM1xuICAgICAgaWYgKCF0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSkge1xuICAgICAgICB0aGlzLmFkZEVsZW1lbnRzKCk7XG4gICAgICB9XG4gICAgICBjb25zdCB7ZGF0YXNldDogbGluZSwgX2RhdGFzZXR9ID0gbWV0YTtcblxuICAgICAgLy8gVXBkYXRlIExpbmVcbiAgICAgIGxpbmUuX2NoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICAgIGxpbmUuX2RhdGFzZXRJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICBsaW5lLl9kZWNpbWF0ZWQgPSAhIV9kYXRhc2V0Ll9kZWNpbWF0ZWQ7XG4gICAgICBsaW5lLnBvaW50cyA9IHBvaW50cztcblxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKTtcbiAgICAgIG9wdGlvbnMuc2VnbWVudCA9IHRoaXMub3B0aW9ucy5zZWdtZW50O1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGxpbmUsIHVuZGVmaW5lZCwge1xuICAgICAgICBhbmltYXRlZDogIWFuaW1hdGlvbnNEaXNhYmxlZCxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfSwgbW9kZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSkge1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzExMzMzXG4gICAgICBkZWxldGUgbWV0YS5kYXRhc2V0O1xuICAgICAgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgUG9pbnRzXG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSk7XG4gIH1cblxuICBhZGRFbGVtZW50cygpIHtcbiAgICBjb25zdCB7c2hvd0xpbmV9ID0gdGhpcy5vcHRpb25zO1xuXG4gICAgaWYgKCF0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSAmJiBzaG93TGluZSkge1xuICAgICAgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUgPSB0aGlzLmNoYXJ0LnJlZ2lzdHJ5LmdldEVsZW1lbnQoJ2xpbmUnKTtcbiAgICB9XG5cbiAgICBzdXBlci5hZGRFbGVtZW50cygpO1xuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlLCBfc3RhY2tlZCwgX2RhdGFzZXR9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBmaXJzdE9wdHMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGNvbnN0IHNoYXJlZE9wdGlvbnMgPSB0aGlzLmdldFNoYXJlZE9wdGlvbnMoZmlyc3RPcHRzKTtcbiAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IHRoaXMuaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucyk7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICAgIGNvbnN0IHtzcGFuR2Fwcywgc2VnbWVudH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWF4R2FwTGVuZ3RoID0gaXNOdW1iZXIoc3BhbkdhcHMpID8gc3BhbkdhcHMgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgY29uc3QgZGlyZWN0VXBkYXRlID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkIHx8IHJlc2V0IHx8IG1vZGUgPT09ICdub25lJztcbiAgICBsZXQgcHJldlBhcnNlZCA9IHN0YXJ0ID4gMCAmJiB0aGlzLmdldFBhcnNlZChzdGFydCAtIDEpO1xuXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGkpO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IGRpcmVjdFVwZGF0ZSA/IHBvaW50IDoge307XG4gICAgICBjb25zdCBudWxsRGF0YSA9IGlzTnVsbE9yVW5kZWYocGFyc2VkW3ZBeGlzXSk7XG4gICAgICBjb25zdCBpUGl4ZWwgPSBwcm9wZXJ0aWVzW2lBeGlzXSA9IGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHBhcnNlZFtpQXhpc10sIGkpO1xuICAgICAgY29uc3QgdlBpeGVsID0gcHJvcGVydGllc1t2QXhpc10gPSByZXNldCB8fCBudWxsRGF0YSA/IHZTY2FsZS5nZXRCYXNlUGl4ZWwoKSA6IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKF9zdGFja2VkID8gdGhpcy5hcHBseVN0YWNrKHZTY2FsZSwgcGFyc2VkLCBfc3RhY2tlZCkgOiBwYXJzZWRbdkF4aXNdLCBpKTtcblxuICAgICAgcHJvcGVydGllcy5za2lwID0gaXNOYU4oaVBpeGVsKSB8fCBpc05hTih2UGl4ZWwpIHx8IG51bGxEYXRhO1xuICAgICAgcHJvcGVydGllcy5zdG9wID0gaSA+IDAgJiYgKE1hdGguYWJzKHBhcnNlZFtpQXhpc10gLSBwcmV2UGFyc2VkW2lBeGlzXSkpID4gbWF4R2FwTGVuZ3RoO1xuICAgICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAgcHJvcGVydGllcy5wYXJzZWQgPSBwYXJzZWQ7XG4gICAgICAgIHByb3BlcnRpZXMucmF3ID0gX2RhdGFzZXQuZGF0YVtpXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZGlyZWN0VXBkYXRlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgICB9XG5cbiAgICAgIHByZXZQYXJzZWQgPSBwYXJzZWQ7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVTaGFyZWRPcHRpb25zKHNoYXJlZE9wdGlvbnMsIG1vZGUsIGZpcnN0T3B0cyk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YSA9IG1ldGEuZGF0YSB8fCBbXTtcblxuICAgIGlmICghdGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG4gICAgICBsZXQgbWF4ID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgZGF0YVtpXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKSkgLyAyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXggPiAwICYmIG1heDtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhc2V0ID0gbWV0YS5kYXRhc2V0O1xuICAgIGNvbnN0IGJvcmRlciA9IGRhdGFzZXQub3B0aW9ucyAmJiBkYXRhc2V0Lm9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMDtcblxuICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBib3JkZXI7XG4gICAgfVxuXG4gICAgY29uc3QgZmlyc3RQb2ludCA9IGRhdGFbMF0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoMCkpO1xuICAgIGNvbnN0IGxhc3RQb2ludCA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhkYXRhLmxlbmd0aCAtIDEpKTtcbiAgICByZXR1cm4gTWF0aC5tYXgoYm9yZGVyLCBmaXJzdFBvaW50LCBsYXN0UG9pbnQpIC8gMjtcbiAgfVxufVxuIiwgIi8qKlxuICogQG5hbWVzcGFjZSBDaGFydC5fYWRhcHRlcnNcbiAqIEBzaW5jZSAyLjguMFxuICogQHByaXZhdGVcbiAqL1xuXG5pbXBvcnQgdHlwZSB7QW55T2JqZWN0fSBmcm9tICcuLi90eXBlcy9iYXNpYy5qcyc7XG5pbXBvcnQgdHlwZSB7Q2hhcnRPcHRpb25zfSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5cbmV4cG9ydCB0eXBlIFRpbWVVbml0ID0gJ21pbGxpc2Vjb25kJyB8ICdzZWNvbmQnIHwgJ21pbnV0ZScgfCAnaG91cicgfCAnZGF5JyB8ICd3ZWVrJyB8ICdtb250aCcgfCAncXVhcnRlcicgfCAneWVhcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0ZUFkYXB0ZXI8VCBleHRlbmRzIEFueU9iamVjdCA9IEFueU9iamVjdD4ge1xuICByZWFkb25seSBvcHRpb25zOiBUO1xuICAvKipcbiAgICogV2lsbCBjYWxsZWQgd2l0aCBjaGFydCBvcHRpb25zIGFmdGVyIGFkYXB0ZXIgY3JlYXRpb24uXG4gICAqL1xuICBpbml0KHRoaXM6IERhdGVBZGFwdGVyPFQ+LCBjaGFydE9wdGlvbnM6IENoYXJ0T3B0aW9ucyk6IHZvaWQ7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbWFwIG9mIHRpbWUgZm9ybWF0cyBmb3IgdGhlIHN1cHBvcnRlZCBmb3JtYXR0aW5nIHVuaXRzIGRlZmluZWRcbiAgICogaW4gVW5pdCBhcyB3ZWxsIGFzICdkYXRldGltZScgcmVwcmVzZW50aW5nIGEgZGV0YWlsZWQgZGF0ZS90aW1lIHN0cmluZy5cbiAgICovXG4gIGZvcm1hdHModGhpczogRGF0ZUFkYXB0ZXI8VD4pOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICAvKipcbiAgICogUGFyc2VzIHRoZSBnaXZlbiBgdmFsdWVgIGFuZCByZXR1cm4gdGhlIGFzc29jaWF0ZWQgdGltZXN0YW1wLlxuICAgKiBAcGFyYW0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gcGFyc2UgKHVzdWFsbHkgY29tZXMgZnJvbSB0aGUgZGF0YSlcbiAgICogQHBhcmFtIFtmb3JtYXRdIC0gdGhlIGV4cGVjdGVkIGRhdGEgZm9ybWF0XG4gICAqL1xuICBwYXJzZSh0aGlzOiBEYXRlQWRhcHRlcjxUPiwgdmFsdWU6IHVua25vd24sIGZvcm1hdD86IFRpbWVVbml0KTogbnVtYmVyIHwgbnVsbDtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZvcm1hdHRlZCBkYXRlIGluIHRoZSBzcGVjaWZpZWQgYGZvcm1hdGAgZm9yIGEgZ2l2ZW4gYHRpbWVzdGFtcGAuXG4gICAqIEBwYXJhbSB0aW1lc3RhbXAgLSB0aGUgdGltZXN0YW1wIHRvIGZvcm1hdFxuICAgKiBAcGFyYW0gZm9ybWF0IC0gdGhlIGRhdGUvdGltZSB0b2tlblxuICAgKi9cbiAgZm9ybWF0KHRoaXM6IERhdGVBZGFwdGVyPFQ+LCB0aW1lc3RhbXA6IG51bWJlciwgZm9ybWF0OiBUaW1lVW5pdCk6IHN0cmluZztcbiAgLyoqXG4gICAqIEFkZHMgdGhlIHNwZWNpZmllZCBgYW1vdW50YCBvZiBgdW5pdGAgdG8gdGhlIGdpdmVuIGB0aW1lc3RhbXBgLlxuICAgKiBAcGFyYW0gdGltZXN0YW1wIC0gdGhlIGlucHV0IHRpbWVzdGFtcFxuICAgKiBAcGFyYW0gYW1vdW50IC0gdGhlIGFtb3VudCB0byBhZGRcbiAgICogQHBhcmFtIHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcbiAgICovXG4gIGFkZCh0aGlzOiBEYXRlQWRhcHRlcjxUPiwgdGltZXN0YW1wOiBudW1iZXIsIGFtb3VudDogbnVtYmVyLCB1bml0OiBUaW1lVW5pdCk6IG51bWJlcjtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBgdW5pdGAgYmV0d2VlbiB0aGUgZ2l2ZW4gdGltZXN0YW1wcy5cbiAgICogQHBhcmFtIGEgLSB0aGUgaW5wdXQgdGltZXN0YW1wIChyZWZlcmVuY2UpXG4gICAqIEBwYXJhbSBiIC0gdGhlIHRpbWVzdGFtcCB0byBzdWJ0cmFjdFxuICAgKiBAcGFyYW0gdW5pdCAtIHRoZSB1bml0IGFzIHN0cmluZ1xuICAgKi9cbiAgZGlmZih0aGlzOiBEYXRlQWRhcHRlcjxUPiwgYTogbnVtYmVyLCBiOiBudW1iZXIsIHVuaXQ6IFRpbWVVbml0KTogbnVtYmVyO1xuICAvKipcbiAgICogUmV0dXJucyBzdGFydCBvZiBgdW5pdGAgZm9yIHRoZSBnaXZlbiBgdGltZXN0YW1wYC5cbiAgICogQHBhcmFtIHRpbWVzdGFtcCAtIHRoZSBpbnB1dCB0aW1lc3RhbXBcbiAgICogQHBhcmFtIHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcbiAgICogQHBhcmFtIFt3ZWVrZGF5XSAtIHRoZSBJU08gZGF5IG9mIHRoZSB3ZWVrIHdpdGggMSBiZWluZyBNb25kYXlcbiAgICogYW5kIDcgYmVpbmcgU3VuZGF5IChvbmx5IG5lZWRlZCBpZiBwYXJhbSAqdW5pdCogaXMgYGlzb1dlZWtgKS5cbiAgICovXG4gIHN0YXJ0T2YodGhpczogRGF0ZUFkYXB0ZXI8VD4sIHRpbWVzdGFtcDogbnVtYmVyLCB1bml0OiBUaW1lVW5pdCB8ICdpc29XZWVrJywgd2Vla2RheT86IG51bWJlcik6IG51bWJlcjtcbiAgLyoqXG4gICAqIFJldHVybnMgZW5kIG9mIGB1bml0YCBmb3IgdGhlIGdpdmVuIGB0aW1lc3RhbXBgLlxuICAgKiBAcGFyYW0gdGltZXN0YW1wIC0gdGhlIGlucHV0IHRpbWVzdGFtcFxuICAgKiBAcGFyYW0gdW5pdCAtIHRoZSB1bml0IGFzIHN0cmluZ1xuICAgKi9cbiAgZW5kT2YodGhpczogRGF0ZUFkYXB0ZXI8VD4sIHRpbWVzdGFtcDogbnVtYmVyLCB1bml0OiBUaW1lVW5pdCB8ICdpc29XZWVrJyk6IG51bWJlcjtcbn1cblxuZnVuY3Rpb24gYWJzdHJhY3Q8VCA9IHZvaWQ+KCk6IFQge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZDogQ2hlY2sgdGhhdCBhIGNvbXBsZXRlIGRhdGUgYWRhcHRlciBpcyBwcm92aWRlZC4nKTtcbn1cblxuLyoqXG4gKiBEYXRlIGFkYXB0ZXIgKGN1cnJlbnQgdXNlZCBieSB0aGUgdGltZSBzY2FsZSlcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuX2FkYXB0ZXJzLl9kYXRlXG4gKiBAbWVtYmVyb2YgQ2hhcnQuX2FkYXB0ZXJzXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBEYXRlQWRhcHRlckJhc2UgaW1wbGVtZW50cyBEYXRlQWRhcHRlciB7XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIGRlZmF1bHQgZGF0ZSBhZGFwdGVyIG1ldGhvZHMuXG4gICAqIEFjY2VwdHMgdHlwZSBwYXJhbWV0ZXIgdG8gZGVmaW5lIG9wdGlvbnMgdHlwZS5cbiAgICogQGV4YW1wbGVcbiAgICogQ2hhcnQuX2FkYXB0ZXJzLl9kYXRlLm92ZXJyaWRlPHtteUFkYXB0ZXJPcHRpb246IHN0cmluZ30+KHtcbiAgICogICBpbml0KCkge1xuICAgKiAgICAgY29uc29sZS5sb2codGhpcy5vcHRpb25zLm15QWRhcHRlck9wdGlvbik7XG4gICAqICAgfVxuICAgKiB9KVxuICAgKi9cbiAgc3RhdGljIG92ZXJyaWRlPFQgZXh0ZW5kcyBBbnlPYmplY3QgPSBBbnlPYmplY3Q+KFxuICAgIG1lbWJlcnM6IFBhcnRpYWw8T21pdDxEYXRlQWRhcHRlcjxUPiwgJ29wdGlvbnMnPj5cbiAgKSB7XG4gICAgT2JqZWN0LmFzc2lnbihEYXRlQWRhcHRlckJhc2UucHJvdG90eXBlLCBtZW1iZXJzKTtcbiAgfVxuXG4gIHJlYWRvbmx5IG9wdGlvbnM6IEFueU9iamVjdDtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBBbnlPYmplY3QpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuICBpbml0KCkge31cblxuICBmb3JtYXRzKCk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4ge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgcGFyc2UoKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICBmb3JtYXQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIGFkZCgpOiBudW1iZXIge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgZGlmZigpOiBudW1iZXIge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgc3RhcnRPZigpOiBudW1iZXIge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgZW5kT2YoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9kYXRlOiBEYXRlQWRhcHRlckJhc2Vcbn07XG4iLCAiaW1wb3J0IHtfbG9va3VwQnlLZXksIF9ybG9va3VwQnlLZXl9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb2xsZWN0aW9uLmpzJztcbmltcG9ydCB7Z2V0UmVsYXRpdmVQb3NpdGlvbn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmRvbS5qcyc7XG5pbXBvcnQge19hbmdsZUJldHdlZW4sIGdldEFuZ2xlRnJvbVBvaW50fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge19pc1BvaW50SW5BcmVhfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLkNoYXJ0RXZlbnQgfSBDaGFydEV2ZW50XG4gKiBAdHlwZWRlZiB7e2F4aXM/OiBzdHJpbmcsIGludGVyc2VjdD86IGJvb2xlYW4sIGluY2x1ZGVJbnZpc2libGU/OiBib29sZWFufX0gSW50ZXJhY3Rpb25PcHRpb25zXG4gKiBAdHlwZWRlZiB7e2RhdGFzZXRJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyLCBlbGVtZW50OiBpbXBvcnQoJy4vY29yZS5lbGVtZW50LmpzJykuZGVmYXVsdH19IEludGVyYWN0aW9uSXRlbVxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuUG9pbnQgfSBQb2ludFxuICovXG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGRvIGJpbmFyeSBzZWFyY2ggd2hlbiBwb3NzaWJsZVxuICogQHBhcmFtIHtvYmplY3R9IG1ldGFzZXQgLSB0aGUgZGF0YXNldCBtZXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGlzIG1vZGUuIHh8eXx4eXxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gZmluZFxuICogQHBhcmFtIHtib29sZWFufSBbaW50ZXJzZWN0XSAtIHNob3VsZCB0aGUgZWxlbWVudCBpbnRlcnNlY3RcbiAqIEByZXR1cm5zIHt7bG86bnVtYmVyLCBoaTpudW1iZXJ9fSBpbmRpY2VzIHRvIHNlYXJjaCBkYXRhIGFycmF5IGJldHdlZW5cbiAqL1xuZnVuY3Rpb24gYmluYXJ5U2VhcmNoKG1ldGFzZXQsIGF4aXMsIHZhbHVlLCBpbnRlcnNlY3QpIHtcbiAgY29uc3Qge2NvbnRyb2xsZXIsIGRhdGEsIF9zb3J0ZWR9ID0gbWV0YXNldDtcbiAgY29uc3QgaVNjYWxlID0gY29udHJvbGxlci5fY2FjaGVkTWV0YS5pU2NhbGU7XG4gIGlmIChpU2NhbGUgJiYgYXhpcyA9PT0gaVNjYWxlLmF4aXMgJiYgYXhpcyAhPT0gJ3InICYmIF9zb3J0ZWQgJiYgZGF0YS5sZW5ndGgpIHtcbiAgICBjb25zdCBsb29rdXBNZXRob2QgPSBpU2NhbGUuX3JldmVyc2VQaXhlbHMgPyBfcmxvb2t1cEJ5S2V5IDogX2xvb2t1cEJ5S2V5O1xuICAgIGlmICghaW50ZXJzZWN0KSB7XG4gICAgICByZXR1cm4gbG9va3VwTWV0aG9kKGRhdGEsIGF4aXMsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRyb2xsZXIuX3NoYXJlZE9wdGlvbnMpIHtcbiAgICAgIC8vIF9zaGFyZWRPcHRpb25zIGluZGljYXRlcyB0aGF0IGVhY2ggZWxlbWVudCBoYXMgZXF1YWwgb3B0aW9ucyAtPiBlcXVhbCBwcm9wb3J0aW9uc1xuICAgICAgLy8gU28gd2UgY2FuIGRvIGEgcmFuZ2VkIGJpbmFyeSBzZWFyY2ggYmFzZWQgb24gdGhlIHJhbmdlIG9mIGZpcnN0IGVsZW1lbnQgYW5kXG4gICAgICAvLyBiZSBjb25maWRlbnQgdG8gZ2V0IHRoZSBmdWxsIHJhbmdlIG9mIGluZGljZXMgdGhhdCBjYW4gaW50ZXJzZWN0IHdpdGggdGhlIHZhbHVlLlxuICAgICAgY29uc3QgZWwgPSBkYXRhWzBdO1xuICAgICAgY29uc3QgcmFuZ2UgPSB0eXBlb2YgZWwuZ2V0UmFuZ2UgPT09ICdmdW5jdGlvbicgJiYgZWwuZ2V0UmFuZ2UoYXhpcyk7XG4gICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBsb29rdXBNZXRob2QoZGF0YSwgYXhpcywgdmFsdWUgLSByYW5nZSk7XG4gICAgICAgIGNvbnN0IGVuZCA9IGxvb2t1cE1ldGhvZChkYXRhLCBheGlzLCB2YWx1ZSArIHJhbmdlKTtcbiAgICAgICAgcmV0dXJuIHtsbzogc3RhcnQubG8sIGhpOiBlbmQuaGl9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBEZWZhdWx0IHRvIGFsbCBlbGVtZW50cywgd2hlbiBiaW5hcnkgc2VhcmNoIGNhbiBub3QgYmUgdXNlZC5cbiAgcmV0dXJuIHtsbzogMCwgaGk6IGRhdGEubGVuZ3RoIC0gMX07XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIHNlbGVjdCBjYW5kaWRhdGUgZWxlbWVudHMgZm9yIGludGVyYWN0aW9uXG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydFxuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhpcyBtb2RlLiB4fHl8eHl8clxuICogQHBhcmFtIHtQb2ludH0gcG9zaXRpb24gLSB0aGUgcG9pbnQgdG8gYmUgbmVhcmVzdCB0bywgaW4gcmVsYXRpdmUgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgLSB0aGUgY2FsbGJhY2sgdG8gZXhlY3V0ZSBmb3IgZWFjaCB2aXNpYmxlIGl0ZW1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ludGVyc2VjdF0gLSBjb25zaWRlciBpbnRlcnNlY3RpbmcgaXRlbXNcbiAqL1xuZnVuY3Rpb24gZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgaGFuZGxlciwgaW50ZXJzZWN0KSB7XG4gIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW2F4aXNdO1xuICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IG1ldGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGNvbnN0IHtpbmRleCwgZGF0YX0gPSBtZXRhc2V0c1tpXTtcbiAgICBjb25zdCB7bG8sIGhpfSA9IGJpbmFyeVNlYXJjaChtZXRhc2V0c1tpXSwgYXhpcywgdmFsdWUsIGludGVyc2VjdCk7XG4gICAgZm9yIChsZXQgaiA9IGxvOyBqIDw9IGhpOyArK2opIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBkYXRhW2pdO1xuICAgICAgaWYgKCFlbGVtZW50LnNraXApIHtcbiAgICAgICAgaGFuZGxlcihlbGVtZW50LCBpbmRleCwgaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2V0IGEgZGlzdGFuY2UgbWV0cmljIGZ1bmN0aW9uIGZvciB0d28gcG9pbnRzIGJhc2VkIG9uIHRoZVxuICogYXhpcyBtb2RlIHNldHRpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIC0gdGhlIGF4aXMgbW9kZS4geHx5fHh5fHJcbiAqL1xuZnVuY3Rpb24gZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzKGF4aXMpIHtcbiAgY29uc3QgdXNlWCA9IGF4aXMuaW5kZXhPZigneCcpICE9PSAtMTtcbiAgY29uc3QgdXNlWSA9IGF4aXMuaW5kZXhPZigneScpICE9PSAtMTtcblxuICByZXR1cm4gZnVuY3Rpb24ocHQxLCBwdDIpIHtcbiAgICBjb25zdCBkZWx0YVggPSB1c2VYID8gTWF0aC5hYnMocHQxLnggLSBwdDIueCkgOiAwO1xuICAgIGNvbnN0IGRlbHRhWSA9IHVzZVkgPyBNYXRoLmFicyhwdDEueSAtIHB0Mi55KSA6IDA7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhkZWx0YVgsIDIpICsgTWF0aC5wb3coZGVsdGFZLCAyKSk7XG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaXRlbXMgdGhhdCBpbnRlcnNlY3QgdGhlIGV2ZW50IHBvc2l0aW9uXG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydFxuICogQHBhcmFtIHtQb2ludH0gcG9zaXRpb24gLSB0aGUgcG9pbnQgdG8gYmUgbmVhcmVzdCB0bywgaW4gcmVsYXRpdmUgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIC0gdGhlIGF4aXMgbW9kZS4geHx5fHh5fHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIHRoZSBlbGVtZW50J3MgYW5pbWF0aW9uIHRhcmdldCBpbnN0ZWFkIG9mIGN1cnJlbnQgcG9zaXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVJbnZpc2libGVdIC0gaW5jbHVkZSBpbnZpc2libGUgcG9pbnRzIHRoYXQgYXJlIG91dHNpZGUgb2YgdGhlIGNoYXJ0IGFyZWFcbiAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSB0aGUgbmVhcmVzdCBpdGVtc1xuICovXG5mdW5jdGlvbiBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpIHtcbiAgY29uc3QgaXRlbXMgPSBbXTtcblxuICBpZiAoIWluY2x1ZGVJbnZpc2libGUgJiYgIWNoYXJ0LmlzUG9pbnRJbkFyZWEocG9zaXRpb24pKSB7XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG5cbiAgY29uc3QgZXZhbHVhdGlvbkZ1bmMgPSBmdW5jdGlvbihlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgaWYgKCFpbmNsdWRlSW52aXNpYmxlICYmICFfaXNQb2ludEluQXJlYShlbGVtZW50LCBjaGFydC5jaGFydEFyZWEsIDApKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdXNlRmluYWxQb3NpdGlvbikpIHtcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcbiAgICB9XG4gIH07XG5cbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgZXZhbHVhdGlvbkZ1bmMsIHRydWUpO1xuICByZXR1cm4gaXRlbXM7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaXRlbXMgbmVhcmVzdCB0byB0aGUgZXZlbnQgcG9zaXRpb24gZm9yIGEgcmFkaWFsIGNoYXJ0XG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byBsb29rIGF0IGVsZW1lbnRzIGZyb21cbiAqIEBwYXJhbSB7UG9pbnR9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG8sIGluIHJlbGF0aXZlIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGVzIGFsb25nIHdoaWNoIHRvIG1lYXN1cmUgZGlzdGFuY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIHRoZSBlbGVtZW50J3MgYW5pbWF0aW9uIHRhcmdldCBpbnN0ZWFkIG9mIGN1cnJlbnQgcG9zaXRpb25cbiAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSB0aGUgbmVhcmVzdCBpdGVtc1xuICovXG5mdW5jdGlvbiBnZXROZWFyZXN0UmFkaWFsSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGxldCBpdGVtcyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGV2YWx1YXRpb25GdW5jKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICBjb25zdCB7c3RhcnRBbmdsZSwgZW5kQW5nbGV9ID0gZWxlbWVudC5nZXRQcm9wcyhbJ3N0YXJ0QW5nbGUnLCAnZW5kQW5nbGUnXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3Qge2FuZ2xlfSA9IGdldEFuZ2xlRnJvbVBvaW50KGVsZW1lbnQsIHt4OiBwb3NpdGlvbi54LCB5OiBwb3NpdGlvbi55fSk7XG5cbiAgICBpZiAoX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpKSB7XG4gICAgICBpdGVtcy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSk7XG4gICAgfVxuICB9XG5cbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgZXZhbHVhdGlvbkZ1bmMpO1xuICByZXR1cm4gaXRlbXM7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaXRlbXMgbmVhcmVzdCB0byB0aGUgZXZlbnQgcG9zaXRpb24gZm9yIGEgY2FydGVzaWFuIGNoYXJ0XG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byBsb29rIGF0IGVsZW1lbnRzIGZyb21cbiAqIEBwYXJhbSB7UG9pbnR9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG8sIGluIHJlbGF0aXZlIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGVzIGFsb25nIHdoaWNoIHRvIG1lYXN1cmUgZGlzdGFuY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ludGVyc2VjdF0gLSBpZiB0cnVlLCBvbmx5IGNvbnNpZGVyIGl0ZW1zIHRoYXQgaW50ZXJzZWN0IHRoZSBwb3NpdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgdGhlIGVsZW1lbnQncyBhbmltYXRpb24gdGFyZ2V0IGluc3RlYWQgb2YgY3VycmVudCBwb3NpdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbaW5jbHVkZUludmlzaWJsZV0gLSBpbmNsdWRlIGludmlzaWJsZSBwb2ludHMgdGhhdCBhcmUgb3V0c2lkZSBvZiB0aGUgY2hhcnQgYXJlYVxuICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IHRoZSBuZWFyZXN0IGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGdldE5lYXJlc3RDYXJ0ZXNpYW5JdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSkge1xuICBsZXQgaXRlbXMgPSBbXTtcbiAgY29uc3QgZGlzdGFuY2VNZXRyaWMgPSBnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMoYXhpcyk7XG4gIGxldCBtaW5EaXN0YW5jZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblxuICBmdW5jdGlvbiBldmFsdWF0aW9uRnVuYyhlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgY29uc3QgaW5SYW5nZSA9IGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBpZiAoaW50ZXJzZWN0ICYmICFpblJhbmdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2VudGVyID0gZWxlbWVudC5nZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCBwb2ludEluQXJlYSA9ICEhaW5jbHVkZUludmlzaWJsZSB8fCBjaGFydC5pc1BvaW50SW5BcmVhKGNlbnRlcik7XG4gICAgaWYgKCFwb2ludEluQXJlYSAmJiAhaW5SYW5nZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGRpc3RhbmNlID0gZGlzdGFuY2VNZXRyaWMocG9zaXRpb24sIGNlbnRlcik7XG4gICAgaWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgIGl0ZW1zID0gW3tlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fV07XG4gICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgIH0gZWxzZSBpZiAoZGlzdGFuY2UgPT09IG1pbkRpc3RhbmNlKSB7XG4gICAgICAvLyBDYW4gaGF2ZSBtdWx0aXBsZSBpdGVtcyBhdCB0aGUgc2FtZSBkaXN0YW5jZSBpbiB3aGljaCBjYXNlIHdlIHNvcnQgYnkgc2l6ZVxuICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0pO1xuICAgIH1cbiAgfVxuXG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGV2YWx1YXRpb25GdW5jKTtcbiAgcmV0dXJuIGl0ZW1zO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGl0ZW1zIG5lYXJlc3QgdG8gdGhlIGV2ZW50IHBvc2l0aW9uIGNvbnNpZGVyaW5nIGFsbCB2aXNpYmxlIGl0ZW1zIGluIHRoZSBjaGFydFxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gbG9vayBhdCBlbGVtZW50cyBmcm9tXG4gKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvbiAtIHRoZSBwb2ludCB0byBiZSBuZWFyZXN0IHRvLCBpbiByZWxhdGl2ZSBjb29yZGluYXRlc1xuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhlcyBhbG9uZyB3aGljaCB0byBtZWFzdXJlIGRpc3RhbmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbnRlcnNlY3RdIC0gaWYgdHJ1ZSwgb25seSBjb25zaWRlciBpdGVtcyB0aGF0IGludGVyc2VjdCB0aGUgcG9zaXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIHRoZSBlbGVtZW50J3MgYW5pbWF0aW9uIHRhcmdldCBpbnN0ZWFkIG9mIGN1cnJlbnQgcG9zaXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVJbnZpc2libGVdIC0gaW5jbHVkZSBpbnZpc2libGUgcG9pbnRzIHRoYXQgYXJlIG91dHNpZGUgb2YgdGhlIGNoYXJ0IGFyZWFcbiAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSB0aGUgbmVhcmVzdCBpdGVtc1xuICovXG5mdW5jdGlvbiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpIHtcbiAgaWYgKCFpbmNsdWRlSW52aXNpYmxlICYmICFjaGFydC5pc1BvaW50SW5BcmVhKHBvc2l0aW9uKSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHJldHVybiBheGlzID09PSAncicgJiYgIWludGVyc2VjdFxuICAgID8gZ2V0TmVhcmVzdFJhZGlhbEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbilcbiAgICA6IGdldE5lYXJlc3RDYXJ0ZXNpYW5JdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaXRlbXMgbWF0Y2hpbmcgYWxvbmcgdGhlIGdpdmVuIFggb3IgWSBheGlzXG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byBsb29rIGF0IGVsZW1lbnRzIGZyb21cbiAqIEBwYXJhbSB7UG9pbnR9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG8sIGluIHJlbGF0aXZlIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGlzIHRvIG1hdGNoXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbnRlcnNlY3RdIC0gaWYgdHJ1ZSwgb25seSBjb25zaWRlciBpdGVtcyB0aGF0IGludGVyc2VjdCB0aGUgcG9zaXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIHRoZSBlbGVtZW50J3MgYW5pbWF0aW9uIHRhcmdldCBpbnN0ZWFkIG9mIGN1cnJlbnQgcG9zaXRpb25cbiAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSB0aGUgbmVhcmVzdCBpdGVtc1xuICovXG5mdW5jdGlvbiBnZXRBeGlzSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgY29uc3QgaXRlbXMgPSBbXTtcbiAgY29uc3QgcmFuZ2VNZXRob2QgPSBheGlzID09PSAneCcgPyAnaW5YUmFuZ2UnIDogJ2luWVJhbmdlJztcbiAgbGV0IGludGVyc2VjdHNJdGVtID0gZmFsc2U7XG5cbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpID0+IHtcbiAgICBpZiAoZWxlbWVudFtyYW5nZU1ldGhvZF0ocG9zaXRpb25bYXhpc10sIHVzZUZpbmFsUG9zaXRpb24pKSB7XG4gICAgICBpdGVtcy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSk7XG4gICAgICBpbnRlcnNlY3RzSXRlbSA9IGludGVyc2VjdHNJdGVtIHx8IGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIElmIHdlIHdhbnQgdG8gdHJpZ2dlciBvbiBhbiBpbnRlcnNlY3QgYW5kIHdlIGRvbid0IGhhdmUgYW55IGl0ZW1zXG4gIC8vIHRoYXQgaW50ZXJzZWN0IHRoZSBwb3NpdGlvbiwgcmV0dXJuIG5vdGhpbmdcbiAgaWYgKGludGVyc2VjdCAmJiAhaW50ZXJzZWN0c0l0ZW0pIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIGl0ZW1zO1xufVxuXG4vKipcbiAqIENvbnRhaW5zIGludGVyYWN0aW9uIHJlbGF0ZWQgZnVuY3Rpb25zXG4gKiBAbmFtZXNwYWNlIENoYXJ0LkludGVyYWN0aW9uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLy8gUGFydCBvZiB0aGUgcHVibGljIEFQSSB0byBmYWNpbGl0YXRlIGRldmVsb3BlcnMgY3JlYXRpbmcgdGhlaXIgb3duIG1vZGVzXG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyxcblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gZm9yIGRpZmZlcmVudCBtb2Rlc1xuICBtb2Rlczoge1xuICAgIC8qKlxuXHRcdCAqIFJldHVybnMgaXRlbXMgYXQgdGhlIHNhbWUgaW5kZXguIElmIHRoZSBvcHRpb25zLmludGVyc2VjdCBwYXJhbWV0ZXIgaXMgdHJ1ZSwgd2Ugb25seSByZXR1cm4gaXRlbXMgaWYgd2UgaW50ZXJzZWN0IHNvbWV0aGluZ1xuXHRcdCAqIElmIHRoZSBvcHRpb25zLmludGVyc2VjdCBtb2RlIGlzIGZhbHNlLCB3ZSBmaW5kIHRoZSBuZWFyZXN0IGl0ZW0gYW5kIHJldHVybiB0aGUgaXRlbXMgYXQgdGhlIHNhbWUgaW5kZXggYXMgdGhhdCBpdGVtXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmluZGV4XG5cdFx0ICogQHNpbmNlIHYyLjQuMFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIGZpbmFsIGVsZW1lbnQgcG9zaXRpb24gKGFuaW1hdGlvbiB0YXJnZXQpXG5cdFx0ICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IC0gaXRlbXMgdGhhdCBhcmUgZm91bmRcblx0XHQgKi9cbiAgICBpbmRleChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIC8vIERlZmF1bHQgYXhpcyBmb3IgaW5kZXggbW9kZSBpcyAneCcgdG8gbWF0Y2ggb2xkIGJlaGF2aW91clxuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneCc7XG4gICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xuICAgICAgY29uc3QgaXRlbXMgPSBvcHRpb25zLmludGVyc2VjdFxuICAgICAgICA/IGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSlcbiAgICAgICAgOiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBmYWxzZSwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG4gICAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuXG4gICAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKS5mb3JFYWNoKChtZXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gaXRlbXNbMF0uaW5kZXg7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBtZXRhLmRhdGFbaW5kZXhdO1xuXG4gICAgICAgIC8vIGRvbid0IGNvdW50IGl0ZW1zIHRoYXQgYXJlIHNraXBwZWQgKG51bGwgZGF0YSlcbiAgICAgICAgaWYgKGVsZW1lbnQgJiYgIWVsZW1lbnQuc2tpcCkge1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleDogbWV0YS5pbmRleCwgaW5kZXh9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICB9LFxuXG4gICAgLyoqXG5cdFx0ICogUmV0dXJucyBpdGVtcyBpbiB0aGUgc2FtZSBkYXRhc2V0LiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgcGFyYW1ldGVyIGlzIHRydWUsIHdlIG9ubHkgcmV0dXJuIGl0ZW1zIGlmIHdlIGludGVyc2VjdCBzb21ldGhpbmdcblx0XHQgKiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgaXMgZmFsc2UsIHdlIGZpbmQgdGhlIG5lYXJlc3QgaXRlbSBhbmQgcmV0dXJuIHRoZSBpdGVtcyBpbiB0aGF0IGRhdGFzZXRcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMuZGF0YXNldFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIGZpbmFsIGVsZW1lbnQgcG9zaXRpb24gKGFuaW1hdGlvbiB0YXJnZXQpXG5cdFx0ICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IC0gaXRlbXMgdGhhdCBhcmUgZm91bmRcblx0XHQgKi9cbiAgICBkYXRhc2V0KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuICAgICAgY29uc3QgaW5jbHVkZUludmlzaWJsZSA9IG9wdGlvbnMuaW5jbHVkZUludmlzaWJsZSB8fCBmYWxzZTtcbiAgICAgIGxldCBpdGVtcyA9IG9wdGlvbnMuaW50ZXJzZWN0XG4gICAgICAgID8gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKSA6XG4gICAgICAgIGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGZhbHNlLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcblxuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgZGF0YXNldEluZGV4ID0gaXRlbXNbMF0uZGF0YXNldEluZGV4O1xuICAgICAgICBjb25zdCBkYXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5kYXRhO1xuICAgICAgICBpdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKHtlbGVtZW50OiBkYXRhW2ldLCBkYXRhc2V0SW5kZXgsIGluZGV4OiBpfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH0sXG5cbiAgICAvKipcblx0XHQgKiBQb2ludCBtb2RlIHJldHVybnMgYWxsIGVsZW1lbnRzIHRoYXQgaGl0IHRlc3QgYmFzZWQgb24gdGhlIGV2ZW50IHBvc2l0aW9uXG5cdFx0ICogb2YgdGhlIGV2ZW50XG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmludGVyc2VjdFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIGZpbmFsIGVsZW1lbnQgcG9zaXRpb24gKGFuaW1hdGlvbiB0YXJnZXQpXG5cdFx0ICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IC0gaXRlbXMgdGhhdCBhcmUgZm91bmRcblx0XHQgKi9cbiAgICBwb2ludChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIGNvbnN0IGF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3h5JztcbiAgICAgIGNvbnN0IGluY2x1ZGVJbnZpc2libGUgPSBvcHRpb25zLmluY2x1ZGVJbnZpc2libGUgfHwgZmFsc2U7XG4gICAgICByZXR1cm4gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcbiAgICB9LFxuXG4gICAgLyoqXG5cdFx0ICogbmVhcmVzdCBtb2RlIHJldHVybnMgdGhlIGVsZW1lbnQgY2xvc2VzdCB0byB0aGUgcG9pbnRcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMuaW50ZXJzZWN0XG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0ge0ludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgZmluYWwgZWxlbWVudCBwb3NpdGlvbiAoYW5pbWF0aW9uIHRhcmdldClcblx0XHQgKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gLSBpdGVtcyB0aGF0IGFyZSBmb3VuZFxuXHRcdCAqL1xuICAgIG5lYXJlc3QoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG4gICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xuICAgICAgcmV0dXJuIGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIG9wdGlvbnMuaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcbiAgICB9LFxuXG4gICAgLyoqXG5cdFx0ICogeCBtb2RlIHJldHVybnMgdGhlIGVsZW1lbnRzIHRoYXQgaGl0LXRlc3QgYXQgdGhlIGN1cnJlbnQgeCBjb29yZGluYXRlXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLnhcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSBmaW5hbCBlbGVtZW50IHBvc2l0aW9uIChhbmltYXRpb24gdGFyZ2V0KVxuXHRcdCAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSAtIGl0ZW1zIHRoYXQgYXJlIGZvdW5kXG5cdFx0ICovXG4gICAgeChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIHJldHVybiBnZXRBeGlzSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCAneCcsIG9wdGlvbnMuaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG5cdFx0ICogeSBtb2RlIHJldHVybnMgdGhlIGVsZW1lbnRzIHRoYXQgaGl0LXRlc3QgYXQgdGhlIGN1cnJlbnQgeSBjb29yZGluYXRlXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLnlcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSBmaW5hbCBlbGVtZW50IHBvc2l0aW9uIChhbmltYXRpb24gdGFyZ2V0KVxuXHRcdCAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSAtIGl0ZW1zIHRoYXQgYXJlIGZvdW5kXG5cdFx0ICovXG4gICAgeShjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIHJldHVybiBnZXRBeGlzSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCAneScsIG9wdGlvbnMuaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9XG4gIH1cbn07XG4iLCAiaW1wb3J0IHtkZWZpbmVkLCBlYWNoLCBpc09iamVjdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHt0b1BhZGRpbmd9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqL1xuXG5jb25zdCBTVEFUSUNfUE9TSVRJT05TID0gWydsZWZ0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nXTtcblxuZnVuY3Rpb24gZmlsdGVyQnlQb3NpdGlvbihhcnJheSwgcG9zaXRpb24pIHtcbiAgcmV0dXJuIGFycmF5LmZpbHRlcih2ID0+IHYucG9zID09PSBwb3NpdGlvbik7XG59XG5cbmZ1bmN0aW9uIGZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyhhcnJheSwgYXhpcykge1xuICByZXR1cm4gYXJyYXkuZmlsdGVyKHYgPT4gU1RBVElDX1BPU0lUSU9OUy5pbmRleE9mKHYucG9zKSA9PT0gLTEgJiYgdi5ib3guYXhpcyA9PT0gYXhpcyk7XG59XG5cbmZ1bmN0aW9uIHNvcnRCeVdlaWdodChhcnJheSwgcmV2ZXJzZSkge1xuICByZXR1cm4gYXJyYXkuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IHYwID0gcmV2ZXJzZSA/IGIgOiBhO1xuICAgIGNvbnN0IHYxID0gcmV2ZXJzZSA/IGEgOiBiO1xuICAgIHJldHVybiB2MC53ZWlnaHQgPT09IHYxLndlaWdodCA/XG4gICAgICB2MC5pbmRleCAtIHYxLmluZGV4IDpcbiAgICAgIHYwLndlaWdodCAtIHYxLndlaWdodDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHdyYXBCb3hlcyhib3hlcykge1xuICBjb25zdCBsYXlvdXRCb3hlcyA9IFtdO1xuICBsZXQgaSwgaWxlbiwgYm94LCBwb3MsIHN0YWNrLCBzdGFja1dlaWdodDtcblxuICBmb3IgKGkgPSAwLCBpbGVuID0gKGJveGVzIHx8IFtdKS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBib3ggPSBib3hlc1tpXTtcbiAgICAoe3Bvc2l0aW9uOiBwb3MsIG9wdGlvbnM6IHtzdGFjaywgc3RhY2tXZWlnaHQgPSAxfX0gPSBib3gpO1xuICAgIGxheW91dEJveGVzLnB1c2goe1xuICAgICAgaW5kZXg6IGksXG4gICAgICBib3gsXG4gICAgICBwb3MsXG4gICAgICBob3Jpem9udGFsOiBib3guaXNIb3Jpem9udGFsKCksXG4gICAgICB3ZWlnaHQ6IGJveC53ZWlnaHQsXG4gICAgICBzdGFjazogc3RhY2sgJiYgKHBvcyArIHN0YWNrKSxcbiAgICAgIHN0YWNrV2VpZ2h0XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGxheW91dEJveGVzO1xufVxuXG5mdW5jdGlvbiBidWlsZFN0YWNrcyhsYXlvdXRzKSB7XG4gIGNvbnN0IHN0YWNrcyA9IHt9O1xuICBmb3IgKGNvbnN0IHdyYXAgb2YgbGF5b3V0cykge1xuICAgIGNvbnN0IHtzdGFjaywgcG9zLCBzdGFja1dlaWdodH0gPSB3cmFwO1xuICAgIGlmICghc3RhY2sgfHwgIVNUQVRJQ19QT1NJVElPTlMuaW5jbHVkZXMocG9zKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IF9zdGFjayA9IHN0YWNrc1tzdGFja10gfHwgKHN0YWNrc1tzdGFja10gPSB7Y291bnQ6IDAsIHBsYWNlZDogMCwgd2VpZ2h0OiAwLCBzaXplOiAwfSk7XG4gICAgX3N0YWNrLmNvdW50Kys7XG4gICAgX3N0YWNrLndlaWdodCArPSBzdGFja1dlaWdodDtcbiAgfVxuICByZXR1cm4gc3RhY2tzO1xufVxuXG4vKipcbiAqIHN0b3JlIGRpbWVuc2lvbnMgdXNlZCBpbnN0ZWFkIG9mIGF2YWlsYWJsZSBjaGFydEFyZWEgaW4gZml0Qm94ZXNcbiAqKi9cbmZ1bmN0aW9uIHNldExheW91dERpbXMobGF5b3V0cywgcGFyYW1zKSB7XG4gIGNvbnN0IHN0YWNrcyA9IGJ1aWxkU3RhY2tzKGxheW91dHMpO1xuICBjb25zdCB7dkJveE1heFdpZHRoLCBoQm94TWF4SGVpZ2h0fSA9IHBhcmFtcztcbiAgbGV0IGksIGlsZW4sIGxheW91dDtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGxheW91dHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgbGF5b3V0ID0gbGF5b3V0c1tpXTtcbiAgICBjb25zdCB7ZnVsbFNpemV9ID0gbGF5b3V0LmJveDtcbiAgICBjb25zdCBzdGFjayA9IHN0YWNrc1tsYXlvdXQuc3RhY2tdO1xuICAgIGNvbnN0IGZhY3RvciA9IHN0YWNrICYmIGxheW91dC5zdGFja1dlaWdodCAvIHN0YWNrLndlaWdodDtcbiAgICBpZiAobGF5b3V0Lmhvcml6b250YWwpIHtcbiAgICAgIGxheW91dC53aWR0aCA9IGZhY3RvciA/IGZhY3RvciAqIHZCb3hNYXhXaWR0aCA6IGZ1bGxTaXplICYmIHBhcmFtcy5hdmFpbGFibGVXaWR0aDtcbiAgICAgIGxheW91dC5oZWlnaHQgPSBoQm94TWF4SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXlvdXQud2lkdGggPSB2Qm94TWF4V2lkdGg7XG4gICAgICBsYXlvdXQuaGVpZ2h0ID0gZmFjdG9yID8gZmFjdG9yICogaEJveE1heEhlaWdodCA6IGZ1bGxTaXplICYmIHBhcmFtcy5hdmFpbGFibGVIZWlnaHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdGFja3M7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkTGF5b3V0Qm94ZXMoYm94ZXMpIHtcbiAgY29uc3QgbGF5b3V0Qm94ZXMgPSB3cmFwQm94ZXMoYm94ZXMpO1xuICBjb25zdCBmdWxsU2l6ZSA9IHNvcnRCeVdlaWdodChsYXlvdXRCb3hlcy5maWx0ZXIod3JhcCA9PiB3cmFwLmJveC5mdWxsU2l6ZSksIHRydWUpO1xuICBjb25zdCBsZWZ0ID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdsZWZ0JyksIHRydWUpO1xuICBjb25zdCByaWdodCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAncmlnaHQnKSk7XG4gIGNvbnN0IHRvcCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAndG9wJyksIHRydWUpO1xuICBjb25zdCBib3R0b20gPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ2JvdHRvbScpKTtcbiAgY29uc3QgY2VudGVySG9yaXpvbnRhbCA9IGZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyhsYXlvdXRCb3hlcywgJ3gnKTtcbiAgY29uc3QgY2VudGVyVmVydGljYWwgPSBmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMobGF5b3V0Qm94ZXMsICd5Jyk7XG5cbiAgcmV0dXJuIHtcbiAgICBmdWxsU2l6ZSxcbiAgICBsZWZ0QW5kVG9wOiBsZWZ0LmNvbmNhdCh0b3ApLFxuICAgIHJpZ2h0QW5kQm90dG9tOiByaWdodC5jb25jYXQoY2VudGVyVmVydGljYWwpLmNvbmNhdChib3R0b20pLmNvbmNhdChjZW50ZXJIb3Jpem9udGFsKSxcbiAgICBjaGFydEFyZWE6IGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdjaGFydEFyZWEnKSxcbiAgICB2ZXJ0aWNhbDogbGVmdC5jb25jYXQocmlnaHQpLmNvbmNhdChjZW50ZXJWZXJ0aWNhbCksXG4gICAgaG9yaXpvbnRhbDogdG9wLmNvbmNhdChib3R0b20pLmNvbmNhdChjZW50ZXJIb3Jpem9udGFsKVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsIGEsIGIpIHtcbiAgcmV0dXJuIE1hdGgubWF4KG1heFBhZGRpbmdbYV0sIGNoYXJ0QXJlYVthXSkgKyBNYXRoLm1heChtYXhQYWRkaW5nW2JdLCBjaGFydEFyZWFbYl0pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVNYXhQYWRkaW5nKG1heFBhZGRpbmcsIGJveFBhZGRpbmcpIHtcbiAgbWF4UGFkZGluZy50b3AgPSBNYXRoLm1heChtYXhQYWRkaW5nLnRvcCwgYm94UGFkZGluZy50b3ApO1xuICBtYXhQYWRkaW5nLmxlZnQgPSBNYXRoLm1heChtYXhQYWRkaW5nLmxlZnQsIGJveFBhZGRpbmcubGVmdCk7XG4gIG1heFBhZGRpbmcuYm90dG9tID0gTWF0aC5tYXgobWF4UGFkZGluZy5ib3R0b20sIGJveFBhZGRpbmcuYm90dG9tKTtcbiAgbWF4UGFkZGluZy5yaWdodCA9IE1hdGgubWF4KG1heFBhZGRpbmcucmlnaHQsIGJveFBhZGRpbmcucmlnaHQpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVEaW1zKGNoYXJ0QXJlYSwgcGFyYW1zLCBsYXlvdXQsIHN0YWNrcykge1xuICBjb25zdCB7cG9zLCBib3h9ID0gbGF5b3V0O1xuICBjb25zdCBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XG5cbiAgLy8gZHluYW1pY2FsbHkgcGxhY2VkIGJveGVzIHNpemUgaXMgbm90IGNvbnNpZGVyZWRcbiAgaWYgKCFpc09iamVjdChwb3MpKSB7XG4gICAgaWYgKGxheW91dC5zaXplKSB7XG4gICAgICAvLyB0aGlzIGxheW91dCB3YXMgYWxyZWFkeSBjb3VudGVkIGZvciwgbGV0cyBmaXJzdCByZWR1Y2Ugb2xkIHNpemVcbiAgICAgIGNoYXJ0QXJlYVtwb3NdIC09IGxheW91dC5zaXplO1xuICAgIH1cbiAgICBjb25zdCBzdGFjayA9IHN0YWNrc1tsYXlvdXQuc3RhY2tdIHx8IHtzaXplOiAwLCBjb3VudDogMX07XG4gICAgc3RhY2suc2l6ZSA9IE1hdGgubWF4KHN0YWNrLnNpemUsIGxheW91dC5ob3Jpem9udGFsID8gYm94LmhlaWdodCA6IGJveC53aWR0aCk7XG4gICAgbGF5b3V0LnNpemUgPSBzdGFjay5zaXplIC8gc3RhY2suY291bnQ7XG4gICAgY2hhcnRBcmVhW3Bvc10gKz0gbGF5b3V0LnNpemU7XG4gIH1cblxuICBpZiAoYm94LmdldFBhZGRpbmcpIHtcbiAgICB1cGRhdGVNYXhQYWRkaW5nKG1heFBhZGRpbmcsIGJveC5nZXRQYWRkaW5nKCkpO1xuICB9XG5cbiAgY29uc3QgbmV3V2lkdGggPSBNYXRoLm1heCgwLCBwYXJhbXMub3V0ZXJXaWR0aCAtIGdldENvbWJpbmVkTWF4KG1heFBhZGRpbmcsIGNoYXJ0QXJlYSwgJ2xlZnQnLCAncmlnaHQnKSk7XG4gIGNvbnN0IG5ld0hlaWdodCA9IE1hdGgubWF4KDAsIHBhcmFtcy5vdXRlckhlaWdodCAtIGdldENvbWJpbmVkTWF4KG1heFBhZGRpbmcsIGNoYXJ0QXJlYSwgJ3RvcCcsICdib3R0b20nKSk7XG4gIGNvbnN0IHdpZHRoQ2hhbmdlZCA9IG5ld1dpZHRoICE9PSBjaGFydEFyZWEudztcbiAgY29uc3QgaGVpZ2h0Q2hhbmdlZCA9IG5ld0hlaWdodCAhPT0gY2hhcnRBcmVhLmg7XG4gIGNoYXJ0QXJlYS53ID0gbmV3V2lkdGg7XG4gIGNoYXJ0QXJlYS5oID0gbmV3SGVpZ2h0O1xuXG4gIC8vIHJldHVybiBib29sZWFucyBvbiB0aGUgY2hhbmdlcyBwZXIgZGlyZWN0aW9uXG4gIHJldHVybiBsYXlvdXQuaG9yaXpvbnRhbFxuICAgID8ge3NhbWU6IHdpZHRoQ2hhbmdlZCwgb3RoZXI6IGhlaWdodENoYW5nZWR9XG4gICAgOiB7c2FtZTogaGVpZ2h0Q2hhbmdlZCwgb3RoZXI6IHdpZHRoQ2hhbmdlZH07XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU1heFBhZGRpbmcoY2hhcnRBcmVhKSB7XG4gIGNvbnN0IG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcblxuICBmdW5jdGlvbiB1cGRhdGVQb3MocG9zKSB7XG4gICAgY29uc3QgY2hhbmdlID0gTWF0aC5tYXgobWF4UGFkZGluZ1twb3NdIC0gY2hhcnRBcmVhW3Bvc10sIDApO1xuICAgIGNoYXJ0QXJlYVtwb3NdICs9IGNoYW5nZTtcbiAgICByZXR1cm4gY2hhbmdlO1xuICB9XG4gIGNoYXJ0QXJlYS55ICs9IHVwZGF0ZVBvcygndG9wJyk7XG4gIGNoYXJ0QXJlYS54ICs9IHVwZGF0ZVBvcygnbGVmdCcpO1xuICB1cGRhdGVQb3MoJ3JpZ2h0Jyk7XG4gIHVwZGF0ZVBvcygnYm90dG9tJyk7XG59XG5cbmZ1bmN0aW9uIGdldE1hcmdpbnMoaG9yaXpvbnRhbCwgY2hhcnRBcmVhKSB7XG4gIGNvbnN0IG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcblxuICBmdW5jdGlvbiBtYXJnaW5Gb3JQb3NpdGlvbnMocG9zaXRpb25zKSB7XG4gICAgY29uc3QgbWFyZ2luID0ge2xlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMH07XG4gICAgcG9zaXRpb25zLmZvckVhY2goKHBvcykgPT4ge1xuICAgICAgbWFyZ2luW3Bvc10gPSBNYXRoLm1heChjaGFydEFyZWFbcG9zXSwgbWF4UGFkZGluZ1twb3NdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbWFyZ2luO1xuICB9XG5cbiAgcmV0dXJuIGhvcml6b250YWxcbiAgICA/IG1hcmdpbkZvclBvc2l0aW9ucyhbJ2xlZnQnLCAncmlnaHQnXSlcbiAgICA6IG1hcmdpbkZvclBvc2l0aW9ucyhbJ3RvcCcsICdib3R0b20nXSk7XG59XG5cbmZ1bmN0aW9uIGZpdEJveGVzKGJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSB7XG4gIGNvbnN0IHJlZml0Qm94ZXMgPSBbXTtcbiAgbGV0IGksIGlsZW4sIGxheW91dCwgYm94LCByZWZpdCwgY2hhbmdlZDtcblxuICBmb3IgKGkgPSAwLCBpbGVuID0gYm94ZXMubGVuZ3RoLCByZWZpdCA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBsYXlvdXQgPSBib3hlc1tpXTtcbiAgICBib3ggPSBsYXlvdXQuYm94O1xuXG4gICAgYm94LnVwZGF0ZShcbiAgICAgIGxheW91dC53aWR0aCB8fCBjaGFydEFyZWEudyxcbiAgICAgIGxheW91dC5oZWlnaHQgfHwgY2hhcnRBcmVhLmgsXG4gICAgICBnZXRNYXJnaW5zKGxheW91dC5ob3Jpem9udGFsLCBjaGFydEFyZWEpXG4gICAgKTtcbiAgICBjb25zdCB7c2FtZSwgb3RoZXJ9ID0gdXBkYXRlRGltcyhjaGFydEFyZWEsIHBhcmFtcywgbGF5b3V0LCBzdGFja3MpO1xuXG4gICAgLy8gRGltZW5zaW9ucyBjaGFuZ2VkIGFuZCB0aGVyZSB3ZXJlIG5vbiBmdWxsIHdpZHRoIGJveGVzIGJlZm9yZSB0aGlzXG4gICAgLy8gLT4gd2UgaGF2ZSB0byByZWZpdCB0aG9zZVxuICAgIHJlZml0IHw9IHNhbWUgJiYgcmVmaXRCb3hlcy5sZW5ndGg7XG5cbiAgICAvLyBDaGFydCBhcmVhIGNoYW5nZWQgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxuICAgIGNoYW5nZWQgPSBjaGFuZ2VkIHx8IG90aGVyO1xuXG4gICAgaWYgKCFib3guZnVsbFNpemUpIHsgLy8gZnVsbFNpemUgYm94ZXMgZG9uJ3QgbmVlZCB0byBiZSByZS1maXR0ZWQgaW4gYW55IGNhc2VcbiAgICAgIHJlZml0Qm94ZXMucHVzaChsYXlvdXQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWZpdCAmJiBmaXRCb3hlcyhyZWZpdEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSB8fCBjaGFuZ2VkO1xufVxuXG5mdW5jdGlvbiBzZXRCb3hEaW1zKGJveCwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGJveC50b3AgPSB0b3A7XG4gIGJveC5sZWZ0ID0gbGVmdDtcbiAgYm94LnJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuICBib3guYm90dG9tID0gdG9wICsgaGVpZ2h0O1xuICBib3gud2lkdGggPSB3aWR0aDtcbiAgYm94LmhlaWdodCA9IGhlaWdodDtcbn1cblxuZnVuY3Rpb24gcGxhY2VCb3hlcyhib3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykge1xuICBjb25zdCB1c2VyUGFkZGluZyA9IHBhcmFtcy5wYWRkaW5nO1xuICBsZXQge3gsIHl9ID0gY2hhcnRBcmVhO1xuXG4gIGZvciAoY29uc3QgbGF5b3V0IG9mIGJveGVzKSB7XG4gICAgY29uc3QgYm94ID0gbGF5b3V0LmJveDtcbiAgICBjb25zdCBzdGFjayA9IHN0YWNrc1tsYXlvdXQuc3RhY2tdIHx8IHtjb3VudDogMSwgcGxhY2VkOiAwLCB3ZWlnaHQ6IDF9O1xuICAgIGNvbnN0IHdlaWdodCA9IChsYXlvdXQuc3RhY2tXZWlnaHQgLyBzdGFjay53ZWlnaHQpIHx8IDE7XG4gICAgaWYgKGxheW91dC5ob3Jpem9udGFsKSB7XG4gICAgICBjb25zdCB3aWR0aCA9IGNoYXJ0QXJlYS53ICogd2VpZ2h0O1xuICAgICAgY29uc3QgaGVpZ2h0ID0gc3RhY2suc2l6ZSB8fCBib3guaGVpZ2h0O1xuICAgICAgaWYgKGRlZmluZWQoc3RhY2suc3RhcnQpKSB7XG4gICAgICAgIHkgPSBzdGFjay5zdGFydDtcbiAgICAgIH1cbiAgICAgIGlmIChib3guZnVsbFNpemUpIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIHVzZXJQYWRkaW5nLmxlZnQsIHksIHBhcmFtcy5vdXRlcldpZHRoIC0gdXNlclBhZGRpbmcucmlnaHQgLSB1c2VyUGFkZGluZy5sZWZ0LCBoZWlnaHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIGNoYXJ0QXJlYS5sZWZ0ICsgc3RhY2sucGxhY2VkLCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnN0YXJ0ID0geTtcbiAgICAgIHN0YWNrLnBsYWNlZCArPSB3aWR0aDtcbiAgICAgIHkgPSBib3guYm90dG9tO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBjaGFydEFyZWEuaCAqIHdlaWdodDtcbiAgICAgIGNvbnN0IHdpZHRoID0gc3RhY2suc2l6ZSB8fCBib3gud2lkdGg7XG4gICAgICBpZiAoZGVmaW5lZChzdGFjay5zdGFydCkpIHtcbiAgICAgICAgeCA9IHN0YWNrLnN0YXJ0O1xuICAgICAgfVxuICAgICAgaWYgKGJveC5mdWxsU2l6ZSkge1xuICAgICAgICBzZXRCb3hEaW1zKGJveCwgeCwgdXNlclBhZGRpbmcudG9wLCB3aWR0aCwgcGFyYW1zLm91dGVySGVpZ2h0IC0gdXNlclBhZGRpbmcuYm90dG9tIC0gdXNlclBhZGRpbmcudG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEJveERpbXMoYm94LCB4LCBjaGFydEFyZWEudG9wICsgc3RhY2sucGxhY2VkLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnN0YXJ0ID0geDtcbiAgICAgIHN0YWNrLnBsYWNlZCArPSBoZWlnaHQ7XG4gICAgICB4ID0gYm94LnJpZ2h0O1xuICAgIH1cbiAgfVxuXG4gIGNoYXJ0QXJlYS54ID0geDtcbiAgY2hhcnRBcmVhLnkgPSB5O1xufVxuXG4vKipcbiAqIEBpbnRlcmZhY2UgTGF5b3V0SXRlbVxuICogQHR5cGVkZWYge29iamVjdH0gTGF5b3V0SXRlbVxuICogQHByb3Age3N0cmluZ30gcG9zaXRpb24gLSBUaGUgcG9zaXRpb24gb2YgdGhlIGl0ZW0gaW4gdGhlIGNoYXJ0IGxheW91dC4gUG9zc2libGUgdmFsdWVzIGFyZVxuICogJ2xlZnQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsIGFuZCAnY2hhcnRBcmVhJ1xuICogQHByb3Age251bWJlcn0gd2VpZ2h0IC0gVGhlIHdlaWdodCB1c2VkIHRvIHNvcnQgdGhlIGl0ZW0uIEhpZ2hlciB3ZWlnaHRzIGFyZSBmdXJ0aGVyIGF3YXkgZnJvbSB0aGUgY2hhcnQgYXJlYVxuICogQHByb3Age2Jvb2xlYW59IGZ1bGxTaXplIC0gaWYgdHJ1ZSwgYW5kIHRoZSBpdGVtIGlzIGhvcml6b250YWwsIHRoZW4gcHVzaCB2ZXJ0aWNhbCBib3hlcyBkb3duXG4gKiBAcHJvcCB7ZnVuY3Rpb259IGlzSG9yaXpvbnRhbCAtIHJldHVybnMgdHJ1ZSBpZiB0aGUgbGF5b3V0IGl0ZW0gaXMgaG9yaXpvbnRhbCAoaWUuIHRvcCBvciBib3R0b20pXG4gKiBAcHJvcCB7ZnVuY3Rpb259IHVwZGF0ZSAtIFRha2VzIHR3byBwYXJhbWV0ZXJzOiB3aWR0aCBhbmQgaGVpZ2h0LiBSZXR1cm5zIHNpemUgb2YgaXRlbVxuICogQHByb3Age2Z1bmN0aW9ufSBkcmF3IC0gRHJhd3MgdGhlIGVsZW1lbnRcbiAqIEBwcm9wIHtmdW5jdGlvbn0gW2dldFBhZGRpbmddIC0gIFJldHVybnMgYW4gb2JqZWN0IHdpdGggcGFkZGluZyBvbiB0aGUgZWRnZXNcbiAqIEBwcm9wIHtudW1iZXJ9IHdpZHRoIC0gV2lkdGggb2YgaXRlbS4gTXVzdCBiZSB2YWxpZCBhZnRlciB1cGRhdGUoKVxuICogQHByb3Age251bWJlcn0gaGVpZ2h0IC0gSGVpZ2h0IG9mIGl0ZW0uIE11c3QgYmUgdmFsaWQgYWZ0ZXIgdXBkYXRlKClcbiAqIEBwcm9wIHtudW1iZXJ9IGxlZnQgLSBMZWZ0IGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcbiAqIEBwcm9wIHtudW1iZXJ9IHRvcCAtIFRvcCBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXG4gKiBAcHJvcCB7bnVtYmVyfSByaWdodCAtIFJpZ2h0IGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcbiAqIEBwcm9wIHtudW1iZXJ9IGJvdHRvbSAtIEJvdHRvbSBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXG4gKi9cblxuLy8gVGhlIGxheW91dCBzZXJ2aWNlIGlzIHZlcnkgc2VsZiBleHBsYW5hdG9yeS4gIEl0J3MgcmVzcG9uc2libGUgZm9yIHRoZSBsYXlvdXQgd2l0aGluIGEgY2hhcnQuXG4vLyBTY2FsZXMsIExlZ2VuZHMgYW5kIFBsdWdpbnMgYWxsIHJlbHkgb24gdGhlIGxheW91dCBzZXJ2aWNlIGFuZCBjYW4gZWFzaWx5IHJlZ2lzdGVyIHRvIGJlIHBsYWNlZCBhbnl3aGVyZSB0aGV5IG5lZWRcbi8vIEl0IGlzIHRoaXMgc2VydmljZSdzIHJlc3BvbnNpYmlsaXR5IG9mIGNhcnJ5aW5nIG91dCB0aGF0IGxheW91dC5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAvKipcblx0ICogUmVnaXN0ZXIgYSBib3ggdG8gYSBjaGFydC5cblx0ICogQSBib3ggaXMgc2ltcGx5IGEgcmVmZXJlbmNlIHRvIGFuIG9iamVjdCB0aGF0IHJlcXVpcmVzIGxheW91dC4gZWcuIFNjYWxlcywgTGVnZW5kLCBUaXRsZS5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gdXNlXG5cdCAqIEBwYXJhbSB7TGF5b3V0SXRlbX0gaXRlbSAtIHRoZSBpdGVtIHRvIGFkZCB0byBiZSBsYWlkIG91dFxuXHQgKi9cbiAgYWRkQm94KGNoYXJ0LCBpdGVtKSB7XG4gICAgaWYgKCFjaGFydC5ib3hlcykge1xuICAgICAgY2hhcnQuYm94ZXMgPSBbXTtcbiAgICB9XG5cbiAgICAvLyBpbml0aWFsaXplIGl0ZW0gd2l0aCBkZWZhdWx0IHZhbHVlc1xuICAgIGl0ZW0uZnVsbFNpemUgPSBpdGVtLmZ1bGxTaXplIHx8IGZhbHNlO1xuICAgIGl0ZW0ucG9zaXRpb24gPSBpdGVtLnBvc2l0aW9uIHx8ICd0b3AnO1xuICAgIGl0ZW0ud2VpZ2h0ID0gaXRlbS53ZWlnaHQgfHwgMDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaXRlbS5fbGF5ZXJzID0gaXRlbS5fbGF5ZXJzIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHo6IDAsXG4gICAgICAgIGRyYXcoY2hhcnRBcmVhKSB7XG4gICAgICAgICAgaXRlbS5kcmF3KGNoYXJ0QXJlYSk7XG4gICAgICAgIH1cbiAgICAgIH1dO1xuICAgIH07XG5cbiAgICBjaGFydC5ib3hlcy5wdXNoKGl0ZW0pO1xuICB9LFxuXG4gIC8qKlxuXHQgKiBSZW1vdmUgYSBsYXlvdXRJdGVtIGZyb20gYSBjaGFydFxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byByZW1vdmUgdGhlIGJveCBmcm9tXG5cdCAqIEBwYXJhbSB7TGF5b3V0SXRlbX0gbGF5b3V0SXRlbSAtIHRoZSBpdGVtIHRvIHJlbW92ZSBmcm9tIHRoZSBsYXlvdXRcblx0ICovXG4gIHJlbW92ZUJveChjaGFydCwgbGF5b3V0SXRlbSkge1xuICAgIGNvbnN0IGluZGV4ID0gY2hhcnQuYm94ZXMgPyBjaGFydC5ib3hlcy5pbmRleE9mKGxheW91dEl0ZW0pIDogLTE7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgY2hhcnQuYm94ZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG5cdCAqIFNldHMgKG9yIHVwZGF0ZXMpIG9wdGlvbnMgb24gdGhlIGdpdmVuIGBpdGVtYC5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgaW4gd2hpY2ggdGhlIGl0ZW0gbGl2ZXMgKG9yIHdpbGwgYmUgYWRkZWQgdG8pXG5cdCAqIEBwYXJhbSB7TGF5b3V0SXRlbX0gaXRlbSAtIHRoZSBpdGVtIHRvIGNvbmZpZ3VyZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gdGhlIG5ldyBpdGVtIG9wdGlvbnMuXG5cdCAqL1xuICBjb25maWd1cmUoY2hhcnQsIGl0ZW0sIG9wdGlvbnMpIHtcbiAgICBpdGVtLmZ1bGxTaXplID0gb3B0aW9ucy5mdWxsU2l6ZTtcbiAgICBpdGVtLnBvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbjtcbiAgICBpdGVtLndlaWdodCA9IG9wdGlvbnMud2VpZ2h0O1xuICB9LFxuXG4gIC8qKlxuXHQgKiBGaXRzIGJveGVzIG9mIHRoZSBnaXZlbiBjaGFydCBpbnRvIHRoZSBnaXZlbiBzaXplIGJ5IGhhdmluZyBlYWNoIGJveCBtZWFzdXJlIGl0c2VsZlxuXHQgKiB0aGVuIHJ1bm5pbmcgYSBmaXR0aW5nIGFsZ29yaXRobVxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydFxuXHQgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSB0aGUgd2lkdGggdG8gZml0IGludG9cblx0ICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIHRoZSBoZWlnaHQgdG8gZml0IGludG9cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pblBhZGRpbmcgLSBtaW5pbXVtIHBhZGRpbmcgcmVxdWlyZWQgZm9yIGVhY2ggc2lkZSBvZiBjaGFydCBhcmVhXG5cdCAqL1xuICB1cGRhdGUoY2hhcnQsIHdpZHRoLCBoZWlnaHQsIG1pblBhZGRpbmcpIHtcbiAgICBpZiAoIWNoYXJ0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhjaGFydC5vcHRpb25zLmxheW91dC5wYWRkaW5nKTtcbiAgICBjb25zdCBhdmFpbGFibGVXaWR0aCA9IE1hdGgubWF4KHdpZHRoIC0gcGFkZGluZy53aWR0aCwgMCk7XG4gICAgY29uc3QgYXZhaWxhYmxlSGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0IC0gcGFkZGluZy5oZWlnaHQsIDApO1xuICAgIGNvbnN0IGJveGVzID0gYnVpbGRMYXlvdXRCb3hlcyhjaGFydC5ib3hlcyk7XG4gICAgY29uc3QgdmVydGljYWxCb3hlcyA9IGJveGVzLnZlcnRpY2FsO1xuICAgIGNvbnN0IGhvcml6b250YWxCb3hlcyA9IGJveGVzLmhvcml6b250YWw7XG5cbiAgICAvLyBCZWZvcmUgYW55IGNoYW5nZXMgYXJlIG1hZGUsIG5vdGlmeSBib3hlcyB0aGF0IGFuIHVwZGF0ZSBpcyBhYm91dCB0byBiZWluZ1xuICAgIC8vIFRoaXMgaXMgdXNlZCB0byBjbGVhciBhbnkgY2FjaGVkIGRhdGEgKGUuZy4gc2NhbGUgbGltaXRzKVxuICAgIGVhY2goY2hhcnQuYm94ZXMsIGJveCA9PiB7XG4gICAgICBpZiAodHlwZW9mIGJveC5iZWZvcmVMYXlvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgYm94LmJlZm9yZUxheW91dCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gRXNzZW50aWFsbHkgd2Ugbm93IGhhdmUgYW55IG51bWJlciBvZiBib3hlcyBvbiBlYWNoIG9mIHRoZSA0IHNpZGVzLlxuICAgIC8vIE91ciBjYW52YXMgbG9va3MgbGlrZSB0aGUgZm9sbG93aW5nLlxuICAgIC8vIFRoZSBhcmVhcyBMMSBhbmQgTDIgYXJlIHRoZSBsZWZ0IGF4ZXMuIFIxIGlzIHRoZSByaWdodCBheGlzLCBUMSBpcyB0aGUgdG9wIGF4aXMgYW5kXG4gICAgLy8gQjEgaXMgdGhlIGJvdHRvbSBheGlzXG4gICAgLy8gVGhlcmUgYXJlIGFsc28gNCBxdWFkcmFudC1saWtlIGxvY2F0aW9ucyAobGVmdCB0byByaWdodCBpbnN0ZWFkIG9mIGNsb2Nrd2lzZSkgcmVzZXJ2ZWQgZm9yIGNoYXJ0IG92ZXJsYXlzXG4gICAgLy8gVGhlc2UgbG9jYXRpb25zIGFyZSBzaW5nbGUtYm94IGxvY2F0aW9ucyBvbmx5LCB3aGVuIHRyeWluZyB0byByZWdpc3RlciBhIGNoYXJ0QXJlYSBsb2NhdGlvbiB0aGF0IGlzIGFscmVhZHkgdGFrZW4sXG4gICAgLy8gYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gICAgLy9cbiAgICAvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAvLyB8ICAgICAgICAgICAgICAgICAgVDEgKEZ1bGwgV2lkdGgpICAgICAgICAgICAgICAgICAgIHxcbiAgICAvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgVDIgICAgICAgICAgICAgICAgICB8ICAgIHxcbiAgICAvLyB8ICAgIHwtLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLXxcbiAgICAvLyB8ICAgIHwgICAgfCBDMSB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBDMiB8ICAgIHxcbiAgICAvLyB8ICAgIHwgICAgfC0tLS18ICAgICAgICAgICAgICAgICAgICAgICAgICAgfC0tLS18ICAgIHxcbiAgICAvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgIHxcbiAgICAvLyB8IEwxIHwgTDIgfCAgICAgICAgICAgQ2hhcnRBcmVhIChDMCkgICAgICAgICAgICB8IFIxIHxcbiAgICAvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgIHxcbiAgICAvLyB8ICAgIHwgICAgfC0tLS18ICAgICAgICAgICAgICAgICAgICAgICAgICAgfC0tLS18ICAgIHxcbiAgICAvLyB8ICAgIHwgICAgfCBDMyB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBDNCB8ICAgIHxcbiAgICAvLyB8ICAgIHwtLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLXxcbiAgICAvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgQjEgICAgICAgICAgICAgICAgICB8ICAgIHxcbiAgICAvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAvLyB8ICAgICAgICAgICAgICAgICAgQjIgKEZ1bGwgV2lkdGgpICAgICAgICAgICAgICAgICAgIHxcbiAgICAvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAvL1xuXG4gICAgY29uc3QgdmlzaWJsZVZlcnRpY2FsQm94Q291bnQgPSB2ZXJ0aWNhbEJveGVzLnJlZHVjZSgodG90YWwsIHdyYXApID0+XG4gICAgICB3cmFwLmJveC5vcHRpb25zICYmIHdyYXAuYm94Lm9wdGlvbnMuZGlzcGxheSA9PT0gZmFsc2UgPyB0b3RhbCA6IHRvdGFsICsgMSwgMCkgfHwgMTtcblxuICAgIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgb3V0ZXJXaWR0aDogd2lkdGgsXG4gICAgICBvdXRlckhlaWdodDogaGVpZ2h0LFxuICAgICAgcGFkZGluZyxcbiAgICAgIGF2YWlsYWJsZVdpZHRoLFxuICAgICAgYXZhaWxhYmxlSGVpZ2h0LFxuICAgICAgdkJveE1heFdpZHRoOiBhdmFpbGFibGVXaWR0aCAvIDIgLyB2aXNpYmxlVmVydGljYWxCb3hDb3VudCxcbiAgICAgIGhCb3hNYXhIZWlnaHQ6IGF2YWlsYWJsZUhlaWdodCAvIDJcbiAgICB9KTtcbiAgICBjb25zdCBtYXhQYWRkaW5nID0gT2JqZWN0LmFzc2lnbih7fSwgcGFkZGluZyk7XG4gICAgdXBkYXRlTWF4UGFkZGluZyhtYXhQYWRkaW5nLCB0b1BhZGRpbmcobWluUGFkZGluZykpO1xuICAgIGNvbnN0IGNoYXJ0QXJlYSA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgbWF4UGFkZGluZyxcbiAgICAgIHc6IGF2YWlsYWJsZVdpZHRoLFxuICAgICAgaDogYXZhaWxhYmxlSGVpZ2h0LFxuICAgICAgeDogcGFkZGluZy5sZWZ0LFxuICAgICAgeTogcGFkZGluZy50b3BcbiAgICB9LCBwYWRkaW5nKTtcblxuICAgIGNvbnN0IHN0YWNrcyA9IHNldExheW91dERpbXModmVydGljYWxCb3hlcy5jb25jYXQoaG9yaXpvbnRhbEJveGVzKSwgcGFyYW1zKTtcblxuICAgIC8vIEZpcnN0IGZpdCB0aGUgZnVsbFNpemUgYm94ZXMsIHRvIHJlZHVjZSBwcm9iYWJpbGl0eSBvZiByZS1maXR0aW5nLlxuICAgIGZpdEJveGVzKGJveGVzLmZ1bGxTaXplLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcblxuICAgIC8vIFRoZW4gZml0IHZlcnRpY2FsIGJveGVzXG4gICAgZml0Qm94ZXModmVydGljYWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG5cbiAgICAvLyBUaGVuIGZpdCBob3Jpem9udGFsIGJveGVzXG4gICAgaWYgKGZpdEJveGVzKGhvcml6b250YWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykpIHtcbiAgICAgIC8vIGlmIHRoZSBhcmVhIGNoYW5nZWQsIHJlLWZpdCB2ZXJ0aWNhbCBib3hlc1xuICAgICAgZml0Qm94ZXModmVydGljYWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG4gICAgfVxuXG4gICAgaGFuZGxlTWF4UGFkZGluZyhjaGFydEFyZWEpO1xuXG4gICAgLy8gRmluYWxseSBwbGFjZSB0aGUgYm94ZXMgdG8gY29ycmVjdCBjb29yZGluYXRlc1xuICAgIHBsYWNlQm94ZXMoYm94ZXMubGVmdEFuZFRvcCwgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG5cbiAgICAvLyBNb3ZlIHRvIG9wcG9zaXRlIHNpZGUgb2YgY2hhcnRcbiAgICBjaGFydEFyZWEueCArPSBjaGFydEFyZWEudztcbiAgICBjaGFydEFyZWEueSArPSBjaGFydEFyZWEuaDtcblxuICAgIHBsYWNlQm94ZXMoYm94ZXMucmlnaHRBbmRCb3R0b20sIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuXG4gICAgY2hhcnQuY2hhcnRBcmVhID0ge1xuICAgICAgbGVmdDogY2hhcnRBcmVhLmxlZnQsXG4gICAgICB0b3A6IGNoYXJ0QXJlYS50b3AsXG4gICAgICByaWdodDogY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEudyxcbiAgICAgIGJvdHRvbTogY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5oLFxuICAgICAgaGVpZ2h0OiBjaGFydEFyZWEuaCxcbiAgICAgIHdpZHRoOiBjaGFydEFyZWEudyxcbiAgICB9O1xuXG4gICAgLy8gRmluYWxseSB1cGRhdGUgYm94ZXMgaW4gY2hhcnRBcmVhIChyYWRpYWwgc2NhbGUgZm9yIGV4YW1wbGUpXG4gICAgZWFjaChib3hlcy5jaGFydEFyZWEsIChsYXlvdXQpID0+IHtcbiAgICAgIGNvbnN0IGJveCA9IGxheW91dC5ib3g7XG4gICAgICBPYmplY3QuYXNzaWduKGJveCwgY2hhcnQuY2hhcnRBcmVhKTtcbiAgICAgIGJveC51cGRhdGUoY2hhcnRBcmVhLncsIGNoYXJ0QXJlYS5oLCB7bGVmdDogMCwgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwfSk7XG4gICAgfSk7XG4gIH1cbn07XG4iLCAiXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9jb3JlL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICovXG5cbi8qKlxuICogQWJzdHJhY3QgY2xhc3MgdGhhdCBhbGxvd3MgYWJzdHJhY3RpbmcgcGxhdGZvcm0gZGVwZW5kZW5jaWVzIGF3YXkgZnJvbSB0aGUgY2hhcnQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VQbGF0Zm9ybSB7XG4gIC8qKlxuXHQgKiBDYWxsZWQgYXQgY2hhcnQgY29uc3RydWN0aW9uIHRpbWUsIHJldHVybnMgYSBjb250ZXh0MmQgaW5zdGFuY2UgaW1wbGVtZW50aW5nXG5cdCAqIHRoZSBbVzNDIENhbnZhcyAyRCBDb250ZXh0IEFQSSBzdGFuZGFyZF17QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSLzJkY29udGV4dC99LlxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgLSBUaGUgY2FudmFzIGZyb20gd2hpY2ggdG8gYWNxdWlyZSBjb250ZXh0IChwbGF0Zm9ybSBzcGVjaWZpYylcblx0ICogQHBhcmFtIHtudW1iZXJ9IFthc3BlY3RSYXRpb10gLSBUaGUgY2hhcnQgb3B0aW9uc1xuXHQgKi9cbiAgYWNxdWlyZUNvbnRleHQoY2FudmFzLCBhc3BlY3RSYXRpbykge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIC8qKlxuXHQgKiBDYWxsZWQgYXQgY2hhcnQgZGVzdHJ1Y3Rpb24gdGltZSwgcmVsZWFzZXMgYW55IHJlc291cmNlcyBhc3NvY2lhdGVkIHRvIHRoZSBjb250ZXh0XG5cdCAqIHByZXZpb3VzbHkgcmV0dXJuZWQgYnkgdGhlIGFjcXVpcmVDb250ZXh0KCkgbWV0aG9kLlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAtIFRoZSBjb250ZXh0MmQgaW5zdGFuY2Vcblx0ICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIG1ldGhvZCBzdWNjZWVkZWQsIGVsc2UgZmFsc2Vcblx0ICovXG4gIHJlbGVhc2VDb250ZXh0KGNvbnRleHQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZWdpc3RlcnMgdGhlIHNwZWNpZmllZCBsaXN0ZW5lciBvbiB0aGUgZ2l2ZW4gY2hhcnQuXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gQ2hhcnQgZnJvbSB3aGljaCB0byBsaXN0ZW4gZm9yIGV2ZW50XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlICh7QGxpbmsgQ2hhcnRFdmVudH0pIHR5cGUgdG8gbGlzdGVuIGZvclxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciAtIFJlY2VpdmVzIGEgbm90aWZpY2F0aW9uIChhbiBvYmplY3QgdGhhdCBpbXBsZW1lbnRzXG5cdCAqIHRoZSB7QGxpbmsgQ2hhcnRFdmVudH0gaW50ZXJmYWNlKSB3aGVuIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBvY2N1cnMuXG5cdCAqL1xuICBhZGRFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIC8qKlxuXHQgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXIgcHJldmlvdXNseSByZWdpc3RlcmVkIHdpdGggYWRkRXZlbnRMaXN0ZW5lci5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBDaGFydCBmcm9tIHdoaWNoIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgKHtAbGluayBDaGFydEV2ZW50fSkgdHlwZSB0byByZW1vdmVcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gcmVtb3ZlIGZyb20gdGhlIGV2ZW50IHRhcmdldC5cblx0ICovXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBjdXJyZW50IGRldmljZVBpeGVsUmF0aW8gb2YgdGhlIGRldmljZSB0aGlzIHBsYXRmb3JtIGlzIGNvbm5lY3RlZCB0by5cblx0ICovXG4gIGdldERldmljZVBpeGVsUmF0aW8oKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgbWF4aW11bSBzaXplIGluIHBpeGVscyBvZiBnaXZlbiBjYW52YXMgZWxlbWVudC5cblx0ICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gZWxlbWVudFxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoXSAtIGNvbnRlbnQgd2lkdGggb2YgcGFyZW50IGVsZW1lbnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHRdIC0gY29udGVudCBoZWlnaHQgb2YgcGFyZW50IGVsZW1lbnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IFthc3BlY3RSYXRpb10gLSBhc3BlY3QgcmF0aW8gdG8gbWFpbnRhaW5cblx0ICovXG4gIGdldE1heGltdW1TaXplKGVsZW1lbnQsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKSB7XG4gICAgd2lkdGggPSBNYXRoLm1heCgwLCB3aWR0aCB8fCBlbGVtZW50LndpZHRoKTtcbiAgICBoZWlnaHQgPSBoZWlnaHQgfHwgZWxlbWVudC5oZWlnaHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0OiBNYXRoLm1heCgwLCBhc3BlY3RSYXRpbyA/IE1hdGguZmxvb3Iod2lkdGggLyBhc3BlY3RSYXRpbykgOiBoZWlnaHQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcblx0ICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGNhbnZhcyBpcyBhdHRhY2hlZCB0byB0aGUgcGxhdGZvcm0sIGZhbHNlIGlmIG5vdC5cblx0ICovXG4gIGlzQXR0YWNoZWQoY2FudmFzKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGNvbmZpZyB3aXRoIHBsYXRmb3JtIHNwZWNpZmljIHJlcXVpcmVtZW50c1xuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vY29yZS9jb3JlLmNvbmZpZy5qcycpLmRlZmF1bHR9IGNvbmZpZ1xuICAgKi9cbiAgdXBkYXRlQ29uZmlnKGNvbmZpZykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgLy8gbm8tb3BcbiAgfVxufVxuIiwgIi8qKlxuICogUGxhdGZvcm0gZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gKG1pbmltYWwpLlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzQ1OTEjaXNzdWVjb21tZW50LTMxOTU3NTkzOVxuICovXG5cbmltcG9ydCBCYXNlUGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybS5iYXNlLmpzJztcblxuLyoqXG4gKiBQbGF0Zm9ybSBjbGFzcyBmb3IgY2hhcnRzIHdpdGhvdXQgYWNjZXNzIHRvIHRoZSBET00gb3IgdG8gbWFueSBlbGVtZW50IHByb3BlcnRpZXNcbiAqIFRoaXMgcGxhdGZvcm0gaXMgdXNlZCBieSBkZWZhdWx0IGZvciBhbnkgY2hhcnQgcGFzc2VkIGFuIE9mZnNjcmVlbkNhbnZhcy5cbiAqIEBleHRlbmRzIEJhc2VQbGF0Zm9ybVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNpY1BsYXRmb3JtIGV4dGVuZHMgQmFzZVBsYXRmb3JtIHtcbiAgYWNxdWlyZUNvbnRleHQoaXRlbSkge1xuICAgIC8vIFRvIHByZXZlbnQgY2FudmFzIGZpbmdlcnByaW50aW5nLCBzb21lIGFkZC1vbnMgdW5kZWZpbmUgdGhlIGdldENvbnRleHRcbiAgICAvLyBtZXRob2QsIGZvciBleGFtcGxlOiBodHRwczovL2dpdGh1Yi5jb20va2thcHNuZXIvQ2FudmFzQmxvY2tlclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yODA3XG4gICAgcmV0dXJuIGl0ZW0gJiYgaXRlbS5nZXRDb250ZXh0ICYmIGl0ZW0uZ2V0Q29udGV4dCgnMmQnKSB8fCBudWxsO1xuICB9XG4gIHVwZGF0ZUNvbmZpZyhjb25maWcpIHtcbiAgICBjb25maWcub3B0aW9ucy5hbmltYXRpb24gPSBmYWxzZTtcbiAgfVxufVxuIiwgIi8qKlxuICogQ2hhcnQuUGxhdGZvcm0gaW1wbGVtZW50YXRpb24gZm9yIHRhcmdldGluZyBhIHdlYiBicm93c2VyXG4gKi9cblxuaW1wb3J0IEJhc2VQbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtLmJhc2UuanMnO1xuaW1wb3J0IHtfZ2V0UGFyZW50Tm9kZSwgZ2V0UmVsYXRpdmVQb3NpdGlvbiwgc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucywgcmVhZFVzZWRTaXplLCBnZXRNYXhpbXVtU2l6ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmRvbS5qcyc7XG5pbXBvcnQge3Rocm90dGxlZH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmV4dHJhcy5qcyc7XG5pbXBvcnQge2lzTnVsbE9yVW5kZWZ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vY29yZS9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqL1xuXG5jb25zdCBFWFBBTkRPX0tFWSA9ICckY2hhcnRqcyc7XG5cbi8qKlxuICogRE9NIGV2ZW50IHR5cGVzIC0+IENoYXJ0LmpzIGV2ZW50IHR5cGVzLlxuICogTm90ZTogb25seSBldmVudHMgd2l0aCBkaWZmZXJlbnQgdHlwZXMgYXJlIG1hcHBlZC5cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvRXZlbnRzXG4gKi9cbmNvbnN0IEVWRU5UX1RZUEVTID0ge1xuICB0b3VjaHN0YXJ0OiAnbW91c2Vkb3duJyxcbiAgdG91Y2htb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgdG91Y2hlbmQ6ICdtb3VzZXVwJyxcbiAgcG9pbnRlcmVudGVyOiAnbW91c2VlbnRlcicsXG4gIHBvaW50ZXJkb3duOiAnbW91c2Vkb3duJyxcbiAgcG9pbnRlcm1vdmU6ICdtb3VzZW1vdmUnLFxuICBwb2ludGVydXA6ICdtb3VzZXVwJyxcbiAgcG9pbnRlcmxlYXZlOiAnbW91c2VvdXQnLFxuICBwb2ludGVyb3V0OiAnbW91c2VvdXQnXG59O1xuXG5jb25zdCBpc051bGxPckVtcHR5ID0gdmFsdWUgPT4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09ICcnO1xuLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgY2FudmFzIHN0eWxlIGFuZCByZW5kZXIgc2l6ZSB3aXRob3V0IG1vZGlmeWluZyB0aGUgY2FudmFzIGRpc3BsYXkgc2l6ZSxcbiAqIHNpbmNlIHJlc3BvbnNpdmVuZXNzIGlzIGhhbmRsZWQgYnkgdGhlIGNvbnRyb2xsZXIucmVzaXplKCkgbWV0aG9kLiBUaGUgY29uZmlnIGlzIHVzZWRcbiAqIHRvIGRldGVybWluZSB0aGUgYXNwZWN0IHJhdGlvIHRvIGFwcGx5IGluIGNhc2Ugbm8gZXhwbGljaXQgaGVpZ2h0IGhhcyBiZWVuIHNwZWNpZmllZC5cbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuICogQHBhcmFtIHtudW1iZXJ9IFthc3BlY3RSYXRpb11cbiAqL1xuZnVuY3Rpb24gaW5pdENhbnZhcyhjYW52YXMsIGFzcGVjdFJhdGlvKSB7XG4gIGNvbnN0IHN0eWxlID0gY2FudmFzLnN0eWxlO1xuXG4gIC8vIE5PVEUoU0IpIGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgIT09IGNhbnZhcy53aWR0aDogaW4gdGhlIGZpcnN0IGNhc2UgaXRcbiAgLy8gcmV0dXJucyBudWxsIG9yICcnIGlmIG5vIGV4cGxpY2l0IHZhbHVlIGhhcyBiZWVuIHNldCB0byB0aGUgY2FudmFzIGF0dHJpYnV0ZS5cbiAgY29uc3QgcmVuZGVySGVpZ2h0ID0gY2FudmFzLmdldEF0dHJpYnV0ZSgnaGVpZ2h0Jyk7XG4gIGNvbnN0IHJlbmRlcldpZHRoID0gY2FudmFzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKTtcblxuICAvLyBDaGFydC5qcyBtb2RpZmllcyBzb21lIGNhbnZhcyB2YWx1ZXMgdGhhdCB3ZSB3YW50IHRvIHJlc3RvcmUgb24gZGVzdHJveVxuICBjYW52YXNbRVhQQU5ET19LRVldID0ge1xuICAgIGluaXRpYWw6IHtcbiAgICAgIGhlaWdodDogcmVuZGVySGVpZ2h0LFxuICAgICAgd2lkdGg6IHJlbmRlcldpZHRoLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZGlzcGxheTogc3R5bGUuZGlzcGxheSxcbiAgICAgICAgaGVpZ2h0OiBzdHlsZS5oZWlnaHQsXG4gICAgICAgIHdpZHRoOiBzdHlsZS53aWR0aFxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBGb3JjZSBjYW52YXMgdG8gZGlzcGxheSBhcyBibG9jayB0byBhdm9pZCBleHRyYSBzcGFjZSBjYXVzZWQgYnkgaW5saW5lXG4gIC8vIGVsZW1lbnRzLCB3aGljaCB3b3VsZCBpbnRlcmZlcmUgd2l0aCB0aGUgcmVzcG9uc2l2ZSByZXNpemUgcHJvY2Vzcy5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI1MzhcbiAgc3R5bGUuZGlzcGxheSA9IHN0eWxlLmRpc3BsYXkgfHwgJ2Jsb2NrJztcbiAgLy8gSW5jbHVkZSBwb3NzaWJsZSBib3JkZXJzIGluIHRoZSBzaXplXG4gIHN0eWxlLmJveFNpemluZyA9IHN0eWxlLmJveFNpemluZyB8fCAnYm9yZGVyLWJveCc7XG5cbiAgaWYgKGlzTnVsbE9yRW1wdHkocmVuZGVyV2lkdGgpKSB7XG4gICAgY29uc3QgZGlzcGxheVdpZHRoID0gcmVhZFVzZWRTaXplKGNhbnZhcywgJ3dpZHRoJyk7XG4gICAgaWYgKGRpc3BsYXlXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjYW52YXMud2lkdGggPSBkaXNwbGF5V2lkdGg7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzTnVsbE9yRW1wdHkocmVuZGVySGVpZ2h0KSkge1xuICAgIGlmIChjYW52YXMuc3R5bGUuaGVpZ2h0ID09PSAnJykge1xuICAgICAgLy8gSWYgbm8gZXhwbGljaXQgcmVuZGVyIGhlaWdodCBhbmQgc3R5bGUgaGVpZ2h0LCBsZXQncyBhcHBseSB0aGUgYXNwZWN0IHJhdGlvLFxuICAgICAgLy8gd2hpY2ggb25lIGNhbiBiZSBzcGVjaWZpZWQgYnkgdGhlIHVzZXIgYnV0IGFsc28gYnkgY2hhcnRzIGFzIGRlZmF1bHQgb3B0aW9uXG4gICAgICAvLyAoaS5lLiBvcHRpb25zLmFzcGVjdFJhdGlvKS4gSWYgbm90IHNwZWNpZmllZCwgdXNlIGNhbnZhcyBhc3BlY3QgcmF0aW8gb2YgMi5cbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXMud2lkdGggLyAoYXNwZWN0UmF0aW8gfHwgMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRpc3BsYXlIZWlnaHQgPSByZWFkVXNlZFNpemUoY2FudmFzLCAnaGVpZ2h0Jyk7XG4gICAgICBpZiAoZGlzcGxheUhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBkaXNwbGF5SGVpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjYW52YXM7XG59XG5cbi8vIERlZmF1bHQgcGFzc2l2ZSB0byB0cnVlIGFzIGV4cGVjdGVkIGJ5IENocm9tZSBmb3IgJ3RvdWNoc3RhcnQnIGFuZCAndG91Y2hlbmQnIGV2ZW50cy5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80Mjg3XG5jb25zdCBldmVudExpc3RlbmVyT3B0aW9ucyA9IHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMgPyB7cGFzc2l2ZTogdHJ1ZX0gOiBmYWxzZTtcblxuZnVuY3Rpb24gYWRkTGlzdGVuZXIobm9kZSwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKG5vZGUpIHtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIGV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKGNoYXJ0ICYmIGNoYXJ0LmNhbnZhcykge1xuICAgIGNoYXJ0LmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBldmVudExpc3RlbmVyT3B0aW9ucyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZnJvbU5hdGl2ZUV2ZW50KGV2ZW50LCBjaGFydCkge1xuICBjb25zdCB0eXBlID0gRVZFTlRfVFlQRVNbZXZlbnQudHlwZV0gfHwgZXZlbnQudHlwZTtcbiAgY29uc3Qge3gsIHl9ID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihldmVudCwgY2hhcnQpO1xuICByZXR1cm4ge1xuICAgIHR5cGUsXG4gICAgY2hhcnQsXG4gICAgbmF0aXZlOiBldmVudCxcbiAgICB4OiB4ICE9PSB1bmRlZmluZWQgPyB4IDogbnVsbCxcbiAgICB5OiB5ICE9PSB1bmRlZmluZWQgPyB5IDogbnVsbCxcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9kZUxpc3RDb250YWlucyhub2RlTGlzdCwgY2FudmFzKSB7XG4gIGZvciAoY29uc3Qgbm9kZSBvZiBub2RlTGlzdCkge1xuICAgIGlmIChub2RlID09PSBjYW52YXMgfHwgbm9kZS5jb250YWlucyhjYW52YXMpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQXR0YWNoT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICBsZXQgdHJpZ2dlciA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgfHwgbm9kZUxpc3RDb250YWlucyhlbnRyeS5hZGRlZE5vZGVzLCBjYW52YXMpO1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgJiYgIW5vZGVMaXN0Q29udGFpbnMoZW50cnkucmVtb3ZlZE5vZGVzLCBjYW52YXMpO1xuICAgIH1cbiAgICBpZiAodHJpZ2dlcikge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LCB7Y2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlfSk7XG4gIHJldHVybiBvYnNlcnZlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGV0YWNoT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICBsZXQgdHJpZ2dlciA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgfHwgbm9kZUxpc3RDb250YWlucyhlbnRyeS5yZW1vdmVkTm9kZXMsIGNhbnZhcyk7XG4gICAgICB0cmlnZ2VyID0gdHJpZ2dlciAmJiAhbm9kZUxpc3RDb250YWlucyhlbnRyeS5hZGRlZE5vZGVzLCBjYW52YXMpO1xuICAgIH1cbiAgICBpZiAodHJpZ2dlcikge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LCB7Y2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlfSk7XG4gIHJldHVybiBvYnNlcnZlcjtcbn1cblxuY29uc3QgZHJwTGlzdGVuaW5nQ2hhcnRzID0gbmV3IE1hcCgpO1xubGV0IG9sZERldmljZVBpeGVsUmF0aW8gPSAwO1xuXG5mdW5jdGlvbiBvbldpbmRvd1Jlc2l6ZSgpIHtcbiAgY29uc3QgZHByID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIGlmIChkcHIgPT09IG9sZERldmljZVBpeGVsUmF0aW8pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb2xkRGV2aWNlUGl4ZWxSYXRpbyA9IGRwcjtcbiAgZHJwTGlzdGVuaW5nQ2hhcnRzLmZvckVhY2goKHJlc2l6ZSwgY2hhcnQpID0+IHtcbiAgICBpZiAoY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8gIT09IGRwcikge1xuICAgICAgcmVzaXplKCk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gbGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQsIHJlc2l6ZSkge1xuICBpZiAoIWRycExpc3RlbmluZ0NoYXJ0cy5zaXplKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uV2luZG93UmVzaXplKTtcbiAgfVxuICBkcnBMaXN0ZW5pbmdDaGFydHMuc2V0KGNoYXJ0LCByZXNpemUpO1xufVxuXG5mdW5jdGlvbiB1bmxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0KSB7XG4gIGRycExpc3RlbmluZ0NoYXJ0cy5kZWxldGUoY2hhcnQpO1xuICBpZiAoIWRycExpc3RlbmluZ0NoYXJ0cy5zaXplKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uV2luZG93UmVzaXplKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVSZXNpemVPYnNlcnZlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBjb250YWluZXIgPSBjYW52YXMgJiYgX2dldFBhcmVudE5vZGUoY2FudmFzKTtcbiAgaWYgKCFjb250YWluZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcmVzaXplID0gdGhyb3R0bGVkKCh3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgY29uc3QgdyA9IGNvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgICBsaXN0ZW5lcih3aWR0aCwgaGVpZ2h0KTtcbiAgICBpZiAodyA8IGNvbnRhaW5lci5jbGllbnRXaWR0aCkge1xuICAgICAgLy8gSWYgdGhlIGNvbnRhaW5lciBzaXplIHNocmFuayBkdXJpbmcgY2hhcnQgcmVzaXplLCBsZXQncyBhc3N1bWVcbiAgICAgIC8vIHNjcm9sbGJhciBhcHBlYXJlZC4gU28gd2UgcmVzaXplIGFnYWluIHdpdGggdGhlIHNjcm9sbGJhciB2aXNpYmxlIC1cbiAgICAgIC8vIGVmZmVjdGl2ZWx5IG1ha2luZyBjaGFydCBzbWFsbGVyIGFuZCB0aGUgc2Nyb2xsYmFyIGhpZGRlbiBhZ2Fpbi5cbiAgICAgIC8vIEJlY2F1c2Ugd2UgYXJlIGluc2lkZSBgdGhyb3R0bGVkYCwgYW5kIGN1cnJlbnRseSBgdGlja2luZ2AsIHNjcm9sbFxuICAgICAgLy8gZXZlbnRzIGFyZSBpZ25vcmVkIGR1cmluZyB0aGlzIHdob2xlIDIgcmVzaXplIHByb2Nlc3MuXG4gICAgICAvLyBJZiB3ZSBhc3N1bWVkIHdyb25nIGFuZCBzb21ldGhpbmcgZWxzZSBoYXBwZW5lZCwgd2UgYXJlIHJlc2l6aW5nXG4gICAgICAvLyB0d2ljZSBpbiBhIGZyYW1lIChwb3RlbnRpYWwgcGVyZm9ybWFuY2UgaXNzdWUpXG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH1cbiAgfSwgd2luZG93KTtcblxuICAvLyBAdHMtaWdub3JlIHVudGlsIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzc4NjEgaW1wbGVtZW50ZWRcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgY29uc3QgZW50cnkgPSBlbnRyaWVzWzBdO1xuICAgIGNvbnN0IHdpZHRoID0gZW50cnkuY29udGVudFJlY3Qud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gZW50cnkuY29udGVudFJlY3QuaGVpZ2h0O1xuICAgIC8vIFdoZW4gaXRzIGNvbnRhaW5lcidzIGRpc3BsYXkgaXMgc2V0IHRvICdub25lJyB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2l0aCBhXG4gICAgLy8gc2l6ZSBvZiAoMCwgMCksIHdoaWNoIHdpbGwgY2F1c2UgdGhlIGNoYXJ0IHRvIGxvc2UgaXRzIG9yaWdpbmFsIGhlaWdodCwgc28gc2tpcFxuICAgIC8vIHJlc2l6aW5nIGluIHN1Y2ggY2FzZS5cbiAgICBpZiAod2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgfSk7XG4gIG9ic2VydmVyLm9ic2VydmUoY29udGFpbmVyKTtcbiAgbGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQsIHJlc2l6ZSk7XG5cbiAgcmV0dXJuIG9ic2VydmVyO1xufVxuXG5mdW5jdGlvbiByZWxlYXNlT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIG9ic2VydmVyKSB7XG4gIGlmIChvYnNlcnZlcikge1xuICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuICBpZiAodHlwZSA9PT0gJ3Jlc2l6ZScpIHtcbiAgICB1bmxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVQcm94eUFuZExpc3RlbihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBwcm94eSA9IHRocm90dGxlZCgoZXZlbnQpID0+IHtcbiAgICAvLyBUaGlzIGNhc2UgY2FuIG9jY3VyIGlmIHRoZSBjaGFydCBpcyBkZXN0cm95ZWQgd2hpbGUgd2FpdGluZ1xuICAgIC8vIGZvciB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHRvIG9jY3VyLiBXZSBwcmV2ZW50IGNyYXNoZXMgYnkgY2hlY2tpbmdcbiAgICAvLyBmb3IgYSBkZXN0cm95ZWQgY2hhcnRcbiAgICBpZiAoY2hhcnQuY3R4ICE9PSBudWxsKSB7XG4gICAgICBsaXN0ZW5lcihmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSk7XG4gICAgfVxuICB9LCBjaGFydCk7XG5cbiAgYWRkTGlzdGVuZXIoY2FudmFzLCB0eXBlLCBwcm94eSk7XG5cbiAgcmV0dXJuIHByb3h5O1xufVxuXG4vKipcbiAqIFBsYXRmb3JtIGNsYXNzIGZvciBjaGFydHMgdGhhdCBjYW4gYWNjZXNzIHRoZSBET00gYW5kIGdsb2JhbCB3aW5kb3cvZG9jdW1lbnQgcHJvcGVydGllc1xuICogQGV4dGVuZHMgQmFzZVBsYXRmb3JtXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERvbVBsYXRmb3JtIGV4dGVuZHMgQmFzZVBsYXRmb3JtIHtcblxuICAvKipcblx0ICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbYXNwZWN0UmF0aW9dXG5cdCAqIEByZXR1cm4ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRHxudWxsfVxuXHQgKi9cbiAgYWNxdWlyZUNvbnRleHQoY2FudmFzLCBhc3BlY3RSYXRpbykge1xuICAgIC8vIFRvIHByZXZlbnQgY2FudmFzIGZpbmdlcnByaW50aW5nLCBzb21lIGFkZC1vbnMgdW5kZWZpbmUgdGhlIGdldENvbnRleHRcbiAgICAvLyBtZXRob2QsIGZvciBleGFtcGxlOiBodHRwczovL2dpdGh1Yi5jb20va2thcHNuZXIvQ2FudmFzQmxvY2tlclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yODA3XG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcyAmJiBjYW52YXMuZ2V0Q29udGV4dCAmJiBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIC8vIGBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50L0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRGAgZmFpbHMgd2hlbiB0aGUgY2FudmFzIGlzXG4gICAgLy8gaW5zaWRlIGFuIGlmcmFtZSBvciB3aGVuIHJ1bm5pbmcgaW4gYSBwcm90ZWN0ZWQgZW52aXJvbm1lbnQuIFdlIGNvdWxkIGd1ZXNzIHRoZVxuICAgIC8vIHR5cGVzIGZyb20gdGhlaXIgdG9TdHJpbmcoKSB2YWx1ZSBidXQgbGV0J3Mga2VlcCB0aGluZ3MgZmxleGlibGUgYW5kIGFzc3VtZSBpdCdzXG4gICAgLy8gYSBzdWZmaWNpZW50IGNvbmRpdGlvbiBpZiB0aGUgY2FudmFzIGhhcyBhIGNvbnRleHQyRCB3aGljaCBoYXMgY2FudmFzIGFzIGBjYW52YXNgLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8zODg3XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQxMDJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDE1MlxuICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuY2FudmFzID09PSBjYW52YXMpIHtcbiAgICAgIC8vIExvYWQgcGxhdGZvcm0gcmVzb3VyY2VzIG9uIGZpcnN0IGNoYXJ0IGNyZWF0aW9uLCB0byBtYWtlIGl0IHBvc3NpYmxlIHRvXG4gICAgICAvLyBpbXBvcnQgdGhlIGxpYnJhcnkgYmVmb3JlIHNldHRpbmcgcGxhdGZvcm0gb3B0aW9ucy5cbiAgICAgIGluaXRDYW52YXMoY2FudmFzLCBhc3BlY3RSYXRpbyk7XG4gICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dFxuXHQgKi9cbiAgcmVsZWFzZUNvbnRleHQoY29udGV4dCkge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNvbnRleHQuY2FudmFzO1xuICAgIGlmICghY2FudmFzW0VYUEFORE9fS0VZXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGluaXRpYWwgPSBjYW52YXNbRVhQQU5ET19LRVldLmluaXRpYWw7XG4gICAgWydoZWlnaHQnLCAnd2lkdGgnXS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGluaXRpYWxbcHJvcF07XG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgICAgY2FudmFzLnJlbW92ZUF0dHJpYnV0ZShwcm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUocHJvcCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3Qgc3R5bGUgPSBpbml0aWFsLnN0eWxlIHx8IHt9O1xuICAgIE9iamVjdC5rZXlzKHN0eWxlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNhbnZhcy5zdHlsZVtrZXldID0gc3R5bGVba2V5XTtcbiAgICB9KTtcblxuICAgIC8vIFRoZSBjYW52YXMgcmVuZGVyIHNpemUgbWlnaHQgaGF2ZSBiZWVuIGNoYW5nZWQgKGFuZCB0aHVzIHRoZSBzdGF0ZSBzdGFjayBkaXNjYXJkZWQpLFxuICAgIC8vIHdlIGNhbid0IHVzZSBzYXZlKCkgYW5kIHJlc3RvcmUoKSB0byByZXN0b3JlIHRoZSBpbml0aWFsIHN0YXRlLiBTbyBtYWtlIHN1cmUgdGhhdCBhdFxuICAgIC8vIGxlYXN0IHRoZSBjYW52YXMgY29udGV4dCBpcyByZXNldCB0byB0aGUgZGVmYXVsdCBzdGF0ZSBieSBzZXR0aW5nIHRoZSBjYW52YXMgd2lkdGguXG4gICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMTEvV0QtaHRtbDUtMjAxMTA1MjUvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1hc3NpZ25cbiAgICBjYW52YXMud2lkdGggPSBjYW52YXMud2lkdGg7XG5cbiAgICBkZWxldGUgY2FudmFzW0VYUEFORE9fS0VZXTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuXHQgKlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lclxuXHQgKi9cbiAgYWRkRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgICAvLyBDYW4gaGF2ZSBvbmx5IG9uZSBsaXN0ZW5lciBwZXIgdHlwZSwgc28gbWFrZSBzdXJlIHByZXZpb3VzIGlzIHJlbW92ZWRcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUpO1xuXG4gICAgY29uc3QgcHJveGllcyA9IGNoYXJ0LiRwcm94aWVzIHx8IChjaGFydC4kcHJveGllcyA9IHt9KTtcbiAgICBjb25zdCBoYW5kbGVycyA9IHtcbiAgICAgIGF0dGFjaDogY3JlYXRlQXR0YWNoT2JzZXJ2ZXIsXG4gICAgICBkZXRhY2g6IGNyZWF0ZURldGFjaE9ic2VydmVyLFxuICAgICAgcmVzaXplOiBjcmVhdGVSZXNpemVPYnNlcnZlclxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW3R5cGVdIHx8IGNyZWF0ZVByb3h5QW5kTGlzdGVuO1xuICAgIHByb3hpZXNbdHlwZV0gPSBoYW5kbGVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuXHQgKi9cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSkge1xuICAgIGNvbnN0IHByb3hpZXMgPSBjaGFydC4kcHJveGllcyB8fCAoY2hhcnQuJHByb3hpZXMgPSB7fSk7XG4gICAgY29uc3QgcHJveHkgPSBwcm94aWVzW3R5cGVdO1xuXG4gICAgaWYgKCFwcm94eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGhhbmRsZXJzID0ge1xuICAgICAgYXR0YWNoOiByZWxlYXNlT2JzZXJ2ZXIsXG4gICAgICBkZXRhY2g6IHJlbGVhc2VPYnNlcnZlcixcbiAgICAgIHJlc2l6ZTogcmVsZWFzZU9ic2VydmVyXG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNbdHlwZV0gfHwgcmVtb3ZlTGlzdGVuZXI7XG4gICAgaGFuZGxlcihjaGFydCwgdHlwZSwgcHJveHkpO1xuICAgIHByb3hpZXNbdHlwZV0gPSB1bmRlZmluZWQ7XG4gIH1cblxuICBnZXREZXZpY2VQaXhlbFJhdGlvKCkge1xuICAgIHJldHVybiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF0gLSBjb250ZW50IHdpZHRoIG9mIHBhcmVudCBlbGVtZW50XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0XSAtIGNvbnRlbnQgaGVpZ2h0IG9mIHBhcmVudCBlbGVtZW50XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbYXNwZWN0UmF0aW9dIC0gYXNwZWN0IHJhdGlvIHRvIG1haW50YWluXG5cdCAqL1xuICBnZXRNYXhpbXVtU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKSB7XG4gICAgcmV0dXJuIGdldE1heGltdW1TaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuXHQgKi9cbiAgaXNBdHRhY2hlZChjYW52YXMpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBfZ2V0UGFyZW50Tm9kZShjYW52YXMpO1xuICAgIHJldHVybiAhIShjb250YWluZXIgJiYgY29udGFpbmVyLmlzQ29ubmVjdGVkKTtcbiAgfVxufVxuIiwgImltcG9ydCB7X2lzRG9tU3VwcG9ydGVkfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCBCYXNlUGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybS5iYXNlLmpzJztcbmltcG9ydCBCYXNpY1BsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm0uYmFzaWMuanMnO1xuaW1wb3J0IERvbVBsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm0uZG9tLmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIF9kZXRlY3RQbGF0Zm9ybShjYW52YXMpIHtcbiAgaWYgKCFfaXNEb21TdXBwb3J0ZWQoKSB8fCAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzKSkge1xuICAgIHJldHVybiBCYXNpY1BsYXRmb3JtO1xuICB9XG4gIHJldHVybiBEb21QbGF0Zm9ybTtcbn1cblxuZXhwb3J0IHtCYXNlUGxhdGZvcm0sIEJhc2ljUGxhdGZvcm0sIERvbVBsYXRmb3JtfTtcbiIsICJpbXBvcnQgdHlwZSB7QW55T2JqZWN0fSBmcm9tICcuLi90eXBlcy9iYXNpYy5qcyc7XG5pbXBvcnQgdHlwZSB7UG9pbnR9IGZyb20gJy4uL3R5cGVzL2dlb21ldHJpYy5qcyc7XG5pbXBvcnQgdHlwZSB7QW5pbWF0aW9ufSBmcm9tICcuLi90eXBlcy9hbmltYXRpb24uanMnO1xuaW1wb3J0IHtpc051bWJlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbGVtZW50PFQgPSBBbnlPYmplY3QsIE8gPSBBbnlPYmplY3Q+IHtcblxuICBzdGF0aWMgZGVmYXVsdHMgPSB7fTtcbiAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB1bmRlZmluZWQ7XG5cbiAgeDogbnVtYmVyO1xuICB5OiBudW1iZXI7XG4gIGFjdGl2ZSA9IGZhbHNlO1xuICBvcHRpb25zOiBPO1xuICAkYW5pbWF0aW9uczogUmVjb3JkPGtleW9mIFQsIEFuaW1hdGlvbj47XG5cbiAgdG9vbHRpcFBvc2l0aW9uKHVzZUZpbmFsUG9zaXRpb246IGJvb2xlYW4pOiBQb2ludCB7XG4gICAgY29uc3Qge3gsIHl9ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICByZXR1cm4ge3gsIHl9IGFzIFBvaW50O1xuICB9XG5cbiAgaGFzVmFsdWUoKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyKHRoaXMueCkgJiYgaXNOdW1iZXIodGhpcy55KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IG9yIGZpbmFsIHZhbHVlIG9mIGVhY2ggcHJvcC4gQ2FuIHJldHVybiBleHRyYSBwcm9wZXJ0aWVzICh3aG9sZSBvYmplY3QpLlxuICAgKiBAcGFyYW0gcHJvcHMgLSBwcm9wZXJ0aWVzIHRvIGdldFxuICAgKiBAcGFyYW0gW2ZpbmFsXSAtIGdldCB0aGUgZmluYWwgdmFsdWUgKGFuaW1hdGlvbiB0YXJnZXQpXG4gICAqL1xuICBnZXRQcm9wczxQIGV4dGVuZHMgKGtleW9mIFQpW10+KHByb3BzOiBQLCBmaW5hbD86IGJvb2xlYW4pOiBQaWNrPFQsIFBbbnVtYmVyXT47XG4gIGdldFByb3BzPFAgZXh0ZW5kcyBzdHJpbmc+KHByb3BzOiBQW10sIGZpbmFsPzogYm9vbGVhbik6IFBhcnRpYWw8UmVjb3JkPFAsIHVua25vd24+PjtcbiAgZ2V0UHJvcHMocHJvcHM6IHN0cmluZ1tdLCBmaW5hbD86IGJvb2xlYW4pOiBQYXJ0aWFsPFJlY29yZDxzdHJpbmcsIHVua25vd24+PiB7XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLiRhbmltYXRpb25zO1xuICAgIGlmICghZmluYWwgfHwgIWFuaW1zKSB7XG4gICAgICAvLyBsZXQncyBub3QgY3JlYXRlIGFuIG9iamVjdCwgaWYgbm90IG5lZWRlZFxuICAgICAgcmV0dXJuIHRoaXMgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gICAgfVxuICAgIGNvbnN0IHJldDogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7fTtcbiAgICBwcm9wcy5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICByZXRbcHJvcF0gPSBhbmltc1twcm9wXSAmJiBhbmltc1twcm9wXS5hY3RpdmUoKSA/IGFuaW1zW3Byb3BdLl90byA6IHRoaXNbcHJvcCBhcyBzdHJpbmddO1xuICAgIH0pO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbn1cbiIsICJpbXBvcnQge2lzTnVsbE9yVW5kZWYsIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge19mYWN0b3JpemV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICogQHR5cGVkZWYge3t2YWx1ZTpudW1iZXIgfCBzdHJpbmcsIGxhYmVsPzpzdHJpbmcsIG1ham9yPzpib29sZWFuLCAkY29udGV4dD86YW55fX0gVGlja1xuICovXG5cbi8qKlxuICogUmV0dXJucyBhIHN1YnNldCBvZiB0aWNrcyB0byBiZSBwbG90dGVkIHRvIGF2b2lkIG92ZXJsYXBwaW5nIGxhYmVscy5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2NvcmUuc2NhbGUuanMnKS5kZWZhdWx0fSBzY2FsZVxuICogQHBhcmFtIHtUaWNrW119IHRpY2tzXG4gKiBAcmV0dXJuIHtUaWNrW119XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXV0b1NraXAoc2NhbGUsIHRpY2tzKSB7XG4gIGNvbnN0IHRpY2tPcHRzID0gc2NhbGUub3B0aW9ucy50aWNrcztcbiAgY29uc3QgZGV0ZXJtaW5lZE1heFRpY2tzID0gZGV0ZXJtaW5lTWF4VGlja3Moc2NhbGUpO1xuICBjb25zdCB0aWNrc0xpbWl0ID0gTWF0aC5taW4odGlja09wdHMubWF4VGlja3NMaW1pdCB8fCBkZXRlcm1pbmVkTWF4VGlja3MsIGRldGVybWluZWRNYXhUaWNrcyk7XG4gIGNvbnN0IG1ham9ySW5kaWNlcyA9IHRpY2tPcHRzLm1ham9yLmVuYWJsZWQgPyBnZXRNYWpvckluZGljZXModGlja3MpIDogW107XG4gIGNvbnN0IG51bU1ham9ySW5kaWNlcyA9IG1ham9ySW5kaWNlcy5sZW5ndGg7XG4gIGNvbnN0IGZpcnN0ID0gbWFqb3JJbmRpY2VzWzBdO1xuICBjb25zdCBsYXN0ID0gbWFqb3JJbmRpY2VzW251bU1ham9ySW5kaWNlcyAtIDFdO1xuICBjb25zdCBuZXdUaWNrcyA9IFtdO1xuXG4gIC8vIElmIHRoZXJlIGFyZSB0b28gbWFueSBtYWpvciB0aWNrcyB0byBkaXNwbGF5IHRoZW0gYWxsXG4gIGlmIChudW1NYWpvckluZGljZXMgPiB0aWNrc0xpbWl0KSB7XG4gICAgc2tpcE1ham9ycyh0aWNrcywgbmV3VGlja3MsIG1ham9ySW5kaWNlcywgbnVtTWFqb3JJbmRpY2VzIC8gdGlja3NMaW1pdCk7XG4gICAgcmV0dXJuIG5ld1RpY2tzO1xuICB9XG5cbiAgY29uc3Qgc3BhY2luZyA9IGNhbGN1bGF0ZVNwYWNpbmcobWFqb3JJbmRpY2VzLCB0aWNrcywgdGlja3NMaW1pdCk7XG5cbiAgaWYgKG51bU1ham9ySW5kaWNlcyA+IDApIHtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBjb25zdCBhdmdNYWpvclNwYWNpbmcgPSBudW1NYWpvckluZGljZXMgPiAxID8gTWF0aC5yb3VuZCgobGFzdCAtIGZpcnN0KSAvIChudW1NYWpvckluZGljZXMgLSAxKSkgOiBudWxsO1xuICAgIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBpc051bGxPclVuZGVmKGF2Z01ham9yU3BhY2luZykgPyAwIDogZmlyc3QgLSBhdmdNYWpvclNwYWNpbmcsIGZpcnN0KTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbnVtTWFqb3JJbmRpY2VzIC0gMTsgaSA8IGlsZW47IGkrKykge1xuICAgICAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcsIG1ham9ySW5kaWNlc1tpXSwgbWFqb3JJbmRpY2VzW2kgKyAxXSk7XG4gICAgfVxuICAgIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBsYXN0LCBpc051bGxPclVuZGVmKGF2Z01ham9yU3BhY2luZykgPyB0aWNrcy5sZW5ndGggOiBsYXN0ICsgYXZnTWFqb3JTcGFjaW5nKTtcbiAgICByZXR1cm4gbmV3VGlja3M7XG4gIH1cbiAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcpO1xuICByZXR1cm4gbmV3VGlja3M7XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZU1heFRpY2tzKHNjYWxlKSB7XG4gIGNvbnN0IG9mZnNldCA9IHNjYWxlLm9wdGlvbnMub2Zmc2V0O1xuICBjb25zdCB0aWNrTGVuZ3RoID0gc2NhbGUuX3RpY2tTaXplKCk7XG4gIGNvbnN0IG1heFNjYWxlID0gc2NhbGUuX2xlbmd0aCAvIHRpY2tMZW5ndGggKyAob2Zmc2V0ID8gMCA6IDEpO1xuICBjb25zdCBtYXhDaGFydCA9IHNjYWxlLl9tYXhMZW5ndGggLyB0aWNrTGVuZ3RoO1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLm1pbihtYXhTY2FsZSwgbWF4Q2hhcnQpKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcltdfSBtYWpvckluZGljZXNcbiAqIEBwYXJhbSB7VGlja1tdfSB0aWNrc1xuICogQHBhcmFtIHtudW1iZXJ9IHRpY2tzTGltaXRcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlU3BhY2luZyhtYWpvckluZGljZXMsIHRpY2tzLCB0aWNrc0xpbWl0KSB7XG4gIGNvbnN0IGV2ZW5NYWpvclNwYWNpbmcgPSBnZXRFdmVuU3BhY2luZyhtYWpvckluZGljZXMpO1xuICBjb25zdCBzcGFjaW5nID0gdGlja3MubGVuZ3RoIC8gdGlja3NMaW1pdDtcblxuICAvLyBJZiB0aGUgbWFqb3IgdGlja3MgYXJlIGV2ZW5seSBzcGFjZWQgYXBhcnQsIHBsYWNlIHRoZSBtaW5vciB0aWNrc1xuICAvLyBzbyB0aGF0IHRoZXkgZGl2aWRlIHRoZSBtYWpvciB0aWNrcyBpbnRvIGV2ZW4gY2h1bmtzXG4gIGlmICghZXZlbk1ham9yU3BhY2luZykge1xuICAgIHJldHVybiBNYXRoLm1heChzcGFjaW5nLCAxKTtcbiAgfVxuXG4gIGNvbnN0IGZhY3RvcnMgPSBfZmFjdG9yaXplKGV2ZW5NYWpvclNwYWNpbmcpO1xuICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IGZhY3RvcnMubGVuZ3RoIC0gMTsgaSA8IGlsZW47IGkrKykge1xuICAgIGNvbnN0IGZhY3RvciA9IGZhY3RvcnNbaV07XG4gICAgaWYgKGZhY3RvciA+IHNwYWNpbmcpIHtcbiAgICAgIHJldHVybiBmYWN0b3I7XG4gICAgfVxuICB9XG4gIHJldHVybiBNYXRoLm1heChzcGFjaW5nLCAxKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpY2tbXX0gdGlja3NcbiAqL1xuZnVuY3Rpb24gZ2V0TWFqb3JJbmRpY2VzKHRpY2tzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgaSwgaWxlbjtcbiAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgIGlmICh0aWNrc1tpXS5tYWpvcikge1xuICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUaWNrW119IHRpY2tzXG4gKiBAcGFyYW0ge1RpY2tbXX0gbmV3VGlja3NcbiAqIEBwYXJhbSB7bnVtYmVyW119IG1ham9ySW5kaWNlc1xuICogQHBhcmFtIHtudW1iZXJ9IHNwYWNpbmdcbiAqL1xuZnVuY3Rpb24gc2tpcE1ham9ycyh0aWNrcywgbmV3VGlja3MsIG1ham9ySW5kaWNlcywgc3BhY2luZykge1xuICBsZXQgY291bnQgPSAwO1xuICBsZXQgbmV4dCA9IG1ham9ySW5kaWNlc1swXTtcbiAgbGV0IGk7XG5cbiAgc3BhY2luZyA9IE1hdGguY2VpbChzcGFjaW5nKTtcbiAgZm9yIChpID0gMDsgaSA8IHRpY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGkgPT09IG5leHQpIHtcbiAgICAgIG5ld1RpY2tzLnB1c2godGlja3NbaV0pO1xuICAgICAgY291bnQrKztcbiAgICAgIG5leHQgPSBtYWpvckluZGljZXNbY291bnQgKiBzcGFjaW5nXTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpY2tbXX0gdGlja3NcbiAqIEBwYXJhbSB7VGlja1tdfSBuZXdUaWNrc1xuICogQHBhcmFtIHtudW1iZXJ9IHNwYWNpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWFqb3JTdGFydF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWFqb3JFbmRdXG4gKi9cbmZ1bmN0aW9uIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBtYWpvclN0YXJ0LCBtYWpvckVuZCkge1xuICBjb25zdCBzdGFydCA9IHZhbHVlT3JEZWZhdWx0KG1ham9yU3RhcnQsIDApO1xuICBjb25zdCBlbmQgPSBNYXRoLm1pbih2YWx1ZU9yRGVmYXVsdChtYWpvckVuZCwgdGlja3MubGVuZ3RoKSwgdGlja3MubGVuZ3RoKTtcbiAgbGV0IGNvdW50ID0gMDtcbiAgbGV0IGxlbmd0aCwgaSwgbmV4dDtcblxuICBzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcpO1xuICBpZiAobWFqb3JFbmQpIHtcbiAgICBsZW5ndGggPSBtYWpvckVuZCAtIG1ham9yU3RhcnQ7XG4gICAgc3BhY2luZyA9IGxlbmd0aCAvIE1hdGguZmxvb3IobGVuZ3RoIC8gc3BhY2luZyk7XG4gIH1cblxuICBuZXh0ID0gc3RhcnQ7XG5cbiAgd2hpbGUgKG5leHQgPCAwKSB7XG4gICAgY291bnQrKztcbiAgICBuZXh0ID0gTWF0aC5yb3VuZChzdGFydCArIGNvdW50ICogc3BhY2luZyk7XG4gIH1cblxuICBmb3IgKGkgPSBNYXRoLm1heChzdGFydCwgMCk7IGkgPCBlbmQ7IGkrKykge1xuICAgIGlmIChpID09PSBuZXh0KSB7XG4gICAgICBuZXdUaWNrcy5wdXNoKHRpY2tzW2ldKTtcbiAgICAgIGNvdW50Kys7XG4gICAgICBuZXh0ID0gTWF0aC5yb3VuZChzdGFydCArIGNvdW50ICogc3BhY2luZyk7XG4gICAgfVxuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcltdfSBhcnJcbiAqL1xuZnVuY3Rpb24gZ2V0RXZlblNwYWNpbmcoYXJyKSB7XG4gIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG4gIGxldCBpLCBkaWZmO1xuXG4gIGlmIChsZW4gPCAyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChkaWZmID0gYXJyWzBdLCBpID0gMTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFycltpXSAtIGFycltpIC0gMV0gIT09IGRpZmYpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRpZmY7XG59XG4iLCAiaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IHtfYWxpZ25QaXhlbCwgX21lYXN1cmVUZXh0LCByZW5kZXJUZXh0LCBjbGlwQXJlYSwgdW5jbGlwQXJlYX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNhbnZhcy5qcyc7XG5pbXBvcnQge2NhbGxiYWNrIGFzIGNhbGwsIGVhY2gsIGZpbml0ZU9yRGVmYXVsdCwgaXNBcnJheSwgaXNGaW5pdGUsIGlzTnVsbE9yVW5kZWYsIGlzT2JqZWN0LCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHt0b0RlZ3JlZXMsIHRvUmFkaWFucywgX2ludDE2UmFuZ2UsIF9saW1pdFZhbHVlLCBIQUxGX1BJfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge19hbGlnblN0YXJ0RW5kLCBfdG9MZWZ0UmlnaHRDZW50ZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuaW1wb3J0IHtjcmVhdGVDb250ZXh0LCB0b0ZvbnQsIHRvUGFkZGluZywgX2FkZEdyYWNlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5pbXBvcnQge2F1dG9Ta2lwfSBmcm9tICcuL2NvcmUuc2NhbGUuYXV0b3NraXAuanMnO1xuXG5jb25zdCByZXZlcnNlQWxpZ24gPSAoYWxpZ24pID0+IGFsaWduID09PSAnbGVmdCcgPyAncmlnaHQnIDogYWxpZ24gPT09ICdyaWdodCcgPyAnbGVmdCcgOiBhbGlnbjtcbmNvbnN0IG9mZnNldEZyb21FZGdlID0gKHNjYWxlLCBlZGdlLCBvZmZzZXQpID0+IGVkZ2UgPT09ICd0b3AnIHx8IGVkZ2UgPT09ICdsZWZ0JyA/IHNjYWxlW2VkZ2VdICsgb2Zmc2V0IDogc2NhbGVbZWRnZV0gLSBvZmZzZXQ7XG5jb25zdCBnZXRUaWNrc0xpbWl0ID0gKHRpY2tzTGVuZ3RoLCBtYXhUaWNrc0xpbWl0KSA9PiBNYXRoLm1pbihtYXhUaWNrc0xpbWl0IHx8IHRpY2tzTGVuZ3RoLCB0aWNrc0xlbmd0aCk7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQ2hhcnQgfSBDaGFydFxuICogQHR5cGVkZWYge3t2YWx1ZTpudW1iZXIgfCBzdHJpbmcsIGxhYmVsPzpzdHJpbmcsIG1ham9yPzpib29sZWFuLCAkY29udGV4dD86YW55fX0gVGlja1xuICovXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBhcnJheSBjb250YWluaW5nIG51bUl0ZW1zIGZyb20gYXJyXG4gKiBAcGFyYW0ge2FueVtdfSBhcnJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1JdGVtc1xuICovXG5mdW5jdGlvbiBzYW1wbGUoYXJyLCBudW1JdGVtcykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgaW5jcmVtZW50ID0gYXJyLmxlbmd0aCAvIG51bUl0ZW1zO1xuICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBsZW47IGkgKz0gaW5jcmVtZW50KSB7XG4gICAgcmVzdWx0LnB1c2goYXJyW01hdGguZmxvb3IoaSldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U2NhbGV9IHNjYWxlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb2Zmc2V0R3JpZExpbmVzXG4gKi9cbmZ1bmN0aW9uIGdldFBpeGVsRm9yR3JpZExpbmUoc2NhbGUsIGluZGV4LCBvZmZzZXRHcmlkTGluZXMpIHtcbiAgY29uc3QgbGVuZ3RoID0gc2NhbGUudGlja3MubGVuZ3RoO1xuICBjb25zdCB2YWxpZEluZGV4ID0gTWF0aC5taW4oaW5kZXgsIGxlbmd0aCAtIDEpO1xuICBjb25zdCBzdGFydCA9IHNjYWxlLl9zdGFydFBpeGVsO1xuICBjb25zdCBlbmQgPSBzY2FsZS5fZW5kUGl4ZWw7XG4gIGNvbnN0IGVwc2lsb24gPSAxZS02OyAvLyAxZS02IGlzIG1hcmdpbiBpbiBwaXhlbHMgZm9yIGFjY3VtdWxhdGVkIGVycm9yLlxuICBsZXQgbGluZVZhbHVlID0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKHZhbGlkSW5kZXgpO1xuICBsZXQgb2Zmc2V0O1xuXG4gIGlmIChvZmZzZXRHcmlkTGluZXMpIHtcbiAgICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgICBvZmZzZXQgPSBNYXRoLm1heChsaW5lVmFsdWUgLSBzdGFydCwgZW5kIC0gbGluZVZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICBvZmZzZXQgPSAoc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKDEpIC0gbGluZVZhbHVlKSAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldCA9IChsaW5lVmFsdWUgLSBzY2FsZS5nZXRQaXhlbEZvclRpY2sodmFsaWRJbmRleCAtIDEpKSAvIDI7XG4gICAgfVxuICAgIGxpbmVWYWx1ZSArPSB2YWxpZEluZGV4IDwgaW5kZXggPyBvZmZzZXQgOiAtb2Zmc2V0O1xuXG4gICAgLy8gUmV0dXJuIHVuZGVmaW5lZCBpZiB0aGUgcGl4ZWwgaXMgb3V0IG9mIHRoZSByYW5nZVxuICAgIGlmIChsaW5lVmFsdWUgPCBzdGFydCAtIGVwc2lsb24gfHwgbGluZVZhbHVlID4gZW5kICsgZXBzaWxvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGluZVZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBjYWNoZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqL1xuZnVuY3Rpb24gZ2FyYmFnZUNvbGxlY3QoY2FjaGVzLCBsZW5ndGgpIHtcbiAgZWFjaChjYWNoZXMsIChjYWNoZSkgPT4ge1xuICAgIGNvbnN0IGdjID0gY2FjaGUuZ2M7XG4gICAgY29uc3QgZ2NMZW4gPSBnYy5sZW5ndGggLyAyO1xuICAgIGxldCBpO1xuICAgIGlmIChnY0xlbiA+IGxlbmd0aCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGdjTGVuOyArK2kpIHtcbiAgICAgICAgZGVsZXRlIGNhY2hlLmRhdGFbZ2NbaV1dO1xuICAgICAgfVxuICAgICAgZ2Muc3BsaWNlKDAsIGdjTGVuKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGdldFRpY2tNYXJrTGVuZ3RoKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuZHJhd1RpY2tzID8gb3B0aW9ucy50aWNrTGVuZ3RoIDogMDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBnZXRUaXRsZUhlaWdodChvcHRpb25zLCBmYWxsYmFjaykge1xuICBpZiAoIW9wdGlvbnMuZGlzcGxheSkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgY29uc3QgZm9udCA9IHRvRm9udChvcHRpb25zLmZvbnQsIGZhbGxiYWNrKTtcbiAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuICBjb25zdCBsaW5lcyA9IGlzQXJyYXkob3B0aW9ucy50ZXh0KSA/IG9wdGlvbnMudGV4dC5sZW5ndGggOiAxO1xuXG4gIHJldHVybiAobGluZXMgKiBmb250LmxpbmVIZWlnaHQpICsgcGFkZGluZy5oZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNjYWxlQ29udGV4dChwYXJlbnQsIHNjYWxlKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIHNjYWxlLFxuICAgIHR5cGU6ICdzY2FsZSdcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRpY2tDb250ZXh0KHBhcmVudCwgaW5kZXgsIHRpY2spIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgdGljayxcbiAgICBpbmRleCxcbiAgICB0eXBlOiAndGljaydcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHRpdGxlQWxpZ24oYWxpZ24sIHBvc2l0aW9uLCByZXZlcnNlKSB7XG4gIC8qKiBAdHlwZSB7Q2FudmFzVGV4dEFsaWdufSAqL1xuICBsZXQgcmV0ID0gX3RvTGVmdFJpZ2h0Q2VudGVyKGFsaWduKTtcbiAgaWYgKChyZXZlcnNlICYmIHBvc2l0aW9uICE9PSAncmlnaHQnKSB8fCAoIXJldmVyc2UgJiYgcG9zaXRpb24gPT09ICdyaWdodCcpKSB7XG4gICAgcmV0ID0gcmV2ZXJzZUFsaWduKHJldCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gdGl0bGVBcmdzKHNjYWxlLCBvZmZzZXQsIHBvc2l0aW9uLCBhbGlnbikge1xuICBjb25zdCB7dG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0LCBjaGFydH0gPSBzY2FsZTtcbiAgY29uc3Qge2NoYXJ0QXJlYSwgc2NhbGVzfSA9IGNoYXJ0O1xuICBsZXQgcm90YXRpb24gPSAwO1xuICBsZXQgbWF4V2lkdGgsIHRpdGxlWCwgdGl0bGVZO1xuICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuXG4gIGlmIChzY2FsZS5pc0hvcml6b250YWwoKSkge1xuICAgIHRpdGxlWCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBsZWZ0LCByaWdodCk7XG5cbiAgICBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgdGl0bGVZID0gc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSArIGhlaWdodCAtIG9mZnNldDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgdGl0bGVZID0gKGNoYXJ0QXJlYS5ib3R0b20gKyBjaGFydEFyZWEudG9wKSAvIDIgKyBoZWlnaHQgLSBvZmZzZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpdGxlWSA9IG9mZnNldEZyb21FZGdlKHNjYWxlLCBwb3NpdGlvbiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgbWF4V2lkdGggPSByaWdodCAtIGxlZnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgIHRpdGxlWCA9IHNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkgLSB3aWR0aCArIG9mZnNldDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgdGl0bGVYID0gKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDIgLSB3aWR0aCArIG9mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGl0bGVYID0gb2Zmc2V0RnJvbUVkZ2Uoc2NhbGUsIHBvc2l0aW9uLCBvZmZzZXQpO1xuICAgIH1cbiAgICB0aXRsZVkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgYm90dG9tLCB0b3ApO1xuICAgIHJvdGF0aW9uID0gcG9zaXRpb24gPT09ICdsZWZ0JyA/IC1IQUxGX1BJIDogSEFMRl9QSTtcbiAgfVxuICByZXR1cm4ge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY2FsZSBleHRlbmRzIEVsZW1lbnQge1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtc3RhdGVtZW50c1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdGhpcy5pZCA9IGNmZy5pZDtcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICB0aGlzLnR5cGUgPSBjZmcudHlwZTtcbiAgICAvKiogQHR5cGUge2FueX0gKi9cbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICovXG4gICAgdGhpcy5jdHggPSBjZmcuY3R4O1xuICAgIC8qKiBAdHlwZSB7Q2hhcnR9ICovXG4gICAgdGhpcy5jaGFydCA9IGNmZy5jaGFydDtcblxuICAgIC8vIGltcGxlbWVudHMgYm94XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMucmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9tYXJnaW5zID0ge1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwXG4gICAgfTtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLm1heFdpZHRoID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMucGFkZGluZ1RvcCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5wYWRkaW5nTGVmdCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnBhZGRpbmdSaWdodCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIHNjYWxlLXNwZWNpZmljIHByb3BlcnRpZXNcbiAgICAvKiogQHR5cGUge3N0cmluZz19ICovXG4gICAgdGhpcy5heGlzID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyPX0gKi9cbiAgICB0aGlzLmxhYmVsUm90YXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5taW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmFuZ2UgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtUaWNrW119ICovXG4gICAgdGhpcy50aWNrcyA9IFtdO1xuICAgIC8qKiBAdHlwZSB7b2JqZWN0W118bnVsbH0gKi9cbiAgICB0aGlzLl9ncmlkTGluZUl0ZW1zID0gbnVsbDtcbiAgICAvKiogQHR5cGUge29iamVjdFtdfG51bGx9ICovXG4gICAgdGhpcy5fbGFiZWxJdGVtcyA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtvYmplY3R8bnVsbH0gKi9cbiAgICB0aGlzLl9sYWJlbFNpemVzID0gbnVsbDtcbiAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgIHRoaXMuX21heExlbmd0aCA9IDA7XG4gICAgdGhpcy5fbG9uZ2VzdFRleHRDYWNoZSA9IHt9O1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX3N0YXJ0UGl4ZWwgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fZW5kUGl4ZWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmV2ZXJzZVBpeGVscyA9IGZhbHNlO1xuICAgIHRoaXMuX3VzZXJNYXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdXNlck1pbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zdWdnZXN0ZWRNYXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3VnZ2VzdGVkTWluID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3RpY2tzTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9ib3JkZXJWYWx1ZSA9IDA7XG4gICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gZmFsc2U7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge2FueX0gb3B0aW9uc1xuXHQgKiBAc2luY2UgMy4wXG5cdCAqL1xuICBpbml0KG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuXG4gICAgdGhpcy5heGlzID0gb3B0aW9ucy5heGlzO1xuXG4gICAgLy8gcGFyc2UgbWluL21heCB2YWx1ZSwgc28gd2UgY2FuIHByb3Blcmx5IGRldGVybWluZSBtaW4vbWF4IGZvciBvdGhlciBzY2FsZXNcbiAgICB0aGlzLl91c2VyTWluID0gdGhpcy5wYXJzZShvcHRpb25zLm1pbik7XG4gICAgdGhpcy5fdXNlck1heCA9IHRoaXMucGFyc2Uob3B0aW9ucy5tYXgpO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1pbiA9IHRoaXMucGFyc2Uob3B0aW9ucy5zdWdnZXN0ZWRNaW4pO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1heCA9IHRoaXMucGFyc2Uob3B0aW9ucy5zdWdnZXN0ZWRNYXgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFBhcnNlIGEgc3VwcG9ydGVkIGlucHV0IHZhbHVlIHRvIGludGVybmFsIHJlcHJlc2VudGF0aW9uLlxuXHQgKiBAcGFyYW0geyp9IHJhd1xuXHQgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4XVxuXHQgKiBAc2luY2UgMy4wXG5cdCAqL1xuICBwYXJzZShyYXcsIGluZGV4KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICByZXR1cm4gcmF3O1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXIsIG1pbkRlZmluZWQ6IGJvb2xlYW4sIG1heERlZmluZWQ6IGJvb2xlYW59fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAzLjBcblx0ICovXG4gIGdldFVzZXJCb3VuZHMoKSB7XG4gICAgbGV0IHtfdXNlck1pbiwgX3VzZXJNYXgsIF9zdWdnZXN0ZWRNaW4sIF9zdWdnZXN0ZWRNYXh9ID0gdGhpcztcbiAgICBfdXNlck1pbiA9IGZpbml0ZU9yRGVmYXVsdChfdXNlck1pbiwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICBfdXNlck1heCA9IGZpbml0ZU9yRGVmYXVsdChfdXNlck1heCwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcbiAgICBfc3VnZ2VzdGVkTWluID0gZmluaXRlT3JEZWZhdWx0KF9zdWdnZXN0ZWRNaW4sIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgX3N1Z2dlc3RlZE1heCA9IGZpbml0ZU9yRGVmYXVsdChfc3VnZ2VzdGVkTWF4LCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO1xuICAgIHJldHVybiB7XG4gICAgICBtaW46IGZpbml0ZU9yRGVmYXVsdChfdXNlck1pbiwgX3N1Z2dlc3RlZE1pbiksXG4gICAgICBtYXg6IGZpbml0ZU9yRGVmYXVsdChfdXNlck1heCwgX3N1Z2dlc3RlZE1heCksXG4gICAgICBtaW5EZWZpbmVkOiBpc0Zpbml0ZShfdXNlck1pbiksXG4gICAgICBtYXhEZWZpbmVkOiBpc0Zpbml0ZShfdXNlck1heClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gY2FuU3RhY2tcblx0ICogQHJldHVybiB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn19XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDMuMFxuXHQgKi9cbiAgZ2V0TWluTWF4KGNhblN0YWNrKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgIGxldCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IHJhbmdlO1xuXG4gICAgaWYgKG1pbkRlZmluZWQgJiYgbWF4RGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHttaW4sIG1heH07XG4gICAgfVxuXG4gICAgY29uc3QgbWV0YXMgPSB0aGlzLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBtZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHJhbmdlID0gbWV0YXNbaV0uY29udHJvbGxlci5nZXRNaW5NYXgodGhpcywgY2FuU3RhY2spO1xuICAgICAgaWYgKCFtaW5EZWZpbmVkKSB7XG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgcmFuZ2UubWluKTtcbiAgICAgIH1cbiAgICAgIGlmICghbWF4RGVmaW5lZCkge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHJhbmdlLm1heCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIG1pbiA8PSBtYXggd2hlbiBvbmx5IG1pbiBvciBtYXggaXMgZGVmaW5lZCBieSB1c2VyIGFuZCB0aGUgZGF0YSBpcyBvdXRzaWRlIHRoYXQgcmFuZ2VcbiAgICBtaW4gPSBtYXhEZWZpbmVkICYmIG1pbiA+IG1heCA/IG1heCA6IG1pbjtcbiAgICBtYXggPSBtaW5EZWZpbmVkICYmIG1pbiA+IG1heCA/IG1pbiA6IG1heDtcblxuICAgIHJldHVybiB7XG4gICAgICBtaW46IGZpbml0ZU9yRGVmYXVsdChtaW4sIGZpbml0ZU9yRGVmYXVsdChtYXgsIG1pbikpLFxuICAgICAgbWF4OiBmaW5pdGVPckRlZmF1bHQobWF4LCBmaW5pdGVPckRlZmF1bHQobWluLCBtYXgpKVxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogR2V0IHRoZSBwYWRkaW5nIG5lZWRlZCBmb3IgdGhlIHNjYWxlXG5cdCAqIEByZXR1cm4ge3t0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyLCBib3R0b206IG51bWJlciwgcmlnaHQ6IG51bWJlcn19IHRoZSBuZWNlc3NhcnkgcGFkZGluZ1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgZ2V0UGFkZGluZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogdGhpcy5wYWRkaW5nTGVmdCB8fCAwLFxuICAgICAgdG9wOiB0aGlzLnBhZGRpbmdUb3AgfHwgMCxcbiAgICAgIHJpZ2h0OiB0aGlzLnBhZGRpbmdSaWdodCB8fCAwLFxuICAgICAgYm90dG9tOiB0aGlzLnBhZGRpbmdCb3R0b20gfHwgMFxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgc2NhbGUgdGljayBvYmplY3RzXG5cdCAqIEByZXR1cm4ge1RpY2tbXX1cblx0ICogQHNpbmNlIDIuN1xuXHQgKi9cbiAgZ2V0VGlja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudGlja3M7XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7c3RyaW5nW119XG5cdCAqL1xuICBnZXRMYWJlbHMoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuY2hhcnQuZGF0YTtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxhYmVscyB8fCAodGhpcy5pc0hvcml6b250YWwoKSA/IGRhdGEueExhYmVscyA6IGRhdGEueUxhYmVscykgfHwgZGF0YS5sYWJlbHMgfHwgW107XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KCcuLi90eXBlcy5qcycpLkxhYmVsSXRlbVtdfVxuICAgKi9cbiAgZ2V0TGFiZWxJdGVtcyhjaGFydEFyZWEgPSB0aGlzLmNoYXJ0LmNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fbGFiZWxJdGVtcyB8fCAodGhpcy5fbGFiZWxJdGVtcyA9IHRoaXMuX2NvbXB1dGVMYWJlbEl0ZW1zKGNoYXJ0QXJlYSkpO1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuXG4gIC8vIFdoZW4gYSBuZXcgbGF5b3V0IGlzIGNyZWF0ZWQsIHJlc2V0IHRoZSBkYXRhIGxpbWl0cyBjYWNoZVxuICBiZWZvcmVMYXlvdXQoKSB7XG4gICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gZmFsc2U7XG4gIH1cblxuICAvLyBUaGVzZSBtZXRob2RzIGFyZSBvcmRlcmVkIGJ5IGxpZmVjeWNsZS4gVXRpbGl0aWVzIHRoZW4gZm9sbG93LlxuICAvLyBBbnkgZnVuY3Rpb24gZGVmaW5lZCBoZXJlIGlzIGluaGVyaXRlZCBieSBhbGwgc2NhbGUgdHlwZXMuXG4gIC8vIEFueSBmdW5jdGlvbiBjYW4gYmUgZXh0ZW5kZWQgYnkgdGhlIHNjYWxlIHR5cGVcblxuICBiZWZvcmVVcGRhdGUoKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYmVmb3JlVXBkYXRlLCBbdGhpc10pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXhXaWR0aCAtIHRoZSBtYXggd2lkdGggaW4gcGl4ZWxzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXhIZWlnaHQgLSB0aGUgbWF4IGhlaWdodCBpbiBwaXhlbHNcblx0ICogQHBhcmFtIHt7dG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlciwgYm90dG9tOiBudW1iZXIsIHJpZ2h0OiBudW1iZXJ9fSBtYXJnaW5zIC0gdGhlIHNwYWNlIGJldHdlZW4gdGhlIGVkZ2Ugb2YgdGhlIG90aGVyIHNjYWxlcyBhbmQgZWRnZSBvZiB0aGUgY2hhcnRcblx0ICogICBUaGlzIHNwYWNlIGNvbWVzIGZyb20gdHdvIHNvdXJjZXM6XG5cdCAqICAgICAtIHBhZGRpbmcgLSBzcGFjZSB0aGF0J3MgcmVxdWlyZWQgdG8gc2hvdyB0aGUgbGFiZWxzIGF0IHRoZSBlZGdlcyBvZiB0aGUgc2NhbGVcblx0ICogICAgIC0gdGhpY2tuZXNzIG9mIHNjYWxlcyBvciBsZWdlbmRzIGluIGFub3RoZXIgb3JpZW50YXRpb25cblx0ICovXG4gIHVwZGF0ZShtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XG4gICAgY29uc3Qge2JlZ2luQXRaZXJvLCBncmFjZSwgdGlja3M6IHRpY2tPcHRzfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBzYW1wbGVTaXplID0gdGlja09wdHMuc2FtcGxlU2l6ZTtcblxuICAgIC8vIFVwZGF0ZSBMaWZlY3ljbGUgLSBQcm9iYWJseSBkb24ndCB3YW50IHRvIGV2ZXIgZXh0ZW5kIG9yIG92ZXJ3cml0ZSB0aGlzIGZ1bmN0aW9uIDspXG4gICAgdGhpcy5iZWZvcmVVcGRhdGUoKTtcblxuICAgIC8vIEFic29yYiB0aGUgbWFzdGVyIG1lYXN1cmVtZW50c1xuICAgIHRoaXMubWF4V2lkdGggPSBtYXhXaWR0aDtcbiAgICB0aGlzLm1heEhlaWdodCA9IG1heEhlaWdodDtcbiAgICB0aGlzLl9tYXJnaW5zID0gbWFyZ2lucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwXG4gICAgfSwgbWFyZ2lucyk7XG5cbiAgICB0aGlzLnRpY2tzID0gbnVsbDtcbiAgICB0aGlzLl9sYWJlbFNpemVzID0gbnVsbDtcbiAgICB0aGlzLl9ncmlkTGluZUl0ZW1zID0gbnVsbDtcbiAgICB0aGlzLl9sYWJlbEl0ZW1zID0gbnVsbDtcblxuICAgIC8vIERpbWVuc2lvbnNcbiAgICB0aGlzLmJlZm9yZVNldERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLnNldERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLmFmdGVyU2V0RGltZW5zaW9ucygpO1xuXG4gICAgdGhpcy5fbWF4TGVuZ3RoID0gdGhpcy5pc0hvcml6b250YWwoKVxuICAgICAgPyB0aGlzLndpZHRoICsgbWFyZ2lucy5sZWZ0ICsgbWFyZ2lucy5yaWdodFxuICAgICAgOiB0aGlzLmhlaWdodCArIG1hcmdpbnMudG9wICsgbWFyZ2lucy5ib3R0b207XG5cbiAgICAvLyBEYXRhIG1pbi9tYXhcbiAgICBpZiAoIXRoaXMuX2RhdGFMaW1pdHNDYWNoZWQpIHtcbiAgICAgIHRoaXMuYmVmb3JlRGF0YUxpbWl0cygpO1xuICAgICAgdGhpcy5kZXRlcm1pbmVEYXRhTGltaXRzKCk7XG4gICAgICB0aGlzLmFmdGVyRGF0YUxpbWl0cygpO1xuICAgICAgdGhpcy5fcmFuZ2UgPSBfYWRkR3JhY2UodGhpcywgZ3JhY2UsIGJlZ2luQXRaZXJvKTtcbiAgICAgIHRoaXMuX2RhdGFMaW1pdHNDYWNoZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuYmVmb3JlQnVpbGRUaWNrcygpO1xuXG4gICAgdGhpcy50aWNrcyA9IHRoaXMuYnVpbGRUaWNrcygpIHx8IFtdO1xuXG4gICAgLy8gQWxsb3cgbW9kaWZpY2F0aW9uIG9mIHRpY2tzIGluIGNhbGxiYWNrLlxuICAgIHRoaXMuYWZ0ZXJCdWlsZFRpY2tzKCk7XG5cbiAgICAvLyBDb21wdXRlIHRpY2sgcm90YXRpb24gYW5kIGZpdCB1c2luZyBhIHNhbXBsZWQgc3Vic2V0IG9mIGxhYmVsc1xuICAgIC8vIFdlIGdlbmVyYWxseSBkb24ndCBuZWVkIHRvIGNvbXB1dGUgdGhlIHNpemUgb2YgZXZlcnkgc2luZ2xlIGxhYmVsIGZvciBkZXRlcm1pbmluZyBzY2FsZSBzaXplXG4gICAgY29uc3Qgc2FtcGxpbmdFbmFibGVkID0gc2FtcGxlU2l6ZSA8IHRoaXMudGlja3MubGVuZ3RoO1xuICAgIHRoaXMuX2NvbnZlcnRUaWNrc1RvTGFiZWxzKHNhbXBsaW5nRW5hYmxlZCA/IHNhbXBsZSh0aGlzLnRpY2tzLCBzYW1wbGVTaXplKSA6IHRoaXMudGlja3MpO1xuXG4gICAgLy8gY29uZmlndXJlIGlzIGNhbGxlZCB0d2ljZSwgb25jZSBoZXJlLCBvbmNlIGZyb20gY29yZS5jb250cm9sbGVyLnVwZGF0ZUxheW91dC5cbiAgICAvLyBIZXJlIHdlIGhhdmVuJ3QgYmVlbiBwb3NpdGlvbmVkIHlldCwgYnV0IGRpbWVuc2lvbnMgYXJlIGNvcnJlY3QuXG4gICAgLy8gVmFyaWFibGVzIHNldCBpbiBjb25maWd1cmUgYXJlIG5lZWRlZCBmb3IgY2FsY3VsYXRlTGFiZWxSb3RhdGlvbiwgYW5kXG4gICAgLy8gaXQncyBvayB0aGF0IGNvb3JkaW5hdGVzIGFyZSBub3QgY29ycmVjdCB0aGVyZSwgb25seSBkaW1lbnNpb25zIG1hdHRlci5cbiAgICB0aGlzLmNvbmZpZ3VyZSgpO1xuXG4gICAgLy8gVGljayBSb3RhdGlvblxuICAgIHRoaXMuYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpO1xuICAgIHRoaXMuY2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpOyAvLyBQcmVjb25kaXRpb25zOiBudW1iZXIgb2YgdGlja3MgYW5kIHNpemVzIG9mIGxhcmdlc3QgbGFiZWxzIG11c3QgYmUgY2FsY3VsYXRlZCBiZWZvcmVoYW5kXG4gICAgdGhpcy5hZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKTtcblxuICAgIC8vIEF1dG8tc2tpcFxuICAgIGlmICh0aWNrT3B0cy5kaXNwbGF5ICYmICh0aWNrT3B0cy5hdXRvU2tpcCB8fCB0aWNrT3B0cy5zb3VyY2UgPT09ICdhdXRvJykpIHtcbiAgICAgIHRoaXMudGlja3MgPSBhdXRvU2tpcCh0aGlzLCB0aGlzLnRpY2tzKTtcbiAgICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBudWxsO1xuICAgICAgdGhpcy5hZnRlckF1dG9Ta2lwKCk7XG4gICAgfVxuXG4gICAgaWYgKHNhbXBsaW5nRW5hYmxlZCkge1xuICAgICAgLy8gR2VuZXJhdGUgbGFiZWxzIHVzaW5nIGFsbCBub24tc2tpcHBlZCB0aWNrc1xuICAgICAgdGhpcy5fY29udmVydFRpY2tzVG9MYWJlbHModGhpcy50aWNrcyk7XG4gICAgfVxuXG4gICAgdGhpcy5iZWZvcmVGaXQoKTtcbiAgICB0aGlzLmZpdCgpOyAvLyBQcmVjb25kaXRpb25zOiBsYWJlbCByb3RhdGlvbiBhbmQgbGFiZWwgc2l6ZXMgbXVzdCBiZSBjYWxjdWxhdGVkIGJlZm9yZWhhbmRcbiAgICB0aGlzLmFmdGVyRml0KCk7XG5cbiAgICAvLyBJTVBPUlRBTlQ6IGFmdGVyIHRoaXMgcG9pbnQsIHdlIGNvbnNpZGVyIHRoYXQgYHRoaXMudGlja3NgIHdpbGwgTkVWRVIgY2hhbmdlIVxuXG4gICAgdGhpcy5hZnRlclVwZGF0ZSgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBsZXQgcmV2ZXJzZVBpeGVscyA9IHRoaXMub3B0aW9ucy5yZXZlcnNlO1xuICAgIGxldCBzdGFydFBpeGVsLCBlbmRQaXhlbDtcblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBzdGFydFBpeGVsID0gdGhpcy5sZWZ0O1xuICAgICAgZW5kUGl4ZWwgPSB0aGlzLnJpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFBpeGVsID0gdGhpcy50b3A7XG4gICAgICBlbmRQaXhlbCA9IHRoaXMuYm90dG9tO1xuICAgICAgLy8gYnkgZGVmYXVsdCB2ZXJ0aWNhbCBzY2FsZXMgYXJlIGZyb20gYm90dG9tIHRvIHRvcCwgc28gcGl4ZWxzIGFyZSByZXZlcnNlZFxuICAgICAgcmV2ZXJzZVBpeGVscyA9ICFyZXZlcnNlUGl4ZWxzO1xuICAgIH1cbiAgICB0aGlzLl9zdGFydFBpeGVsID0gc3RhcnRQaXhlbDtcbiAgICB0aGlzLl9lbmRQaXhlbCA9IGVuZFBpeGVsO1xuICAgIHRoaXMuX3JldmVyc2VQaXhlbHMgPSByZXZlcnNlUGl4ZWxzO1xuICAgIHRoaXMuX2xlbmd0aCA9IGVuZFBpeGVsIC0gc3RhcnRQaXhlbDtcbiAgICB0aGlzLl9hbGlnblRvUGl4ZWxzID0gdGhpcy5vcHRpb25zLmFsaWduVG9QaXhlbHM7XG4gIH1cblxuICBhZnRlclVwZGF0ZSgpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5hZnRlclVwZGF0ZSwgW3RoaXNdKTtcbiAgfVxuXG4gIC8vXG5cbiAgYmVmb3JlU2V0RGltZW5zaW9ucygpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5iZWZvcmVTZXREaW1lbnNpb25zLCBbdGhpc10pO1xuICB9XG4gIHNldERpbWVuc2lvbnMoKSB7XG4gICAgLy8gU2V0IHRoZSB1bmNvbnN0cmFpbmVkIGRpbWVuc2lvbiBiZWZvcmUgbGFiZWwgcm90YXRpb25cbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgLy8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5tYXhXaWR0aDtcbiAgICAgIHRoaXMubGVmdCA9IDA7XG4gICAgICB0aGlzLnJpZ2h0ID0gdGhpcy53aWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLm1heEhlaWdodDtcblxuICAgICAgLy8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXG4gICAgICB0aGlzLnRvcCA9IDA7XG4gICAgICB0aGlzLmJvdHRvbSA9IHRoaXMuaGVpZ2h0O1xuICAgIH1cblxuICAgIC8vIFJlc2V0IHBhZGRpbmdcbiAgICB0aGlzLnBhZGRpbmdMZWZ0ID0gMDtcbiAgICB0aGlzLnBhZGRpbmdUb3AgPSAwO1xuICAgIHRoaXMucGFkZGluZ1JpZ2h0ID0gMDtcbiAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSAwO1xuICB9XG4gIGFmdGVyU2V0RGltZW5zaW9ucygpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5hZnRlclNldERpbWVuc2lvbnMsIFt0aGlzXSk7XG4gIH1cblxuICBfY2FsbEhvb2tzKG5hbWUpIHtcbiAgICB0aGlzLmNoYXJ0Lm5vdGlmeVBsdWdpbnMobmFtZSwgdGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNhbGwodGhpcy5vcHRpb25zW25hbWVdLCBbdGhpc10pO1xuICB9XG5cbiAgLy8gRGF0YSBsaW1pdHNcbiAgYmVmb3JlRGF0YUxpbWl0cygpIHtcbiAgICB0aGlzLl9jYWxsSG9va3MoJ2JlZm9yZURhdGFMaW1pdHMnKTtcbiAgfVxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge31cbiAgYWZ0ZXJEYXRhTGltaXRzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYWZ0ZXJEYXRhTGltaXRzJyk7XG4gIH1cblxuICAvL1xuICBiZWZvcmVCdWlsZFRpY2tzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYmVmb3JlQnVpbGRUaWNrcycpO1xuICB9XG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtvYmplY3RbXX0gdGhlIHRpY2tzXG5cdCAqL1xuICBidWlsZFRpY2tzKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBhZnRlckJ1aWxkVGlja3MoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdhZnRlckJ1aWxkVGlja3MnKTtcbiAgfVxuXG4gIGJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbigpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5iZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24sIFt0aGlzXSk7XG4gIH1cbiAgLyoqXG5cdCAqIENvbnZlcnQgdGlja3MgdG8gbGFiZWwgc3RyaW5nc1xuXHQgKiBAcGFyYW0ge1RpY2tbXX0gdGlja3Ncblx0ICovXG4gIGdlbmVyYXRlVGlja0xhYmVscyh0aWNrcykge1xuICAgIGNvbnN0IHRpY2tPcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgIGxldCBpLCBpbGVuLCB0aWNrO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHRpY2sgPSB0aWNrc1tpXTtcbiAgICAgIHRpY2subGFiZWwgPSBjYWxsKHRpY2tPcHRzLmNhbGxiYWNrLCBbdGljay52YWx1ZSwgaSwgdGlja3NdLCB0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24oKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24sIFt0aGlzXSk7XG4gIH1cblxuICAvL1xuXG4gIGJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiwgW3RoaXNdKTtcbiAgfVxuICBjYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGlja09wdHMgPSBvcHRpb25zLnRpY2tzO1xuICAgIGNvbnN0IG51bVRpY2tzID0gZ2V0VGlja3NMaW1pdCh0aGlzLnRpY2tzLmxlbmd0aCwgb3B0aW9ucy50aWNrcy5tYXhUaWNrc0xpbWl0KTtcbiAgICBjb25zdCBtaW5Sb3RhdGlvbiA9IHRpY2tPcHRzLm1pblJvdGF0aW9uIHx8IDA7XG4gICAgY29uc3QgbWF4Um90YXRpb24gPSB0aWNrT3B0cy5tYXhSb3RhdGlvbjtcbiAgICBsZXQgbGFiZWxSb3RhdGlvbiA9IG1pblJvdGF0aW9uO1xuICAgIGxldCB0aWNrV2lkdGgsIG1heEhlaWdodCwgbWF4TGFiZWxEaWFnb25hbDtcblxuICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkgfHwgIXRpY2tPcHRzLmRpc3BsYXkgfHwgbWluUm90YXRpb24gPj0gbWF4Um90YXRpb24gfHwgbnVtVGlja3MgPD0gMSB8fCAhdGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGhpcy5sYWJlbFJvdGF0aW9uID0gbWluUm90YXRpb247XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBjb25zdCBtYXhMYWJlbFdpZHRoID0gbGFiZWxTaXplcy53aWRlc3Qud2lkdGg7XG4gICAgY29uc3QgbWF4TGFiZWxIZWlnaHQgPSBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0O1xuXG4gICAgLy8gRXN0aW1hdGUgdGhlIHdpZHRoIG9mIGVhY2ggZ3JpZCBiYXNlZCBvbiB0aGUgY2FudmFzIHdpZHRoLCB0aGUgbWF4aW11bVxuICAgIC8vIGxhYmVsIHdpZHRoIGFuZCB0aGUgbnVtYmVyIG9mIHRpY2sgaW50ZXJ2YWxzXG4gICAgY29uc3QgbWF4V2lkdGggPSBfbGltaXRWYWx1ZSh0aGlzLmNoYXJ0LndpZHRoIC0gbWF4TGFiZWxXaWR0aCwgMCwgdGhpcy5tYXhXaWR0aCk7XG4gICAgdGlja1dpZHRoID0gb3B0aW9ucy5vZmZzZXQgPyB0aGlzLm1heFdpZHRoIC8gbnVtVGlja3MgOiBtYXhXaWR0aCAvIChudW1UaWNrcyAtIDEpO1xuXG4gICAgLy8gQWxsb3cgMyBwaXhlbHMgeDIgcGFkZGluZyBlaXRoZXIgc2lkZSBmb3IgbGFiZWwgcmVhZGFiaWxpdHlcbiAgICBpZiAobWF4TGFiZWxXaWR0aCArIDYgPiB0aWNrV2lkdGgpIHtcbiAgICAgIHRpY2tXaWR0aCA9IG1heFdpZHRoIC8gKG51bVRpY2tzIC0gKG9wdGlvbnMub2Zmc2V0ID8gMC41IDogMSkpO1xuICAgICAgbWF4SGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQgLSBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zLmdyaWQpXG5cdFx0XHRcdC0gdGlja09wdHMucGFkZGluZyAtIGdldFRpdGxlSGVpZ2h0KG9wdGlvbnMudGl0bGUsIHRoaXMuY2hhcnQub3B0aW9ucy5mb250KTtcbiAgICAgIG1heExhYmVsRGlhZ29uYWwgPSBNYXRoLnNxcnQobWF4TGFiZWxXaWR0aCAqIG1heExhYmVsV2lkdGggKyBtYXhMYWJlbEhlaWdodCAqIG1heExhYmVsSGVpZ2h0KTtcbiAgICAgIGxhYmVsUm90YXRpb24gPSB0b0RlZ3JlZXMoTWF0aC5taW4oXG4gICAgICAgIE1hdGguYXNpbihfbGltaXRWYWx1ZSgobGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCArIDYpIC8gdGlja1dpZHRoLCAtMSwgMSkpLFxuICAgICAgICBNYXRoLmFzaW4oX2xpbWl0VmFsdWUobWF4SGVpZ2h0IC8gbWF4TGFiZWxEaWFnb25hbCwgLTEsIDEpKSAtIE1hdGguYXNpbihfbGltaXRWYWx1ZShtYXhMYWJlbEhlaWdodCAvIG1heExhYmVsRGlhZ29uYWwsIC0xLCAxKSlcbiAgICAgICkpO1xuICAgICAgbGFiZWxSb3RhdGlvbiA9IE1hdGgubWF4KG1pblJvdGF0aW9uLCBNYXRoLm1pbihtYXhSb3RhdGlvbiwgbGFiZWxSb3RhdGlvbikpO1xuICAgIH1cblxuICAgIHRoaXMubGFiZWxSb3RhdGlvbiA9IGxhYmVsUm90YXRpb247XG4gIH1cbiAgYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiwgW3RoaXNdKTtcbiAgfVxuICBhZnRlckF1dG9Ta2lwKCkge31cblxuICAvL1xuXG4gIGJlZm9yZUZpdCgpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5iZWZvcmVGaXQsIFt0aGlzXSk7XG4gIH1cbiAgZml0KCkge1xuICAgIC8vIFJlc2V0XG4gICAgY29uc3QgbWluU2l6ZSA9IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfTtcblxuICAgIGNvbnN0IHtjaGFydCwgb3B0aW9uczoge3RpY2tzOiB0aWNrT3B0cywgdGl0bGU6IHRpdGxlT3B0cywgZ3JpZDogZ3JpZE9wdHN9fSA9IHRoaXM7XG4gICAgY29uc3QgZGlzcGxheSA9IHRoaXMuX2lzVmlzaWJsZSgpO1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG5cbiAgICBpZiAoZGlzcGxheSkge1xuICAgICAgY29uc3QgdGl0bGVIZWlnaHQgPSBnZXRUaXRsZUhlaWdodCh0aXRsZU9wdHMsIGNoYXJ0Lm9wdGlvbnMuZm9udCk7XG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIG1pblNpemUud2lkdGggPSB0aGlzLm1heFdpZHRoO1xuICAgICAgICBtaW5TaXplLmhlaWdodCA9IGdldFRpY2tNYXJrTGVuZ3RoKGdyaWRPcHRzKSArIHRpdGxlSGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWluU2l6ZS5oZWlnaHQgPSB0aGlzLm1heEhlaWdodDsgLy8gZmlsbCBhbGwgdGhlIGhlaWdodFxuICAgICAgICBtaW5TaXplLndpZHRoID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZE9wdHMpICsgdGl0bGVIZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIC8vIERvbid0IGJvdGhlciBmaXR0aW5nIHRoZSB0aWNrcyBpZiB3ZSBhcmUgbm90IHNob3dpbmcgdGhlIGxhYmVsc1xuICAgICAgaWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgdGhpcy50aWNrcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3Qge2ZpcnN0LCBsYXN0LCB3aWRlc3QsIGhpZ2hlc3R9ID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgICAgICBjb25zdCB0aWNrUGFkZGluZyA9IHRpY2tPcHRzLnBhZGRpbmcgKiAyO1xuICAgICAgICBjb25zdCBhbmdsZVJhZGlhbnMgPSB0b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcbiAgICAgICAgY29uc3QgY29zID0gTWF0aC5jb3MoYW5nbGVSYWRpYW5zKTtcbiAgICAgICAgY29uc3Qgc2luID0gTWF0aC5zaW4oYW5nbGVSYWRpYW5zKTtcblxuICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIC8vIEEgaG9yaXpvbnRhbCBheGlzIGlzIG1vcmUgY29uc3RyYWluZWQgYnkgdGhlIGhlaWdodC5cbiAgICAgICAgICBjb25zdCBsYWJlbEhlaWdodCA9IHRpY2tPcHRzLm1pcnJvciA/IDAgOiBzaW4gKiB3aWRlc3Qud2lkdGggKyBjb3MgKiBoaWdoZXN0LmhlaWdodDtcbiAgICAgICAgICBtaW5TaXplLmhlaWdodCA9IE1hdGgubWluKHRoaXMubWF4SGVpZ2h0LCBtaW5TaXplLmhlaWdodCArIGxhYmVsSGVpZ2h0ICsgdGlja1BhZGRpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBIHZlcnRpY2FsIGF4aXMgaXMgbW9yZSBjb25zdHJhaW5lZCBieSB0aGUgd2lkdGguIExhYmVscyBhcmUgdGhlXG4gICAgICAgIC8vIGRvbWluYW50IGZhY3RvciBoZXJlLCBzbyBnZXQgdGhhdCBsZW5ndGggZmlyc3QgYW5kIGFjY291bnQgZm9yIHBhZGRpbmdcbiAgICAgICAgICBjb25zdCBsYWJlbFdpZHRoID0gdGlja09wdHMubWlycm9yID8gMCA6IGNvcyAqIHdpZGVzdC53aWR0aCArIHNpbiAqIGhpZ2hlc3QuaGVpZ2h0O1xuXG4gICAgICAgICAgbWluU2l6ZS53aWR0aCA9IE1hdGgubWluKHRoaXMubWF4V2lkdGgsIG1pblNpemUud2lkdGggKyBsYWJlbFdpZHRoICsgdGlja1BhZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZVBhZGRpbmcoZmlyc3QsIGxhc3QsIHNpbiwgY29zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9oYW5kbGVNYXJnaW5zKCk7XG5cbiAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5fbGVuZ3RoID0gY2hhcnQud2lkdGggLSB0aGlzLl9tYXJnaW5zLmxlZnQgLSB0aGlzLl9tYXJnaW5zLnJpZ2h0O1xuICAgICAgdGhpcy5oZWlnaHQgPSBtaW5TaXplLmhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53aWR0aCA9IG1pblNpemUud2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuX2xlbmd0aCA9IGNoYXJ0LmhlaWdodCAtIHRoaXMuX21hcmdpbnMudG9wIC0gdGhpcy5fbWFyZ2lucy5ib3R0b207XG4gICAgfVxuICB9XG5cbiAgX2NhbGN1bGF0ZVBhZGRpbmcoZmlyc3QsIGxhc3QsIHNpbiwgY29zKSB7XG4gICAgY29uc3Qge3RpY2tzOiB7YWxpZ24sIHBhZGRpbmd9LCBwb3NpdGlvbn0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgaXNSb3RhdGVkID0gdGhpcy5sYWJlbFJvdGF0aW9uICE9PSAwO1xuICAgIGNvbnN0IGxhYmVsc0JlbG93VGlja3MgPSBwb3NpdGlvbiAhPT0gJ3RvcCcgJiYgdGhpcy5heGlzID09PSAneCc7XG5cbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgY29uc3Qgb2Zmc2V0TGVmdCA9IHRoaXMuZ2V0UGl4ZWxGb3JUaWNrKDApIC0gdGhpcy5sZWZ0O1xuICAgICAgY29uc3Qgb2Zmc2V0UmlnaHQgPSB0aGlzLnJpZ2h0IC0gdGhpcy5nZXRQaXhlbEZvclRpY2sodGhpcy50aWNrcy5sZW5ndGggLSAxKTtcbiAgICAgIGxldCBwYWRkaW5nTGVmdCA9IDA7XG4gICAgICBsZXQgcGFkZGluZ1JpZ2h0ID0gMDtcblxuICAgICAgLy8gRW5zdXJlIHRoYXQgb3VyIHRpY2tzIGFyZSBhbHdheXMgaW5zaWRlIHRoZSBjYW52YXMuIFdoZW4gcm90YXRlZCwgdGlja3MgYXJlIHJpZ2h0IGFsaWduZWRcbiAgICAgIC8vIHdoaWNoIG1lYW5zIHRoYXQgdGhlIHJpZ2h0IHBhZGRpbmcgaXMgZG9taW5hdGVkIGJ5IHRoZSBmb250IGhlaWdodFxuICAgICAgaWYgKGlzUm90YXRlZCkge1xuICAgICAgICBpZiAobGFiZWxzQmVsb3dUaWNrcykge1xuICAgICAgICAgIHBhZGRpbmdMZWZ0ID0gY29zICogZmlyc3Qud2lkdGg7XG4gICAgICAgICAgcGFkZGluZ1JpZ2h0ID0gc2luICogbGFzdC5oZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFkZGluZ0xlZnQgPSBzaW4gKiBmaXJzdC5oZWlnaHQ7XG4gICAgICAgICAgcGFkZGluZ1JpZ2h0ID0gY29zICogbGFzdC53aWR0aDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBwYWRkaW5nUmlnaHQgPSBsYXN0LndpZHRoO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgcGFkZGluZ0xlZnQgPSBmaXJzdC53aWR0aDtcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gIT09ICdpbm5lcicpIHtcbiAgICAgICAgcGFkZGluZ0xlZnQgPSBmaXJzdC53aWR0aCAvIDI7XG4gICAgICAgIHBhZGRpbmdSaWdodCA9IGxhc3Qud2lkdGggLyAyO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGp1c3QgcGFkZGluZyB0YWtpbmcgaW50byBhY2NvdW50IGNoYW5nZXMgaW4gb2Zmc2V0c1xuICAgICAgdGhpcy5wYWRkaW5nTGVmdCA9IE1hdGgubWF4KChwYWRkaW5nTGVmdCAtIG9mZnNldExlZnQgKyBwYWRkaW5nKSAqIHRoaXMud2lkdGggLyAodGhpcy53aWR0aCAtIG9mZnNldExlZnQpLCAwKTtcbiAgICAgIHRoaXMucGFkZGluZ1JpZ2h0ID0gTWF0aC5tYXgoKHBhZGRpbmdSaWdodCAtIG9mZnNldFJpZ2h0ICsgcGFkZGluZykgKiB0aGlzLndpZHRoIC8gKHRoaXMud2lkdGggLSBvZmZzZXRSaWdodCksIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcGFkZGluZ1RvcCA9IGxhc3QuaGVpZ2h0IC8gMjtcbiAgICAgIGxldCBwYWRkaW5nQm90dG9tID0gZmlyc3QuaGVpZ2h0IC8gMjtcblxuICAgICAgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgIHBhZGRpbmdUb3AgPSAwO1xuICAgICAgICBwYWRkaW5nQm90dG9tID0gZmlyc3QuaGVpZ2h0O1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgcGFkZGluZ1RvcCA9IGxhc3QuaGVpZ2h0O1xuICAgICAgICBwYWRkaW5nQm90dG9tID0gMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wYWRkaW5nVG9wID0gcGFkZGluZ1RvcCArIHBhZGRpbmc7XG4gICAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSBwYWRkaW5nQm90dG9tICsgcGFkZGluZztcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogSGFuZGxlIG1hcmdpbnMgYW5kIHBhZGRpbmcgaW50ZXJhY3Rpb25zXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfaGFuZGxlTWFyZ2lucygpIHtcbiAgICBpZiAodGhpcy5fbWFyZ2lucykge1xuICAgICAgdGhpcy5fbWFyZ2lucy5sZWZ0ID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nTGVmdCwgdGhpcy5fbWFyZ2lucy5sZWZ0KTtcbiAgICAgIHRoaXMuX21hcmdpbnMudG9wID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nVG9wLCB0aGlzLl9tYXJnaW5zLnRvcCk7XG4gICAgICB0aGlzLl9tYXJnaW5zLnJpZ2h0ID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nUmlnaHQsIHRoaXMuX21hcmdpbnMucmlnaHQpO1xuICAgICAgdGhpcy5fbWFyZ2lucy5ib3R0b20gPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdCb3R0b20sIHRoaXMuX21hcmdpbnMuYm90dG9tKTtcbiAgICB9XG4gIH1cblxuICBhZnRlckZpdCgpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5hZnRlckZpdCwgW3RoaXNdKTtcbiAgfVxuXG4gIC8vIFNoYXJlZCBNZXRob2RzXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cbiAgaXNIb3Jpem9udGFsKCkge1xuICAgIGNvbnN0IHtheGlzLCBwb3NpdGlvbn0gPSB0aGlzLm9wdGlvbnM7XG4gICAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScgfHwgYXhpcyA9PT0gJ3gnO1xuICB9XG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cbiAgaXNGdWxsU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmZ1bGxTaXplO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7VGlja1tdfSB0aWNrc1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NvbnZlcnRUaWNrc1RvTGFiZWxzKHRpY2tzKSB7XG4gICAgdGhpcy5iZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24oKTtcblxuICAgIHRoaXMuZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKTtcblxuICAgIC8vIFRpY2tzIHNob3VsZCBiZSBza2lwcGVkIHdoZW4gY2FsbGJhY2sgcmV0dXJucyBudWxsIG9yIHVuZGVmLCBzbyBsZXRzIHJlbW92ZSB0aG9zZS5cbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZih0aWNrc1tpXS5sYWJlbCkpIHtcbiAgICAgICAgdGlja3Muc3BsaWNlKGksIDEpO1xuICAgICAgICBpbGVuLS07XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uKCk7XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7eyBmaXJzdDogb2JqZWN0LCBsYXN0OiBvYmplY3QsIHdpZGVzdDogb2JqZWN0LCBoaWdoZXN0OiBvYmplY3QsIHdpZHRoczogQXJyYXksIGhlaWdodHM6IGFycmF5IH19XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0TGFiZWxTaXplcygpIHtcbiAgICBsZXQgbGFiZWxTaXplcyA9IHRoaXMuX2xhYmVsU2l6ZXM7XG5cbiAgICBpZiAoIWxhYmVsU2l6ZXMpIHtcbiAgICAgIGNvbnN0IHNhbXBsZVNpemUgPSB0aGlzLm9wdGlvbnMudGlja3Muc2FtcGxlU2l6ZTtcbiAgICAgIGxldCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgICBpZiAoc2FtcGxlU2l6ZSA8IHRpY2tzLmxlbmd0aCkge1xuICAgICAgICB0aWNrcyA9IHNhbXBsZSh0aWNrcywgc2FtcGxlU2l6ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBsYWJlbFNpemVzID0gdGhpcy5fY29tcHV0ZUxhYmVsU2l6ZXModGlja3MsIHRpY2tzLmxlbmd0aCwgdGhpcy5vcHRpb25zLnRpY2tzLm1heFRpY2tzTGltaXQpO1xuICAgIH1cblxuICAgIHJldHVybiBsYWJlbFNpemVzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMge3dpZHRoLCBoZWlnaHQsIG9mZnNldH0gb2JqZWN0cyBmb3IgdGhlIGZpcnN0LCBsYXN0LCB3aWRlc3QsIGhpZ2hlc3QgdGlja1xuXHQgKiBsYWJlbHMgd2hlcmUgb2Zmc2V0IGluZGljYXRlcyB0aGUgYW5jaG9yIHBvaW50IG9mZnNldCBmcm9tIHRoZSB0b3AgaW4gcGl4ZWxzLlxuXHQgKiBAcmV0dXJuIHt7IGZpcnN0OiBvYmplY3QsIGxhc3Q6IG9iamVjdCwgd2lkZXN0OiBvYmplY3QsIGhpZ2hlc3Q6IG9iamVjdCwgd2lkdGhzOiBBcnJheSwgaGVpZ2h0czogYXJyYXkgfX1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jb21wdXRlTGFiZWxTaXplcyh0aWNrcywgbGVuZ3RoLCBtYXhUaWNrc0xpbWl0KSB7XG4gICAgY29uc3Qge2N0eCwgX2xvbmdlc3RUZXh0Q2FjaGU6IGNhY2hlc30gPSB0aGlzO1xuICAgIGNvbnN0IHdpZHRocyA9IFtdO1xuICAgIGNvbnN0IGhlaWdodHMgPSBbXTtcbiAgICBjb25zdCBpbmNyZW1lbnQgPSBNYXRoLmZsb29yKGxlbmd0aCAvIGdldFRpY2tzTGltaXQobGVuZ3RoLCBtYXhUaWNrc0xpbWl0KSk7XG4gICAgbGV0IHdpZGVzdExhYmVsU2l6ZSA9IDA7XG4gICAgbGV0IGhpZ2hlc3RMYWJlbFNpemUgPSAwO1xuICAgIGxldCBpLCBqLCBqbGVuLCBsYWJlbCwgdGlja0ZvbnQsIGZvbnRTdHJpbmcsIGNhY2hlLCBsaW5lSGVpZ2h0LCB3aWR0aCwgaGVpZ2h0LCBuZXN0ZWRMYWJlbDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gaW5jcmVtZW50KSB7XG4gICAgICBsYWJlbCA9IHRpY2tzW2ldLmxhYmVsO1xuICAgICAgdGlja0ZvbnQgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKGkpO1xuICAgICAgY3R4LmZvbnQgPSBmb250U3RyaW5nID0gdGlja0ZvbnQuc3RyaW5nO1xuICAgICAgY2FjaGUgPSBjYWNoZXNbZm9udFN0cmluZ10gPSBjYWNoZXNbZm9udFN0cmluZ10gfHwge2RhdGE6IHt9LCBnYzogW119O1xuICAgICAgbGluZUhlaWdodCA9IHRpY2tGb250LmxpbmVIZWlnaHQ7XG4gICAgICB3aWR0aCA9IGhlaWdodCA9IDA7XG4gICAgICAvLyBVbmRlZmluZWQgbGFiZWxzIGFuZCBhcnJheXMgc2hvdWxkIG5vdCBiZSBtZWFzdXJlZFxuICAgICAgaWYgKCFpc051bGxPclVuZGVmKGxhYmVsKSAmJiAhaXNBcnJheShsYWJlbCkpIHtcbiAgICAgICAgd2lkdGggPSBfbWVhc3VyZVRleHQoY3R4LCBjYWNoZS5kYXRhLCBjYWNoZS5nYywgd2lkdGgsIGxhYmVsKTtcbiAgICAgICAgaGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShsYWJlbCkpIHtcbiAgICAgICAgLy8gaWYgaXQgaXMgYW4gYXJyYXkgbGV0J3MgbWVhc3VyZSBlYWNoIGVsZW1lbnRcbiAgICAgICAgZm9yIChqID0gMCwgamxlbiA9IGxhYmVsLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuICAgICAgICAgIG5lc3RlZExhYmVsID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChsYWJlbFtqXSk7XG4gICAgICAgICAgLy8gVW5kZWZpbmVkIGxhYmVscyBhbmQgYXJyYXlzIHNob3VsZCBub3QgYmUgbWVhc3VyZWRcbiAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWYobmVzdGVkTGFiZWwpICYmICFpc0FycmF5KG5lc3RlZExhYmVsKSkge1xuICAgICAgICAgICAgd2lkdGggPSBfbWVhc3VyZVRleHQoY3R4LCBjYWNoZS5kYXRhLCBjYWNoZS5nYywgd2lkdGgsIG5lc3RlZExhYmVsKTtcbiAgICAgICAgICAgIGhlaWdodCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2lkdGhzLnB1c2god2lkdGgpO1xuICAgICAgaGVpZ2h0cy5wdXNoKGhlaWdodCk7XG4gICAgICB3aWRlc3RMYWJlbFNpemUgPSBNYXRoLm1heCh3aWR0aCwgd2lkZXN0TGFiZWxTaXplKTtcbiAgICAgIGhpZ2hlc3RMYWJlbFNpemUgPSBNYXRoLm1heChoZWlnaHQsIGhpZ2hlc3RMYWJlbFNpemUpO1xuICAgIH1cbiAgICBnYXJiYWdlQ29sbGVjdChjYWNoZXMsIGxlbmd0aCk7XG5cbiAgICBjb25zdCB3aWRlc3QgPSB3aWR0aHMuaW5kZXhPZih3aWRlc3RMYWJlbFNpemUpO1xuICAgIGNvbnN0IGhpZ2hlc3QgPSBoZWlnaHRzLmluZGV4T2YoaGlnaGVzdExhYmVsU2l6ZSk7XG5cbiAgICBjb25zdCB2YWx1ZUF0ID0gKGlkeCkgPT4gKHt3aWR0aDogd2lkdGhzW2lkeF0gfHwgMCwgaGVpZ2h0OiBoZWlnaHRzW2lkeF0gfHwgMH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZpcnN0OiB2YWx1ZUF0KDApLFxuICAgICAgbGFzdDogdmFsdWVBdChsZW5ndGggLSAxKSxcbiAgICAgIHdpZGVzdDogdmFsdWVBdCh3aWRlc3QpLFxuICAgICAgaGlnaGVzdDogdmFsdWVBdChoaWdoZXN0KSxcbiAgICAgIHdpZHRocyxcbiAgICAgIGhlaWdodHMsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVc2VkIHRvIGdldCB0aGUgbGFiZWwgdG8gZGlzcGxheSBpbiB0aGUgdG9vbHRpcCBmb3IgdGhlIGdpdmVuIHZhbHVlXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWVcblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBsb2NhdGlvbiBvZiB0aGUgZ2l2ZW4gZGF0YSBwb2ludC4gVmFsdWUgY2FuIGVpdGhlciBiZSBhbiBpbmRleCBvciBhIG51bWVyaWNhbCB2YWx1ZVxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHsqfSB2YWx1ZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4XVxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlLCBpbmRleCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVc2VkIHRvIGdldCB0aGUgZGF0YSB2YWx1ZSBmcm9tIGEgZ2l2ZW4gcGl4ZWwuIFRoaXMgaXMgdGhlIGludmVyc2Ugb2YgZ2V0UGl4ZWxGb3JWYWx1ZVxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsXG5cdCAqIEByZXR1cm4geyp9XG5cdCAqL1xuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIGxvY2F0aW9uIG9mIHRoZSB0aWNrIGF0IHRoZSBnaXZlbiBpbmRleFxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldFBpeGVsRm9yVGljayhpbmRleCkge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGlja3MubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGlja3NbaW5kZXhdLnZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVdGlsaXR5IGZvciBnZXR0aW5nIHRoZSBwaXhlbCBsb2NhdGlvbiBvZiBhIHBlcmNlbnRhZ2Ugb2Ygc2NhbGVcblx0ICogVGhlIGNvb3JkaW5hdGUgKDAsIDApIGlzIGF0IHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkZWNpbWFsXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldFBpeGVsRm9yRGVjaW1hbChkZWNpbWFsKSB7XG4gICAgaWYgKHRoaXMuX3JldmVyc2VQaXhlbHMpIHtcbiAgICAgIGRlY2ltYWwgPSAxIC0gZGVjaW1hbDtcbiAgICB9XG5cbiAgICBjb25zdCBwaXhlbCA9IHRoaXMuX3N0YXJ0UGl4ZWwgKyBkZWNpbWFsICogdGhpcy5fbGVuZ3RoO1xuICAgIHJldHVybiBfaW50MTZSYW5nZSh0aGlzLl9hbGlnblRvUGl4ZWxzID8gX2FsaWduUGl4ZWwodGhpcy5jaGFydCwgcGl4ZWwsIDApIDogcGl4ZWwpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBkZWNpbWFsID0gKHBpeGVsIC0gdGhpcy5fc3RhcnRQaXhlbCkgLyB0aGlzLl9sZW5ndGg7XG4gICAgcmV0dXJuIHRoaXMuX3JldmVyc2VQaXhlbHMgPyAxIC0gZGVjaW1hbCA6IGRlY2ltYWw7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgcGl4ZWwgZm9yIHRoZSBtaW5pbXVtIGNoYXJ0IHZhbHVlXG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRCYXNlUGl4ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLmdldEJhc2VWYWx1ZSgpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRCYXNlVmFsdWUoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXM7XG5cbiAgICByZXR1cm4gbWluIDwgMCAmJiBtYXggPCAwID8gbWF4IDpcbiAgICAgIG1pbiA+IDAgJiYgbWF4ID4gMCA/IG1pbiA6XG4gICAgICAwO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldENvbnRleHQoaW5kZXgpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3MgfHwgW107XG5cbiAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRpY2tzLmxlbmd0aCkge1xuICAgICAgY29uc3QgdGljayA9IHRpY2tzW2luZGV4XTtcbiAgICAgIHJldHVybiB0aWNrLiRjb250ZXh0IHx8XG5cdFx0XHRcdCh0aWNrLiRjb250ZXh0ID0gY3JlYXRlVGlja0NvbnRleHQodGhpcy5nZXRDb250ZXh0KCksIGluZGV4LCB0aWNrKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiRjb250ZXh0IHx8XG5cdFx0XHQodGhpcy4kY29udGV4dCA9IGNyZWF0ZVNjYWxlQ29udGV4dCh0aGlzLmNoYXJ0LmdldENvbnRleHQoKSwgdGhpcykpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF90aWNrU2l6ZSgpIHtcbiAgICBjb25zdCBvcHRpb25UaWNrcyA9IHRoaXMub3B0aW9ucy50aWNrcztcblxuICAgIC8vIENhbGN1bGF0ZSBzcGFjZSBuZWVkZWQgYnkgbGFiZWwgaW4gYXhpcyBkaXJlY3Rpb24uXG4gICAgY29uc3Qgcm90ID0gdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG4gICAgY29uc3QgY29zID0gTWF0aC5hYnMoTWF0aC5jb3Mocm90KSk7XG4gICAgY29uc3Qgc2luID0gTWF0aC5hYnMoTWF0aC5zaW4ocm90KSk7XG5cbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGNvbnN0IHBhZGRpbmcgPSBvcHRpb25UaWNrcy5hdXRvU2tpcFBhZGRpbmcgfHwgMDtcbiAgICBjb25zdCB3ID0gbGFiZWxTaXplcyA/IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoICsgcGFkZGluZyA6IDA7XG4gICAgY29uc3QgaCA9IGxhYmVsU2l6ZXMgPyBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0ICsgcGFkZGluZyA6IDA7XG5cbiAgICAvLyBDYWxjdWxhdGUgc3BhY2UgbmVlZGVkIGZvciAxIHRpY2sgaW4gYXhpcyBkaXJlY3Rpb24uXG4gICAgcmV0dXJuIHRoaXMuaXNIb3Jpem9udGFsKClcbiAgICAgID8gaCAqIGNvcyA+IHcgKiBzaW4gPyB3IC8gY29zIDogaCAvIHNpblxuICAgICAgOiBoICogc2luIDwgdyAqIGNvcyA/IGggLyBjb3MgOiB3IC8gc2luO1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfaXNWaXNpYmxlKCkge1xuICAgIGNvbnN0IGRpc3BsYXkgPSB0aGlzLm9wdGlvbnMuZGlzcGxheTtcblxuICAgIGlmIChkaXNwbGF5ICE9PSAnYXV0bycpIHtcbiAgICAgIHJldHVybiAhIWRpc3BsYXk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKS5sZW5ndGggPiAwO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY29tcHV0ZUdyaWRMaW5lSXRlbXMoY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgYXhpcyA9IHRoaXMuYXhpcztcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7Z3JpZCwgcG9zaXRpb24sIGJvcmRlcn0gPSBvcHRpb25zO1xuICAgIGNvbnN0IG9mZnNldCA9IGdyaWQub2Zmc2V0O1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGNvbnN0IHRpY2tzTGVuZ3RoID0gdGlja3MubGVuZ3RoICsgKG9mZnNldCA/IDEgOiAwKTtcbiAgICBjb25zdCB0bCA9IGdldFRpY2tNYXJrTGVuZ3RoKGdyaWQpO1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG5cbiAgICBjb25zdCBib3JkZXJPcHRzID0gYm9yZGVyLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IGF4aXNXaWR0aCA9IGJvcmRlck9wdHMuZGlzcGxheSA/IGJvcmRlck9wdHMud2lkdGggOiAwO1xuICAgIGNvbnN0IGF4aXNIYWxmV2lkdGggPSBheGlzV2lkdGggLyAyO1xuICAgIGNvbnN0IGFsaWduQm9yZGVyVmFsdWUgPSBmdW5jdGlvbihwaXhlbCkge1xuICAgICAgcmV0dXJuIF9hbGlnblBpeGVsKGNoYXJ0LCBwaXhlbCwgYXhpc1dpZHRoKTtcbiAgICB9O1xuICAgIGxldCBib3JkZXJWYWx1ZSwgaSwgbGluZVZhbHVlLCBhbGlnbmVkTGluZVZhbHVlO1xuICAgIGxldCB0eDEsIHR5MSwgdHgyLCB0eTIsIHgxLCB5MSwgeDIsIHkyO1xuXG4gICAgaWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMuYm90dG9tKTtcbiAgICAgIHR5MSA9IHRoaXMuYm90dG9tIC0gdGw7XG4gICAgICB0eTIgPSBib3JkZXJWYWx1ZSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB5MSA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLnRvcCkgKyBheGlzSGFsZldpZHRoO1xuICAgICAgeTIgPSBjaGFydEFyZWEuYm90dG9tO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy50b3ApO1xuICAgICAgeTEgPSBjaGFydEFyZWEudG9wO1xuICAgICAgeTIgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5ib3R0b20pIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR5MSA9IGJvcmRlclZhbHVlICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR5MiA9IHRoaXMudG9wICsgdGw7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5yaWdodCk7XG4gICAgICB0eDEgPSB0aGlzLnJpZ2h0IC0gdGw7XG4gICAgICB0eDIgPSBib3JkZXJWYWx1ZSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB4MSA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLmxlZnQpICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHgyID0gY2hhcnRBcmVhLnJpZ2h0O1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmxlZnQpO1xuICAgICAgeDEgPSBjaGFydEFyZWEubGVmdDtcbiAgICAgIHgyID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEucmlnaHQpIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR4MSA9IGJvcmRlclZhbHVlICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR4MiA9IHRoaXMubGVmdCArIHRsO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3gnKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSgoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMiArIDAuNSk7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkpO1xuICAgICAgfVxuXG4gICAgICB5MSA9IGNoYXJ0QXJlYS50b3A7XG4gICAgICB5MiA9IGNoYXJ0QXJlYS5ib3R0b207XG4gICAgICB0eTEgPSBib3JkZXJWYWx1ZSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eTIgPSB0eTEgKyB0bDtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUoKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDIpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpKTtcbiAgICAgIH1cblxuICAgICAgdHgxID0gYm9yZGVyVmFsdWUgLSBheGlzSGFsZldpZHRoO1xuICAgICAgdHgyID0gdHgxIC0gdGw7XG4gICAgICB4MSA9IGNoYXJ0QXJlYS5sZWZ0O1xuICAgICAgeDIgPSBjaGFydEFyZWEucmlnaHQ7XG4gICAgfVxuXG4gICAgY29uc3QgbGltaXQgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnRpY2tzLm1heFRpY2tzTGltaXQsIHRpY2tzTGVuZ3RoKTtcbiAgICBjb25zdCBzdGVwID0gTWF0aC5tYXgoMSwgTWF0aC5jZWlsKHRpY2tzTGVuZ3RoIC8gbGltaXQpKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGlja3NMZW5ndGg7IGkgKz0gc3RlcCkge1xuICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0Q29udGV4dChpKTtcbiAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gZ3JpZC5zZXRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgY29uc3Qgb3B0c0F0SW5kZXhCb3JkZXIgPSBib3JkZXIuc2V0Q29udGV4dChjb250ZXh0KTtcblxuICAgICAgY29uc3QgbGluZVdpZHRoID0gb3B0c0F0SW5kZXgubGluZVdpZHRoO1xuICAgICAgY29uc3QgbGluZUNvbG9yID0gb3B0c0F0SW5kZXguY29sb3I7XG4gICAgICBjb25zdCBib3JkZXJEYXNoID0gb3B0c0F0SW5kZXhCb3JkZXIuZGFzaCB8fCBbXTtcbiAgICAgIGNvbnN0IGJvcmRlckRhc2hPZmZzZXQgPSBvcHRzQXRJbmRleEJvcmRlci5kYXNoT2Zmc2V0O1xuXG4gICAgICBjb25zdCB0aWNrV2lkdGggPSBvcHRzQXRJbmRleC50aWNrV2lkdGg7XG4gICAgICBjb25zdCB0aWNrQ29sb3IgPSBvcHRzQXRJbmRleC50aWNrQ29sb3I7XG4gICAgICBjb25zdCB0aWNrQm9yZGVyRGFzaCA9IG9wdHNBdEluZGV4LnRpY2tCb3JkZXJEYXNoIHx8IFtdO1xuICAgICAgY29uc3QgdGlja0JvcmRlckRhc2hPZmZzZXQgPSBvcHRzQXRJbmRleC50aWNrQm9yZGVyRGFzaE9mZnNldDtcblxuICAgICAgbGluZVZhbHVlID0gZ2V0UGl4ZWxGb3JHcmlkTGluZSh0aGlzLCBpLCBvZmZzZXQpO1xuXG4gICAgICAvLyBTa2lwIGlmIHRoZSBwaXhlbCBpcyBvdXQgb2YgdGhlIHJhbmdlXG4gICAgICBpZiAobGluZVZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGFsaWduZWRMaW5lVmFsdWUgPSBfYWxpZ25QaXhlbChjaGFydCwgbGluZVZhbHVlLCBsaW5lV2lkdGgpO1xuXG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIHR4MSA9IHR4MiA9IHgxID0geDIgPSBhbGlnbmVkTGluZVZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHkxID0gdHkyID0geTEgPSB5MiA9IGFsaWduZWRMaW5lVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICB0eDEsXG4gICAgICAgIHR5MSxcbiAgICAgICAgdHgyLFxuICAgICAgICB0eTIsXG4gICAgICAgIHgxLFxuICAgICAgICB5MSxcbiAgICAgICAgeDIsXG4gICAgICAgIHkyLFxuICAgICAgICB3aWR0aDogbGluZVdpZHRoLFxuICAgICAgICBjb2xvcjogbGluZUNvbG9yLFxuICAgICAgICBib3JkZXJEYXNoLFxuICAgICAgICBib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgICB0aWNrV2lkdGgsXG4gICAgICAgIHRpY2tDb2xvcixcbiAgICAgICAgdGlja0JvcmRlckRhc2gsXG4gICAgICAgIHRpY2tCb3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5fdGlja3NMZW5ndGggPSB0aWNrc0xlbmd0aDtcbiAgICB0aGlzLl9ib3JkZXJWYWx1ZSA9IGJvcmRlclZhbHVlO1xuXG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY29tcHV0ZUxhYmVsSXRlbXMoY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgYXhpcyA9IHRoaXMuYXhpcztcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHtwb3NpdGlvbiwgdGlja3M6IG9wdGlvblRpY2tzfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgY29uc3Qge2FsaWduLCBjcm9zc0FsaWduLCBwYWRkaW5nLCBtaXJyb3J9ID0gb3B0aW9uVGlja3M7XG4gICAgY29uc3QgdGwgPSBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zLmdyaWQpO1xuICAgIGNvbnN0IHRpY2tBbmRQYWRkaW5nID0gdGwgKyBwYWRkaW5nO1xuICAgIGNvbnN0IGhUaWNrQW5kUGFkZGluZyA9IG1pcnJvciA/IC1wYWRkaW5nIDogdGlja0FuZFBhZGRpbmc7XG4gICAgY29uc3Qgcm90YXRpb24gPSAtdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgdGljaywgbGFiZWwsIHgsIHksIHRleHRBbGlnbiwgcGl4ZWwsIGZvbnQsIGxpbmVIZWlnaHQsIGxpbmVDb3VudCwgdGV4dE9mZnNldDtcbiAgICBsZXQgdGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cbiAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICB5ID0gdGhpcy5ib3R0b20gLSBoVGlja0FuZFBhZGRpbmc7XG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCk7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHkgPSB0aGlzLnRvcCArIGhUaWNrQW5kUGFkZGluZztcbiAgICAgIHRleHRBbGlnbiA9IHRoaXMuX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgIGNvbnN0IHJldCA9IHRoaXMuX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpO1xuICAgICAgdGV4dEFsaWduID0gcmV0LnRleHRBbGlnbjtcbiAgICAgIHggPSByZXQueDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICBjb25zdCByZXQgPSB0aGlzLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKTtcbiAgICAgIHRleHRBbGlnbiA9IHJldC50ZXh0QWxpZ247XG4gICAgICB4ID0gcmV0Lng7XG4gICAgfSBlbHNlIGlmIChheGlzID09PSAneCcpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgeSA9ICgoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMikgKyB0aWNrQW5kUGFkZGluZztcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgeSA9IHRoaXMuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSArIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgfVxuICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3knKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHggPSAoKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDIpIC0gdGlja0FuZFBhZGRpbmc7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIHggPSB0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKS50ZXh0QWxpZ247XG4gICAgfVxuXG4gICAgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgICAgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgIHRleHRCYXNlbGluZSA9ICd0b3AnO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgdGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aWNrID0gdGlja3NbaV07XG4gICAgICBsYWJlbCA9IHRpY2subGFiZWw7XG5cbiAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gb3B0aW9uVGlja3Muc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaSkpO1xuICAgICAgcGl4ZWwgPSB0aGlzLmdldFBpeGVsRm9yVGljayhpKSArIG9wdGlvblRpY2tzLmxhYmVsT2Zmc2V0O1xuICAgICAgZm9udCA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoaSk7XG4gICAgICBsaW5lSGVpZ2h0ID0gZm9udC5saW5lSGVpZ2h0O1xuICAgICAgbGluZUNvdW50ID0gaXNBcnJheShsYWJlbCkgPyBsYWJlbC5sZW5ndGggOiAxO1xuICAgICAgY29uc3QgaGFsZkNvdW50ID0gbGluZUNvdW50IC8gMjtcbiAgICAgIGNvbnN0IGNvbG9yID0gb3B0c0F0SW5kZXguY29sb3I7XG4gICAgICBjb25zdCBzdHJva2VDb2xvciA9IG9wdHNBdEluZGV4LnRleHRTdHJva2VDb2xvcjtcbiAgICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gb3B0c0F0SW5kZXgudGV4dFN0cm9rZVdpZHRoO1xuICAgICAgbGV0IHRpY2tUZXh0QWxpZ24gPSB0ZXh0QWxpZ247XG5cbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgeCA9IHBpeGVsO1xuXG4gICAgICAgIGlmICh0ZXh0QWxpZ24gPT09ICdpbm5lcicpIHtcbiAgICAgICAgICBpZiAoaSA9PT0gaWxlbiAtIDEpIHtcbiAgICAgICAgICAgIHRpY2tUZXh0QWxpZ24gPSAhdGhpcy5vcHRpb25zLnJldmVyc2UgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgdGlja1RleHRBbGlnbiA9ICF0aGlzLm9wdGlvbnMucmV2ZXJzZSA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpY2tUZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJyB8fCByb3RhdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IC1saW5lQ291bnQgKiBsaW5lSGVpZ2h0ICsgbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IC1sYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0IC8gMiAtIGhhbGZDb3VudCAqIGxpbmVIZWlnaHQgKyBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gLWxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgKyBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmVseS1pZlxuICAgICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicgfHwgcm90YXRpb24gIT09IDApIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCAvIDIgLSBoYWxmQ291bnQgKiBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCAtIGxpbmVDb3VudCAqIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgICB0ZXh0T2Zmc2V0ICo9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3RhdGlvbiAhPT0gMCAmJiAhb3B0c0F0SW5kZXguc2hvd0xhYmVsQmFja2Ryb3ApIHtcbiAgICAgICAgICB4ICs9IChsaW5lSGVpZ2h0IC8gMikgKiBNYXRoLnNpbihyb3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkgPSBwaXhlbDtcbiAgICAgICAgdGV4dE9mZnNldCA9ICgxIC0gbGluZUNvdW50KSAqIGxpbmVIZWlnaHQgLyAyO1xuICAgICAgfVxuXG4gICAgICBsZXQgYmFja2Ryb3A7XG5cbiAgICAgIGlmIChvcHRzQXRJbmRleC5zaG93TGFiZWxCYWNrZHJvcCkge1xuICAgICAgICBjb25zdCBsYWJlbFBhZGRpbmcgPSB0b1BhZGRpbmcob3B0c0F0SW5kZXguYmFja2Ryb3BQYWRkaW5nKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gbGFiZWxTaXplcy5oZWlnaHRzW2ldO1xuICAgICAgICBjb25zdCB3aWR0aCA9IGxhYmVsU2l6ZXMud2lkdGhzW2ldO1xuXG4gICAgICAgIGxldCB0b3AgPSB0ZXh0T2Zmc2V0IC0gbGFiZWxQYWRkaW5nLnRvcDtcbiAgICAgICAgbGV0IGxlZnQgPSAwIC0gbGFiZWxQYWRkaW5nLmxlZnQ7XG5cbiAgICAgICAgc3dpdGNoICh0ZXh0QmFzZWxpbmUpIHtcbiAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICB0b3AgLT0gaGVpZ2h0IC8gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICB0b3AgLT0gaGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICh0ZXh0QWxpZ24pIHtcbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICBsZWZ0IC09IHdpZHRoIC8gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2lubmVyJzpcbiAgICAgICAgICBpZiAoaSA9PT0gaWxlbiAtIDEpIHtcbiAgICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgICAgfSBlbHNlIGlmIChpID4gMCkge1xuICAgICAgICAgICAgbGVmdCAtPSB3aWR0aCAvIDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgYmFja2Ryb3AgPSB7XG4gICAgICAgICAgbGVmdCxcbiAgICAgICAgICB0b3AsXG4gICAgICAgICAgd2lkdGg6IHdpZHRoICsgbGFiZWxQYWRkaW5nLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0ICsgbGFiZWxQYWRkaW5nLmhlaWdodCxcblxuICAgICAgICAgIGNvbG9yOiBvcHRzQXRJbmRleC5iYWNrZHJvcENvbG9yLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGZvbnQsXG4gICAgICAgIHRleHRPZmZzZXQsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICBjb2xvcixcbiAgICAgICAgICBzdHJva2VDb2xvcixcbiAgICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgICB0ZXh0QWxpZ246IHRpY2tUZXh0QWxpZ24sXG4gICAgICAgICAgdGV4dEJhc2VsaW5lLFxuICAgICAgICAgIHRyYW5zbGF0aW9uOiBbeCwgeV0sXG4gICAgICAgICAgYmFja2Ryb3AsXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBpdGVtcztcbiAgfVxuXG4gIF9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCkge1xuICAgIGNvbnN0IHtwb3NpdGlvbiwgdGlja3N9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gLXRvUmFkaWFucyh0aGlzLmxhYmVsUm90YXRpb24pO1xuXG4gICAgaWYgKHJvdGF0aW9uKSB7XG4gICAgICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB9XG5cbiAgICBsZXQgYWxpZ24gPSAnY2VudGVyJztcblxuICAgIGlmICh0aWNrcy5hbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgYWxpZ24gPSAnbGVmdCc7XG4gICAgfSBlbHNlIGlmICh0aWNrcy5hbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgIGFsaWduID0gJ3JpZ2h0JztcbiAgICB9IGVsc2UgaWYgKHRpY2tzLmFsaWduID09PSAnaW5uZXInKSB7XG4gICAgICBhbGlnbiA9ICdpbm5lcic7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFsaWduO1xuICB9XG5cbiAgX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpIHtcbiAgICBjb25zdCB7cG9zaXRpb24sIHRpY2tzOiB7Y3Jvc3NBbGlnbiwgbWlycm9yLCBwYWRkaW5nfX0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBjb25zdCB0aWNrQW5kUGFkZGluZyA9IHRsICsgcGFkZGluZztcbiAgICBjb25zdCB3aWRlc3QgPSBsYWJlbFNpemVzLndpZGVzdC53aWR0aDtcblxuICAgIGxldCB0ZXh0QWxpZ247XG4gICAgbGV0IHg7XG5cbiAgICBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgaWYgKG1pcnJvcikge1xuICAgICAgICB4ID0gdGhpcy5yaWdodCArIHBhZGRpbmc7XG5cbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIHggKz0gKHdpZGVzdCAvIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgeCArPSB3aWRlc3Q7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB0aGlzLnJpZ2h0IC0gdGlja0FuZFBhZGRpbmc7XG5cbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4IC09ICh3aWRlc3QgLyAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgeCA9IHRoaXMubGVmdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgeCA9IHRoaXMubGVmdCArIHBhZGRpbmc7XG5cbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4IC09ICh3aWRlc3QgLyAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgeCAtPSB3aWRlc3Q7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB0aGlzLmxlZnQgKyB0aWNrQW5kUGFkZGluZztcblxuICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCArPSB3aWRlc3QgLyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgeCA9IHRoaXMucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICB9XG5cbiAgICByZXR1cm4ge3RleHRBbGlnbiwgeH07XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jb21wdXRlTGFiZWxBcmVhKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudGlja3MubWlycm9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xuXG4gICAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcgfHwgcG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIHJldHVybiB7dG9wOiAwLCBsZWZ0OiB0aGlzLmxlZnQsIGJvdHRvbTogY2hhcnQuaGVpZ2h0LCByaWdodDogdGhpcy5yaWdodH07XG4gICAgfSBpZiAocG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgcmV0dXJuIHt0b3A6IHRoaXMudG9wLCBsZWZ0OiAwLCBib3R0b206IHRoaXMuYm90dG9tLCByaWdodDogY2hhcnQud2lkdGh9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBkcmF3QmFja2dyb3VuZCgpIHtcbiAgICBjb25zdCB7Y3R4LCBvcHRpb25zOiB7YmFja2dyb3VuZENvbG9yfSwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0fSA9IHRoaXM7XG4gICAgaWYgKGJhY2tncm91bmRDb2xvcikge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgICBjdHguZmlsbFJlY3QobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0TGluZVdpZHRoRm9yVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBncmlkID0gdGhpcy5vcHRpb25zLmdyaWQ7XG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSB8fCAhZ3JpZC5kaXNwbGF5KSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGNvbnN0IGluZGV4ID0gdGlja3MuZmluZEluZGV4KHQgPT4gdC52YWx1ZSA9PT0gdmFsdWUpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBjb25zdCBvcHRzID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpbmRleCkpO1xuICAgICAgcmV0dXJuIG9wdHMubGluZVdpZHRoO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3R3JpZChjaGFydEFyZWEpIHtcbiAgICBjb25zdCBncmlkID0gdGhpcy5vcHRpb25zLmdyaWQ7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLl9ncmlkTGluZUl0ZW1zIHx8ICh0aGlzLl9ncmlkTGluZUl0ZW1zID0gdGhpcy5fY29tcHV0ZUdyaWRMaW5lSXRlbXMoY2hhcnRBcmVhKSk7XG4gICAgbGV0IGksIGlsZW47XG5cbiAgICBjb25zdCBkcmF3TGluZSA9IChwMSwgcDIsIHN0eWxlKSA9PiB7XG4gICAgICBpZiAoIXN0eWxlLndpZHRoIHx8ICFzdHlsZS5jb2xvcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IHN0eWxlLndpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGUuY29sb3I7XG4gICAgICBjdHguc2V0TGluZURhc2goc3R5bGUuYm9yZGVyRGFzaCB8fCBbXSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBzdHlsZS5ib3JkZXJEYXNoT2Zmc2V0O1xuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHAxLngsIHAxLnkpO1xuICAgICAgY3R4LmxpbmVUbyhwMi54LCBwMi55KTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfTtcblxuICAgIGlmIChncmlkLmRpc3BsYXkpIHtcbiAgICAgIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuXG4gICAgICAgIGlmIChncmlkLmRyYXdPbkNoYXJ0QXJlYSkge1xuICAgICAgICAgIGRyYXdMaW5lKFxuICAgICAgICAgICAge3g6IGl0ZW0ueDEsIHk6IGl0ZW0ueTF9LFxuICAgICAgICAgICAge3g6IGl0ZW0ueDIsIHk6IGl0ZW0ueTJ9LFxuICAgICAgICAgICAgaXRlbVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ3JpZC5kcmF3VGlja3MpIHtcbiAgICAgICAgICBkcmF3TGluZShcbiAgICAgICAgICAgIHt4OiBpdGVtLnR4MSwgeTogaXRlbS50eTF9LFxuICAgICAgICAgICAge3g6IGl0ZW0udHgyLCB5OiBpdGVtLnR5Mn0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbG9yOiBpdGVtLnRpY2tDb2xvcixcbiAgICAgICAgICAgICAgd2lkdGg6IGl0ZW0udGlja1dpZHRoLFxuICAgICAgICAgICAgICBib3JkZXJEYXNoOiBpdGVtLnRpY2tCb3JkZXJEYXNoLFxuICAgICAgICAgICAgICBib3JkZXJEYXNoT2Zmc2V0OiBpdGVtLnRpY2tCb3JkZXJEYXNoT2Zmc2V0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3Qm9yZGVyKCkge1xuICAgIGNvbnN0IHtjaGFydCwgY3R4LCBvcHRpb25zOiB7Ym9yZGVyLCBncmlkfX0gPSB0aGlzO1xuICAgIGNvbnN0IGJvcmRlck9wdHMgPSBib3JkZXIuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3QgYXhpc1dpZHRoID0gYm9yZGVyLmRpc3BsYXkgPyBib3JkZXJPcHRzLndpZHRoIDogMDtcbiAgICBpZiAoIWF4aXNXaWR0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXN0TGluZVdpZHRoID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgwKSkubGluZVdpZHRoO1xuICAgIGNvbnN0IGJvcmRlclZhbHVlID0gdGhpcy5fYm9yZGVyVmFsdWU7XG4gICAgbGV0IHgxLCB4MiwgeTEsIHkyO1xuXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHgxID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMubGVmdCwgYXhpc1dpZHRoKSAtIGF4aXNXaWR0aCAvIDI7XG4gICAgICB4MiA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLnJpZ2h0LCBsYXN0TGluZVdpZHRoKSArIGxhc3RMaW5lV2lkdGggLyAyO1xuICAgICAgeTEgPSB5MiA9IGJvcmRlclZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB5MSA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLnRvcCwgYXhpc1dpZHRoKSAtIGF4aXNXaWR0aCAvIDI7XG4gICAgICB5MiA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLmJvdHRvbSwgbGFzdExpbmVXaWR0aCkgKyBsYXN0TGluZVdpZHRoIC8gMjtcbiAgICAgIHgxID0geDIgPSBib3JkZXJWYWx1ZTtcbiAgICB9XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyT3B0cy53aWR0aDtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBib3JkZXJPcHRzLmNvbG9yO1xuXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcbiAgICBjdHgubGluZVRvKHgyLCB5Mik7XG4gICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3TGFiZWxzKGNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IG9wdGlvblRpY2tzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuXG4gICAgaWYgKCFvcHRpb25UaWNrcy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG5cbiAgICBjb25zdCBhcmVhID0gdGhpcy5fY29tcHV0ZUxhYmVsQXJlYSgpO1xuICAgIGlmIChhcmVhKSB7XG4gICAgICBjbGlwQXJlYShjdHgsIGFyZWEpO1xuICAgIH1cblxuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5nZXRMYWJlbEl0ZW1zKGNoYXJ0QXJlYSk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICBjb25zdCByZW5kZXJUZXh0T3B0aW9ucyA9IGl0ZW0ub3B0aW9ucztcbiAgICAgIGNvbnN0IHRpY2tGb250ID0gaXRlbS5mb250O1xuICAgICAgY29uc3QgbGFiZWwgPSBpdGVtLmxhYmVsO1xuICAgICAgY29uc3QgeSA9IGl0ZW0udGV4dE9mZnNldDtcbiAgICAgIHJlbmRlclRleHQoY3R4LCBsYWJlbCwgMCwgeSwgdGlja0ZvbnQsIHJlbmRlclRleHRPcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoYXJlYSkge1xuICAgICAgdW5jbGlwQXJlYShjdHgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3VGl0bGUoKSB7XG4gICAgY29uc3Qge2N0eCwgb3B0aW9uczoge3Bvc2l0aW9uLCB0aXRsZSwgcmV2ZXJzZX19ID0gdGhpcztcblxuICAgIGlmICghdGl0bGUuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGZvbnQgPSB0b0ZvbnQodGl0bGUuZm9udCk7XG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyh0aXRsZS5wYWRkaW5nKTtcbiAgICBjb25zdCBhbGlnbiA9IHRpdGxlLmFsaWduO1xuICAgIGxldCBvZmZzZXQgPSBmb250LmxpbmVIZWlnaHQgLyAyO1xuXG4gICAgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJyB8fCBwb3NpdGlvbiA9PT0gJ2NlbnRlcicgfHwgaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICBvZmZzZXQgKz0gcGFkZGluZy5ib3R0b207XG4gICAgICBpZiAoaXNBcnJheSh0aXRsZS50ZXh0KSkge1xuICAgICAgICBvZmZzZXQgKz0gZm9udC5saW5lSGVpZ2h0ICogKHRpdGxlLnRleHQubGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldCArPSBwYWRkaW5nLnRvcDtcbiAgICB9XG5cbiAgICBjb25zdCB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn0gPSB0aXRsZUFyZ3ModGhpcywgb2Zmc2V0LCBwb3NpdGlvbiwgYWxpZ24pO1xuXG4gICAgcmVuZGVyVGV4dChjdHgsIHRpdGxlLnRleHQsIDAsIDAsIGZvbnQsIHtcbiAgICAgIGNvbG9yOiB0aXRsZS5jb2xvcixcbiAgICAgIG1heFdpZHRoLFxuICAgICAgcm90YXRpb24sXG4gICAgICB0ZXh0QWxpZ246IHRpdGxlQWxpZ24oYWxpZ24sIHBvc2l0aW9uLCByZXZlcnNlKSxcbiAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZScsXG4gICAgICB0cmFuc2xhdGlvbjogW3RpdGxlWCwgdGl0bGVZXSxcbiAgICB9KTtcbiAgfVxuXG4gIGRyYXcoY2hhcnRBcmVhKSB7XG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZHJhd0JhY2tncm91bmQoKTtcbiAgICB0aGlzLmRyYXdHcmlkKGNoYXJ0QXJlYSk7XG4gICAgdGhpcy5kcmF3Qm9yZGVyKCk7XG4gICAgdGhpcy5kcmF3VGl0bGUoKTtcbiAgICB0aGlzLmRyYXdMYWJlbHMoY2hhcnRBcmVhKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtvYmplY3RbXX1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9sYXllcnMoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0eiA9IG9wdHMudGlja3MgJiYgb3B0cy50aWNrcy56IHx8IDA7XG4gICAgY29uc3QgZ3ogPSB2YWx1ZU9yRGVmYXVsdChvcHRzLmdyaWQgJiYgb3B0cy5ncmlkLnosIC0xKTtcbiAgICBjb25zdCBieiA9IHZhbHVlT3JEZWZhdWx0KG9wdHMuYm9yZGVyICYmIG9wdHMuYm9yZGVyLnosIDApO1xuXG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSB8fCB0aGlzLmRyYXcgIT09IFNjYWxlLnByb3RvdHlwZS5kcmF3KSB7XG4gICAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5OiBkcmF3IGhhcyBiZWVuIG92ZXJyaWRkZW4gYnkgY3VzdG9tIHNjYWxlXG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgejogdHosXG4gICAgICAgIGRyYXc6IChjaGFydEFyZWEpID0+IHtcbiAgICAgICAgICB0aGlzLmRyYXcoY2hhcnRBcmVhKTtcbiAgICAgICAgfVxuICAgICAgfV07XG4gICAgfVxuXG4gICAgcmV0dXJuIFt7XG4gICAgICB6OiBneixcbiAgICAgIGRyYXc6IChjaGFydEFyZWEpID0+IHtcbiAgICAgICAgdGhpcy5kcmF3QmFja2dyb3VuZCgpO1xuICAgICAgICB0aGlzLmRyYXdHcmlkKGNoYXJ0QXJlYSk7XG4gICAgICAgIHRoaXMuZHJhd1RpdGxlKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgejogYnosXG4gICAgICBkcmF3OiAoKSA9PiB7XG4gICAgICAgIHRoaXMuZHJhd0JvcmRlcigpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHo6IHR6LFxuICAgICAgZHJhdzogKGNoYXJ0QXJlYSkgPT4ge1xuICAgICAgICB0aGlzLmRyYXdMYWJlbHMoY2hhcnRBcmVhKTtcbiAgICAgIH1cbiAgICB9XTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHZpc2libGUgZGF0YXNldCBtZXRhcyB0aGF0IGFyZSBhdHRhY2hlZCB0byB0aGlzIHNjYWxlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gLSBpZiBzcGVjaWZpZWQsIGFsc28gZmlsdGVyIGJ5IGRhdGFzZXQgdHlwZVxuXHQgKiBAcmV0dXJuIHtvYmplY3RbXX1cblx0ICovXG4gIGdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHR5cGUpIHtcbiAgICBjb25zdCBtZXRhcyA9IHRoaXMuY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGNvbnN0IGF4aXNJRCA9IHRoaXMuYXhpcyArICdBeGlzSUQnO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGFzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3QgbWV0YSA9IG1ldGFzW2ldO1xuICAgICAgaWYgKG1ldGFbYXhpc0lEXSA9PT0gdGhpcy5pZCAmJiAoIXR5cGUgfHwgbWV0YS50eXBlID09PSB0eXBlKSkge1xuICAgICAgICByZXN1bHQucHVzaChtZXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcblx0ICogQHJldHVybiB7b2JqZWN0fVxuXHQgKiBAcHJvdGVjdGVkXG4gXHQgKi9cbiAgX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoaW5kZXgpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGluZGV4KSk7XG4gICAgcmV0dXJuIHRvRm9udChvcHRzLmZvbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9tYXhEaWdpdHMoKSB7XG4gICAgY29uc3QgZm9udFNpemUgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKDApLmxpbmVIZWlnaHQ7XG4gICAgcmV0dXJuICh0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGhpcy53aWR0aCA6IHRoaXMuaGVpZ2h0KSAvIGZvbnRTaXplO1xuICB9XG59XG4iLCAiaW1wb3J0IHttZXJnZX0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQgZGVmYXVsdHMsIHtvdmVycmlkZXN9IGZyb20gJy4vY29yZS5kZWZhdWx0cy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge3tpZDogc3RyaW5nLCBkZWZhdWx0czogYW55LCBvdmVycmlkZXM/OiBhbnksIGRlZmF1bHRSb3V0ZXM6IGFueX19IElDaGFydENvbXBvbmVudFxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFR5cGVkUmVnaXN0cnkge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBzY29wZSwgb3ZlcnJpZGUpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB0aGlzLm92ZXJyaWRlID0gb3ZlcnJpZGU7XG4gICAgdGhpcy5pdGVtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cblxuICBpc0ZvclR5cGUodHlwZSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YuY2FsbCh0aGlzLnR5cGUucHJvdG90eXBlLCB0eXBlLnByb3RvdHlwZSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtJQ2hhcnRDb21wb25lbnR9IGl0ZW1cblx0ICogQHJldHVybnMge3N0cmluZ30gVGhlIHNjb3BlIHdoZXJlIGl0ZW1zIGRlZmF1bHRzIHdlcmUgcmVnaXN0ZXJlZCB0by5cblx0ICovXG4gIHJlZ2lzdGVyKGl0ZW0pIHtcbiAgICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihpdGVtKTtcbiAgICBsZXQgcGFyZW50U2NvcGU7XG5cbiAgICBpZiAoaXNJQ2hhcnRDb21wb25lbnQocHJvdG8pKSB7XG4gICAgICAvLyBNYWtlIHN1cmUgdGhlIHBhcmVudCBpcyByZWdpc3RlcmVkIGFuZCBub3RlIHRoZSBzY29wZSB3aGVyZSBpdHMgZGVmYXVsdHMgYXJlLlxuICAgICAgcGFyZW50U2NvcGUgPSB0aGlzLnJlZ2lzdGVyKHByb3RvKTtcbiAgICB9XG5cbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgY29uc3QgaWQgPSBpdGVtLmlkO1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZSArICcuJyArIGlkO1xuXG4gICAgaWYgKCFpZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbGFzcyBkb2VzIG5vdCBoYXZlIGlkOiAnICsgaXRlbSk7XG4gICAgfVxuXG4gICAgaWYgKGlkIGluIGl0ZW1zKSB7XG4gICAgICAvLyBhbHJlYWR5IHJlZ2lzdGVyZWRcbiAgICAgIHJldHVybiBzY29wZTtcbiAgICB9XG5cbiAgICBpdGVtc1tpZF0gPSBpdGVtO1xuICAgIHJlZ2lzdGVyRGVmYXVsdHMoaXRlbSwgc2NvcGUsIHBhcmVudFNjb3BlKTtcbiAgICBpZiAodGhpcy5vdmVycmlkZSkge1xuICAgICAgZGVmYXVsdHMub3ZlcnJpZGUoaXRlbS5pZCwgaXRlbS5vdmVycmlkZXMpO1xuICAgIH1cblxuICAgIHJldHVybiBzY29wZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWRcblx0ICogQHJldHVybnMge29iamVjdD99XG5cdCAqL1xuICBnZXQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtc1tpZF07XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtJQ2hhcnRDb21wb25lbnR9IGl0ZW1cblx0ICovXG4gIHVucmVnaXN0ZXIoaXRlbSkge1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5pdGVtcztcbiAgICBjb25zdCBpZCA9IGl0ZW0uaWQ7XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzLnNjb3BlO1xuXG4gICAgaWYgKGlkIGluIGl0ZW1zKSB7XG4gICAgICBkZWxldGUgaXRlbXNbaWRdO1xuICAgIH1cblxuICAgIGlmIChzY29wZSAmJiBpZCBpbiBkZWZhdWx0c1tzY29wZV0pIHtcbiAgICAgIGRlbGV0ZSBkZWZhdWx0c1tzY29wZV1baWRdO1xuICAgICAgaWYgKHRoaXMub3ZlcnJpZGUpIHtcbiAgICAgICAgZGVsZXRlIG92ZXJyaWRlc1tpZF07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdHMoaXRlbSwgc2NvcGUsIHBhcmVudFNjb3BlKSB7XG4gIC8vIEluaGVyaXQgdGhlIHBhcmVudCdzIGRlZmF1bHRzIGFuZCBrZWVwIGV4aXN0aW5nIGRlZmF1bHRzXG4gIGNvbnN0IGl0ZW1EZWZhdWx0cyA9IG1lcmdlKE9iamVjdC5jcmVhdGUobnVsbCksIFtcbiAgICBwYXJlbnRTY29wZSA/IGRlZmF1bHRzLmdldChwYXJlbnRTY29wZSkgOiB7fSxcbiAgICBkZWZhdWx0cy5nZXQoc2NvcGUpLFxuICAgIGl0ZW0uZGVmYXVsdHNcbiAgXSk7XG5cbiAgZGVmYXVsdHMuc2V0KHNjb3BlLCBpdGVtRGVmYXVsdHMpO1xuXG4gIGlmIChpdGVtLmRlZmF1bHRSb3V0ZXMpIHtcbiAgICByb3V0ZURlZmF1bHRzKHNjb3BlLCBpdGVtLmRlZmF1bHRSb3V0ZXMpO1xuICB9XG5cbiAgaWYgKGl0ZW0uZGVzY3JpcHRvcnMpIHtcbiAgICBkZWZhdWx0cy5kZXNjcmliZShzY29wZSwgaXRlbS5kZXNjcmlwdG9ycyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcm91dGVEZWZhdWx0cyhzY29wZSwgcm91dGVzKSB7XG4gIE9iamVjdC5rZXlzKHJvdXRlcykuZm9yRWFjaChwcm9wZXJ0eSA9PiB7XG4gICAgY29uc3QgcHJvcGVydHlQYXJ0cyA9IHByb3BlcnR5LnNwbGl0KCcuJyk7XG4gICAgY29uc3Qgc291cmNlTmFtZSA9IHByb3BlcnR5UGFydHMucG9wKCk7XG4gICAgY29uc3Qgc291cmNlU2NvcGUgPSBbc2NvcGVdLmNvbmNhdChwcm9wZXJ0eVBhcnRzKS5qb2luKCcuJyk7XG4gICAgY29uc3QgcGFydHMgPSByb3V0ZXNbcHJvcGVydHldLnNwbGl0KCcuJyk7XG4gICAgY29uc3QgdGFyZ2V0TmFtZSA9IHBhcnRzLnBvcCgpO1xuICAgIGNvbnN0IHRhcmdldFNjb3BlID0gcGFydHMuam9pbignLicpO1xuICAgIGRlZmF1bHRzLnJvdXRlKHNvdXJjZVNjb3BlLCBzb3VyY2VOYW1lLCB0YXJnZXRTY29wZSwgdGFyZ2V0TmFtZSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc0lDaGFydENvbXBvbmVudChwcm90bykge1xuICByZXR1cm4gJ2lkJyBpbiBwcm90byAmJiAnZGVmYXVsdHMnIGluIHByb3RvO1xufVxuIiwgImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IFNjYWxlIGZyb20gJy4vY29yZS5zY2FsZS5qcyc7XG5pbXBvcnQgVHlwZWRSZWdpc3RyeSBmcm9tICcuL2NvcmUudHlwZWRSZWdpc3RyeS5qcyc7XG5pbXBvcnQge2VhY2gsIGNhbGxiYWNrIGFzIGNhbGwsIF9jYXBpdGFsaXplfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5cbi8qKlxuICogUGxlYXNlIHVzZSB0aGUgbW9kdWxlJ3MgZGVmYXVsdCBleHBvcnQgd2hpY2ggcHJvdmlkZXMgYSBzaW5nbGV0b24gaW5zdGFuY2VcbiAqIE5vdGU6IGNsYXNzIGlzIGV4cG9ydGVkIGZvciB0eXBlZG9jXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWdpc3RyeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY29udHJvbGxlcnMgPSBuZXcgVHlwZWRSZWdpc3RyeShEYXRhc2V0Q29udHJvbGxlciwgJ2RhdGFzZXRzJywgdHJ1ZSk7XG4gICAgdGhpcy5lbGVtZW50cyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KEVsZW1lbnQsICdlbGVtZW50cycpO1xuICAgIHRoaXMucGx1Z2lucyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KE9iamVjdCwgJ3BsdWdpbnMnKTtcbiAgICB0aGlzLnNjYWxlcyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KFNjYWxlLCAnc2NhbGVzJyk7XG4gICAgLy8gT3JkZXIgaXMgaW1wb3J0YW50LCBTY2FsZSBoYXMgRWxlbWVudCBpbiBwcm90b3R5cGUgY2hhaW4sXG4gICAgLy8gc28gU2NhbGVzIG11c3QgYmUgYmVmb3JlIEVsZW1lbnRzLiBQbHVnaW5zIGFyZSBhIGZhbGxiYWNrLCBzbyBub3QgbGlzdGVkIGhlcmUuXG4gICAgdGhpcy5fdHlwZWRSZWdpc3RyaWVzID0gW3RoaXMuY29udHJvbGxlcnMsIHRoaXMuc2NhbGVzLCB0aGlzLmVsZW1lbnRzXTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3Ncblx0ICovXG4gIGFkZCguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzKTtcbiAgfVxuXG4gIHJlbW92ZSguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLnR5cGVvZiBEYXRhc2V0Q29udHJvbGxlcn0gYXJnc1xuXHQgKi9cbiAgYWRkQ29udHJvbGxlcnMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5jb250cm9sbGVycyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtICB7Li4udHlwZW9mIEVsZW1lbnR9IGFyZ3Ncblx0ICovXG4gIGFkZEVsZW1lbnRzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMuZWxlbWVudHMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLmFueX0gYXJnc1xuXHQgKi9cbiAgYWRkUGx1Z2lucyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLnBsdWdpbnMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLnR5cGVvZiBTY2FsZX0gYXJnc1xuXHQgKi9cbiAgYWRkU2NhbGVzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMuc2NhbGVzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWRcblx0ICogQHJldHVybnMge3R5cGVvZiBEYXRhc2V0Q29udHJvbGxlcn1cblx0ICovXG4gIGdldENvbnRyb2xsZXIoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLmNvbnRyb2xsZXJzLCAnY29udHJvbGxlcicpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuXHQgKiBAcmV0dXJucyB7dHlwZW9mIEVsZW1lbnR9XG5cdCAqL1xuICBnZXRFbGVtZW50KGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5lbGVtZW50cywgJ2VsZW1lbnQnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWRcblx0ICogQHJldHVybnMge29iamVjdH1cblx0ICovXG4gIGdldFBsdWdpbihpZCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoaWQsIHRoaXMucGx1Z2lucywgJ3BsdWdpbicpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuXHQgKiBAcmV0dXJucyB7dHlwZW9mIFNjYWxlfVxuXHQgKi9cbiAgZ2V0U2NhbGUoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLnNjYWxlcywgJ3NjYWxlJyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtICB7Li4udHlwZW9mIERhdGFzZXRDb250cm9sbGVyfSBhcmdzXG5cdCAqL1xuICByZW1vdmVDb250cm9sbGVycyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMuY29udHJvbGxlcnMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLnR5cGVvZiBFbGVtZW50fSBhcmdzXG5cdCAqL1xuICByZW1vdmVFbGVtZW50cyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMuZWxlbWVudHMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLmFueX0gYXJnc1xuXHQgKi9cbiAgcmVtb3ZlUGx1Z2lucyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMucGx1Z2lucyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtICB7Li4udHlwZW9mIFNjYWxlfSBhcmdzXG5cdCAqL1xuICByZW1vdmVTY2FsZXMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLnNjYWxlcyk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9lYWNoKG1ldGhvZCwgYXJncywgdHlwZWRSZWdpc3RyeSkge1xuICAgIFsuLi5hcmdzXS5mb3JFYWNoKGFyZyA9PiB7XG4gICAgICBjb25zdCByZWcgPSB0eXBlZFJlZ2lzdHJ5IHx8IHRoaXMuX2dldFJlZ2lzdHJ5Rm9yVHlwZShhcmcpO1xuICAgICAgaWYgKHR5cGVkUmVnaXN0cnkgfHwgcmVnLmlzRm9yVHlwZShhcmcpIHx8IChyZWcgPT09IHRoaXMucGx1Z2lucyAmJiBhcmcuaWQpKSB7XG4gICAgICAgIHRoaXMuX2V4ZWMobWV0aG9kLCByZWcsIGFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBIYW5kbGUgbG9vcGFibGUgYXJnc1xuICAgICAgICAvLyBVc2UgY2FzZTpcbiAgICAgICAgLy8gIGltcG9ydCAqIGFzIHBsdWdpbnMgZnJvbSAnLi9wbHVnaW5zLmpzJztcbiAgICAgICAgLy8gIENoYXJ0LnJlZ2lzdGVyKHBsdWdpbnMpO1xuICAgICAgICBlYWNoKGFyZywgaXRlbSA9PiB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG1peGVkIHR5cGVzIGluIHRoZSBsb29wYWJsZSwgbWFrZSBzdXJlIHRob3NlIGFyZVxuICAgICAgICAgIC8vIHJlZ2lzdGVyZWQgaW4gY29ycmVjdCByZWdpc3RyeVxuICAgICAgICAgIC8vIFVzZSBjYXNlOiAodHJlZW1hcCBleHBvcnRpbmcgY29udHJvbGxlciwgZWxlbWVudHMgZXRjKVxuICAgICAgICAgIC8vICBpbXBvcnQgKiBhcyB0cmVlbWFwIGZyb20gJ2NoYXJ0anMtY2hhcnQtdHJlZW1hcC5qcyc7XG4gICAgICAgICAgLy8gIENoYXJ0LnJlZ2lzdGVyKHRyZWVtYXApO1xuXG4gICAgICAgICAgY29uc3QgaXRlbVJlZyA9IHR5cGVkUmVnaXN0cnkgfHwgdGhpcy5fZ2V0UmVnaXN0cnlGb3JUeXBlKGl0ZW0pO1xuICAgICAgICAgIHRoaXMuX2V4ZWMobWV0aG9kLCBpdGVtUmVnLCBpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9leGVjKG1ldGhvZCwgcmVnaXN0cnksIGNvbXBvbmVudCkge1xuICAgIGNvbnN0IGNhbWVsTWV0aG9kID0gX2NhcGl0YWxpemUobWV0aG9kKTtcbiAgICBjYWxsKGNvbXBvbmVudFsnYmVmb3JlJyArIGNhbWVsTWV0aG9kXSwgW10sIGNvbXBvbmVudCk7IC8vIGJlZm9yZVJlZ2lzdGVyIC8gYmVmb3JlVW5yZWdpc3RlclxuICAgIHJlZ2lzdHJ5W21ldGhvZF0oY29tcG9uZW50KTtcbiAgICBjYWxsKGNvbXBvbmVudFsnYWZ0ZXInICsgY2FtZWxNZXRob2RdLCBbXSwgY29tcG9uZW50KTsgLy8gYWZ0ZXJSZWdpc3RlciAvIGFmdGVyVW5yZWdpc3RlclxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0UmVnaXN0cnlGb3JUeXBlKHR5cGUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3R5cGVkUmVnaXN0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVnID0gdGhpcy5fdHlwZWRSZWdpc3RyaWVzW2ldO1xuICAgICAgaWYgKHJlZy5pc0ZvclR5cGUodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHJlZztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcGx1Z2lucyBpcyB0aGUgZmFsbGJhY2sgcmVnaXN0cnlcbiAgICByZXR1cm4gdGhpcy5wbHVnaW5zO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0KGlkLCB0eXBlZFJlZ2lzdHJ5LCB0eXBlKSB7XG4gICAgY29uc3QgaXRlbSA9IHR5cGVkUmVnaXN0cnkuZ2V0KGlkKTtcbiAgICBpZiAoaXRlbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGlkICsgJ1wiIGlzIG5vdCBhIHJlZ2lzdGVyZWQgJyArIHR5cGUgKyAnLicpO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbTtcbiAgfVxuXG59XG5cbi8vIHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGRlZmF1bHQgLyogI19fUFVSRV9fICovIG5ldyBSZWdpc3RyeSgpO1xuIiwgImltcG9ydCByZWdpc3RyeSBmcm9tICcuL2NvcmUucmVnaXN0cnkuanMnO1xuaW1wb3J0IHtjYWxsYmFjayBhcyBjYWxsQ2FsbGJhY2ssIGlzTnVsbE9yVW5kZWYsIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5DaGFydEV2ZW50IH0gQ2hhcnRFdmVudFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3BsdWdpbnMvcGx1Z2luLnRvb2x0aXAuanMnKS5kZWZhdWx0IH0gVG9vbHRpcFxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIGZpbHRlckNhbGxiYWNrXG4gKiBAcGFyYW0ge3twbHVnaW46IG9iamVjdCwgb3B0aW9uczogb2JqZWN0fX0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXhdXG4gKiBAcGFyYW0ge2FycmF5fSBbYXJyYXldXG4gKiBAcGFyYW0ge29iamVjdH0gW3RoaXNBcmddXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGx1Z2luU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2luaXQgPSBbXTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBDYWxscyBlbmFibGVkIHBsdWdpbnMgZm9yIGBjaGFydGAgb24gdGhlIHNwZWNpZmllZCBob29rIGFuZCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuXHQgKiBUaGlzIG1ldGhvZCBpbW1lZGlhdGVseSByZXR1cm5zIGFzIHNvb24gYXMgYSBwbHVnaW4gZXhwbGljaXRseSByZXR1cm5zIGZhbHNlLiBUaGVcblx0ICogcmV0dXJuZWQgdmFsdWUgY2FuIGJlIHVzZWQsIGZvciBpbnN0YW5jZSwgdG8gaW50ZXJydXB0IHRoZSBjdXJyZW50IGFjdGlvbi5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBUaGUgY2hhcnQgaW5zdGFuY2UgZm9yIHdoaWNoIHBsdWdpbnMgc2hvdWxkIGJlIGNhbGxlZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGhvb2sgLSBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luIG1ldGhvZCB0byBjYWxsIChlLmcuICdiZWZvcmVVcGRhdGUnKS5cblx0ICogQHBhcmFtIHtvYmplY3R9IFthcmdzXSAtIEV4dHJhIGFyZ3VtZW50cyB0byBhcHBseSB0byB0aGUgaG9vayBjYWxsLlxuICAgKiBAcGFyYW0ge2ZpbHRlckNhbGxiYWNrfSBbZmlsdGVyXSAtIEZpbHRlcmluZyBmdW5jdGlvbiBmb3IgbGltaXRpbmcgd2hpY2ggcGx1Z2lucyBhcmUgbm90aWZpZWRcblx0ICogQHJldHVybnMge2Jvb2xlYW59IGZhbHNlIGlmIGFueSBvZiB0aGUgcGx1Z2lucyByZXR1cm4gZmFsc2UsIGVsc2UgcmV0dXJucyB0cnVlLlxuXHQgKi9cbiAgbm90aWZ5KGNoYXJ0LCBob29rLCBhcmdzLCBmaWx0ZXIpIHtcbiAgICBpZiAoaG9vayA9PT0gJ2JlZm9yZUluaXQnKSB7XG4gICAgICB0aGlzLl9pbml0ID0gdGhpcy5fY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIHRydWUpO1xuICAgICAgdGhpcy5fbm90aWZ5KHRoaXMuX2luaXQsIGNoYXJ0LCAnaW5zdGFsbCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gZmlsdGVyID8gdGhpcy5fZGVzY3JpcHRvcnMoY2hhcnQpLmZpbHRlcihmaWx0ZXIpIDogdGhpcy5fZGVzY3JpcHRvcnMoY2hhcnQpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX25vdGlmeShkZXNjcmlwdG9ycywgY2hhcnQsIGhvb2ssIGFyZ3MpO1xuXG4gICAgaWYgKGhvb2sgPT09ICdhZnRlckRlc3Ryb3knKSB7XG4gICAgICB0aGlzLl9ub3RpZnkoZGVzY3JpcHRvcnMsIGNoYXJ0LCAnc3RvcCcpO1xuICAgICAgdGhpcy5fbm90aWZ5KHRoaXMuX2luaXQsIGNoYXJ0LCAndW5pbnN0YWxsJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9ub3RpZnkoZGVzY3JpcHRvcnMsIGNoYXJ0LCBob29rLCBhcmdzKSB7XG4gICAgYXJncyA9IGFyZ3MgfHwge307XG4gICAgZm9yIChjb25zdCBkZXNjcmlwdG9yIG9mIGRlc2NyaXB0b3JzKSB7XG4gICAgICBjb25zdCBwbHVnaW4gPSBkZXNjcmlwdG9yLnBsdWdpbjtcbiAgICAgIGNvbnN0IG1ldGhvZCA9IHBsdWdpbltob29rXTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IFtjaGFydCwgYXJncywgZGVzY3JpcHRvci5vcHRpb25zXTtcbiAgICAgIGlmIChjYWxsQ2FsbGJhY2sobWV0aG9kLCBwYXJhbXMsIHBsdWdpbikgPT09IGZhbHNlICYmIGFyZ3MuY2FuY2VsYWJsZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpbnZhbGlkYXRlKCkge1xuICAgIC8vIFdoZW4gcGx1Z2lucyBhcmUgcmVnaXN0ZXJlZCwgdGhlcmUgaXMgdGhlIHBvc3NpYmlsaXR5IG9mIGEgZG91YmxlXG4gICAgLy8gaW52YWxpZGF0ZSBzaXR1YXRpb24uIEluIHRoaXMgY2FzZSwgd2Ugb25seSB3YW50IHRvIGludmFsaWRhdGUgb25jZS5cbiAgICAvLyBJZiB3ZSBpbnZhbGlkYXRlIG11bHRpcGxlIHRpbWVzLCB0aGUgYF9vbGRDYWNoZWAgaXMgbG9zdCBhbmQgYWxsIG9mIHRoZVxuICAgIC8vIHBsdWdpbnMgYXJlIHJlc3RhcnRlZCB3aXRob3V0IGJlaW5nIGNvcnJlY3RseSBzdG9wcGVkLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvODE0N1xuICAgIGlmICghaXNOdWxsT3JVbmRlZih0aGlzLl9jYWNoZSkpIHtcbiAgICAgIHRoaXMuX29sZENhY2hlID0gdGhpcy5fY2FjaGU7XG4gICAgICB0aGlzLl9jYWNoZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kZXNjcmlwdG9ycyhjaGFydCkge1xuICAgIGlmICh0aGlzLl9jYWNoZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlO1xuICAgIH1cblxuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gdGhpcy5fY2FjaGUgPSB0aGlzLl9jcmVhdGVEZXNjcmlwdG9ycyhjaGFydCk7XG5cbiAgICB0aGlzLl9ub3RpZnlTdGF0ZUNoYW5nZXMoY2hhcnQpO1xuXG4gICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xuICB9XG5cbiAgX2NyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCBhbGwpIHtcbiAgICBjb25zdCBjb25maWcgPSBjaGFydCAmJiBjaGFydC5jb25maWc7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHZhbHVlT3JEZWZhdWx0KGNvbmZpZy5vcHRpb25zICYmIGNvbmZpZy5vcHRpb25zLnBsdWdpbnMsIHt9KTtcbiAgICBjb25zdCBwbHVnaW5zID0gYWxsUGx1Z2lucyhjb25maWcpO1xuICAgIC8vIG9wdGlvbnMgPT09IGZhbHNlID0+IGFsbCBwbHVnaW5zIGFyZSBkaXNhYmxlZFxuICAgIHJldHVybiBvcHRpb25zID09PSBmYWxzZSAmJiAhYWxsID8gW10gOiBjcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwgcGx1Z2lucywgb3B0aW9ucywgYWxsKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX25vdGlmeVN0YXRlQ2hhbmdlcyhjaGFydCkge1xuICAgIGNvbnN0IHByZXZpb3VzRGVzY3JpcHRvcnMgPSB0aGlzLl9vbGRDYWNoZSB8fCBbXTtcbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IHRoaXMuX2NhY2hlO1xuICAgIGNvbnN0IGRpZmYgPSAoYSwgYikgPT4gYS5maWx0ZXIoeCA9PiAhYi5zb21lKHkgPT4geC5wbHVnaW4uaWQgPT09IHkucGx1Z2luLmlkKSk7XG4gICAgdGhpcy5fbm90aWZ5KGRpZmYocHJldmlvdXNEZXNjcmlwdG9ycywgZGVzY3JpcHRvcnMpLCBjaGFydCwgJ3N0b3AnKTtcbiAgICB0aGlzLl9ub3RpZnkoZGlmZihkZXNjcmlwdG9ycywgcHJldmlvdXNEZXNjcmlwdG9ycyksIGNoYXJ0LCAnc3RhcnQnKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2NvcmUuY29uZmlnLmpzJykuZGVmYXVsdH0gY29uZmlnXG4gKi9cbmZ1bmN0aW9uIGFsbFBsdWdpbnMoY29uZmlnKSB7XG4gIGNvbnN0IGxvY2FsSWRzID0ge307XG4gIGNvbnN0IHBsdWdpbnMgPSBbXTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHJlZ2lzdHJ5LnBsdWdpbnMuaXRlbXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBwbHVnaW5zLnB1c2gocmVnaXN0cnkuZ2V0UGx1Z2luKGtleXNbaV0pKTtcbiAgfVxuXG4gIGNvbnN0IGxvY2FsID0gY29uZmlnLnBsdWdpbnMgfHwgW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwbHVnaW4gPSBsb2NhbFtpXTtcblxuICAgIGlmIChwbHVnaW5zLmluZGV4T2YocGx1Z2luKSA9PT0gLTEpIHtcbiAgICAgIHBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgICAgbG9jYWxJZHNbcGx1Z2luLmlkXSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtwbHVnaW5zLCBsb2NhbElkc307XG59XG5cbmZ1bmN0aW9uIGdldE9wdHMob3B0aW9ucywgYWxsKSB7XG4gIGlmICghYWxsICYmIG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKG9wdGlvbnMgPT09IHRydWUpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCB7cGx1Z2lucywgbG9jYWxJZHN9LCBvcHRpb25zLCBhbGwpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IGNvbnRleHQgPSBjaGFydC5nZXRDb250ZXh0KCk7XG5cbiAgZm9yIChjb25zdCBwbHVnaW4gb2YgcGx1Z2lucykge1xuICAgIGNvbnN0IGlkID0gcGx1Z2luLmlkO1xuICAgIGNvbnN0IG9wdHMgPSBnZXRPcHRzKG9wdGlvbnNbaWRdLCBhbGwpO1xuICAgIGlmIChvcHRzID09PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2goe1xuICAgICAgcGx1Z2luLFxuICAgICAgb3B0aW9uczogcGx1Z2luT3B0cyhjaGFydC5jb25maWcsIHtwbHVnaW4sIGxvY2FsOiBsb2NhbElkc1tpZF19LCBvcHRzLCBjb250ZXh0KVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGx1Z2luT3B0cyhjb25maWcsIHtwbHVnaW4sIGxvY2FsfSwgb3B0cywgY29udGV4dCkge1xuICBjb25zdCBrZXlzID0gY29uZmlnLnBsdWdpblNjb3BlS2V5cyhwbHVnaW4pO1xuICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKG9wdHMsIGtleXMpO1xuICBpZiAobG9jYWwgJiYgcGx1Z2luLmRlZmF1bHRzKSB7XG4gICAgLy8gbWFrZSBzdXJlIHBsdWdpbiBkZWZhdWx0cyBhcmUgaW4gc2NvcGVzIGZvciBsb2NhbCAobm90IHJlZ2lzdGVyZWQpIHBsdWdpbnNcbiAgICBzY29wZXMucHVzaChwbHVnaW4uZGVmYXVsdHMpO1xuICB9XG4gIHJldHVybiBjb25maWcuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBjb250ZXh0LCBbJyddLCB7XG4gICAgLy8gVGhlc2UgYXJlIGp1c3QgZGVmYXVsdHMgdGhhdCBwbHVnaW5zIGNhbiBvdmVycmlkZVxuICAgIHNjcmlwdGFibGU6IGZhbHNlLFxuICAgIGluZGV4YWJsZTogZmFsc2UsXG4gICAgYWxsS2V5czogdHJ1ZVxuICB9KTtcbn1cbiIsICJpbXBvcnQgZGVmYXVsdHMsIHtvdmVycmlkZXMsIGRlc2NyaXB0b3JzfSBmcm9tICcuL2NvcmUuZGVmYXVsdHMuanMnO1xuaW1wb3J0IHttZXJnZUlmLCByZXNvbHZlT2JqZWN0S2V5LCBpc0FycmF5LCBpc0Z1bmN0aW9uLCB2YWx1ZU9yRGVmYXVsdCwgaXNPYmplY3R9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7X2F0dGFjaENvbnRleHQsIF9jcmVhdGVSZXNvbHZlciwgX2Rlc2NyaXB0b3JzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29uZmlnLmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEluZGV4QXhpcyh0eXBlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGRhdGFzZXREZWZhdWx0cyA9IGRlZmF1bHRzLmRhdGFzZXRzW3R5cGVdIHx8IHt9O1xuICBjb25zdCBkYXRhc2V0T3B0aW9ucyA9IChvcHRpb25zLmRhdGFzZXRzIHx8IHt9KVt0eXBlXSB8fCB7fTtcbiAgcmV0dXJuIGRhdGFzZXRPcHRpb25zLmluZGV4QXhpcyB8fCBvcHRpb25zLmluZGV4QXhpcyB8fCBkYXRhc2V0RGVmYXVsdHMuaW5kZXhBeGlzIHx8ICd4Jztcbn1cblxuZnVuY3Rpb24gZ2V0QXhpc0Zyb21EZWZhdWx0U2NhbGVJRChpZCwgaW5kZXhBeGlzKSB7XG4gIGxldCBheGlzID0gaWQ7XG4gIGlmIChpZCA9PT0gJ19pbmRleF8nKSB7XG4gICAgYXhpcyA9IGluZGV4QXhpcztcbiAgfSBlbHNlIGlmIChpZCA9PT0gJ192YWx1ZV8nKSB7XG4gICAgYXhpcyA9IGluZGV4QXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xuICB9XG4gIHJldHVybiBheGlzO1xufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0U2NhbGVJREZyb21BeGlzKGF4aXMsIGluZGV4QXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gaW5kZXhBeGlzID8gJ19pbmRleF8nIDogJ192YWx1ZV8nO1xufVxuXG5mdW5jdGlvbiBpZE1hdGNoZXNBeGlzKGlkKSB7XG4gIGlmIChpZCA9PT0gJ3gnIHx8IGlkID09PSAneScgfHwgaWQgPT09ICdyJykge1xuICAgIHJldHVybiBpZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBheGlzRnJvbVBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgcmV0dXJuICd4JztcbiAgfVxuICBpZiAocG9zaXRpb24gPT09ICdsZWZ0JyB8fCBwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHJldHVybiAneSc7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluZUF4aXMoaWQsIC4uLnNjYWxlT3B0aW9ucykge1xuICBpZiAoaWRNYXRjaGVzQXhpcyhpZCkpIHtcbiAgICByZXR1cm4gaWQ7XG4gIH1cbiAgZm9yIChjb25zdCBvcHRzIG9mIHNjYWxlT3B0aW9ucykge1xuICAgIGNvbnN0IGF4aXMgPSBvcHRzLmF4aXNcbiAgICAgIHx8IGF4aXNGcm9tUG9zaXRpb24ob3B0cy5wb3NpdGlvbilcbiAgICAgIHx8IGlkLmxlbmd0aCA+IDEgJiYgaWRNYXRjaGVzQXhpcyhpZFswXS50b0xvd2VyQ2FzZSgpKTtcbiAgICBpZiAoYXhpcykge1xuICAgICAgcmV0dXJuIGF4aXM7XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGRldGVybWluZSB0eXBlIG9mICcke2lkfScgYXhpcy4gUGxlYXNlIHByb3ZpZGUgJ2F4aXMnIG9yICdwb3NpdGlvbicgb3B0aW9uLmApO1xufVxuXG5mdW5jdGlvbiBnZXRBeGlzRnJvbURhdGFzZXQoaWQsIGF4aXMsIGRhdGFzZXQpIHtcbiAgaWYgKGRhdGFzZXRbYXhpcyArICdBeGlzSUQnXSA9PT0gaWQpIHtcbiAgICByZXR1cm4ge2F4aXN9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJldHJpZXZlQXhpc0Zyb21EYXRhc2V0cyhpZCwgY29uZmlnKSB7XG4gIGlmIChjb25maWcuZGF0YSAmJiBjb25maWcuZGF0YS5kYXRhc2V0cykge1xuICAgIGNvbnN0IGJvdW5kRHMgPSBjb25maWcuZGF0YS5kYXRhc2V0cy5maWx0ZXIoKGQpID0+IGQueEF4aXNJRCA9PT0gaWQgfHwgZC55QXhpc0lEID09PSBpZCk7XG4gICAgaWYgKGJvdW5kRHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZ2V0QXhpc0Zyb21EYXRhc2V0KGlkLCAneCcsIGJvdW5kRHNbMF0pIHx8IGdldEF4aXNGcm9tRGF0YXNldChpZCwgJ3knLCBib3VuZERzWzBdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiBtZXJnZVNjYWxlQ29uZmlnKGNvbmZpZywgb3B0aW9ucykge1xuICBjb25zdCBjaGFydERlZmF1bHRzID0gb3ZlcnJpZGVzW2NvbmZpZy50eXBlXSB8fCB7c2NhbGVzOiB7fX07XG4gIGNvbnN0IGNvbmZpZ1NjYWxlcyA9IG9wdGlvbnMuc2NhbGVzIHx8IHt9O1xuICBjb25zdCBjaGFydEluZGV4QXhpcyA9IGdldEluZGV4QXhpcyhjb25maWcudHlwZSwgb3B0aW9ucyk7XG4gIGNvbnN0IHNjYWxlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy8gRmlyc3QgZmlndXJlIG91dCBmaXJzdCBzY2FsZSBpZCdzIHBlciBheGlzLlxuICBPYmplY3Qua2V5cyhjb25maWdTY2FsZXMpLmZvckVhY2goaWQgPT4ge1xuICAgIGNvbnN0IHNjYWxlQ29uZiA9IGNvbmZpZ1NjYWxlc1tpZF07XG4gICAgaWYgKCFpc09iamVjdChzY2FsZUNvbmYpKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcihgSW52YWxpZCBzY2FsZSBjb25maWd1cmF0aW9uIGZvciBzY2FsZTogJHtpZH1gKTtcbiAgICB9XG4gICAgaWYgKHNjYWxlQ29uZi5fcHJveHkpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLndhcm4oYElnbm9yaW5nIHJlc29sdmVyIHBhc3NlZCBhcyBvcHRpb25zIGZvciBzY2FsZTogJHtpZH1gKTtcbiAgICB9XG4gICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlQ29uZiwgcmV0cmlldmVBeGlzRnJvbURhdGFzZXRzKGlkLCBjb25maWcpLCBkZWZhdWx0cy5zY2FsZXNbc2NhbGVDb25mLnR5cGVdKTtcbiAgICBjb25zdCBkZWZhdWx0SWQgPSBnZXREZWZhdWx0U2NhbGVJREZyb21BeGlzKGF4aXMsIGNoYXJ0SW5kZXhBeGlzKTtcbiAgICBjb25zdCBkZWZhdWx0U2NhbGVPcHRpb25zID0gY2hhcnREZWZhdWx0cy5zY2FsZXMgfHwge307XG4gICAgc2NhbGVzW2lkXSA9IG1lcmdlSWYoT2JqZWN0LmNyZWF0ZShudWxsKSwgW3theGlzfSwgc2NhbGVDb25mLCBkZWZhdWx0U2NhbGVPcHRpb25zW2F4aXNdLCBkZWZhdWx0U2NhbGVPcHRpb25zW2RlZmF1bHRJZF1dKTtcbiAgfSk7XG5cbiAgLy8gVGhlbiBtZXJnZSBkYXRhc2V0IGRlZmF1bHRzIHRvIHNjYWxlIGNvbmZpZ3NcbiAgY29uZmlnLmRhdGEuZGF0YXNldHMuZm9yRWFjaChkYXRhc2V0ID0+IHtcbiAgICBjb25zdCB0eXBlID0gZGF0YXNldC50eXBlIHx8IGNvbmZpZy50eXBlO1xuICAgIGNvbnN0IGluZGV4QXhpcyA9IGRhdGFzZXQuaW5kZXhBeGlzIHx8IGdldEluZGV4QXhpcyh0eXBlLCBvcHRpb25zKTtcbiAgICBjb25zdCBkYXRhc2V0RGVmYXVsdHMgPSBvdmVycmlkZXNbdHlwZV0gfHwge307XG4gICAgY29uc3QgZGVmYXVsdFNjYWxlT3B0aW9ucyA9IGRhdGFzZXREZWZhdWx0cy5zY2FsZXMgfHwge307XG4gICAgT2JqZWN0LmtleXMoZGVmYXVsdFNjYWxlT3B0aW9ucykuZm9yRWFjaChkZWZhdWx0SUQgPT4ge1xuICAgICAgY29uc3QgYXhpcyA9IGdldEF4aXNGcm9tRGVmYXVsdFNjYWxlSUQoZGVmYXVsdElELCBpbmRleEF4aXMpO1xuICAgICAgY29uc3QgaWQgPSBkYXRhc2V0W2F4aXMgKyAnQXhpc0lEJ10gfHwgYXhpcztcbiAgICAgIHNjYWxlc1tpZF0gPSBzY2FsZXNbaWRdIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBtZXJnZUlmKHNjYWxlc1tpZF0sIFt7YXhpc30sIGNvbmZpZ1NjYWxlc1tpZF0sIGRlZmF1bHRTY2FsZU9wdGlvbnNbZGVmYXVsdElEXV0pO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBhcHBseSBzY2FsZSBkZWZhdWx0cywgaWYgbm90IG92ZXJyaWRkZW4gYnkgZGF0YXNldCBkZWZhdWx0c1xuICBPYmplY3Qua2V5cyhzY2FsZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICBjb25zdCBzY2FsZSA9IHNjYWxlc1trZXldO1xuICAgIG1lcmdlSWYoc2NhbGUsIFtkZWZhdWx0cy5zY2FsZXNbc2NhbGUudHlwZV0sIGRlZmF1bHRzLnNjYWxlXSk7XG4gIH0pO1xuXG4gIHJldHVybiBzY2FsZXM7XG59XG5cbmZ1bmN0aW9uIGluaXRPcHRpb25zKGNvbmZpZykge1xuICBjb25zdCBvcHRpb25zID0gY29uZmlnLm9wdGlvbnMgfHwgKGNvbmZpZy5vcHRpb25zID0ge30pO1xuXG4gIG9wdGlvbnMucGx1Z2lucyA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMucGx1Z2lucywge30pO1xuICBvcHRpb25zLnNjYWxlcyA9IG1lcmdlU2NhbGVDb25maWcoY29uZmlnLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEoZGF0YSkge1xuICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgZGF0YS5kYXRhc2V0cyA9IGRhdGEuZGF0YXNldHMgfHwgW107XG4gIGRhdGEubGFiZWxzID0gZGF0YS5sYWJlbHMgfHwgW107XG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBpbml0Q29uZmlnKGNvbmZpZykge1xuICBjb25maWcgPSBjb25maWcgfHwge307XG4gIGNvbmZpZy5kYXRhID0gaW5pdERhdGEoY29uZmlnLmRhdGEpO1xuXG4gIGluaXRPcHRpb25zKGNvbmZpZyk7XG5cbiAgcmV0dXJuIGNvbmZpZztcbn1cblxuY29uc3Qga2V5Q2FjaGUgPSBuZXcgTWFwKCk7XG5jb25zdCBrZXlzQ2FjaGVkID0gbmV3IFNldCgpO1xuXG5mdW5jdGlvbiBjYWNoZWRLZXlzKGNhY2hlS2V5LCBnZW5lcmF0ZSkge1xuICBsZXQga2V5cyA9IGtleUNhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmICgha2V5cykge1xuICAgIGtleXMgPSBnZW5lcmF0ZSgpO1xuICAgIGtleUNhY2hlLnNldChjYWNoZUtleSwga2V5cyk7XG4gICAga2V5c0NhY2hlZC5hZGQoa2V5cyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5cbmNvbnN0IGFkZElmRm91bmQgPSAoc2V0LCBvYmosIGtleSkgPT4ge1xuICBjb25zdCBvcHRzID0gcmVzb2x2ZU9iamVjdEtleShvYmosIGtleSk7XG4gIGlmIChvcHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICBzZXQuYWRkKG9wdHMpO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb25maWcge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLl9jb25maWcgPSBpbml0Q29uZmlnKGNvbmZpZyk7XG4gICAgdGhpcy5fc2NvcGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9yZXNvbHZlckNhY2hlID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgZ2V0IHBsYXRmb3JtKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcucGxhdGZvcm07XG4gIH1cblxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLnR5cGU7XG4gIH1cblxuICBzZXQgdHlwZSh0eXBlKSB7XG4gICAgdGhpcy5fY29uZmlnLnR5cGUgPSB0eXBlO1xuICB9XG5cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5kYXRhO1xuICB9XG5cbiAgc2V0IGRhdGEoZGF0YSkge1xuICAgIHRoaXMuX2NvbmZpZy5kYXRhID0gaW5pdERhdGEoZGF0YSk7XG4gIH1cblxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLm9wdGlvbnM7XG4gIH1cblxuICBzZXQgb3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdGhpcy5fY29uZmlnLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG5cbiAgZ2V0IHBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5wbHVnaW5zO1xuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuX2NvbmZpZztcbiAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcbiAgICBpbml0T3B0aW9ucyhjb25maWcpO1xuICB9XG5cbiAgY2xlYXJDYWNoZSgpIHtcbiAgICB0aGlzLl9zY29wZUNhY2hlLmNsZWFyKCk7XG4gICAgdGhpcy5fcmVzb2x2ZXJDYWNoZS5jbGVhcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9wdGlvbiBzY29wZSBrZXlzIGZvciByZXNvbHZpbmcgZGF0YXNldCBvcHRpb25zLlxuICAgKiBUaGVzZSBrZXlzIGRvIG5vdCBpbmNsdWRlIHRoZSBkYXRhc2V0IGl0c2VsZiwgYmVjYXVzZSBpdCBpcyBub3QgdW5kZXIgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFzZXRUeXBlXG4gICAqIEByZXR1cm4ge3N0cmluZ1tdW119XG4gICAqL1xuICBkYXRhc2V0U2NvcGVLZXlzKGRhdGFzZXRUeXBlKSB7XG4gICAgcmV0dXJuIGNhY2hlZEtleXMoZGF0YXNldFR5cGUsXG4gICAgICAoKSA9PiBbW1xuICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX1gLFxuICAgICAgICAnJ1xuICAgICAgXV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9wdGlvbiBzY29wZSBrZXlzIGZvciByZXNvbHZpbmcgZGF0YXNldCBhbmltYXRpb24gb3B0aW9ucy5cbiAgICogVGhlc2Uga2V5cyBkbyBub3QgaW5jbHVkZSB0aGUgZGF0YXNldCBpdHNlbGYsIGJlY2F1c2UgaXQgaXMgbm90IHVuZGVyIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhc2V0VHlwZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhbnNpdGlvblxuICAgKiBAcmV0dXJuIHtzdHJpbmdbXVtdfVxuICAgKi9cbiAgZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyhkYXRhc2V0VHlwZSwgdHJhbnNpdGlvbikge1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGAke2RhdGFzZXRUeXBlfS50cmFuc2l0aW9uLiR7dHJhbnNpdGlvbn1gLFxuICAgICAgKCkgPT4gW1xuICAgICAgICBbXG4gICAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9LnRyYW5zaXRpb25zLiR7dHJhbnNpdGlvbn1gLFxuICAgICAgICAgIGB0cmFuc2l0aW9ucy4ke3RyYW5zaXRpb259YCxcbiAgICAgICAgXSxcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBhcmUgdXNlZCBmb3IgbG9va2luZyB1cCB0aGUgYGFuaW1hdGlvbnNgIGFuZCBgYW5pbWF0aW9uYCBrZXlzXG4gICAgICAgIFtcbiAgICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX1gLFxuICAgICAgICAgICcnXG4gICAgICAgIF1cbiAgICAgIF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9wdGlvbnMgc2NvcGUga2V5cyBmb3IgcmVzb2x2aW5nIGVsZW1lbnQgb3B0aW9ucyB0aGF0IGJlbG9uZ1xuICAgKiB0byBhbiBkYXRhc2V0LiBUaGVzZSBrZXlzIGRvIG5vdCBpbmNsdWRlIHRoZSBkYXRhc2V0IGl0c2VsZiwgYmVjYXVzZSBpdFxuICAgKiBpcyBub3QgdW5kZXIgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFzZXRUeXBlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50VHlwZVxuICAgKiBAcmV0dXJuIHtzdHJpbmdbXVtdfVxuICAgKi9cbiAgZGF0YXNldEVsZW1lbnRTY29wZUtleXMoZGF0YXNldFR5cGUsIGVsZW1lbnRUeXBlKSB7XG4gICAgcmV0dXJuIGNhY2hlZEtleXMoYCR7ZGF0YXNldFR5cGV9LSR7ZWxlbWVudFR5cGV9YCxcbiAgICAgICgpID0+IFtbXG4gICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfS5lbGVtZW50cy4ke2VsZW1lbnRUeXBlfWAsXG4gICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfWAsXG4gICAgICAgIGBlbGVtZW50cy4ke2VsZW1lbnRUeXBlfWAsXG4gICAgICAgICcnXG4gICAgICBdXSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3B0aW9ucyBzY29wZSBrZXlzIGZvciByZXNvbHZpbmcgcGx1Z2luIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7e2lkOiBzdHJpbmcsIGFkZGl0aW9uYWxPcHRpb25TY29wZXM/OiBzdHJpbmdbXX19IHBsdWdpblxuICAgKiBAcmV0dXJuIHtzdHJpbmdbXVtdfVxuICAgKi9cbiAgcGx1Z2luU2NvcGVLZXlzKHBsdWdpbikge1xuICAgIGNvbnN0IGlkID0gcGx1Z2luLmlkO1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLnR5cGU7XG4gICAgcmV0dXJuIGNhY2hlZEtleXMoYCR7dHlwZX0tcGx1Z2luLSR7aWR9YCxcbiAgICAgICgpID0+IFtbXG4gICAgICAgIGBwbHVnaW5zLiR7aWR9YCxcbiAgICAgICAgLi4ucGx1Z2luLmFkZGl0aW9uYWxPcHRpb25TY29wZXMgfHwgW10sXG4gICAgICBdXSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jYWNoZWRTY29wZXMobWFpblNjb3BlLCByZXNldENhY2hlKSB7XG4gICAgY29uc3QgX3Njb3BlQ2FjaGUgPSB0aGlzLl9zY29wZUNhY2hlO1xuICAgIGxldCBjYWNoZSA9IF9zY29wZUNhY2hlLmdldChtYWluU2NvcGUpO1xuICAgIGlmICghY2FjaGUgfHwgcmVzZXRDYWNoZSkge1xuICAgICAgY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICBfc2NvcGVDYWNoZS5zZXQobWFpblNjb3BlLCBjYWNoZSk7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyB0aGUgb2JqZWN0cyBmcm9tIG9wdGlvbnMgYW5kIGRlZmF1bHRzIGZvciBvcHRpb24gdmFsdWUgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtvYmplY3R9IG1haW5TY29wZSAtIFRoZSBtYWluIHNjb3BlIG9iamVjdCBmb3Igb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ1tdW119IGtleUxpc3RzIC0gVGhlIGFycmF5cyBvZiBrZXlzIGluIHJlc29sdXRpb24gb3JkZXJcbiAgICogQHBhcmFtIHtib29sZWFufSBbcmVzZXRDYWNoZV0gLSByZXNldCB0aGUgY2FjaGUgZm9yIHRoaXMgbWFpblNjb3BlXG4gICAqL1xuICBnZXRPcHRpb25TY29wZXMobWFpblNjb3BlLCBrZXlMaXN0cywgcmVzZXRDYWNoZSkge1xuICAgIGNvbnN0IHtvcHRpb25zLCB0eXBlfSA9IHRoaXM7XG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLl9jYWNoZWRTY29wZXMobWFpblNjb3BlLCByZXNldENhY2hlKTtcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoa2V5TGlzdHMpO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuXG4gICAgY29uc3Qgc2NvcGVzID0gbmV3IFNldCgpO1xuXG4gICAga2V5TGlzdHMuZm9yRWFjaChrZXlzID0+IHtcbiAgICAgIGlmIChtYWluU2NvcGUpIHtcbiAgICAgICAgc2NvcGVzLmFkZChtYWluU2NvcGUpO1xuICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBtYWluU2NvcGUsIGtleSkpO1xuICAgICAgfVxuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3Blcywgb3B0aW9ucywga2V5KSk7XG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBvdmVycmlkZXNbdHlwZV0gfHwge30sIGtleSkpO1xuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3BlcywgZGVmYXVsdHMsIGtleSkpO1xuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3BlcywgZGVzY3JpcHRvcnMsIGtleSkpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgYXJyYXkgPSBBcnJheS5mcm9tKHNjb3Blcyk7XG4gICAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgYXJyYXkucHVzaChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICB9XG4gICAgaWYgKGtleXNDYWNoZWQuaGFzKGtleUxpc3RzKSkge1xuICAgICAgY2FjaGUuc2V0KGtleUxpc3RzLCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcHRpb24gc2NvcGVzIGZvciByZXNvbHZpbmcgY2hhcnQgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtvYmplY3RbXX1cbiAgICovXG4gIGNoYXJ0T3B0aW9uU2NvcGVzKCkge1xuICAgIGNvbnN0IHtvcHRpb25zLCB0eXBlfSA9IHRoaXM7XG5cbiAgICByZXR1cm4gW1xuICAgICAgb3B0aW9ucyxcbiAgICAgIG92ZXJyaWRlc1t0eXBlXSB8fCB7fSxcbiAgICAgIGRlZmF1bHRzLmRhdGFzZXRzW3R5cGVdIHx8IHt9LCAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvODUzMVxuICAgICAge3R5cGV9LFxuICAgICAgZGVmYXVsdHMsXG4gICAgICBkZXNjcmlwdG9yc1xuICAgIF07XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3RbXX0gc2NvcGVzXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IG5hbWVzXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb258b2JqZWN0fSBjb250ZXh0XG4gICAqIEBwYXJhbSB7c3RyaW5nW119IFtwcmVmaXhlc11cbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKi9cbiAgcmVzb2x2ZU5hbWVkT3B0aW9ucyhzY29wZXMsIG5hbWVzLCBjb250ZXh0LCBwcmVmaXhlcyA9IFsnJ10pIHtcbiAgICBjb25zdCByZXN1bHQgPSB7JHNoYXJlZDogdHJ1ZX07XG4gICAgY29uc3Qge3Jlc29sdmVyLCBzdWJQcmVmaXhlc30gPSBnZXRSZXNvbHZlcih0aGlzLl9yZXNvbHZlckNhY2hlLCBzY29wZXMsIHByZWZpeGVzKTtcbiAgICBsZXQgb3B0aW9ucyA9IHJlc29sdmVyO1xuICAgIGlmIChuZWVkQ29udGV4dChyZXNvbHZlciwgbmFtZXMpKSB7XG4gICAgICByZXN1bHQuJHNoYXJlZCA9IGZhbHNlO1xuICAgICAgY29udGV4dCA9IGlzRnVuY3Rpb24oY29udGV4dCkgPyBjb250ZXh0KCkgOiBjb250ZXh0O1xuICAgICAgLy8gc3ViUmVzb2x2ZXIgaXMgcGFzc2VkIHRvIHNjcmlwdGFibGUgb3B0aW9ucy4gSXQgc2hvdWxkIG5vdCByZXNvbHZlIHRvIGhvdmVyIG9wdGlvbnMuXG4gICAgICBjb25zdCBzdWJSZXNvbHZlciA9IHRoaXMuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBjb250ZXh0LCBzdWJQcmVmaXhlcyk7XG4gICAgICBvcHRpb25zID0gX2F0dGFjaENvbnRleHQocmVzb2x2ZXIsIGNvbnRleHQsIHN1YlJlc29sdmVyKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgbmFtZXMpIHtcbiAgICAgIHJlc3VsdFtwcm9wXSA9IG9wdGlvbnNbcHJvcF07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3RbXX0gc2NvcGVzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF1cbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gW3ByZWZpeGVzXVxuICAgKiBAcGFyYW0ge3tzY3JpcHRhYmxlOiBib29sZWFuLCBpbmRleGFibGU6IGJvb2xlYW4sIGFsbEtleXM/OiBib29sZWFufX0gW2Rlc2NyaXB0b3JEZWZhdWx0c11cbiAgICovXG4gIGNyZWF0ZVJlc29sdmVyKHNjb3BlcywgY29udGV4dCwgcHJlZml4ZXMgPSBbJyddLCBkZXNjcmlwdG9yRGVmYXVsdHMpIHtcbiAgICBjb25zdCB7cmVzb2x2ZXJ9ID0gZ2V0UmVzb2x2ZXIodGhpcy5fcmVzb2x2ZXJDYWNoZSwgc2NvcGVzLCBwcmVmaXhlcyk7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGNvbnRleHQpXG4gICAgICA/IF9hdHRhY2hDb250ZXh0KHJlc29sdmVyLCBjb250ZXh0LCB1bmRlZmluZWQsIGRlc2NyaXB0b3JEZWZhdWx0cylcbiAgICAgIDogcmVzb2x2ZXI7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmVzb2x2ZXIocmVzb2x2ZXJDYWNoZSwgc2NvcGVzLCBwcmVmaXhlcykge1xuICBsZXQgY2FjaGUgPSByZXNvbHZlckNhY2hlLmdldChzY29wZXMpO1xuICBpZiAoIWNhY2hlKSB7XG4gICAgY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgcmVzb2x2ZXJDYWNoZS5zZXQoc2NvcGVzLCBjYWNoZSk7XG4gIH1cbiAgY29uc3QgY2FjaGVLZXkgPSBwcmVmaXhlcy5qb2luKCk7XG4gIGxldCBjYWNoZWQgPSBjYWNoZS5nZXQoY2FjaGVLZXkpO1xuICBpZiAoIWNhY2hlZCkge1xuICAgIGNvbnN0IHJlc29sdmVyID0gX2NyZWF0ZVJlc29sdmVyKHNjb3BlcywgcHJlZml4ZXMpO1xuICAgIGNhY2hlZCA9IHtcbiAgICAgIHJlc29sdmVyLFxuICAgICAgc3ViUHJlZml4ZXM6IHByZWZpeGVzLmZpbHRlcihwID0+ICFwLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2hvdmVyJykpXG4gICAgfTtcbiAgICBjYWNoZS5zZXQoY2FjaGVLZXksIGNhY2hlZCk7XG4gIH1cbiAgcmV0dXJuIGNhY2hlZDtcbn1cblxuY29uc3QgaGFzRnVuY3Rpb24gPSB2YWx1ZSA9PiBpc09iamVjdCh2YWx1ZSlcbiAgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpLnNvbWUoKGtleSkgPT4gaXNGdW5jdGlvbih2YWx1ZVtrZXldKSk7XG5cbmZ1bmN0aW9uIG5lZWRDb250ZXh0KHByb3h5LCBuYW1lcykge1xuICBjb25zdCB7aXNTY3JpcHRhYmxlLCBpc0luZGV4YWJsZX0gPSBfZGVzY3JpcHRvcnMocHJveHkpO1xuXG4gIGZvciAoY29uc3QgcHJvcCBvZiBuYW1lcykge1xuICAgIGNvbnN0IHNjcmlwdGFibGUgPSBpc1NjcmlwdGFibGUocHJvcCk7XG4gICAgY29uc3QgaW5kZXhhYmxlID0gaXNJbmRleGFibGUocHJvcCk7XG4gICAgY29uc3QgdmFsdWUgPSAoaW5kZXhhYmxlIHx8IHNjcmlwdGFibGUpICYmIHByb3h5W3Byb3BdO1xuICAgIGlmICgoc2NyaXB0YWJsZSAmJiAoaXNGdW5jdGlvbih2YWx1ZSkgfHwgaGFzRnVuY3Rpb24odmFsdWUpKSlcbiAgICAgIHx8IChpbmRleGFibGUgJiYgaXNBcnJheSh2YWx1ZSkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuIiwgImltcG9ydCBhbmltYXRvciBmcm9tICcuL2NvcmUuYW5pbWF0b3IuanMnO1xuaW1wb3J0IGRlZmF1bHRzLCB7b3ZlcnJpZGVzfSBmcm9tICcuL2NvcmUuZGVmYXVsdHMuanMnO1xuaW1wb3J0IEludGVyYWN0aW9uIGZyb20gJy4vY29yZS5pbnRlcmFjdGlvbi5qcyc7XG5pbXBvcnQgbGF5b3V0cyBmcm9tICcuL2NvcmUubGF5b3V0cy5qcyc7XG5pbXBvcnQge19kZXRlY3RQbGF0Zm9ybX0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXguanMnO1xuaW1wb3J0IFBsdWdpblNlcnZpY2UgZnJvbSAnLi9jb3JlLnBsdWdpbnMuanMnO1xuaW1wb3J0IHJlZ2lzdHJ5IGZyb20gJy4vY29yZS5yZWdpc3RyeS5qcyc7XG5pbXBvcnQgQ29uZmlnLCB7ZGV0ZXJtaW5lQXhpcywgZ2V0SW5kZXhBeGlzfSBmcm9tICcuL2NvcmUuY29uZmlnLmpzJztcbmltcG9ydCB7cmV0aW5hU2NhbGUsIF9pc0RvbVN1cHBvcnRlZH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmRvbS5qcyc7XG5pbXBvcnQge2VhY2gsIGNhbGxiYWNrIGFzIGNhbGxDYWxsYmFjaywgdWlkLCB2YWx1ZU9yRGVmYXVsdCwgX2VsZW1lbnRzRXF1YWwsIGlzTnVsbE9yVW5kZWYsIHNldHNFcXVhbCwgZGVmaW5lZCwgaXNGdW5jdGlvbiwgX2lzQ2xpY2tFdmVudH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtjbGVhckNhbnZhcywgY2xpcEFyZWEsIGNyZWF0ZUNvbnRleHQsIHVuY2xpcEFyZWEsIF9pc1BvaW50SW5BcmVhfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7dmVyc2lvbn0gZnJvbSAnLi4vLi4vcGFja2FnZS5qc29uJztcbmltcG9ydCB7ZGVib3VuY2V9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLkNoYXJ0RXZlbnQgfSBDaGFydEV2ZW50XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5Qb2ludCB9IFBvaW50XG4gKi9cblxuY29uc3QgS05PV05fUE9TSVRJT05TID0gWyd0b3AnLCAnYm90dG9tJywgJ2xlZnQnLCAncmlnaHQnLCAnY2hhcnRBcmVhJ107XG5mdW5jdGlvbiBwb3NpdGlvbklzSG9yaXpvbnRhbChwb3NpdGlvbiwgYXhpcykge1xuICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJyB8fCAoS05PV05fUE9TSVRJT05TLmluZGV4T2YocG9zaXRpb24pID09PSAtMSAmJiBheGlzID09PSAneCcpO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlMkxldmVsKGwxLCBsMikge1xuICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBhW2wxXSA9PT0gYltsMV1cbiAgICAgID8gYVtsMl0gLSBiW2wyXVxuICAgICAgOiBhW2wxXSAtIGJbbDFdO1xuICB9O1xufVxuXG5mdW5jdGlvbiBvbkFuaW1hdGlvbnNDb21wbGV0ZShjb250ZXh0KSB7XG4gIGNvbnN0IGNoYXJ0ID0gY29udGV4dC5jaGFydDtcbiAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uO1xuXG4gIGNoYXJ0Lm5vdGlmeVBsdWdpbnMoJ2FmdGVyUmVuZGVyJyk7XG4gIGNhbGxDYWxsYmFjayhhbmltYXRpb25PcHRpb25zICYmIGFuaW1hdGlvbk9wdGlvbnMub25Db21wbGV0ZSwgW2NvbnRleHRdLCBjaGFydCk7XG59XG5cbmZ1bmN0aW9uIG9uQW5pbWF0aW9uUHJvZ3Jlc3MoY29udGV4dCkge1xuICBjb25zdCBjaGFydCA9IGNvbnRleHQuY2hhcnQ7XG4gIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmFuaW1hdGlvbjtcbiAgY2FsbENhbGxiYWNrKGFuaW1hdGlvbk9wdGlvbnMgJiYgYW5pbWF0aW9uT3B0aW9ucy5vblByb2dyZXNzLCBbY29udGV4dF0sIGNoYXJ0KTtcbn1cblxuLyoqXG4gKiBDaGFydC5qcyBjYW4gdGFrZSBhIHN0cmluZyBpZCBvZiBhIGNhbnZhcyBlbGVtZW50LCBhIDJkIGNvbnRleHQsIG9yIGEgY2FudmFzIGVsZW1lbnQgaXRzZWxmLlxuICogQXR0ZW1wdCB0byB1bndyYXAgdGhlIGl0ZW0gcGFzc2VkIGludG8gdGhlIGNoYXJ0IGNvbnN0cnVjdG9yIHNvIHRoYXQgaXQgaXMgYSBjYW52YXMgZWxlbWVudCAoaWYgcG9zc2libGUpLlxuICovXG5mdW5jdGlvbiBnZXRDYW52YXMoaXRlbSkge1xuICBpZiAoX2lzRG9tU3VwcG9ydGVkKCkgJiYgdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgaXRlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGl0ZW0pO1xuICB9IGVsc2UgaWYgKGl0ZW0gJiYgaXRlbS5sZW5ndGgpIHtcbiAgICAvLyBTdXBwb3J0IGZvciBhcnJheSBiYXNlZCBxdWVyaWVzIChzdWNoIGFzIGpRdWVyeSlcbiAgICBpdGVtID0gaXRlbVswXTtcbiAgfVxuXG4gIGlmIChpdGVtICYmIGl0ZW0uY2FudmFzKSB7XG4gICAgLy8gU3VwcG9ydCBmb3IgYW55IG9iamVjdCBhc3NvY2lhdGVkIHRvIGEgY2FudmFzIChpbmNsdWRpbmcgYSBjb250ZXh0MmQpXG4gICAgaXRlbSA9IGl0ZW0uY2FudmFzO1xuICB9XG4gIHJldHVybiBpdGVtO1xufVxuXG5jb25zdCBpbnN0YW5jZXMgPSB7fTtcbmNvbnN0IGdldENoYXJ0ID0gKGtleSkgPT4ge1xuICBjb25zdCBjYW52YXMgPSBnZXRDYW52YXMoa2V5KTtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoaW5zdGFuY2VzKS5maWx0ZXIoKGMpID0+IGMuY2FudmFzID09PSBjYW52YXMpLnBvcCgpO1xufTtcblxuZnVuY3Rpb24gbW92ZU51bWVyaWNLZXlzKG9iaiwgc3RhcnQsIG1vdmUpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBjb25zdCBpbnRLZXkgPSAra2V5O1xuICAgIGlmIChpbnRLZXkgPj0gc3RhcnQpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XG4gICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICBpZiAobW92ZSA+IDAgfHwgaW50S2V5ID4gc3RhcnQpIHtcbiAgICAgICAgb2JqW2ludEtleSArIG1vdmVdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaGFydEV2ZW50fSBlXG4gKiBAcGFyYW0ge0NoYXJ0RXZlbnR8bnVsbH0gbGFzdEV2ZW50XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluQ2hhcnRBcmVhXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzQ2xpY2tcbiAqIEByZXR1cm5zIHtDaGFydEV2ZW50fG51bGx9XG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZUxhc3RFdmVudChlLCBsYXN0RXZlbnQsIGluQ2hhcnRBcmVhLCBpc0NsaWNrKSB7XG4gIGlmICghaW5DaGFydEFyZWEgfHwgZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGlzQ2xpY2spIHtcbiAgICByZXR1cm4gbGFzdEV2ZW50O1xuICB9XG4gIHJldHVybiBlO1xufVxuXG5mdW5jdGlvbiBnZXRTaXplRm9yQXJlYShzY2FsZSwgY2hhcnRBcmVhLCBmaWVsZCkge1xuICByZXR1cm4gc2NhbGUub3B0aW9ucy5jbGlwID8gc2NhbGVbZmllbGRdIDogY2hhcnRBcmVhW2ZpZWxkXTtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YXNldEFyZWEobWV0YSwgY2hhcnRBcmVhKSB7XG4gIGNvbnN0IHt4U2NhbGUsIHlTY2FsZX0gPSBtZXRhO1xuICBpZiAoeFNjYWxlICYmIHlTY2FsZSkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBnZXRTaXplRm9yQXJlYSh4U2NhbGUsIGNoYXJ0QXJlYSwgJ2xlZnQnKSxcbiAgICAgIHJpZ2h0OiBnZXRTaXplRm9yQXJlYSh4U2NhbGUsIGNoYXJ0QXJlYSwgJ3JpZ2h0JyksXG4gICAgICB0b3A6IGdldFNpemVGb3JBcmVhKHlTY2FsZSwgY2hhcnRBcmVhLCAndG9wJyksXG4gICAgICBib3R0b206IGdldFNpemVGb3JBcmVhKHlTY2FsZSwgY2hhcnRBcmVhLCAnYm90dG9tJylcbiAgICB9O1xuICB9XG4gIHJldHVybiBjaGFydEFyZWE7XG59XG5cbmNsYXNzIENoYXJ0IHtcblxuICBzdGF0aWMgZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgc3RhdGljIGluc3RhbmNlcyA9IGluc3RhbmNlcztcbiAgc3RhdGljIG92ZXJyaWRlcyA9IG92ZXJyaWRlcztcbiAgc3RhdGljIHJlZ2lzdHJ5ID0gcmVnaXN0cnk7XG4gIHN0YXRpYyB2ZXJzaW9uID0gdmVyc2lvbjtcbiAgc3RhdGljIGdldENoYXJ0ID0gZ2V0Q2hhcnQ7XG5cbiAgc3RhdGljIHJlZ2lzdGVyKC4uLml0ZW1zKSB7XG4gICAgcmVnaXN0cnkuYWRkKC4uLml0ZW1zKTtcbiAgICBpbnZhbGlkYXRlUGx1Z2lucygpO1xuICB9XG5cbiAgc3RhdGljIHVucmVnaXN0ZXIoLi4uaXRlbXMpIHtcbiAgICByZWdpc3RyeS5yZW1vdmUoLi4uaXRlbXMpO1xuICAgIGludmFsaWRhdGVQbHVnaW5zKCk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXN0YXRlbWVudHNcbiAgY29uc3RydWN0b3IoaXRlbSwgdXNlckNvbmZpZykge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnID0gbmV3IENvbmZpZyh1c2VyQ29uZmlnKTtcbiAgICBjb25zdCBpbml0aWFsQ2FudmFzID0gZ2V0Q2FudmFzKGl0ZW0pO1xuICAgIGNvbnN0IGV4aXN0aW5nQ2hhcnQgPSBnZXRDaGFydChpbml0aWFsQ2FudmFzKTtcbiAgICBpZiAoZXhpc3RpbmdDaGFydCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQ2FudmFzIGlzIGFscmVhZHkgaW4gdXNlLiBDaGFydCB3aXRoIElEIFxcJycgKyBleGlzdGluZ0NoYXJ0LmlkICsgJ1xcJycgK1xuXHRcdFx0XHQnIG11c3QgYmUgZGVzdHJveWVkIGJlZm9yZSB0aGUgY2FudmFzIHdpdGggSUQgXFwnJyArIGV4aXN0aW5nQ2hhcnQuY2FudmFzLmlkICsgJ1xcJyBjYW4gYmUgcmV1c2VkLidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihjb25maWcuY2hhcnRPcHRpb25TY29wZXMoKSwgdGhpcy5nZXRDb250ZXh0KCkpO1xuXG4gICAgdGhpcy5wbGF0Zm9ybSA9IG5ldyAoY29uZmlnLnBsYXRmb3JtIHx8IF9kZXRlY3RQbGF0Zm9ybShpbml0aWFsQ2FudmFzKSkoKTtcbiAgICB0aGlzLnBsYXRmb3JtLnVwZGF0ZUNvbmZpZyhjb25maWcpO1xuXG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMucGxhdGZvcm0uYWNxdWlyZUNvbnRleHQoaW5pdGlhbENhbnZhcywgb3B0aW9ucy5hc3BlY3RSYXRpbyk7XG4gICAgY29uc3QgY2FudmFzID0gY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcztcbiAgICBjb25zdCBoZWlnaHQgPSBjYW52YXMgJiYgY2FudmFzLmhlaWdodDtcbiAgICBjb25zdCB3aWR0aCA9IGNhbnZhcyAmJiBjYW52YXMud2lkdGg7XG5cbiAgICB0aGlzLmlkID0gdWlkKCk7XG4gICAgdGhpcy5jdHggPSBjb250ZXh0O1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICAvLyBTdG9yZSB0aGUgcHJldmlvdXNseSB1c2VkIGFzcGVjdCByYXRpbyB0byBkZXRlcm1pbmUgaWYgYSByZXNpemVcbiAgICAvLyBpcyBuZWVkZWQgZHVyaW5nIHVwZGF0ZXMuIERvIHRoaXMgYWZ0ZXIgX29wdGlvbnMgaXMgc2V0IHNpbmNlXG4gICAgLy8gYXNwZWN0UmF0aW8gdXNlcyBhIGdldHRlclxuICAgIHRoaXMuX2FzcGVjdFJhdGlvID0gdGhpcy5hc3BlY3RSYXRpbztcbiAgICB0aGlzLl9sYXllcnMgPSBbXTtcbiAgICB0aGlzLl9tZXRhc2V0cyA9IFtdO1xuICAgIHRoaXMuX3N0YWNrcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJveGVzID0gW107XG4gICAgdGhpcy5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNoYXJ0QXJlYSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9hY3RpdmUgPSBbXTtcbiAgICB0aGlzLl9sYXN0RXZlbnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgLyoqIEB0eXBlIHs/e2F0dGFjaD86IGZ1bmN0aW9uLCBkZXRhY2g/OiBmdW5jdGlvbiwgcmVzaXplPzogZnVuY3Rpb259fSAqL1xuICAgIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc29ydGVkTWV0YXNldHMgPSBbXTtcbiAgICB0aGlzLnNjYWxlcyA9IHt9O1xuICAgIHRoaXMuX3BsdWdpbnMgPSBuZXcgUGx1Z2luU2VydmljZSgpO1xuICAgIHRoaXMuJHByb3hpZXMgPSB7fTtcbiAgICB0aGlzLl9oaWRkZW5JbmRpY2VzID0ge307XG4gICAgdGhpcy5hdHRhY2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2FuaW1hdGlvbnNEaXNhYmxlZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RvUmVzaXplID0gZGVib3VuY2UobW9kZSA9PiB0aGlzLnVwZGF0ZShtb2RlKSwgb3B0aW9ucy5yZXNpemVEZWxheSB8fCAwKTtcbiAgICB0aGlzLl9kYXRhQ2hhbmdlcyA9IFtdO1xuXG4gICAgLy8gQWRkIHRoZSBjaGFydCBpbnN0YW5jZSB0byB0aGUgZ2xvYmFsIG5hbWVzcGFjZVxuICAgIGluc3RhbmNlc1t0aGlzLmlkXSA9IHRoaXM7XG5cbiAgICBpZiAoIWNvbnRleHQgfHwgIWNhbnZhcykge1xuICAgICAgLy8gVGhlIGdpdmVuIGl0ZW0gaXMgbm90IGEgY29tcGF0aWJsZSBjb250ZXh0MmQgZWxlbWVudCwgbGV0J3MgcmV0dXJuIGJlZm9yZSBmaW5hbGl6aW5nXG4gICAgICAvLyB0aGUgY2hhcnQgaW5pdGlhbGl6YXRpb24gYnV0IGFmdGVyIHNldHRpbmcgYmFzaWMgY2hhcnQgLyBjb250cm9sbGVyIHByb3BlcnRpZXMgdGhhdFxuICAgICAgLy8gY2FuIGhlbHAgdG8gZmlndXJlIG91dCB0aGF0IHRoZSBjaGFydCBpcyBub3QgdmFsaWQgKGUuZyBjaGFydC5jYW52YXMgIT09IG51bGwpO1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI4MDdcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIGNoYXJ0OiBjYW4ndCBhY3F1aXJlIGNvbnRleHQgZnJvbSB0aGUgZ2l2ZW4gaXRlbVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhbmltYXRvci5saXN0ZW4odGhpcywgJ2NvbXBsZXRlJywgb25BbmltYXRpb25zQ29tcGxldGUpO1xuICAgIGFuaW1hdG9yLmxpc3Rlbih0aGlzLCAncHJvZ3Jlc3MnLCBvbkFuaW1hdGlvblByb2dyZXNzKTtcblxuICAgIHRoaXMuX2luaXRpYWxpemUoKTtcbiAgICBpZiAodGhpcy5hdHRhY2hlZCkge1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gIH1cblxuICBnZXQgYXNwZWN0UmF0aW8oKSB7XG4gICAgY29uc3Qge29wdGlvbnM6IHthc3BlY3RSYXRpbywgbWFpbnRhaW5Bc3BlY3RSYXRpb30sIHdpZHRoLCBoZWlnaHQsIF9hc3BlY3RSYXRpb30gPSB0aGlzO1xuICAgIGlmICghaXNOdWxsT3JVbmRlZihhc3BlY3RSYXRpbykpIHtcbiAgICAgIC8vIElmIGFzcGVjdFJhdGlvIGlzIGRlZmluZWQgaW4gb3B0aW9ucywgdXNlIHRoYXQuXG4gICAgICByZXR1cm4gYXNwZWN0UmF0aW87XG4gICAgfVxuXG4gICAgaWYgKG1haW50YWluQXNwZWN0UmF0aW8gJiYgX2FzcGVjdFJhdGlvKSB7XG4gICAgICAvLyBJZiBtYWludGFpbkFzcGVjdFJhdGlvIGlzIHRydXRobHkgYW5kIHdlIGhhZCBwcmV2aW91c2x5IGRldGVybWluZWQgX2FzcGVjdFJhdGlvLCB1c2UgdGhhdFxuICAgICAgcmV0dXJuIF9hc3BlY3RSYXRpbztcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGVcbiAgICByZXR1cm4gaGVpZ2h0ID8gd2lkdGggLyBoZWlnaHQgOiBudWxsO1xuICB9XG5cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmRhdGE7XG4gIH1cblxuICBzZXQgZGF0YShkYXRhKSB7XG4gICAgdGhpcy5jb25maWcuZGF0YSA9IGRhdGE7XG4gIH1cblxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgfVxuXG4gIHNldCBvcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLmNvbmZpZy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIGdldCByZWdpc3RyeSgpIHtcbiAgICByZXR1cm4gcmVnaXN0cnk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9pbml0aWFsaXplKCkge1xuICAgIC8vIEJlZm9yZSBpbml0IHBsdWdpbiBub3RpZmljYXRpb25cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUluaXQnKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0aW5hU2NhbGUodGhpcywgdGhpcy5vcHRpb25zLmRldmljZVBpeGVsUmF0aW8pO1xuICAgIH1cblxuICAgIHRoaXMuYmluZEV2ZW50cygpO1xuXG4gICAgLy8gQWZ0ZXIgaW5pdCBwbHVnaW4gbm90aWZpY2F0aW9uXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckluaXQnKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgY2xlYXJDYW52YXModGhpcy5jYW52YXMsIHRoaXMuY3R4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgYW5pbWF0b3Iuc3RvcCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXNpemUgdGhlIGNoYXJ0IHRvIGl0cyBjb250YWluZXIgb3IgdG8gZXhwbGljaXQgZGltZW5zaW9ucy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF1cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHRdXG5cdCAqL1xuICByZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGlmICghYW5pbWF0b3IucnVubmluZyh0aGlzKSkge1xuICAgICAgdGhpcy5fcmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXNpemVCZWZvcmVEcmF3ID0ge3dpZHRoLCBoZWlnaHR9O1xuICAgIH1cbiAgfVxuXG4gIF9yZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgY29uc3QgYXNwZWN0UmF0aW8gPSBvcHRpb25zLm1haW50YWluQXNwZWN0UmF0aW8gJiYgdGhpcy5hc3BlY3RSYXRpbztcbiAgICBjb25zdCBuZXdTaXplID0gdGhpcy5wbGF0Zm9ybS5nZXRNYXhpbXVtU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKTtcbiAgICBjb25zdCBuZXdSYXRpbyA9IG9wdGlvbnMuZGV2aWNlUGl4ZWxSYXRpbyB8fCB0aGlzLnBsYXRmb3JtLmdldERldmljZVBpeGVsUmF0aW8oKTtcbiAgICBjb25zdCBtb2RlID0gdGhpcy53aWR0aCA/ICdyZXNpemUnIDogJ2F0dGFjaCc7XG5cbiAgICB0aGlzLndpZHRoID0gbmV3U2l6ZS53aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IG5ld1NpemUuaGVpZ2h0O1xuICAgIHRoaXMuX2FzcGVjdFJhdGlvID0gdGhpcy5hc3BlY3RSYXRpbztcbiAgICBpZiAoIXJldGluYVNjYWxlKHRoaXMsIG5ld1JhdGlvLCB0cnVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygncmVzaXplJywge3NpemU6IG5ld1NpemV9KTtcblxuICAgIGNhbGxDYWxsYmFjayhvcHRpb25zLm9uUmVzaXplLCBbdGhpcywgbmV3U2l6ZV0sIHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuYXR0YWNoZWQpIHtcbiAgICAgIGlmICh0aGlzLl9kb1Jlc2l6ZShtb2RlKSkge1xuICAgICAgICAvLyBUaGUgcmVzaXplIHVwZGF0ZSBpcyBkZWxheWVkLCBvbmx5IGRyYXcgd2l0aG91dCB1cGRhdGluZy5cbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlbnN1cmVTY2FsZXNIYXZlSURzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgc2NhbGVzT3B0aW9ucyA9IG9wdGlvbnMuc2NhbGVzIHx8IHt9O1xuXG4gICAgZWFjaChzY2FsZXNPcHRpb25zLCAoYXhpc09wdGlvbnMsIGF4aXNJRCkgPT4ge1xuICAgICAgYXhpc09wdGlvbnMuaWQgPSBheGlzSUQ7XG4gICAgfSk7XG4gIH1cblxuICAvKipcblx0ICogQnVpbGRzIGEgbWFwIG9mIHNjYWxlIElEIHRvIHNjYWxlIG9iamVjdCBmb3IgZnV0dXJlIGxvb2t1cC5cblx0ICovXG4gIGJ1aWxkT3JVcGRhdGVTY2FsZXMoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBzY2FsZU9wdHMgPSBvcHRpb25zLnNjYWxlcztcbiAgICBjb25zdCBzY2FsZXMgPSB0aGlzLnNjYWxlcztcbiAgICBjb25zdCB1cGRhdGVkID0gT2JqZWN0LmtleXMoc2NhbGVzKS5yZWR1Y2UoKG9iaiwgaWQpID0+IHtcbiAgICAgIG9ialtpZF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSwge30pO1xuICAgIGxldCBpdGVtcyA9IFtdO1xuXG4gICAgaWYgKHNjYWxlT3B0cykge1xuICAgICAgaXRlbXMgPSBpdGVtcy5jb25jYXQoXG4gICAgICAgIE9iamVjdC5rZXlzKHNjYWxlT3B0cykubWFwKChpZCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHNjYWxlT3B0aW9ucyA9IHNjYWxlT3B0c1tpZF07XG4gICAgICAgICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlT3B0aW9ucyk7XG4gICAgICAgICAgY29uc3QgaXNSYWRpYWwgPSBheGlzID09PSAncic7XG4gICAgICAgICAgY29uc3QgaXNIb3Jpem9udGFsID0gYXhpcyA9PT0gJ3gnO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcHRpb25zOiBzY2FsZU9wdGlvbnMsXG4gICAgICAgICAgICBkcG9zaXRpb246IGlzUmFkaWFsID8gJ2NoYXJ0QXJlYScgOiBpc0hvcml6b250YWwgPyAnYm90dG9tJyA6ICdsZWZ0JyxcbiAgICAgICAgICAgIGR0eXBlOiBpc1JhZGlhbCA/ICdyYWRpYWxMaW5lYXInIDogaXNIb3Jpem9udGFsID8gJ2NhdGVnb3J5JyA6ICdsaW5lYXInXG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZWFjaChpdGVtcywgKGl0ZW0pID0+IHtcbiAgICAgIGNvbnN0IHNjYWxlT3B0aW9ucyA9IGl0ZW0ub3B0aW9ucztcbiAgICAgIGNvbnN0IGlkID0gc2NhbGVPcHRpb25zLmlkO1xuICAgICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlT3B0aW9ucyk7XG4gICAgICBjb25zdCBzY2FsZVR5cGUgPSB2YWx1ZU9yRGVmYXVsdChzY2FsZU9wdGlvbnMudHlwZSwgaXRlbS5kdHlwZSk7XG5cbiAgICAgIGlmIChzY2FsZU9wdGlvbnMucG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbklzSG9yaXpvbnRhbChzY2FsZU9wdGlvbnMucG9zaXRpb24sIGF4aXMpICE9PSBwb3NpdGlvbklzSG9yaXpvbnRhbChpdGVtLmRwb3NpdGlvbikpIHtcbiAgICAgICAgc2NhbGVPcHRpb25zLnBvc2l0aW9uID0gaXRlbS5kcG9zaXRpb247XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZWRbaWRdID0gdHJ1ZTtcbiAgICAgIGxldCBzY2FsZSA9IG51bGw7XG4gICAgICBpZiAoaWQgaW4gc2NhbGVzICYmIHNjYWxlc1tpZF0udHlwZSA9PT0gc2NhbGVUeXBlKSB7XG4gICAgICAgIHNjYWxlID0gc2NhbGVzW2lkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNjYWxlQ2xhc3MgPSByZWdpc3RyeS5nZXRTY2FsZShzY2FsZVR5cGUpO1xuICAgICAgICBzY2FsZSA9IG5ldyBzY2FsZUNsYXNzKHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICB0eXBlOiBzY2FsZVR5cGUsXG4gICAgICAgICAgY3R4OiB0aGlzLmN0eCxcbiAgICAgICAgICBjaGFydDogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgc2NhbGVzW3NjYWxlLmlkXSA9IHNjYWxlO1xuICAgICAgfVxuXG4gICAgICBzY2FsZS5pbml0KHNjYWxlT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgfSk7XG4gICAgLy8gY2xlYXIgdXAgZGlzY2FyZGVkIHNjYWxlc1xuICAgIGVhY2godXBkYXRlZCwgKGhhc1VwZGF0ZWQsIGlkKSA9PiB7XG4gICAgICBpZiAoIWhhc1VwZGF0ZWQpIHtcbiAgICAgICAgZGVsZXRlIHNjYWxlc1tpZF07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBlYWNoKHNjYWxlcywgKHNjYWxlKSA9PiB7XG4gICAgICBsYXlvdXRzLmNvbmZpZ3VyZSh0aGlzLCBzY2FsZSwgc2NhbGUub3B0aW9ucyk7XG4gICAgICBsYXlvdXRzLmFkZEJveCh0aGlzLCBzY2FsZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVNZXRhc2V0cygpIHtcbiAgICBjb25zdCBtZXRhc2V0cyA9IHRoaXMuX21ldGFzZXRzO1xuICAgIGNvbnN0IG51bURhdGEgPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoO1xuICAgIGNvbnN0IG51bU1ldGEgPSBtZXRhc2V0cy5sZW5ndGg7XG5cbiAgICBtZXRhc2V0cy5zb3J0KChhLCBiKSA9PiBhLmluZGV4IC0gYi5pbmRleCk7XG4gICAgaWYgKG51bU1ldGEgPiBudW1EYXRhKSB7XG4gICAgICBmb3IgKGxldCBpID0gbnVtRGF0YTsgaSA8IG51bU1ldGE7ICsraSkge1xuICAgICAgICB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEoaSk7XG4gICAgICB9XG4gICAgICBtZXRhc2V0cy5zcGxpY2UobnVtRGF0YSwgbnVtTWV0YSAtIG51bURhdGEpO1xuICAgIH1cbiAgICB0aGlzLl9zb3J0ZWRNZXRhc2V0cyA9IG1ldGFzZXRzLnNsaWNlKDApLnNvcnQoY29tcGFyZTJMZXZlbCgnb3JkZXInLCAnaW5kZXgnKSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9yZW1vdmVVbnJlZmVyZW5jZWRNZXRhc2V0cygpIHtcbiAgICBjb25zdCB7X21ldGFzZXRzOiBtZXRhc2V0cywgZGF0YToge2RhdGFzZXRzfX0gPSB0aGlzO1xuICAgIGlmIChtZXRhc2V0cy5sZW5ndGggPiBkYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9zdGFja3M7XG4gICAgfVxuICAgIG1ldGFzZXRzLmZvckVhY2goKG1ldGEsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoZGF0YXNldHMuZmlsdGVyKHggPT4geCA9PT0gbWV0YS5fZGF0YXNldCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpbmRleCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBidWlsZE9yVXBkYXRlQ29udHJvbGxlcnMoKSB7XG4gICAgY29uc3QgbmV3Q29udHJvbGxlcnMgPSBbXTtcbiAgICBjb25zdCBkYXRhc2V0cyA9IHRoaXMuZGF0YS5kYXRhc2V0cztcbiAgICBsZXQgaSwgaWxlbjtcblxuICAgIHRoaXMuX3JlbW92ZVVucmVmZXJlbmNlZE1ldGFzZXRzKCk7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBkYXRhc2V0ID0gZGF0YXNldHNbaV07XG4gICAgICBsZXQgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICBjb25zdCB0eXBlID0gZGF0YXNldC50eXBlIHx8IHRoaXMuY29uZmlnLnR5cGU7XG5cbiAgICAgIGlmIChtZXRhLnR5cGUgJiYgbWV0YS50eXBlICE9PSB0eXBlKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpKTtcbiAgICAgICAgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICB9XG4gICAgICBtZXRhLnR5cGUgPSB0eXBlO1xuICAgICAgbWV0YS5pbmRleEF4aXMgPSBkYXRhc2V0LmluZGV4QXhpcyB8fCBnZXRJbmRleEF4aXModHlwZSwgdGhpcy5vcHRpb25zKTtcbiAgICAgIG1ldGEub3JkZXIgPSBkYXRhc2V0Lm9yZGVyIHx8IDA7XG4gICAgICBtZXRhLmluZGV4ID0gaTtcbiAgICAgIG1ldGEubGFiZWwgPSAnJyArIGRhdGFzZXQubGFiZWw7XG4gICAgICBtZXRhLnZpc2libGUgPSB0aGlzLmlzRGF0YXNldFZpc2libGUoaSk7XG5cbiAgICAgIGlmIChtZXRhLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgbWV0YS5jb250cm9sbGVyLnVwZGF0ZUluZGV4KGkpO1xuICAgICAgICBtZXRhLmNvbnRyb2xsZXIubGlua1NjYWxlcygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgQ29udHJvbGxlckNsYXNzID0gcmVnaXN0cnkuZ2V0Q29udHJvbGxlcih0eXBlKTtcbiAgICAgICAgY29uc3Qge2RhdGFzZXRFbGVtZW50VHlwZSwgZGF0YUVsZW1lbnRUeXBlfSA9IGRlZmF1bHRzLmRhdGFzZXRzW3R5cGVdO1xuICAgICAgICBPYmplY3QuYXNzaWduKENvbnRyb2xsZXJDbGFzcywge1xuICAgICAgICAgIGRhdGFFbGVtZW50VHlwZTogcmVnaXN0cnkuZ2V0RWxlbWVudChkYXRhRWxlbWVudFR5cGUpLFxuICAgICAgICAgIGRhdGFzZXRFbGVtZW50VHlwZTogZGF0YXNldEVsZW1lbnRUeXBlICYmIHJlZ2lzdHJ5LmdldEVsZW1lbnQoZGF0YXNldEVsZW1lbnRUeXBlKVxuICAgICAgICB9KTtcbiAgICAgICAgbWV0YS5jb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXJDbGFzcyh0aGlzLCBpKTtcbiAgICAgICAgbmV3Q29udHJvbGxlcnMucHVzaChtZXRhLmNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZU1ldGFzZXRzKCk7XG4gICAgcmV0dXJuIG5ld0NvbnRyb2xsZXJzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJlc2V0IHRoZSBlbGVtZW50cyBvZiBhbGwgZGF0YXNldHNcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9yZXNldEVsZW1lbnRzKCkge1xuICAgIGVhY2godGhpcy5kYXRhLmRhdGFzZXRzLCAoZGF0YXNldCwgZGF0YXNldEluZGV4KSA9PiB7XG4gICAgICB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlci5yZXNldCgpO1xuICAgIH0sIHRoaXMpO1xuICB9XG5cbiAgLyoqXG5cdCogUmVzZXRzIHRoZSBjaGFydCBiYWNrIHRvIGl0cyBzdGF0ZSBiZWZvcmUgdGhlIGluaXRpYWwgYW5pbWF0aW9uXG5cdCovXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3Jlc2V0RWxlbWVudHMoKTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ3Jlc2V0Jyk7XG4gIH1cblxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuXG4gICAgY29uZmlnLnVwZGF0ZSgpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKGNvbmZpZy5jaGFydE9wdGlvblNjb3BlcygpLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3QgYW5pbXNEaXNhYmxlZCA9IHRoaXMuX2FuaW1hdGlvbnNEaXNhYmxlZCA9ICFvcHRpb25zLmFuaW1hdGlvbjtcblxuICAgIHRoaXMuX3VwZGF0ZVNjYWxlcygpO1xuICAgIHRoaXMuX2NoZWNrRXZlbnRCaW5kaW5ncygpO1xuICAgIHRoaXMuX3VwZGF0ZUhpZGRlbkluZGljZXMoKTtcblxuICAgIC8vIHBsdWdpbnMgb3B0aW9ucyByZWZlcmVuY2VzIG1pZ2h0IGhhdmUgY2hhbmdlLCBsZXQncyBpbnZhbGlkYXRlIHRoZSBjYWNoZVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81MTExI2lzc3VlY29tbWVudC0zNTU5MzQxNjdcbiAgICB0aGlzLl9wbHVnaW5zLmludmFsaWRhdGUoKTtcblxuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZVVwZGF0ZScsIHttb2RlLCBjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIGRhdGFzZXQgY29udHJvbGxlcnMgYXJlIHVwZGF0ZWQgYW5kIG5ldyBjb250cm9sbGVycyBhcmUgcmVzZXRcbiAgICBjb25zdCBuZXdDb250cm9sbGVycyA9IHRoaXMuYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzKCk7XG5cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUVsZW1lbnRzVXBkYXRlJyk7XG5cbiAgICAvLyBNYWtlIHN1cmUgYWxsIGRhdGFzZXQgY29udHJvbGxlcnMgaGF2ZSBjb3JyZWN0IG1ldGEgZGF0YSBjb3VudHNcbiAgICBsZXQgbWluUGFkZGluZyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBjb25zdCB7Y29udHJvbGxlcn0gPSB0aGlzLmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgY29uc3QgcmVzZXQgPSAhYW5pbXNEaXNhYmxlZCAmJiBuZXdDb250cm9sbGVycy5pbmRleE9mKGNvbnRyb2xsZXIpID09PSAtMTtcbiAgICAgIC8vIE5ldyBjb250cm9sbGVycyB3aWxsIGJlIHJlc2V0IGFmdGVyIHRoZSBsYXlvdXQgcGFzcywgc28gd2Ugb25seSB3YW50IHRvIG1vZGlmeVxuICAgICAgLy8gZWxlbWVudHMgYWRkZWQgdG8gbmV3IGRhdGFzZXRzXG4gICAgICBjb250cm9sbGVyLmJ1aWxkT3JVcGRhdGVFbGVtZW50cyhyZXNldCk7XG4gICAgICBtaW5QYWRkaW5nID0gTWF0aC5tYXgoK2NvbnRyb2xsZXIuZ2V0TWF4T3ZlcmZsb3coKSwgbWluUGFkZGluZyk7XG4gICAgfVxuICAgIG1pblBhZGRpbmcgPSB0aGlzLl9taW5QYWRkaW5nID0gb3B0aW9ucy5sYXlvdXQuYXV0b1BhZGRpbmcgPyBtaW5QYWRkaW5nIDogMDtcbiAgICB0aGlzLl91cGRhdGVMYXlvdXQobWluUGFkZGluZyk7XG5cbiAgICAvLyBPbmx5IHJlc2V0IHRoZSBjb250cm9sbGVycyBpZiB3ZSBoYXZlIGFuaW1hdGlvbnNcbiAgICBpZiAoIWFuaW1zRGlzYWJsZWQpIHtcbiAgICAgIC8vIENhbiBvbmx5IHJlc2V0IHRoZSBuZXcgY29udHJvbGxlcnMgYWZ0ZXIgdGhlIHNjYWxlcyBoYXZlIGJlZW4gdXBkYXRlZFxuICAgICAgLy8gUmVzZXQgaXMgZG9uZSB0byBnZXQgdGhlIHN0YXJ0aW5nIHBvaW50IGZvciB0aGUgaW5pdGlhbCBhbmltYXRpb25cbiAgICAgIGVhY2gobmV3Q29udHJvbGxlcnMsIChjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIucmVzZXQoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZURhdGFzZXRzKG1vZGUpO1xuXG4gICAgLy8gRG8gdGhpcyBiZWZvcmUgcmVuZGVyIHNvIHRoYXQgYW55IHBsdWdpbnMgdGhhdCBuZWVkIGZpbmFsIHNjYWxlIHVwZGF0ZXMgY2FuIHVzZSBpdFxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJVcGRhdGUnLCB7bW9kZX0pO1xuXG4gICAgdGhpcy5fbGF5ZXJzLnNvcnQoY29tcGFyZTJMZXZlbCgneicsICdfaWR4JykpO1xuXG4gICAgLy8gUmVwbGF5IGxhc3QgZXZlbnQgZnJvbSBiZWZvcmUgdXBkYXRlLCBvciBzZXQgaG92ZXIgc3R5bGVzIG9uIGFjdGl2ZSBlbGVtZW50c1xuICAgIGNvbnN0IHtfYWN0aXZlLCBfbGFzdEV2ZW50fSA9IHRoaXM7XG4gICAgaWYgKF9sYXN0RXZlbnQpIHtcbiAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcihfbGFzdEV2ZW50LCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKF9hY3RpdmUubGVuZ3RoKSB7XG4gICAgICB0aGlzLl91cGRhdGVIb3ZlclN0eWxlcyhfYWN0aXZlLCBfYWN0aXZlLCB0cnVlKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlU2NhbGVzKCkge1xuICAgIGVhY2godGhpcy5zY2FsZXMsIChzY2FsZSkgPT4ge1xuICAgICAgbGF5b3V0cy5yZW1vdmVCb3godGhpcywgc2NhbGUpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5lbnN1cmVTY2FsZXNIYXZlSURzKCk7XG4gICAgdGhpcy5idWlsZE9yVXBkYXRlU2NhbGVzKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jaGVja0V2ZW50QmluZGluZ3MoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBleGlzdGluZ0V2ZW50cyA9IG5ldyBTZXQoT2JqZWN0LmtleXModGhpcy5fbGlzdGVuZXJzKSk7XG4gICAgY29uc3QgbmV3RXZlbnRzID0gbmV3IFNldChvcHRpb25zLmV2ZW50cyk7XG5cbiAgICBpZiAoIXNldHNFcXVhbChleGlzdGluZ0V2ZW50cywgbmV3RXZlbnRzKSB8fCAhIXRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgIT09IG9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgLy8gVGhlIGNvbmZpZ3VyZWQgZXZlbnRzIGhhdmUgY2hhbmdlZC4gUmViaW5kLlxuICAgICAgdGhpcy51bmJpbmRFdmVudHMoKTtcbiAgICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZUhpZGRlbkluZGljZXMoKSB7XG4gICAgY29uc3Qge19oaWRkZW5JbmRpY2VzfSA9IHRoaXM7XG4gICAgY29uc3QgY2hhbmdlcyA9IHRoaXMuX2dldFVuaWZvcm1EYXRhQ2hhbmdlcygpIHx8IFtdO1xuICAgIGZvciAoY29uc3Qge21ldGhvZCwgc3RhcnQsIGNvdW50fSBvZiBjaGFuZ2VzKSB7XG4gICAgICBjb25zdCBtb3ZlID0gbWV0aG9kID09PSAnX3JlbW92ZUVsZW1lbnRzJyA/IC1jb3VudCA6IGNvdW50O1xuICAgICAgbW92ZU51bWVyaWNLZXlzKF9oaWRkZW5JbmRpY2VzLCBzdGFydCwgbW92ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0VW5pZm9ybURhdGFDaGFuZ2VzKCkge1xuICAgIGNvbnN0IF9kYXRhQ2hhbmdlcyA9IHRoaXMuX2RhdGFDaGFuZ2VzO1xuICAgIGlmICghX2RhdGFDaGFuZ2VzIHx8ICFfZGF0YUNoYW5nZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fZGF0YUNoYW5nZXMgPSBbXTtcbiAgICBjb25zdCBkYXRhc2V0Q291bnQgPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoO1xuICAgIGNvbnN0IG1ha2VTZXQgPSAoaWR4KSA9PiBuZXcgU2V0KFxuICAgICAgX2RhdGFDaGFuZ2VzXG4gICAgICAgIC5maWx0ZXIoYyA9PiBjWzBdID09PSBpZHgpXG4gICAgICAgIC5tYXAoKGMsIGkpID0+IGkgKyAnLCcgKyBjLnNwbGljZSgxKS5qb2luKCcsJykpXG4gICAgKTtcblxuICAgIGNvbnN0IGNoYW5nZVNldCA9IG1ha2VTZXQoMCk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBkYXRhc2V0Q291bnQ7IGkrKykge1xuICAgICAgaWYgKCFzZXRzRXF1YWwoY2hhbmdlU2V0LCBtYWtlU2V0KGkpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKGNoYW5nZVNldClcbiAgICAgIC5tYXAoYyA9PiBjLnNwbGl0KCcsJykpXG4gICAgICAubWFwKGEgPT4gKHttZXRob2Q6IGFbMV0sIHN0YXJ0OiArYVsyXSwgY291bnQ6ICthWzNdfSkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFVwZGF0ZXMgdGhlIGNoYXJ0IGxheW91dCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlTGF5b3V0YFxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJMYXlvdXRgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZUxheW91dChtaW5QYWRkaW5nKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlTGF5b3V0Jywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsYXlvdXRzLnVwZGF0ZSh0aGlzLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgbWluUGFkZGluZyk7XG5cbiAgICBjb25zdCBhcmVhID0gdGhpcy5jaGFydEFyZWE7XG4gICAgY29uc3Qgbm9BcmVhID0gYXJlYS53aWR0aCA8PSAwIHx8IGFyZWEuaGVpZ2h0IDw9IDA7XG5cbiAgICB0aGlzLl9sYXllcnMgPSBbXTtcbiAgICBlYWNoKHRoaXMuYm94ZXMsIChib3gpID0+IHtcbiAgICAgIGlmIChub0FyZWEgJiYgYm94LnBvc2l0aW9uID09PSAnY2hhcnRBcmVhJykge1xuICAgICAgICAvLyBTa2lwIGRyYXdpbmcgYW5kIGNvbmZpZ3VyaW5nIGNoYXJ0QXJlYSBib3hlcyB3aGVuIGNoYXJ0QXJlYSBpcyB6ZXJvIG9yIG5lZ2F0aXZlXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gY29uZmlndXJlIGlzIGNhbGxlZCB0d2ljZSwgb25jZSBpbiBjb3JlLnNjYWxlLnVwZGF0ZSBhbmQgb25jZSBoZXJlLlxuICAgICAgLy8gSGVyZSB0aGUgYm94ZXMgYXJlIGZ1bGx5IHVwZGF0ZWQgYW5kIGF0IHRoZWlyIGZpbmFsIHBvc2l0aW9ucy5cbiAgICAgIGlmIChib3guY29uZmlndXJlKSB7XG4gICAgICAgIGJveC5jb25maWd1cmUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2xheWVycy5wdXNoKC4uLmJveC5fbGF5ZXJzKCkpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5fbGF5ZXJzLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICBpdGVtLl9pZHggPSBpbmRleDtcbiAgICB9KTtcblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJMYXlvdXQnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVcGRhdGVzIGFsbCBkYXRhc2V0cyB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldHNVcGRhdGVgXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckRhdGFzZXRzVXBkYXRlYC5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVEYXRhc2V0cyhtb2RlKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldHNVcGRhdGUnLCB7bW9kZSwgY2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGhpcy5nZXREYXRhc2V0TWV0YShpKS5jb250cm9sbGVyLmNvbmZpZ3VyZSgpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGhpcy5fdXBkYXRlRGF0YXNldChpLCBpc0Z1bmN0aW9uKG1vZGUpID8gbW9kZSh7ZGF0YXNldEluZGV4OiBpfSkgOiBtb2RlKTtcbiAgICB9XG5cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldHNVcGRhdGUnLCB7bW9kZX0pO1xuICB9XG5cbiAgLyoqXG5cdCAqIFVwZGF0ZXMgZGF0YXNldCBhdCBpbmRleCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldFVwZGF0ZWBcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldFVwZGF0ZWAuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlRGF0YXNldChpbmRleCwgbW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGluZGV4KTtcbiAgICBjb25zdCBhcmdzID0ge21ldGEsIGluZGV4LCBtb2RlLCBjYW5jZWxhYmxlOiB0cnVlfTtcblxuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXRVcGRhdGUnLCBhcmdzKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBtZXRhLmNvbnRyb2xsZXIuX3VwZGF0ZShtb2RlKTtcblxuICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0VXBkYXRlJywgYXJncyk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlUmVuZGVyJywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYW5pbWF0b3IuaGFzKHRoaXMpKSB7XG4gICAgICBpZiAodGhpcy5hdHRhY2hlZCAmJiAhYW5pbWF0b3IucnVubmluZyh0aGlzKSkge1xuICAgICAgICBhbmltYXRvci5zdGFydCh0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kcmF3KCk7XG4gICAgICBvbkFuaW1hdGlvbnNDb21wbGV0ZSh7Y2hhcnQ6IHRoaXN9KTtcbiAgICB9XG4gIH1cblxuICBkcmF3KCkge1xuICAgIGxldCBpO1xuICAgIGlmICh0aGlzLl9yZXNpemVCZWZvcmVEcmF3KSB7XG4gICAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0aGlzLl9yZXNpemVCZWZvcmVEcmF3O1xuICAgICAgdGhpcy5fcmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5fcmVzaXplQmVmb3JlRHJhdyA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuY2xlYXIoKTtcblxuICAgIGlmICh0aGlzLndpZHRoIDw9IDAgfHwgdGhpcy5oZWlnaHQgPD0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURyYXcnLCB7Y2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEJlY2F1c2Ugb2YgcGx1Z2luIGhvb2tzIChiZWZvcmUvYWZ0ZXJEYXRhc2V0c0RyYXcpLCBkYXRhc2V0cyBjYW4ndFxuICAgIC8vIGN1cnJlbnRseSBiZSBwYXJ0IG9mIGxheWVycy4gSW5zdGVhZCwgd2UgZHJhd1xuICAgIC8vIGxheWVycyA8PSAwIGJlZm9yZShkZWZhdWx0LCBiYWNrd2FyZCBjb21wYXQpLCBhbmQgdGhlIHJlc3QgYWZ0ZXJcbiAgICBjb25zdCBsYXllcnMgPSB0aGlzLl9sYXllcnM7XG4gICAgZm9yIChpID0gMDsgaSA8IGxheWVycy5sZW5ndGggJiYgbGF5ZXJzW2ldLnogPD0gMDsgKytpKSB7XG4gICAgICBsYXllcnNbaV0uZHJhdyh0aGlzLmNoYXJ0QXJlYSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZHJhd0RhdGFzZXRzKCk7XG5cbiAgICAvLyBSZXN0IG9mIGxheWVyc1xuICAgIGZvciAoOyBpIDwgbGF5ZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICBsYXllcnNbaV0uZHJhdyh0aGlzLmNoYXJ0QXJlYSk7XG4gICAgfVxuXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRyYXcnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFNvcnRlZERhdGFzZXRNZXRhcyhmaWx0ZXJWaXNpYmxlKSB7XG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLl9zb3J0ZWRNZXRhc2V0cztcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgaSwgaWxlbjtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IG1ldGEgPSBtZXRhc2V0c1tpXTtcbiAgICAgIGlmICghZmlsdGVyVmlzaWJsZSB8fCBtZXRhLnZpc2libGUpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobWV0YSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXRzIHRoZSB2aXNpYmxlIGRhdGFzZXQgbWV0YXMgaW4gZHJhd2luZyBvcmRlclxuXHQgKiBAcmV0dXJuIHtvYmplY3RbXX1cblx0ICovXG4gIGdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFNvcnRlZERhdGFzZXRNZXRhcyh0cnVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBEcmF3cyBhbGwgZGF0YXNldHMgdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZURhdGFzZXRzRHJhd2Bcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldHNEcmF3YC5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kcmF3RGF0YXNldHMoKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldHNEcmF3Jywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBtZXRhc2V0cyA9IHRoaXMuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGZvciAobGV0IGkgPSBtZXRhc2V0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGhpcy5fZHJhd0RhdGFzZXQobWV0YXNldHNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0c0RyYXcnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBEcmF3cyBkYXRhc2V0IGF0IGluZGV4IHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVEYXRhc2V0RHJhd2Bcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldERyYXdgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2RyYXdEYXRhc2V0KG1ldGEpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBjbGlwID0gbWV0YS5fY2xpcDtcbiAgICBjb25zdCB1c2VDbGlwID0gIWNsaXAuZGlzYWJsZWQ7XG4gICAgY29uc3QgYXJlYSA9IGdldERhdGFzZXRBcmVhKG1ldGEsIHRoaXMuY2hhcnRBcmVhKTtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgbWV0YSxcbiAgICAgIGluZGV4OiBtZXRhLmluZGV4LFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgIH07XG5cbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0RHJhdycsIGFyZ3MpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh1c2VDbGlwKSB7XG4gICAgICBjbGlwQXJlYShjdHgsIHtcbiAgICAgICAgbGVmdDogY2xpcC5sZWZ0ID09PSBmYWxzZSA/IDAgOiBhcmVhLmxlZnQgLSBjbGlwLmxlZnQsXG4gICAgICAgIHJpZ2h0OiBjbGlwLnJpZ2h0ID09PSBmYWxzZSA/IHRoaXMud2lkdGggOiBhcmVhLnJpZ2h0ICsgY2xpcC5yaWdodCxcbiAgICAgICAgdG9wOiBjbGlwLnRvcCA9PT0gZmFsc2UgPyAwIDogYXJlYS50b3AgLSBjbGlwLnRvcCxcbiAgICAgICAgYm90dG9tOiBjbGlwLmJvdHRvbSA9PT0gZmFsc2UgPyB0aGlzLmhlaWdodCA6IGFyZWEuYm90dG9tICsgY2xpcC5ib3R0b21cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIG1ldGEuY29udHJvbGxlci5kcmF3KCk7XG5cbiAgICBpZiAodXNlQ2xpcCkge1xuICAgICAgdW5jbGlwQXJlYShjdHgpO1xuICAgIH1cblxuICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0RHJhdycsIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBwb2ludCBpcyBpbiB0aGUgY2hhcnQgYXJlYS5cbiAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSBpbiByZWxhdGl2ZSBjb29yZGluYXRlcyAoc2VlLCBlLmcuLCBnZXRSZWxhdGl2ZVBvc2l0aW9uKVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGlzUG9pbnRJbkFyZWEocG9pbnQpIHtcbiAgICByZXR1cm4gX2lzUG9pbnRJbkFyZWEocG9pbnQsIHRoaXMuY2hhcnRBcmVhLCB0aGlzLl9taW5QYWRkaW5nKTtcbiAgfVxuXG4gIGdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgbW9kZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IG1ldGhvZCA9IEludGVyYWN0aW9uLm1vZGVzW21vZGVdO1xuICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbWV0aG9kKHRoaXMsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgICBjb25zdCBtZXRhc2V0cyA9IHRoaXMuX21ldGFzZXRzO1xuICAgIGxldCBtZXRhID0gbWV0YXNldHMuZmlsdGVyKHggPT4geCAmJiB4Ll9kYXRhc2V0ID09PSBkYXRhc2V0KS5wb3AoKTtcblxuICAgIGlmICghbWV0YSkge1xuICAgICAgbWV0YSA9IHtcbiAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgZGF0YTogW10sXG4gICAgICAgIGRhdGFzZXQ6IG51bGwsXG4gICAgICAgIGNvbnRyb2xsZXI6IG51bGwsXG4gICAgICAgIGhpZGRlbjogbnVsbCxcdFx0XHQvLyBTZWUgaXNEYXRhc2V0VmlzaWJsZSgpIGNvbW1lbnRcbiAgICAgICAgeEF4aXNJRDogbnVsbCxcbiAgICAgICAgeUF4aXNJRDogbnVsbCxcbiAgICAgICAgb3JkZXI6IGRhdGFzZXQgJiYgZGF0YXNldC5vcmRlciB8fCAwLFxuICAgICAgICBpbmRleDogZGF0YXNldEluZGV4LFxuICAgICAgICBfZGF0YXNldDogZGF0YXNldCxcbiAgICAgICAgX3BhcnNlZDogW10sXG4gICAgICAgIF9zb3J0ZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgICAgbWV0YXNldHMucHVzaChtZXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWV0YTtcbiAgfVxuXG4gIGdldENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQgfHwgKHRoaXMuJGNvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwsIHtjaGFydDogdGhpcywgdHlwZTogJ2NoYXJ0J30pKTtcbiAgfVxuXG4gIGdldFZpc2libGVEYXRhc2V0Q291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpLmxlbmd0aDtcbiAgfVxuXG4gIGlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuICAgIGlmICghZGF0YXNldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cbiAgICAvLyBtZXRhLmhpZGRlbiBpcyBhIHBlciBjaGFydCBkYXRhc2V0IGhpZGRlbiBmbGFnIG92ZXJyaWRlIHdpdGggMyBzdGF0ZXM6IGlmIHRydWUgb3IgZmFsc2UsXG4gICAgLy8gdGhlIGRhdGFzZXQuaGlkZGVuIHZhbHVlIGlzIGlnbm9yZWQsIGVsc2UgaWYgbnVsbCwgdGhlIGRhdGFzZXQgaGlkZGVuIHN0YXRlIGlzIHJldHVybmVkLlxuICAgIHJldHVybiB0eXBlb2YgbWV0YS5oaWRkZW4gPT09ICdib29sZWFuJyA/ICFtZXRhLmhpZGRlbiA6ICFkYXRhc2V0LmhpZGRlbjtcbiAgfVxuXG4gIHNldERhdGFzZXRWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgdmlzaWJsZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgbWV0YS5oaWRkZW4gPSAhdmlzaWJsZTtcbiAgfVxuXG4gIHRvZ2dsZURhdGFWaXNpYmlsaXR5KGluZGV4KSB7XG4gICAgdGhpcy5faGlkZGVuSW5kaWNlc1tpbmRleF0gPSAhdGhpcy5faGlkZGVuSW5kaWNlc1tpbmRleF07XG4gIH1cblxuICBnZXREYXRhVmlzaWJpbGl0eShpbmRleCkge1xuICAgIHJldHVybiAhdGhpcy5faGlkZGVuSW5kaWNlc1tpbmRleF07XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4LCB2aXNpYmxlKSB7XG4gICAgY29uc3QgbW9kZSA9IHZpc2libGUgPyAnc2hvdycgOiAnaGlkZSc7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICBjb25zdCBhbmltcyA9IG1ldGEuY29udHJvbGxlci5fcmVzb2x2ZUFuaW1hdGlvbnModW5kZWZpbmVkLCBtb2RlKTtcblxuICAgIGlmIChkZWZpbmVkKGRhdGFJbmRleCkpIHtcbiAgICAgIG1ldGEuZGF0YVtkYXRhSW5kZXhdLmhpZGRlbiA9ICF2aXNpYmxlO1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXREYXRhc2V0VmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIHZpc2libGUpO1xuICAgICAgLy8gQW5pbWF0ZSB2aXNpYmxlIHN0YXRlLCBzbyBoaWRlIGFuaW1hdGlvbiBjYW4gYmUgc2Vlbi4gVGhpcyBjb3VsZCBiZSBoYW5kbGVkIGJldHRlciBpZiB1cGRhdGUgLyB1cGRhdGVEYXRhc2V0IHJldHVybmVkIGEgUHJvbWlzZS5cbiAgICAgIGFuaW1zLnVwZGF0ZShtZXRhLCB7dmlzaWJsZX0pO1xuICAgICAgdGhpcy51cGRhdGUoKGN0eCkgPT4gY3R4LmRhdGFzZXRJbmRleCA9PT0gZGF0YXNldEluZGV4ID8gbW9kZSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICB9XG5cbiAgaGlkZShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCkge1xuICAgIHRoaXMuX3VwZGF0ZVZpc2liaWxpdHkoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgsIGZhbHNlKTtcbiAgfVxuXG4gIHNob3coZGF0YXNldEluZGV4LCBkYXRhSW5kZXgpIHtcbiAgICB0aGlzLl91cGRhdGVWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2Rlc3Ryb3lEYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fbWV0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgICBpZiAobWV0YSAmJiBtZXRhLmNvbnRyb2xsZXIpIHtcbiAgICAgIG1ldGEuY29udHJvbGxlci5fZGVzdHJveSgpO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5fbWV0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgfVxuXG4gIF9zdG9wKCkge1xuICAgIGxldCBpLCBpbGVuO1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIGFuaW1hdG9yLnJlbW92ZSh0aGlzKTtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEoaSk7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURlc3Ryb3knKTtcbiAgICBjb25zdCB7Y2FudmFzLCBjdHh9ID0gdGhpcztcblxuICAgIHRoaXMuX3N0b3AoKTtcbiAgICB0aGlzLmNvbmZpZy5jbGVhckNhY2hlKCk7XG5cbiAgICBpZiAoY2FudmFzKSB7XG4gICAgICB0aGlzLnVuYmluZEV2ZW50cygpO1xuICAgICAgY2xlYXJDYW52YXMoY2FudmFzLCBjdHgpO1xuICAgICAgdGhpcy5wbGF0Zm9ybS5yZWxlYXNlQ29udGV4dChjdHgpO1xuICAgICAgdGhpcy5jYW52YXMgPSBudWxsO1xuICAgICAgdGhpcy5jdHggPSBudWxsO1xuICAgIH1cblxuICAgIGRlbGV0ZSBpbnN0YW5jZXNbdGhpcy5pZF07XG5cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGVzdHJveScpO1xuICB9XG5cbiAgdG9CYXNlNjRJbWFnZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzLnRvRGF0YVVSTCguLi5hcmdzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLmJpbmRVc2VyRXZlbnRzKCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICB0aGlzLmJpbmRSZXNwb25zaXZlRXZlbnRzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXR0YWNoZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYmluZFVzZXJFdmVudHMoKSB7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgIGNvbnN0IHBsYXRmb3JtID0gdGhpcy5wbGF0Zm9ybTtcblxuICAgIGNvbnN0IF9hZGQgPSAodHlwZSwgbGlzdGVuZXIpID0+IHtcbiAgICAgIHBsYXRmb3JtLmFkZEV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgbGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgfTtcblxuICAgIGNvbnN0IGxpc3RlbmVyID0gKGUsIHgsIHkpID0+IHtcbiAgICAgIGUub2Zmc2V0WCA9IHg7XG4gICAgICBlLm9mZnNldFkgPSB5O1xuICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyKGUpO1xuICAgIH07XG5cbiAgICBlYWNoKHRoaXMub3B0aW9ucy5ldmVudHMsICh0eXBlKSA9PiBfYWRkKHR5cGUsIGxpc3RlbmVyKSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGJpbmRSZXNwb25zaXZlRXZlbnRzKCkge1xuICAgIGlmICghdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycykge1xuICAgICAgdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyA9IHt9O1xuICAgIH1cbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzO1xuICAgIGNvbnN0IHBsYXRmb3JtID0gdGhpcy5wbGF0Zm9ybTtcblxuICAgIGNvbnN0IF9hZGQgPSAodHlwZSwgbGlzdGVuZXIpID0+IHtcbiAgICAgIHBsYXRmb3JtLmFkZEV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgbGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgfTtcbiAgICBjb25zdCBfcmVtb3ZlID0gKHR5cGUsIGxpc3RlbmVyKSA9PiB7XG4gICAgICBpZiAobGlzdGVuZXJzW3R5cGVdKSB7XG4gICAgICAgIHBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICBkZWxldGUgbGlzdGVuZXJzW3R5cGVdO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBsaXN0ZW5lciA9ICh3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxldCBkZXRhY2hlZDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItY29uc3RcbiAgICBjb25zdCBhdHRhY2hlZCA9ICgpID0+IHtcbiAgICAgIF9yZW1vdmUoJ2F0dGFjaCcsIGF0dGFjaGVkKTtcblxuICAgICAgdGhpcy5hdHRhY2hlZCA9IHRydWU7XG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuXG4gICAgICBfYWRkKCdyZXNpemUnLCBsaXN0ZW5lcik7XG4gICAgICBfYWRkKCdkZXRhY2gnLCBkZXRhY2hlZCk7XG4gICAgfTtcblxuICAgIGRldGFjaGVkID0gKCkgPT4ge1xuICAgICAgdGhpcy5hdHRhY2hlZCA9IGZhbHNlO1xuXG4gICAgICBfcmVtb3ZlKCdyZXNpemUnLCBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFN0b3AgYW5pbWF0aW5nIGFuZCByZW1vdmUgbWV0YXNldHMsIHNvIHdoZW4gcmUtYXR0YWNoZWQsIHRoZSBhbmltYXRpb25zIHN0YXJ0IGZyb20gYmVnaW5uaW5nLlxuICAgICAgdGhpcy5fc3RvcCgpO1xuICAgICAgdGhpcy5fcmVzaXplKDAsIDApO1xuXG4gICAgICBfYWRkKCdhdHRhY2gnLCBhdHRhY2hlZCk7XG4gICAgfTtcblxuICAgIGlmIChwbGF0Zm9ybS5pc0F0dGFjaGVkKHRoaXMuY2FudmFzKSkge1xuICAgICAgYXR0YWNoZWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGV0YWNoZWQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIHVuYmluZEV2ZW50cygpIHtcbiAgICBlYWNoKHRoaXMuX2xpc3RlbmVycywgKGxpc3RlbmVyLCB0eXBlKSA9PiB7XG4gICAgICB0aGlzLnBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgIH0pO1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuXG4gICAgZWFjaCh0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzLCAobGlzdGVuZXIsIHR5cGUpID0+IHtcbiAgICAgIHRoaXMucGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgfSk7XG4gICAgdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHVwZGF0ZUhvdmVyU3R5bGUoaXRlbXMsIG1vZGUsIGVuYWJsZWQpIHtcbiAgICBjb25zdCBwcmVmaXggPSBlbmFibGVkID8gJ3NldCcgOiAncmVtb3ZlJztcbiAgICBsZXQgbWV0YSwgaXRlbSwgaSwgaWxlbjtcblxuICAgIGlmIChtb2RlID09PSAnZGF0YXNldCcpIHtcbiAgICAgIG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGl0ZW1zWzBdLmRhdGFzZXRJbmRleCk7XG4gICAgICBtZXRhLmNvbnRyb2xsZXJbJ18nICsgcHJlZml4ICsgJ0RhdGFzZXRIb3ZlclN0eWxlJ10oKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICBjb25zdCBjb250cm9sbGVyID0gaXRlbSAmJiB0aGlzLmdldERhdGFzZXRNZXRhKGl0ZW0uZGF0YXNldEluZGV4KS5jb250cm9sbGVyO1xuICAgICAgaWYgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlcltwcmVmaXggKyAnSG92ZXJTdHlsZSddKGl0ZW0uZWxlbWVudCwgaXRlbS5kYXRhc2V0SW5kZXgsIGl0ZW0uaW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXQgYWN0aXZlIChob3ZlcmVkKSBlbGVtZW50c1xuXHQgKiBAcmV0dXJucyBhcnJheVxuXHQgKi9cbiAgZ2V0QWN0aXZlRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBTZXQgYWN0aXZlIChob3ZlcmVkKSBlbGVtZW50c1xuXHQgKiBAcGFyYW0ge2FycmF5fSBhY3RpdmVFbGVtZW50cyBOZXcgYWN0aXZlIGRhdGEgcG9pbnRzXG5cdCAqL1xuICBzZXRBY3RpdmVFbGVtZW50cyhhY3RpdmVFbGVtZW50cykge1xuICAgIGNvbnN0IGxhc3RBY3RpdmUgPSB0aGlzLl9hY3RpdmUgfHwgW107XG4gICAgY29uc3QgYWN0aXZlID0gYWN0aXZlRWxlbWVudHMubWFwKCh7ZGF0YXNldEluZGV4LCBpbmRleH0pID0+IHtcbiAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgICBpZiAoIW1ldGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBkYXRhc2V0IGZvdW5kIGF0IGluZGV4ICcgKyBkYXRhc2V0SW5kZXgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhc2V0SW5kZXgsXG4gICAgICAgIGVsZW1lbnQ6IG1ldGEuZGF0YVtpbmRleF0sXG4gICAgICAgIGluZGV4LFxuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBjaGFuZ2VkID0gIV9lbGVtZW50c0VxdWFsKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG5cbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gYWN0aXZlO1xuICAgICAgLy8gTWFrZSBzdXJlIHdlIGRvbid0IHVzZSB0aGUgcHJldmlvdXMgbW91c2UgZXZlbnQgdG8gb3ZlcnJpZGUgdGhlIGFjdGl2ZSBlbGVtZW50cyBpbiB1cGRhdGUuXG4gICAgICB0aGlzLl9sYXN0RXZlbnQgPSBudWxsO1xuICAgICAgdGhpcy5fdXBkYXRlSG92ZXJTdHlsZXMoYWN0aXZlLCBsYXN0QWN0aXZlKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQ2FsbHMgZW5hYmxlZCBwbHVnaW5zIG9uIHRoZSBzcGVjaWZpZWQgaG9vayBhbmQgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cblx0ICogVGhpcyBtZXRob2QgaW1tZWRpYXRlbHkgcmV0dXJucyBhcyBzb29uIGFzIGEgcGx1Z2luIGV4cGxpY2l0bHkgcmV0dXJucyBmYWxzZS4gVGhlXG5cdCAqIHJldHVybmVkIHZhbHVlIGNhbiBiZSB1c2VkLCBmb3IgaW5zdGFuY2UsIHRvIGludGVycnVwdCB0aGUgY3VycmVudCBhY3Rpb24uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBob29rIC0gVGhlIG5hbWUgb2YgdGhlIHBsdWdpbiBtZXRob2QgdG8gY2FsbCAoZS5nLiAnYmVmb3JlVXBkYXRlJykuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnc10gLSBFeHRyYSBhcmd1bWVudHMgdG8gYXBwbHkgdG8gdGhlIGhvb2sgY2FsbC5cbiAgICogQHBhcmFtIHtpbXBvcnQoJy4vY29yZS5wbHVnaW5zLmpzJykuZmlsdGVyQ2FsbGJhY2t9IFtmaWx0ZXJdIC0gRmlsdGVyaW5nIGZ1bmN0aW9uIGZvciBsaW1pdGluZyB3aGljaCBwbHVnaW5zIGFyZSBub3RpZmllZFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gZmFsc2UgaWYgYW55IG9mIHRoZSBwbHVnaW5zIHJldHVybiBmYWxzZSwgZWxzZSByZXR1cm5zIHRydWUuXG5cdCAqL1xuICBub3RpZnlQbHVnaW5zKGhvb2ssIGFyZ3MsIGZpbHRlcikge1xuICAgIHJldHVybiB0aGlzLl9wbHVnaW5zLm5vdGlmeSh0aGlzLCBob29rLCBhcmdzLCBmaWx0ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgcGx1Z2luIHdpdGggdGhlIHNwZWNpZmljIElEIGlzIHJlZ2lzdGVyZWQgYW5kIGVuYWJsZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBsdWdpbklkIC0gVGhlIElEIG9mIHRoZSBwbHVnaW4gb2Ygd2hpY2ggdG8gY2hlY2sgaWYgaXQgaXMgZW5hYmxlZFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGlzUGx1Z2luRW5hYmxlZChwbHVnaW5JZCkge1xuICAgIHJldHVybiB0aGlzLl9wbHVnaW5zLl9jYWNoZS5maWx0ZXIocCA9PiBwLnBsdWdpbi5pZCA9PT0gcGx1Z2luSWQpLmxlbmd0aCA9PT0gMTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZUhvdmVyU3R5bGVzKGFjdGl2ZSwgbGFzdEFjdGl2ZSwgcmVwbGF5KSB7XG4gICAgY29uc3QgaG92ZXJPcHRpb25zID0gdGhpcy5vcHRpb25zLmhvdmVyO1xuICAgIGNvbnN0IGRpZmYgPSAoYSwgYikgPT4gYS5maWx0ZXIoeCA9PiAhYi5zb21lKHkgPT4geC5kYXRhc2V0SW5kZXggPT09IHkuZGF0YXNldEluZGV4ICYmIHguaW5kZXggPT09IHkuaW5kZXgpKTtcbiAgICBjb25zdCBkZWFjdGl2YXRlZCA9IGRpZmYobGFzdEFjdGl2ZSwgYWN0aXZlKTtcbiAgICBjb25zdCBhY3RpdmF0ZWQgPSByZXBsYXkgPyBhY3RpdmUgOiBkaWZmKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG5cbiAgICBpZiAoZGVhY3RpdmF0ZWQubGVuZ3RoKSB7XG4gICAgICB0aGlzLnVwZGF0ZUhvdmVyU3R5bGUoZGVhY3RpdmF0ZWQsIGhvdmVyT3B0aW9ucy5tb2RlLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGl2YXRlZC5sZW5ndGggJiYgaG92ZXJPcHRpb25zLm1vZGUpIHtcbiAgICAgIHRoaXMudXBkYXRlSG92ZXJTdHlsZShhY3RpdmF0ZWQsIGhvdmVyT3B0aW9ucy5tb2RlLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9ldmVudEhhbmRsZXIoZSwgcmVwbGF5KSB7XG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgIGV2ZW50OiBlLFxuICAgICAgcmVwbGF5LFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGluQ2hhcnRBcmVhOiB0aGlzLmlzUG9pbnRJbkFyZWEoZSlcbiAgICB9O1xuICAgIGNvbnN0IGV2ZW50RmlsdGVyID0gKHBsdWdpbikgPT4gKHBsdWdpbi5vcHRpb25zLmV2ZW50cyB8fCB0aGlzLm9wdGlvbnMuZXZlbnRzKS5pbmNsdWRlcyhlLm5hdGl2ZS50eXBlKTtcblxuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUV2ZW50JywgYXJncywgZXZlbnRGaWx0ZXIpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLl9oYW5kbGVFdmVudChlLCByZXBsYXksIGFyZ3MuaW5DaGFydEFyZWEpO1xuXG4gICAgYXJncy5jYW5jZWxhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckV2ZW50JywgYXJncywgZXZlbnRGaWx0ZXIpO1xuXG4gICAgaWYgKGNoYW5nZWQgfHwgYXJncy5jaGFuZ2VkKSB7XG4gICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEhhbmRsZSBhbiBldmVudFxuXHQgKiBAcGFyYW0ge0NoYXJ0RXZlbnR9IGUgdGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXBsYXldIC0gdHJ1ZSBpZiB0aGUgZXZlbnQgd2FzIHJlcGxheWVkIGJ5IGB1cGRhdGVgXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luQ2hhcnRBcmVhXSAtIHRydWUgaWYgdGhlIGV2ZW50IGlzIGluc2lkZSBjaGFydEFyZWFcblx0ICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgY2hhcnQgbmVlZHMgdG8gcmUtcmVuZGVyXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfaGFuZGxlRXZlbnQoZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IHtfYWN0aXZlOiBsYXN0QWN0aXZlID0gW10sIG9wdGlvbnN9ID0gdGhpcztcblxuICAgIC8vIElmIHRoZSBldmVudCBpcyByZXBsYXllZCBmcm9tIGB1cGRhdGVgLCB3ZSBzaG91bGQgZXZhbHVhdGUgd2l0aCB0aGUgZmluYWwgcG9zaXRpb25zLlxuICAgIC8vXG4gICAgLy8gVGhlIGByZXBsYXlgOlxuICAgIC8vIEl0J3MgdGhlIGxhc3QgZXZlbnQgKGV4Y2x1ZGluZyBjbGljaykgdGhhdCBoYXMgb2NjdXJyZWQgYmVmb3JlIGB1cGRhdGVgLlxuICAgIC8vIFNvIG1vdXNlIGhhcyBub3QgbW92ZWQuIEl0J3MgYWxzbyBvdmVyIHRoZSBjaGFydCwgYmVjYXVzZSB0aGVyZSBpcyBhIGByZXBsYXlgLlxuICAgIC8vXG4gICAgLy8gVGhlIHdoeTpcbiAgICAvLyBJZiBhbmltYXRpb25zIGFyZSBhY3RpdmUsIHRoZSBlbGVtZW50cyBoYXZlbid0IG1vdmVkIHlldCBjb21wYXJlZCB0byBzdGF0ZSBiZWZvcmUgdXBkYXRlLlxuICAgIC8vIEJ1dCBpZiB0aGV5IHdpbGwsIHdlIGFyZSBhY3RpdmF0aW5nIHRoZSBlbGVtZW50cyB0aGF0IHdvdWxkIGJlIGFjdGl2ZSwgaWYgdGhpcyBjaGVja1xuICAgIC8vIHdhcyBkb25lIGFmdGVyIHRoZSBhbmltYXRpb25zIGhhdmUgY29tcGxldGVkLiA9PiBcImZpbmFsIHBvc2l0aW9uc1wiLlxuICAgIC8vIElmIHRoZXJlIGlzIG5vIGFuaW1hdGlvbnMsIHRoZSBcImZpbmFsXCIgYW5kIFwiY3VycmVudFwiIHBvc2l0aW9ucyBhcmUgZXF1YWwuXG4gICAgLy8gVGhpcyBpcyBkb25lIHNvIHdlIGRvIG5vdCBoYXZlIHRvIGV2YWx1YXRlIHRoZSBhY3RpdmUgZWxlbWVudHMgZWFjaCBhbmltYXRpb24gZnJhbWVcbiAgICAvLyAtIGl0IHdvdWxkIGJlIGV4cGVuc2l2ZS5cbiAgICBjb25zdCB1c2VGaW5hbFBvc2l0aW9uID0gcmVwbGF5O1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2dldEFjdGl2ZUVsZW1lbnRzKGUsIGxhc3RBY3RpdmUsIGluQ2hhcnRBcmVhLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCBpc0NsaWNrID0gX2lzQ2xpY2tFdmVudChlKTtcbiAgICBjb25zdCBsYXN0RXZlbnQgPSBkZXRlcm1pbmVMYXN0RXZlbnQoZSwgdGhpcy5fbGFzdEV2ZW50LCBpbkNoYXJ0QXJlYSwgaXNDbGljayk7XG5cbiAgICBpZiAoaW5DaGFydEFyZWEpIHtcbiAgICAgIC8vIFNldCBfbGFzdEV2ZW50IHRvIG51bGwgd2hpbGUgd2UgYXJlIHByb2Nlc3NpbmcgdGhlIGV2ZW50IGhhbmRsZXJzLlxuICAgICAgLy8gVGhpcyBwcmV2ZW50cyByZWN1cnNpb24gaWYgdGhlIGhhbmRsZXIgY2FsbHMgY2hhcnQudXBkYXRlKClcbiAgICAgIHRoaXMuX2xhc3RFdmVudCA9IG51bGw7XG5cbiAgICAgIC8vIEludm9rZSBvbkhvdmVyIGhvb2tcbiAgICAgIGNhbGxDYWxsYmFjayhvcHRpb25zLm9uSG92ZXIsIFtlLCBhY3RpdmUsIHRoaXNdLCB0aGlzKTtcblxuICAgICAgaWYgKGlzQ2xpY2spIHtcbiAgICAgICAgY2FsbENhbGxiYWNrKG9wdGlvbnMub25DbGljaywgW2UsIGFjdGl2ZSwgdGhpc10sIHRoaXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGNoYW5nZWQgPSAhX2VsZW1lbnRzRXF1YWwoYWN0aXZlLCBsYXN0QWN0aXZlKTtcbiAgICBpZiAoY2hhbmdlZCB8fCByZXBsYXkpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKGFjdGl2ZSwgbGFzdEFjdGl2ZSwgcmVwbGF5KTtcbiAgICB9XG5cbiAgICB0aGlzLl9sYXN0RXZlbnQgPSBsYXN0RXZlbnQ7XG5cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NoYXJ0RXZlbnR9IGUgLSBUaGUgZXZlbnRcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQWN0aXZlRWxlbWVudFtdfSBsYXN0QWN0aXZlIC0gUHJldmlvdXNseSBhY3RpdmUgZWxlbWVudHNcbiAgICogQHBhcmFtIHtib29sZWFufSBpbkNoYXJ0QXJlYSAtIElzIHRoZSBlbnZlbnQgaW5zaWRlIGNoYXJ0QXJlYVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVzZUZpbmFsUG9zaXRpb24gLSBTaG91bGQgdGhlIGV2YWx1YXRpb24gYmUgZG9uZSB3aXRoIGN1cnJlbnQgb3IgZmluYWwgKGFmdGVyIGFuaW1hdGlvbikgZWxlbWVudCBwb3NpdGlvbnNcbiAgICogQHJldHVybnMge2ltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5BY3RpdmVFbGVtZW50W119IC0gVGhlIGFjdGl2ZSBlbGVtZW50c1xuICAgKiBAcHJhdmF0ZVxuICAgKi9cbiAgX2dldEFjdGl2ZUVsZW1lbnRzKGUsIGxhc3RBY3RpdmUsIGluQ2hhcnRBcmVhLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGlmICghaW5DaGFydEFyZWEpIHtcbiAgICAgIC8vIExldCB1c2VyIGNvbnRyb2wgdGhlIGFjdGl2ZSBlbGVtZW50cyBvdXRzaWRlIGNoYXJ0QXJlYS4gRWcuIHVzaW5nIExlZ2VuZC5cbiAgICAgIHJldHVybiBsYXN0QWN0aXZlO1xuICAgIH1cblxuICAgIGNvbnN0IGhvdmVyT3B0aW9ucyA9IHRoaXMub3B0aW9ucy5ob3ZlcjtcbiAgICByZXR1cm4gdGhpcy5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIGhvdmVyT3B0aW9ucy5tb2RlLCBob3Zlck9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG59XG5cbi8vIEB0cy1pZ25vcmVcbmZ1bmN0aW9uIGludmFsaWRhdGVQbHVnaW5zKCkge1xuICByZXR1cm4gZWFjaChDaGFydC5pbnN0YW5jZXMsIChjaGFydCkgPT4gY2hhcnQuX3BsdWdpbnMuaW52YWxpZGF0ZSgpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2hhcnQ7XG4iLCAiaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi4vY29yZS9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IHtfYW5nbGVCZXR3ZWVuLCBnZXRBbmdsZUZyb21Qb2ludCwgVEFVLCBIQUxGX1BJLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge1BJLCBfaXNCZXR3ZWVuLCBfbGltaXRWYWx1ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtfcmVhZFZhbHVlVG9Qcm9wc30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm9wdGlvbnMuanMnO1xuaW1wb3J0IHR5cGUge0FyY09wdGlvbnMsIFBvaW50fSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5cblxuZnVuY3Rpb24gY2xpcEFyYyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgZWxlbWVudDogQXJjRWxlbWVudCwgZW5kQW5nbGU6IG51bWJlcikge1xuICBjb25zdCB7c3RhcnRBbmdsZSwgcGl4ZWxNYXJnaW4sIHgsIHksIG91dGVyUmFkaXVzLCBpbm5lclJhZGl1c30gPSBlbGVtZW50O1xuICBsZXQgYW5nbGVNYXJnaW4gPSBwaXhlbE1hcmdpbiAvIG91dGVyUmFkaXVzO1xuXG4gIC8vIERyYXcgYW4gaW5uZXIgYm9yZGVyIGJ5IGNsaXBwaW5nIHRoZSBhcmMgYW5kIGRyYXdpbmcgYSBkb3VibGUtd2lkdGggYm9yZGVyXG4gIC8vIEVubGFyZ2UgdGhlIGNsaXBwaW5nIGFyYyBieSAwLjMzIHBpeGVscyB0byBlbGltaW5hdGUgZ2xpdGNoZXMgYmV0d2VlbiBib3JkZXJzXG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCBvdXRlclJhZGl1cywgc3RhcnRBbmdsZSAtIGFuZ2xlTWFyZ2luLCBlbmRBbmdsZSArIGFuZ2xlTWFyZ2luKTtcbiAgaWYgKGlubmVyUmFkaXVzID4gcGl4ZWxNYXJnaW4pIHtcbiAgICBhbmdsZU1hcmdpbiA9IHBpeGVsTWFyZ2luIC8gaW5uZXJSYWRpdXM7XG4gICAgY3R4LmFyYyh4LCB5LCBpbm5lclJhZGl1cywgZW5kQW5nbGUgKyBhbmdsZU1hcmdpbiwgc3RhcnRBbmdsZSAtIGFuZ2xlTWFyZ2luLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBjdHguYXJjKHgsIHksIHBpeGVsTWFyZ2luLCBlbmRBbmdsZSArIEhBTEZfUEksIHN0YXJ0QW5nbGUgLSBIQUxGX1BJKTtcbiAgfVxuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5jbGlwKCk7XG59XG5cbmZ1bmN0aW9uIHRvUmFkaXVzQ29ybmVycyh2YWx1ZSkge1xuICByZXR1cm4gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIFsnb3V0ZXJTdGFydCcsICdvdXRlckVuZCcsICdpbm5lclN0YXJ0JywgJ2lubmVyRW5kJ10pO1xufVxuXG4vKipcbiAqIFBhcnNlIGJvcmRlciByYWRpdXMgZnJvbSB0aGUgcHJvdmlkZWQgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBwYXJzZUJvcmRlclJhZGl1cyhhcmM6IEFyY0VsZW1lbnQsIGlubmVyUmFkaXVzOiBudW1iZXIsIG91dGVyUmFkaXVzOiBudW1iZXIsIGFuZ2xlRGVsdGE6IG51bWJlcikge1xuICBjb25zdCBvID0gdG9SYWRpdXNDb3JuZXJzKGFyYy5vcHRpb25zLmJvcmRlclJhZGl1cyk7XG4gIGNvbnN0IGhhbGZUaGlja25lc3MgPSAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyAyO1xuICBjb25zdCBpbm5lckxpbWl0ID0gTWF0aC5taW4oaGFsZlRoaWNrbmVzcywgYW5nbGVEZWx0YSAqIGlubmVyUmFkaXVzIC8gMik7XG5cbiAgLy8gT3V0ZXIgbGltaXRzIGFyZSBjb21wbGljYXRlZC4gV2Ugd2FudCB0byBjb21wdXRlIHRoZSBhdmFpbGFibGUgYW5ndWxhciBkaXN0YW5jZSBhdFxuICAvLyBhIHJhZGl1cyBvZiBvdXRlclJhZGl1cyAtIGJvcmRlclJhZGl1cyBiZWNhdXNlIGZvciBzbWFsbCBhbmd1bGFyIGRpc3RhbmNlcywgdGhpcyB0ZXJtIGxpbWl0cy5cbiAgLy8gV2UgY29tcHV0ZSBhdCByID0gb3V0ZXJSYWRpdXMgLSBib3JkZXJSYWRpdXMgYmVjYXVzZSB0aGlzIGNpcmNsZSBkZWZpbmVzIHRoZSBjZW50ZXIgb2YgdGhlIGJvcmRlciBjb3JuZXJzLlxuICAvL1xuICAvLyBJZiB0aGUgYm9yZGVyUmFkaXVzIGlzIGxhcmdlLCB0aGF0IHZhbHVlIGNhbiBiZWNvbWUgbmVnYXRpdmUuXG4gIC8vIFRoaXMgY2F1c2VzIHRoZSBvdXRlciBib3JkZXJzIHRvIGxvc2UgdGhlaXIgcmFkaXVzIGVudGlyZWx5LCB3aGljaCBpcyByYXRoZXIgdW5leHBlY3RlZC4gVG8gc29sdmUgdGhhdCwgaWYgYm9yZGVyUmFkaXVzID4gb3V0ZXJSYWRpdXNcbiAgLy8gd2Uga25vdyB0aGF0IHRoZSB0aGlja25lc3MgdGVybSB3aWxsIGRvbWluYXRlIGFuZCBjb21wdXRlIHRoZSBsaW1pdHMgYXQgdGhhdCBwb2ludFxuICBjb25zdCBjb21wdXRlT3V0ZXJMaW1pdCA9ICh2YWwpID0+IHtcbiAgICBjb25zdCBvdXRlckFyY0xpbWl0ID0gKG91dGVyUmFkaXVzIC0gTWF0aC5taW4oaGFsZlRoaWNrbmVzcywgdmFsKSkgKiBhbmdsZURlbHRhIC8gMjtcbiAgICByZXR1cm4gX2xpbWl0VmFsdWUodmFsLCAwLCBNYXRoLm1pbihoYWxmVGhpY2tuZXNzLCBvdXRlckFyY0xpbWl0KSk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBvdXRlclN0YXJ0OiBjb21wdXRlT3V0ZXJMaW1pdChvLm91dGVyU3RhcnQpLFxuICAgIG91dGVyRW5kOiBjb21wdXRlT3V0ZXJMaW1pdChvLm91dGVyRW5kKSxcbiAgICBpbm5lclN0YXJ0OiBfbGltaXRWYWx1ZShvLmlubmVyU3RhcnQsIDAsIGlubmVyTGltaXQpLFxuICAgIGlubmVyRW5kOiBfbGltaXRWYWx1ZShvLmlubmVyRW5kLCAwLCBpbm5lckxpbWl0KSxcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IChyLCDwnZyDKSB0byAoeCwgeSlcbiAqL1xuZnVuY3Rpb24gclRoZXRhVG9YWShyOiBudW1iZXIsIHRoZXRhOiBudW1iZXIsIHg6IG51bWJlciwgeTogbnVtYmVyKSB7XG4gIHJldHVybiB7XG4gICAgeDogeCArIHIgKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgeTogeSArIHIgKiBNYXRoLnNpbih0aGV0YSksXG4gIH07XG59XG5cblxuLyoqXG4gKiBQYXRoIHRoZSBhcmMsIHJlc3BlY3RpbmcgYm9yZGVyIHJhZGl1cyBieSBzZXBhcmF0aW5nIGludG8gbGVmdCBhbmQgcmlnaHQgaGFsdmVzLlxuICpcbiAqICAgU3RhcnQgICAgICBFbmRcbiAqXG4gKiAgICAxLS0tPmEtLS0+MiAgICBPdXRlclxuICogICAvICAgICAgICAgICBcXFxuICogICA4ICAgICAgICAgICAzXG4gKiAgIHwgICAgICAgICAgIHxcbiAqICAgfCAgICAgICAgICAgfFxuICogICA3ICAgICAgICAgICA0XG4gKiAgIFxcICAgICAgICAgICAvXG4gKiAgICA2PC0tLWI8LS0tNSAgICBJbm5lclxuICovXG5mdW5jdGlvbiBwYXRoQXJjKFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgZWxlbWVudDogQXJjRWxlbWVudCxcbiAgb2Zmc2V0OiBudW1iZXIsXG4gIHNwYWNpbmc6IG51bWJlcixcbiAgZW5kOiBudW1iZXIsXG4gIGNpcmN1bGFyOiBib29sZWFuLFxuKSB7XG4gIGNvbnN0IHt4LCB5LCBzdGFydEFuZ2xlOiBzdGFydCwgcGl4ZWxNYXJnaW4sIGlubmVyUmFkaXVzOiBpbm5lclJ9ID0gZWxlbWVudDtcblxuICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KGVsZW1lbnQub3V0ZXJSYWRpdXMgKyBzcGFjaW5nICsgb2Zmc2V0IC0gcGl4ZWxNYXJnaW4sIDApO1xuICBjb25zdCBpbm5lclJhZGl1cyA9IGlubmVyUiA+IDAgPyBpbm5lclIgKyBzcGFjaW5nICsgb2Zmc2V0ICsgcGl4ZWxNYXJnaW4gOiAwO1xuXG4gIGxldCBzcGFjaW5nT2Zmc2V0ID0gMDtcbiAgY29uc3QgYWxwaGEgPSBlbmQgLSBzdGFydDtcblxuICBpZiAoc3BhY2luZykge1xuICAgIC8vIFdoZW4gc3BhY2luZyBpcyBwcmVzZW50LCBpdCBpcyB0aGUgc2FtZSBmb3IgYWxsIGl0ZW1zXG4gICAgLy8gU28gd2UgYWRqdXN0IHRoZSBzdGFydCBhbmQgZW5kIGFuZ2xlIG9mIHRoZSBhcmMgc3VjaCB0aGF0XG4gICAgLy8gdGhlIGRpc3RhbmNlIGlzIHRoZSBzYW1lIGFzIGl0IHdvdWxkIGJlIHdpdGhvdXQgdGhlIHNwYWNpbmdcbiAgICBjb25zdCBub1NwYWNpbmdJbm5lclJhZGl1cyA9IGlubmVyUiA+IDAgPyBpbm5lclIgLSBzcGFjaW5nIDogMDtcbiAgICBjb25zdCBub1NwYWNpbmdPdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzID4gMCA/IG91dGVyUmFkaXVzIC0gc3BhY2luZyA6IDA7XG4gICAgY29uc3QgYXZOb2dTcGFjaW5nUmFkaXVzID0gKG5vU3BhY2luZ0lubmVyUmFkaXVzICsgbm9TcGFjaW5nT3V0ZXJSYWRpdXMpIC8gMjtcbiAgICBjb25zdCBhZGp1c3RlZEFuZ2xlID0gYXZOb2dTcGFjaW5nUmFkaXVzICE9PSAwID8gKGFscGhhICogYXZOb2dTcGFjaW5nUmFkaXVzKSAvIChhdk5vZ1NwYWNpbmdSYWRpdXMgKyBzcGFjaW5nKSA6IGFscGhhO1xuICAgIHNwYWNpbmdPZmZzZXQgPSAoYWxwaGEgLSBhZGp1c3RlZEFuZ2xlKSAvIDI7XG4gIH1cblxuICBjb25zdCBiZXRhID0gTWF0aC5tYXgoMC4wMDEsIGFscGhhICogb3V0ZXJSYWRpdXMgLSBvZmZzZXQgLyBQSSkgLyBvdXRlclJhZGl1cztcbiAgY29uc3QgYW5nbGVPZmZzZXQgPSAoYWxwaGEgLSBiZXRhKSAvIDI7XG4gIGNvbnN0IHN0YXJ0QW5nbGUgPSBzdGFydCArIGFuZ2xlT2Zmc2V0ICsgc3BhY2luZ09mZnNldDtcbiAgY29uc3QgZW5kQW5nbGUgPSBlbmQgLSBhbmdsZU9mZnNldCAtIHNwYWNpbmdPZmZzZXQ7XG4gIGNvbnN0IHtvdXRlclN0YXJ0LCBvdXRlckVuZCwgaW5uZXJTdGFydCwgaW5uZXJFbmR9ID0gcGFyc2VCb3JkZXJSYWRpdXMoZWxlbWVudCwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpO1xuXG4gIGNvbnN0IG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cyA9IG91dGVyUmFkaXVzIC0gb3V0ZXJTdGFydDtcbiAgY29uc3Qgb3V0ZXJFbmRBZGp1c3RlZFJhZGl1cyA9IG91dGVyUmFkaXVzIC0gb3V0ZXJFbmQ7XG4gIGNvbnN0IG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlID0gc3RhcnRBbmdsZSArIG91dGVyU3RhcnQgLyBvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXM7XG4gIGNvbnN0IG91dGVyRW5kQWRqdXN0ZWRBbmdsZSA9IGVuZEFuZ2xlIC0gb3V0ZXJFbmQgLyBvdXRlckVuZEFkanVzdGVkUmFkaXVzO1xuXG4gIGNvbnN0IGlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cyA9IGlubmVyUmFkaXVzICsgaW5uZXJTdGFydDtcbiAgY29uc3QgaW5uZXJFbmRBZGp1c3RlZFJhZGl1cyA9IGlubmVyUmFkaXVzICsgaW5uZXJFbmQ7XG4gIGNvbnN0IGlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlID0gc3RhcnRBbmdsZSArIGlubmVyU3RhcnQgLyBpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXM7XG4gIGNvbnN0IGlubmVyRW5kQWRqdXN0ZWRBbmdsZSA9IGVuZEFuZ2xlIC0gaW5uZXJFbmQgLyBpbm5lckVuZEFkanVzdGVkUmFkaXVzO1xuXG4gIGN0eC5iZWdpblBhdGgoKTtcblxuICBpZiAoY2lyY3VsYXIpIHtcbiAgICAvLyBUaGUgZmlyc3QgYXJjIHNlZ21lbnRzIGZyb20gcG9pbnQgMSB0byBwb2ludCBhIHRvIHBvaW50IDJcbiAgICBjb25zdCBvdXRlck1pZEFkanVzdGVkQW5nbGUgPSAob3V0ZXJTdGFydEFkanVzdGVkQW5nbGUgKyBvdXRlckVuZEFkanVzdGVkQW5nbGUpIC8gMjtcbiAgICBjdHguYXJjKHgsIHksIG91dGVyUmFkaXVzLCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSwgb3V0ZXJNaWRBZGp1c3RlZEFuZ2xlKTtcbiAgICBjdHguYXJjKHgsIHksIG91dGVyUmFkaXVzLCBvdXRlck1pZEFkanVzdGVkQW5nbGUsIG91dGVyRW5kQWRqdXN0ZWRBbmdsZSk7XG5cbiAgICAvLyBUaGUgY29ybmVyIHNlZ21lbnQgZnJvbSBwb2ludCAyIHRvIHBvaW50IDNcbiAgICBpZiAob3V0ZXJFbmQgPiAwKSB7XG4gICAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShvdXRlckVuZEFkanVzdGVkUmFkaXVzLCBvdXRlckVuZEFkanVzdGVkQW5nbGUsIHgsIHkpO1xuICAgICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgb3V0ZXJFbmQsIG91dGVyRW5kQWRqdXN0ZWRBbmdsZSwgZW5kQW5nbGUgKyBIQUxGX1BJKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgbGluZSBmcm9tIHBvaW50IDMgdG8gcG9pbnQgNFxuICAgIGNvbnN0IHA0ID0gclRoZXRhVG9YWShpbm5lckVuZEFkanVzdGVkUmFkaXVzLCBlbmRBbmdsZSwgeCwgeSk7XG4gICAgY3R4LmxpbmVUbyhwNC54LCBwNC55KTtcblxuICAgIC8vIFRoZSBjb3JuZXIgc2VnbWVudCBmcm9tIHBvaW50IDQgdG8gcG9pbnQgNVxuICAgIGlmIChpbm5lckVuZCA+IDApIHtcbiAgICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKGlubmVyRW5kQWRqdXN0ZWRSYWRpdXMsIGlubmVyRW5kQWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBpbm5lckVuZCwgZW5kQW5nbGUgKyBIQUxGX1BJLCBpbm5lckVuZEFkanVzdGVkQW5nbGUgKyBNYXRoLlBJKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgaW5uZXIgYXJjIGZyb20gcG9pbnQgNSB0byBwb2ludCBiIHRvIHBvaW50IDZcbiAgICBjb25zdCBpbm5lck1pZEFkanVzdGVkQW5nbGUgPSAoKGVuZEFuZ2xlIC0gKGlubmVyRW5kIC8gaW5uZXJSYWRpdXMpKSArIChzdGFydEFuZ2xlICsgKGlubmVyU3RhcnQgLyBpbm5lclJhZGl1cykpKSAvIDI7XG4gICAgY3R4LmFyYyh4LCB5LCBpbm5lclJhZGl1cywgZW5kQW5nbGUgLSAoaW5uZXJFbmQgLyBpbm5lclJhZGl1cyksIGlubmVyTWlkQWRqdXN0ZWRBbmdsZSwgdHJ1ZSk7XG4gICAgY3R4LmFyYyh4LCB5LCBpbm5lclJhZGl1cywgaW5uZXJNaWRBZGp1c3RlZEFuZ2xlLCBzdGFydEFuZ2xlICsgKGlubmVyU3RhcnQgLyBpbm5lclJhZGl1cyksIHRydWUpO1xuXG4gICAgLy8gVGhlIGNvcm5lciBzZWdtZW50IGZyb20gcG9pbnQgNiB0byBwb2ludCA3XG4gICAgaWYgKGlubmVyU3RhcnQgPiAwKSB7XG4gICAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXMsIGlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIGlubmVyU3RhcnQsIGlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlICsgTWF0aC5QSSwgc3RhcnRBbmdsZSAtIEhBTEZfUEkpO1xuICAgIH1cblxuICAgIC8vIFRoZSBsaW5lIGZyb20gcG9pbnQgNyB0byBwb2ludCA4XG4gICAgY29uc3QgcDggPSByVGhldGFUb1hZKG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cywgc3RhcnRBbmdsZSwgeCwgeSk7XG4gICAgY3R4LmxpbmVUbyhwOC54LCBwOC55KTtcblxuICAgIC8vIFRoZSBjb3JuZXIgc2VnbWVudCBmcm9tIHBvaW50IDggdG8gcG9pbnQgMVxuICAgIGlmIChvdXRlclN0YXJ0ID4gMCkge1xuICAgICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkob3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzLCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBvdXRlclN0YXJ0LCBzdGFydEFuZ2xlIC0gSEFMRl9QSSwgb3V0ZXJTdGFydEFkanVzdGVkQW5nbGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjdHgubW92ZVRvKHgsIHkpO1xuXG4gICAgY29uc3Qgb3V0ZXJTdGFydFggPSBNYXRoLmNvcyhvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSkgKiBvdXRlclJhZGl1cyArIHg7XG4gICAgY29uc3Qgb3V0ZXJTdGFydFkgPSBNYXRoLnNpbihvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSkgKiBvdXRlclJhZGl1cyArIHk7XG4gICAgY3R4LmxpbmVUbyhvdXRlclN0YXJ0WCwgb3V0ZXJTdGFydFkpO1xuXG4gICAgY29uc3Qgb3V0ZXJFbmRYID0gTWF0aC5jb3Mob3V0ZXJFbmRBZGp1c3RlZEFuZ2xlKSAqIG91dGVyUmFkaXVzICsgeDtcbiAgICBjb25zdCBvdXRlckVuZFkgPSBNYXRoLnNpbihvdXRlckVuZEFkanVzdGVkQW5nbGUpICogb3V0ZXJSYWRpdXMgKyB5O1xuICAgIGN0eC5saW5lVG8ob3V0ZXJFbmRYLCBvdXRlckVuZFkpO1xuICB9XG5cbiAgY3R4LmNsb3NlUGF0aCgpO1xufVxuXG5mdW5jdGlvbiBkcmF3QXJjKFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgZWxlbWVudDogQXJjRWxlbWVudCxcbiAgb2Zmc2V0OiBudW1iZXIsXG4gIHNwYWNpbmc6IG51bWJlcixcbiAgY2lyY3VsYXI6IGJvb2xlYW4sXG4pIHtcbiAgY29uc3Qge2Z1bGxDaXJjbGVzLCBzdGFydEFuZ2xlLCBjaXJjdW1mZXJlbmNlfSA9IGVsZW1lbnQ7XG4gIGxldCBlbmRBbmdsZSA9IGVsZW1lbnQuZW5kQW5nbGU7XG4gIGlmIChmdWxsQ2lyY2xlcykge1xuICAgIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlLCBjaXJjdWxhcik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmdWxsQ2lyY2xlczsgKytpKSB7XG4gICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgICBpZiAoIWlzTmFOKGNpcmN1bWZlcmVuY2UpKSB7XG4gICAgICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyAoY2lyY3VtZmVyZW5jZSAlIFRBVSB8fCBUQVUpO1xuICAgIH1cbiAgfVxuICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSwgY2lyY3VsYXIpO1xuICBjdHguZmlsbCgpO1xuICByZXR1cm4gZW5kQW5nbGU7XG59XG5cbmZ1bmN0aW9uIGRyYXdCb3JkZXIoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBlbGVtZW50OiBBcmNFbGVtZW50LFxuICBvZmZzZXQ6IG51bWJlcixcbiAgc3BhY2luZzogbnVtYmVyLFxuICBjaXJjdWxhcjogYm9vbGVhbixcbikge1xuICBjb25zdCB7ZnVsbENpcmNsZXMsIHN0YXJ0QW5nbGUsIGNpcmN1bWZlcmVuY2UsIG9wdGlvbnN9ID0gZWxlbWVudDtcbiAgY29uc3Qge2JvcmRlcldpZHRoLCBib3JkZXJKb2luU3R5bGUsIGJvcmRlckRhc2gsIGJvcmRlckRhc2hPZmZzZXR9ID0gb3B0aW9ucztcbiAgY29uc3QgaW5uZXIgPSBvcHRpb25zLmJvcmRlckFsaWduID09PSAnaW5uZXInO1xuXG4gIGlmICghYm9yZGVyV2lkdGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjdHguc2V0TGluZURhc2goYm9yZGVyRGFzaCB8fCBbXSk7XG4gIGN0eC5saW5lRGFzaE9mZnNldCA9IGJvcmRlckRhc2hPZmZzZXQ7XG5cbiAgaWYgKGlubmVyKSB7XG4gICAgY3R4LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoICogMjtcbiAgICBjdHgubGluZUpvaW4gPSBib3JkZXJKb2luU3R5bGUgfHwgJ3JvdW5kJztcbiAgfSBlbHNlIHtcbiAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyV2lkdGg7XG4gICAgY3R4LmxpbmVKb2luID0gYm9yZGVySm9pblN0eWxlIHx8ICdiZXZlbCc7XG4gIH1cblxuICBsZXQgZW5kQW5nbGUgPSBlbGVtZW50LmVuZEFuZ2xlO1xuICBpZiAoZnVsbENpcmNsZXMpIHtcbiAgICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSwgY2lyY3VsYXIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnVsbENpcmNsZXM7ICsraSkge1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgICBpZiAoIWlzTmFOKGNpcmN1bWZlcmVuY2UpKSB7XG4gICAgICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyAoY2lyY3VtZmVyZW5jZSAlIFRBVSB8fCBUQVUpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpbm5lcikge1xuICAgIGNsaXBBcmMoY3R4LCBlbGVtZW50LCBlbmRBbmdsZSk7XG4gIH1cblxuICBpZiAoIWZ1bGxDaXJjbGVzKSB7XG4gICAgcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kQW5nbGUsIGNpcmN1bGFyKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBBcmNQcm9wcyBleHRlbmRzIFBvaW50IHtcbiAgc3RhcnRBbmdsZTogbnVtYmVyO1xuICBlbmRBbmdsZTogbnVtYmVyO1xuICBpbm5lclJhZGl1czogbnVtYmVyO1xuICBvdXRlclJhZGl1czogbnVtYmVyO1xuICBjaXJjdW1mZXJlbmNlOiBudW1iZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFyY0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PEFyY1Byb3BzLCBBcmNPcHRpb25zPiB7XG5cbiAgc3RhdGljIGlkID0gJ2FyYyc7XG5cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGJvcmRlckFsaWduOiAnY2VudGVyJyxcbiAgICBib3JkZXJDb2xvcjogJyNmZmYnLFxuICAgIGJvcmRlckRhc2g6IFtdLFxuICAgIGJvcmRlckRhc2hPZmZzZXQ6IDAsXG4gICAgYm9yZGVySm9pblN0eWxlOiB1bmRlZmluZWQsXG4gICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgIGJvcmRlcldpZHRoOiAyLFxuICAgIG9mZnNldDogMCxcbiAgICBzcGFjaW5nOiAwLFxuICAgIGFuZ2xlOiB1bmRlZmluZWQsXG4gICAgY2lyY3VsYXI6IHRydWUsXG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJ1xuICB9O1xuXG4gIHN0YXRpYyBkZXNjcmlwdG9ycyA9IHtcbiAgICBfc2NyaXB0YWJsZTogdHJ1ZSxcbiAgICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JvcmRlckRhc2gnXG4gIH07XG5cbiAgY2lyY3VtZmVyZW5jZTogbnVtYmVyO1xuICBlbmRBbmdsZTogbnVtYmVyO1xuICBmdWxsQ2lyY2xlczogbnVtYmVyO1xuICBpbm5lclJhZGl1czogbnVtYmVyO1xuICBvdXRlclJhZGl1czogbnVtYmVyO1xuICBwaXhlbE1hcmdpbjogbnVtYmVyO1xuICBzdGFydEFuZ2xlOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNpcmN1bWZlcmVuY2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zdGFydEFuZ2xlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW5kQW5nbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGl4ZWxNYXJnaW4gPSAwO1xuICAgIHRoaXMuZnVsbENpcmNsZXMgPSAwO1xuXG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuXG4gIGluUmFuZ2UoY2hhcnRYOiBudW1iZXIsIGNoYXJ0WTogbnVtYmVyLCB1c2VGaW5hbFBvc2l0aW9uOiBib29sZWFuKSB7XG4gICAgY29uc3QgcG9pbnQgPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHthbmdsZSwgZGlzdGFuY2V9ID0gZ2V0QW5nbGVGcm9tUG9pbnQocG9pbnQsIHt4OiBjaGFydFgsIHk6IGNoYXJ0WX0pO1xuICAgIGNvbnN0IHtzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBjaXJjdW1mZXJlbmNlfSA9IHRoaXMuZ2V0UHJvcHMoW1xuICAgICAgJ3N0YXJ0QW5nbGUnLFxuICAgICAgJ2VuZEFuZ2xlJyxcbiAgICAgICdpbm5lclJhZGl1cycsXG4gICAgICAnb3V0ZXJSYWRpdXMnLFxuICAgICAgJ2NpcmN1bWZlcmVuY2UnXG4gICAgXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3QgckFkanVzdCA9ICh0aGlzLm9wdGlvbnMuc3BhY2luZyArIHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aCkgLyAyO1xuICAgIGNvbnN0IF9jaXJjdW1mZXJlbmNlID0gdmFsdWVPckRlZmF1bHQoY2lyY3VtZmVyZW5jZSwgZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcbiAgICBjb25zdCBiZXR3ZWVuQW5nbGVzID0gX2NpcmN1bWZlcmVuY2UgPj0gVEFVIHx8IF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTtcbiAgICBjb25zdCB3aXRoaW5SYWRpdXMgPSBfaXNCZXR3ZWVuKGRpc3RhbmNlLCBpbm5lclJhZGl1cyArIHJBZGp1c3QsIG91dGVyUmFkaXVzICsgckFkanVzdCk7XG5cbiAgICByZXR1cm4gKGJldHdlZW5BbmdsZXMgJiYgd2l0aGluUmFkaXVzKTtcbiAgfVxuXG4gIGdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb246IGJvb2xlYW4pIHtcbiAgICBjb25zdCB7eCwgeSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1c30gPSB0aGlzLmdldFByb3BzKFtcbiAgICAgICd4JyxcbiAgICAgICd5JyxcbiAgICAgICdzdGFydEFuZ2xlJyxcbiAgICAgICdlbmRBbmdsZScsXG4gICAgICAnaW5uZXJSYWRpdXMnLFxuICAgICAgJ291dGVyUmFkaXVzJ1xuICAgIF0sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHtvZmZzZXQsIHNwYWNpbmd9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGhhbGZBbmdsZSA9IChzdGFydEFuZ2xlICsgZW5kQW5nbGUpIC8gMjtcbiAgICBjb25zdCBoYWxmUmFkaXVzID0gKGlubmVyUmFkaXVzICsgb3V0ZXJSYWRpdXMgKyBzcGFjaW5nICsgb2Zmc2V0KSAvIDI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHggKyBNYXRoLmNvcyhoYWxmQW5nbGUpICogaGFsZlJhZGl1cyxcbiAgICAgIHk6IHkgKyBNYXRoLnNpbihoYWxmQW5nbGUpICogaGFsZlJhZGl1c1xuICAgIH07XG4gIH1cblxuICB0b29sdGlwUG9zaXRpb24odXNlRmluYWxQb3NpdGlvbjogYm9vbGVhbikge1xuICAgIHJldHVybiB0aGlzLmdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG5cbiAgZHJhdyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xuICAgIGNvbnN0IHtvcHRpb25zLCBjaXJjdW1mZXJlbmNlfSA9IHRoaXM7XG4gICAgY29uc3Qgb2Zmc2V0ID0gKG9wdGlvbnMub2Zmc2V0IHx8IDApIC8gNDtcbiAgICBjb25zdCBzcGFjaW5nID0gKG9wdGlvbnMuc3BhY2luZyB8fCAwKSAvIDI7XG4gICAgY29uc3QgY2lyY3VsYXIgPSBvcHRpb25zLmNpcmN1bGFyO1xuICAgIHRoaXMucGl4ZWxNYXJnaW4gPSAob3B0aW9ucy5ib3JkZXJBbGlnbiA9PT0gJ2lubmVyJykgPyAwLjMzIDogMDtcbiAgICB0aGlzLmZ1bGxDaXJjbGVzID0gY2lyY3VtZmVyZW5jZSA+IFRBVSA/IE1hdGguZmxvb3IoY2lyY3VtZmVyZW5jZSAvIFRBVSkgOiAwO1xuXG4gICAgaWYgKGNpcmN1bWZlcmVuY2UgPT09IDAgfHwgdGhpcy5pbm5lclJhZGl1cyA8IDAgfHwgdGhpcy5vdXRlclJhZGl1cyA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdHguc2F2ZSgpO1xuXG4gICAgY29uc3QgaGFsZkFuZ2xlID0gKHRoaXMuc3RhcnRBbmdsZSArIHRoaXMuZW5kQW5nbGUpIC8gMjtcbiAgICBjdHgudHJhbnNsYXRlKE1hdGguY29zKGhhbGZBbmdsZSkgKiBvZmZzZXQsIE1hdGguc2luKGhhbGZBbmdsZSkgKiBvZmZzZXQpO1xuICAgIGNvbnN0IGZpeCA9IDEgLSBNYXRoLnNpbihNYXRoLm1pbihQSSwgY2lyY3VtZmVyZW5jZSB8fCAwKSk7XG4gICAgY29uc3QgcmFkaXVzT2Zmc2V0ID0gb2Zmc2V0ICogZml4O1xuXG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG5cbiAgICBkcmF3QXJjKGN0eCwgdGhpcywgcmFkaXVzT2Zmc2V0LCBzcGFjaW5nLCBjaXJjdWxhcik7XG4gICAgZHJhd0JvcmRlcihjdHgsIHRoaXMsIHJhZGl1c09mZnNldCwgc3BhY2luZywgY2lyY3VsYXIpO1xuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxufVxuIiwgImltcG9ydCBFbGVtZW50IGZyb20gJy4uL2NvcmUvY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCB7X2JlemllckludGVycG9sYXRpb24sIF9wb2ludEluTGluZSwgX3N0ZXBwZWRJbnRlcnBvbGF0aW9ufSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuaW50ZXJwb2xhdGlvbi5qcyc7XG5pbXBvcnQge19jb21wdXRlU2VnbWVudHMsIF9ib3VuZFNlZ21lbnRzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuc2VnbWVudC5qcyc7XG5pbXBvcnQge19zdGVwcGVkTGluZVRvLCBfYmV6aWVyQ3VydmVUb30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNhbnZhcy5qcyc7XG5pbXBvcnQge191cGRhdGVCZXppZXJDb250cm9sUG9pbnRzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY3VydmUuanMnO1xuaW1wb3J0IHt2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vZWxlbWVudC5wb2ludC5qcycpLmRlZmF1bHQgfSBQb2ludEVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBzZXRTdHlsZShjdHgsIG9wdGlvbnMsIHN0eWxlID0gb3B0aW9ucykge1xuICBjdHgubGluZUNhcCA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckNhcFN0eWxlLCBvcHRpb25zLmJvcmRlckNhcFN0eWxlKTtcbiAgY3R4LnNldExpbmVEYXNoKHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckRhc2gsIG9wdGlvbnMuYm9yZGVyRGFzaCkpO1xuICBjdHgubGluZURhc2hPZmZzZXQgPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJEYXNoT2Zmc2V0LCBvcHRpb25zLmJvcmRlckRhc2hPZmZzZXQpO1xuICBjdHgubGluZUpvaW4gPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJKb2luU3R5bGUsIG9wdGlvbnMuYm9yZGVySm9pblN0eWxlKTtcbiAgY3R4LmxpbmVXaWR0aCA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlcldpZHRoLCBvcHRpb25zLmJvcmRlcldpZHRoKTtcbiAgY3R4LnN0cm9rZVN0eWxlID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyQ29sb3IsIG9wdGlvbnMuYm9yZGVyQ29sb3IpO1xufVxuXG5mdW5jdGlvbiBsaW5lVG8oY3R4LCBwcmV2aW91cywgdGFyZ2V0KSB7XG4gIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5mdW5jdGlvbiBnZXRMaW5lTWV0aG9kKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuc3RlcHBlZCkge1xuICAgIHJldHVybiBfc3RlcHBlZExpbmVUbztcbiAgfVxuXG4gIGlmIChvcHRpb25zLnRlbnNpb24gfHwgb3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSB7XG4gICAgcmV0dXJuIF9iZXppZXJDdXJ2ZVRvO1xuICB9XG5cbiAgcmV0dXJuIGxpbmVUbztcbn1cblxuZnVuY3Rpb24gcGF0aFZhcnMocG9pbnRzLCBzZWdtZW50LCBwYXJhbXMgPSB7fSkge1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IHtzdGFydDogcGFyYW1zU3RhcnQgPSAwLCBlbmQ6IHBhcmFtc0VuZCA9IGNvdW50IC0gMX0gPSBwYXJhbXM7XG4gIGNvbnN0IHtzdGFydDogc2VnbWVudFN0YXJ0LCBlbmQ6IHNlZ21lbnRFbmR9ID0gc2VnbWVudDtcbiAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heChwYXJhbXNTdGFydCwgc2VnbWVudFN0YXJ0KTtcbiAgY29uc3QgZW5kID0gTWF0aC5taW4ocGFyYW1zRW5kLCBzZWdtZW50RW5kKTtcbiAgY29uc3Qgb3V0c2lkZSA9IHBhcmFtc1N0YXJ0IDwgc2VnbWVudFN0YXJ0ICYmIHBhcmFtc0VuZCA8IHNlZ21lbnRTdGFydCB8fCBwYXJhbXNTdGFydCA+IHNlZ21lbnRFbmQgJiYgcGFyYW1zRW5kID4gc2VnbWVudEVuZDtcblxuICByZXR1cm4ge1xuICAgIGNvdW50LFxuICAgIHN0YXJ0LFxuICAgIGxvb3A6IHNlZ21lbnQubG9vcCxcbiAgICBpbGVuOiBlbmQgPCBzdGFydCAmJiAhb3V0c2lkZSA/IGNvdW50ICsgZW5kIC0gc3RhcnQgOiBlbmQgLSBzdGFydFxuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZSBwYXRoIGZyb20gcG9pbnRzLCBncm91cGluZyBieSB0cnVuY2F0ZWQgeC1jb29yZGluYXRlXG4gKiBQb2ludHMgbmVlZCB0byBiZSBpbiBvcmRlciBieSB4LWNvb3JkaW5hdGUgZm9yIHRoaXMgdG8gd29yayBlZmZpY2llbnRseVxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR8UGF0aDJEfSBjdHggLSBDb250ZXh0XG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcGFyYW0ge29iamVjdH0gc2VnbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnQuc3RhcnQgLSBzdGFydCBpbmRleCBvZiB0aGUgc2VnbWVudCwgcmVmZXJyaW5nIHRoZSBwb2ludHMgYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LmVuZCAtIGVuZCBpbmRleCBvZiB0aGUgc2VnbWVudCwgcmVmZXJyaW5nIHRoZSBwb2ludHMgYXJyYXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VnbWVudC5sb29wIC0gaW5kaWNhdGVzIHRoYXQgdGhlIHNlZ21lbnQgaXMgYSBsb29wXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5tb3ZlIC0gbW92ZSB0byBzdGFydGluZyBwb2ludCAodnMgbGluZSB0byBpdClcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLnJldmVyc2UgLSBwYXRoIHRoZSBzZWdtZW50IGZyb20gZW5kIHRvIHN0YXJ0XG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnN0YXJ0IC0gbGltaXQgc2VnbWVudCB0byBwb2ludHMgc3RhcnRpbmcgZnJvbSBgc3RhcnRgIGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmVuZCAtIGxpbWl0IHNlZ21lbnQgdG8gcG9pbnRzIGVuZGluZyBhdCBgc3RhcnRgICsgYGNvdW50YCBpbmRleFxuICovXG5mdW5jdGlvbiBwYXRoU2VnbWVudChjdHgsIGxpbmUsIHNlZ21lbnQsIHBhcmFtcykge1xuICBjb25zdCB7cG9pbnRzLCBvcHRpb25zfSA9IGxpbmU7XG4gIGNvbnN0IHtjb3VudCwgc3RhcnQsIGxvb3AsIGlsZW59ID0gcGF0aFZhcnMocG9pbnRzLCBzZWdtZW50LCBwYXJhbXMpO1xuICBjb25zdCBsaW5lTWV0aG9kID0gZ2V0TGluZU1ldGhvZChvcHRpb25zKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICBsZXQge21vdmUgPSB0cnVlLCByZXZlcnNlfSA9IHBhcmFtcyB8fCB7fTtcbiAgbGV0IGksIHBvaW50LCBwcmV2O1xuXG4gIGZvciAoaSA9IDA7IGkgPD0gaWxlbjsgKytpKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbKHN0YXJ0ICsgKHJldmVyc2UgPyBpbGVuIC0gaSA6IGkpKSAlIGNvdW50XTtcblxuICAgIGlmIChwb2ludC5za2lwKSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBhIHNraXBwZWQgcG9pbnQgaW5zaWRlIGEgc2VnbWVudCwgc3BhbkdhcHMgbXVzdCBiZSB0cnVlXG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKG1vdmUpIHtcbiAgICAgIGN0eC5tb3ZlVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICBtb3ZlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmVNZXRob2QoY3R4LCBwcmV2LCBwb2ludCwgcmV2ZXJzZSwgb3B0aW9ucy5zdGVwcGVkKTtcbiAgICB9XG5cbiAgICBwcmV2ID0gcG9pbnQ7XG4gIH1cblxuICBpZiAobG9vcCkge1xuICAgIHBvaW50ID0gcG9pbnRzWyhzdGFydCArIChyZXZlcnNlID8gaWxlbiA6IDApKSAlIGNvdW50XTtcbiAgICBsaW5lTWV0aG9kKGN0eCwgcHJldiwgcG9pbnQsIHJldmVyc2UsIG9wdGlvbnMuc3RlcHBlZCk7XG4gIH1cblxuICByZXR1cm4gISFsb29wO1xufVxuXG4vKipcbiAqIENyZWF0ZSBwYXRoIGZyb20gcG9pbnRzLCBncm91cGluZyBieSB0cnVuY2F0ZWQgeC1jb29yZGluYXRlXG4gKiBQb2ludHMgbmVlZCB0byBiZSBpbiBvcmRlciBieSB4LWNvb3JkaW5hdGUgZm9yIHRoaXMgdG8gd29yayBlZmZpY2llbnRseVxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR8UGF0aDJEfSBjdHggLSBDb250ZXh0XG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcGFyYW0ge29iamVjdH0gc2VnbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnQuc3RhcnQgLSBzdGFydCBpbmRleCBvZiB0aGUgc2VnbWVudCwgcmVmZXJyaW5nIHRoZSBwb2ludHMgYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LmVuZCAtIGVuZCBpbmRleCBvZiB0aGUgc2VnbWVudCwgcmVmZXJyaW5nIHRoZSBwb2ludHMgYXJyYXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VnbWVudC5sb29wIC0gaW5kaWNhdGVzIHRoYXQgdGhlIHNlZ21lbnQgaXMgYSBsb29wXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5tb3ZlIC0gbW92ZSB0byBzdGFydGluZyBwb2ludCAodnMgbGluZSB0byBpdClcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLnJldmVyc2UgLSBwYXRoIHRoZSBzZWdtZW50IGZyb20gZW5kIHRvIHN0YXJ0XG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnN0YXJ0IC0gbGltaXQgc2VnbWVudCB0byBwb2ludHMgc3RhcnRpbmcgZnJvbSBgc3RhcnRgIGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmVuZCAtIGxpbWl0IHNlZ21lbnQgdG8gcG9pbnRzIGVuZGluZyBhdCBgc3RhcnRgICsgYGNvdW50YCBpbmRleFxuICovXG5mdW5jdGlvbiBmYXN0UGF0aFNlZ21lbnQoY3R4LCBsaW5lLCBzZWdtZW50LCBwYXJhbXMpIHtcbiAgY29uc3QgcG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IHtjb3VudCwgc3RhcnQsIGlsZW59ID0gcGF0aFZhcnMocG9pbnRzLCBzZWdtZW50LCBwYXJhbXMpO1xuICBjb25zdCB7bW92ZSA9IHRydWUsIHJldmVyc2V9ID0gcGFyYW1zIHx8IHt9O1xuICBsZXQgYXZnWCA9IDA7XG4gIGxldCBjb3VudFggPSAwO1xuICBsZXQgaSwgcG9pbnQsIHByZXZYLCBtaW5ZLCBtYXhZLCBsYXN0WTtcblxuICBjb25zdCBwb2ludEluZGV4ID0gKGluZGV4KSA9PiAoc3RhcnQgKyAocmV2ZXJzZSA/IGlsZW4gLSBpbmRleCA6IGluZGV4KSkgJSBjb3VudDtcbiAgY29uc3QgZHJhd1ggPSAoKSA9PiB7XG4gICAgaWYgKG1pblkgIT09IG1heFkpIHtcbiAgICAgIC8vIERyYXcgbGluZSB0byBtYXhZIGFuZCBtaW5ZLCB1c2luZyB0aGUgYXZlcmFnZSB4LWNvb3JkaW5hdGVcbiAgICAgIGN0eC5saW5lVG8oYXZnWCwgbWF4WSk7XG4gICAgICBjdHgubGluZVRvKGF2Z1gsIG1pblkpO1xuICAgICAgLy8gTGluZSB0byB5LXZhbHVlIG9mIGxhc3QgcG9pbnQgaW4gZ3JvdXAuIFNvIHRoZSBsaW5lIGNvbnRpbnVlc1xuICAgICAgLy8gZnJvbSBjb3JyZWN0IHBvc2l0aW9uLiBOb3QgdXNpbmcgbW92ZSwgdG8gaGF2ZSBzb2xpZCBwYXRoLlxuICAgICAgY3R4LmxpbmVUbyhhdmdYLCBsYXN0WSk7XG4gICAgfVxuICB9O1xuXG4gIGlmIChtb3ZlKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbcG9pbnRJbmRleCgwKV07XG4gICAgY3R4Lm1vdmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPD0gaWxlbjsgKytpKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbcG9pbnRJbmRleChpKV07XG5cbiAgICBpZiAocG9pbnQuc2tpcCkge1xuICAgICAgLy8gSWYgdGhlcmUgaXMgYSBza2lwcGVkIHBvaW50IGluc2lkZSBhIHNlZ21lbnQsIHNwYW5HYXBzIG11c3QgYmUgdHJ1ZVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgeCA9IHBvaW50Lng7XG4gICAgY29uc3QgeSA9IHBvaW50Lnk7XG4gICAgY29uc3QgdHJ1bmNYID0geCB8IDA7IC8vIHRydW5jYXRlZCB4LWNvb3JkaW5hdGVcblxuICAgIGlmICh0cnVuY1ggPT09IHByZXZYKSB7XG4gICAgICAvLyBEZXRlcm1pbmUgYG1pbllgIC8gYG1heFlgIGFuZCBgYXZnWGAgd2hpbGUgd2Ugc3RheSB3aXRoaW4gc2FtZSB4LXBvc2l0aW9uXG4gICAgICBpZiAoeSA8IG1pblkpIHtcbiAgICAgICAgbWluWSA9IHk7XG4gICAgICB9IGVsc2UgaWYgKHkgPiBtYXhZKSB7XG4gICAgICAgIG1heFkgPSB5O1xuICAgICAgfVxuICAgICAgLy8gRm9yIGZpcnN0IHBvaW50IGluIGdyb3VwLCBjb3VudFggaXMgYDBgLCBzbyBhdmVyYWdlIHdpbGwgYmUgYHhgIC8gMS5cbiAgICAgIGF2Z1ggPSAoY291bnRYICogYXZnWCArIHgpIC8gKytjb3VudFg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRyYXdYKCk7XG4gICAgICAvLyBEcmF3IGxpbmUgdG8gbmV4dCB4LXBvc2l0aW9uLCB1c2luZyB0aGUgZmlyc3QgKG9yIG9ubHkpXG4gICAgICAvLyB5LXZhbHVlIGluIHRoYXQgZ3JvdXBcbiAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG5cbiAgICAgIHByZXZYID0gdHJ1bmNYO1xuICAgICAgY291bnRYID0gMDtcbiAgICAgIG1pblkgPSBtYXhZID0geTtcbiAgICB9XG4gICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgbGFzdCB5LXZhbHVlIGluIGdyb3VwXG4gICAgbGFzdFkgPSB5O1xuICB9XG4gIGRyYXdYKCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZSAtIHRoZSBsaW5lXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfZ2V0U2VnbWVudE1ldGhvZChsaW5lKSB7XG4gIGNvbnN0IG9wdHMgPSBsaW5lLm9wdGlvbnM7XG4gIGNvbnN0IGJvcmRlckRhc2ggPSBvcHRzLmJvcmRlckRhc2ggJiYgb3B0cy5ib3JkZXJEYXNoLmxlbmd0aDtcbiAgY29uc3QgdXNlRmFzdFBhdGggPSAhbGluZS5fZGVjaW1hdGVkICYmICFsaW5lLl9sb29wICYmICFvcHRzLnRlbnNpb24gJiYgb3B0cy5jdWJpY0ludGVycG9sYXRpb25Nb2RlICE9PSAnbW9ub3RvbmUnICYmICFvcHRzLnN0ZXBwZWQgJiYgIWJvcmRlckRhc2g7XG4gIHJldHVybiB1c2VGYXN0UGF0aCA/IGZhc3RQYXRoU2VnbWVudCA6IHBhdGhTZWdtZW50O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9nZXRJbnRlcnBvbGF0aW9uTWV0aG9kKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuc3RlcHBlZCkge1xuICAgIHJldHVybiBfc3RlcHBlZEludGVycG9sYXRpb247XG4gIH1cblxuICBpZiAob3B0aW9ucy50ZW5zaW9uIHx8IG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xuICAgIHJldHVybiBfYmV6aWVySW50ZXJwb2xhdGlvbjtcbiAgfVxuXG4gIHJldHVybiBfcG9pbnRJbkxpbmU7XG59XG5cbmZ1bmN0aW9uIHN0cm9rZVBhdGhXaXRoQ2FjaGUoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpIHtcbiAgbGV0IHBhdGggPSBsaW5lLl9wYXRoO1xuICBpZiAoIXBhdGgpIHtcbiAgICBwYXRoID0gbGluZS5fcGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgICBpZiAobGluZS5wYXRoKHBhdGgsIHN0YXJ0LCBjb3VudCkpIHtcbiAgICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gICAgfVxuICB9XG4gIHNldFN0eWxlKGN0eCwgbGluZS5vcHRpb25zKTtcbiAgY3R4LnN0cm9rZShwYXRoKTtcbn1cblxuZnVuY3Rpb24gc3Ryb2tlUGF0aERpcmVjdChjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCkge1xuICBjb25zdCB7c2VnbWVudHMsIG9wdGlvbnN9ID0gbGluZTtcbiAgY29uc3Qgc2VnbWVudE1ldGhvZCA9IF9nZXRTZWdtZW50TWV0aG9kKGxpbmUpO1xuXG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgIHNldFN0eWxlKGN0eCwgb3B0aW9ucywgc2VnbWVudC5zdHlsZSk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGlmIChzZWdtZW50TWV0aG9kKGN0eCwgbGluZSwgc2VnbWVudCwge3N0YXJ0LCBlbmQ6IHN0YXJ0ICsgY291bnQgLSAxfSkpIHtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5cbmNvbnN0IHVzZVBhdGgyRCA9IHR5cGVvZiBQYXRoMkQgPT09ICdmdW5jdGlvbic7XG5cbmZ1bmN0aW9uIGRyYXcoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpIHtcbiAgaWYgKHVzZVBhdGgyRCAmJiAhbGluZS5vcHRpb25zLnNlZ21lbnQpIHtcbiAgICBzdHJva2VQYXRoV2l0aENhY2hlKGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KTtcbiAgfSBlbHNlIHtcbiAgICBzdHJva2VQYXRoRGlyZWN0KGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5lRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuXG4gIHN0YXRpYyBpZCA9ICdsaW5lJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBib3JkZXJDYXBTdHlsZTogJ2J1dHQnLFxuICAgIGJvcmRlckRhc2g6IFtdLFxuICAgIGJvcmRlckRhc2hPZmZzZXQ6IDAsXG4gICAgYm9yZGVySm9pblN0eWxlOiAnbWl0ZXInLFxuICAgIGJvcmRlcldpZHRoOiAzLFxuICAgIGNhcEJlemllclBvaW50czogdHJ1ZSxcbiAgICBjdWJpY0ludGVycG9sYXRpb25Nb2RlOiAnZGVmYXVsdCcsXG4gICAgZmlsbDogZmFsc2UsXG4gICAgc3BhbkdhcHM6IGZhbHNlLFxuICAgIHN0ZXBwZWQ6IGZhbHNlLFxuICAgIHRlbnNpb246IDAsXG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdFJvdXRlcyA9IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InLFxuICAgIGJvcmRlckNvbG9yOiAnYm9yZGVyQ29sb3InXG4gIH07XG5cblxuICBzdGF0aWMgZGVzY3JpcHRvcnMgPSB7XG4gICAgX3NjcmlwdGFibGU6IHRydWUsXG4gICAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdib3JkZXJEYXNoJyAmJiBuYW1lICE9PSAnZmlsbCcsXG4gIH07XG5cblxuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5hbmltYXRlZCA9IHRydWU7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2NoYXJ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2xvb3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZnVsbExvb3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcGF0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wb2ludHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc2VnbWVudHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZGVjaW1hdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcG9pbnRzVXBkYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2RhdGFzZXRJbmRleCA9IHVuZGVmaW5lZDtcblxuICAgIGlmIChjZmcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVDb250cm9sUG9pbnRzKGNoYXJ0QXJlYSwgaW5kZXhBeGlzKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoKG9wdGlvbnMudGVuc2lvbiB8fCBvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpICYmICFvcHRpb25zLnN0ZXBwZWQgJiYgIXRoaXMuX3BvaW50c1VwZGF0ZWQpIHtcbiAgICAgIGNvbnN0IGxvb3AgPSBvcHRpb25zLnNwYW5HYXBzID8gdGhpcy5fbG9vcCA6IHRoaXMuX2Z1bGxMb29wO1xuICAgICAgX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHModGhpcy5fcG9pbnRzLCBvcHRpb25zLCBjaGFydEFyZWEsIGxvb3AsIGluZGV4QXhpcyk7XG4gICAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBzZXQgcG9pbnRzKHBvaW50cykge1xuICAgIHRoaXMuX3BvaW50cyA9IHBvaW50cztcbiAgICBkZWxldGUgdGhpcy5fc2VnbWVudHM7XG4gICAgZGVsZXRlIHRoaXMuX3BhdGg7XG4gICAgdGhpcy5fcG9pbnRzVXBkYXRlZCA9IGZhbHNlO1xuICB9XG5cbiAgZ2V0IHBvaW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9pbnRzO1xuICB9XG5cbiAgZ2V0IHNlZ21lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWdtZW50cyB8fCAodGhpcy5fc2VnbWVudHMgPSBfY29tcHV0ZVNlZ21lbnRzKHRoaXMsIHRoaXMub3B0aW9ucy5zZWdtZW50KSk7XG4gIH1cblxuICAvKipcblx0ICogRmlyc3Qgbm9uLXNraXBwZWQgcG9pbnQgb24gdGhpcyBsaW5lXG5cdCAqIEByZXR1cm5zIHtQb2ludEVsZW1lbnR8dW5kZWZpbmVkfVxuXHQgKi9cbiAgZmlyc3QoKSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgIHJldHVybiBzZWdtZW50cy5sZW5ndGggJiYgcG9pbnRzW3NlZ21lbnRzWzBdLnN0YXJ0XTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBMYXN0IG5vbi1za2lwcGVkIHBvaW50IG9uIHRoaXMgbGluZVxuXHQgKiBAcmV0dXJucyB7UG9pbnRFbGVtZW50fHVuZGVmaW5lZH1cblx0ICovXG4gIGxhc3QoKSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgIGNvbnN0IGNvdW50ID0gc2VnbWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBjb3VudCAmJiBwb2ludHNbc2VnbWVudHNbY291bnQgLSAxXS5lbmRdO1xuICB9XG5cbiAgLyoqXG5cdCAqIEludGVycG9sYXRlIGEgcG9pbnQgaW4gdGhpcyBsaW5lIGF0IHRoZSBzYW1lIHZhbHVlIG9uIGBwcm9wZXJ0eWAgYXNcblx0ICogdGhlIHJlZmVyZW5jZSBgcG9pbnRgIHByb3ZpZGVkXG5cdCAqIEBwYXJhbSB7UG9pbnRFbGVtZW50fSBwb2ludCAtIHRoZSByZWZlcmVuY2UgcG9pbnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IC0gdGhlIHByb3BlcnR5IHRvIG1hdGNoIG9uXG5cdCAqIEByZXR1cm5zIHtQb2ludEVsZW1lbnR8dW5kZWZpbmVkfVxuXHQgKi9cbiAgaW50ZXJwb2xhdGUocG9pbnQsIHByb3BlcnR5KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB2YWx1ZSA9IHBvaW50W3Byb3BlcnR5XTtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICBjb25zdCBzZWdtZW50cyA9IF9ib3VuZFNlZ21lbnRzKHRoaXMsIHtwcm9wZXJ0eSwgc3RhcnQ6IHZhbHVlLCBlbmQ6IHZhbHVlfSk7XG5cbiAgICBpZiAoIXNlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IF9pbnRlcnBvbGF0ZSA9IF9nZXRJbnRlcnBvbGF0aW9uTWV0aG9kKG9wdGlvbnMpO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IHtzdGFydCwgZW5kfSA9IHNlZ21lbnRzW2ldO1xuICAgICAgY29uc3QgcDEgPSBwb2ludHNbc3RhcnRdO1xuICAgICAgY29uc3QgcDIgPSBwb2ludHNbZW5kXTtcbiAgICAgIGlmIChwMSA9PT0gcDIpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gocDEpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHQgPSBNYXRoLmFicygodmFsdWUgLSBwMVtwcm9wZXJ0eV0pIC8gKHAyW3Byb3BlcnR5XSAtIHAxW3Byb3BlcnR5XSkpO1xuICAgICAgY29uc3QgaW50ZXJwb2xhdGVkID0gX2ludGVycG9sYXRlKHAxLCBwMiwgdCwgb3B0aW9ucy5zdGVwcGVkKTtcbiAgICAgIGludGVycG9sYXRlZFtwcm9wZXJ0eV0gPSBwb2ludFtwcm9wZXJ0eV07XG4gICAgICByZXN1bHQucHVzaChpbnRlcnBvbGF0ZWQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PT0gMSA/IHJlc3VsdFswXSA6IHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBcHBlbmQgYSBzZWdtZW50IG9mIHRoaXMgbGluZSB0byBjdXJyZW50IHBhdGguXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICogQHBhcmFtIHtvYmplY3R9IHNlZ21lbnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnQuc3RhcnQgLSBzdGFydCBpbmRleCBvZiB0aGUgc2VnbWVudCwgcmVmZXJyaW5nIHRoZSBwb2ludHMgYXJyYXlcbiBcdCAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LmVuZCAtIGVuZCBpbmRleCBvZiB0aGUgc2VnbWVudCwgcmVmZXJyaW5nIHRoZSBwb2ludHMgYXJyYXlcbiBcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VnbWVudC5sb29wIC0gaW5kaWNhdGVzIHRoYXQgdGhlIHNlZ21lbnQgaXMgYSBsb29wXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcblx0ICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMubW92ZSAtIG1vdmUgdG8gc3RhcnRpbmcgcG9pbnQgKHZzIGxpbmUgdG8gaXQpXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLnJldmVyc2UgLSBwYXRoIHRoZSBzZWdtZW50IGZyb20gZW5kIHRvIHN0YXJ0XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuc3RhcnQgLSBsaW1pdCBzZWdtZW50IHRvIHBvaW50cyBzdGFydGluZyBmcm9tIGBzdGFydGAgaW5kZXhcblx0ICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5lbmQgLSBsaW1pdCBzZWdtZW50IHRvIHBvaW50cyBlbmRpbmcgYXQgYHN0YXJ0YCArIGBjb3VudGAgaW5kZXhcblx0ICogQHJldHVybnMge3VuZGVmaW5lZHxib29sZWFufSAtIHRydWUgaWYgdGhlIHNlZ21lbnQgaXMgYSBmdWxsIGxvb3AgKHBhdGggc2hvdWxkIGJlIGNsb3NlZClcblx0ICovXG4gIHBhdGhTZWdtZW50KGN0eCwgc2VnbWVudCwgcGFyYW1zKSB7XG4gICAgY29uc3Qgc2VnbWVudE1ldGhvZCA9IF9nZXRTZWdtZW50TWV0aG9kKHRoaXMpO1xuICAgIHJldHVybiBzZWdtZW50TWV0aG9kKGN0eCwgdGhpcywgc2VnbWVudCwgcGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBcHBlbmQgYWxsIHNlZ21lbnRzIG9mIHRoaXMgbGluZSB0byBjdXJyZW50IHBhdGguXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfFBhdGgyRH0gY3R4XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRdXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbY291bnRdXG5cdCAqIEByZXR1cm5zIHt1bmRlZmluZWR8Ym9vbGVhbn0gLSB0cnVlIGlmIGxpbmUgaXMgYSBmdWxsIGxvb3AgKHBhdGggc2hvdWxkIGJlIGNsb3NlZClcblx0ICovXG4gIHBhdGgoY3R4LCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgY29uc3Qgc2VnbWVudE1ldGhvZCA9IF9nZXRTZWdtZW50TWV0aG9kKHRoaXMpO1xuICAgIGxldCBsb29wID0gdGhpcy5fbG9vcDtcblxuICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgICBjb3VudCA9IGNvdW50IHx8ICh0aGlzLnBvaW50cy5sZW5ndGggLSBzdGFydCk7XG5cbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICAgIGxvb3AgJj0gc2VnbWVudE1ldGhvZChjdHgsIHRoaXMsIHNlZ21lbnQsIHtzdGFydCwgZW5kOiBzdGFydCArIGNvdW50IC0gMX0pO1xuICAgIH1cbiAgICByZXR1cm4gISFsb29wO1xuICB9XG5cbiAgLyoqXG5cdCAqIERyYXdcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuXHQgKiBAcGFyYW0ge29iamVjdH0gY2hhcnRBcmVhXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRdXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbY291bnRdXG5cdCAqL1xuICBkcmF3KGN0eCwgY2hhcnRBcmVhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzIHx8IFtdO1xuXG4gICAgaWYgKHBvaW50cy5sZW5ndGggJiYgb3B0aW9ucy5ib3JkZXJXaWR0aCkge1xuICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgZHJhdyhjdHgsIHRoaXMsIHN0YXJ0LCBjb3VudCk7XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYW5pbWF0ZWQpIHtcbiAgICAgIC8vIFdoZW4gbGluZSBpcyBhbmltYXRlZCwgdGhlIGNvbnRyb2wgcG9pbnRzIGFuZCBwYXRoIGFyZSBub3QgY2FjaGVkLlxuICAgICAgdGhpcy5fcG9pbnRzVXBkYXRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fcGF0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQgRWxlbWVudCBmcm9tICcuLi9jb3JlL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQge2RyYXdQb2ludCwgX2lzUG9pbnRJbkFyZWF9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHR5cGUge1xuICBDYXJ0ZXNpYW5QYXJzZWREYXRhLFxuICBDaGFydEFyZWEsXG4gIFBvaW50LFxuICBQb2ludEhvdmVyT3B0aW9ucyxcbiAgUG9pbnRPcHRpb25zLFxufSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5cbmZ1bmN0aW9uIGluUmFuZ2UoZWw6IFBvaW50RWxlbWVudCwgcG9zOiBudW1iZXIsIGF4aXM6ICd4JyB8ICd5JywgdXNlRmluYWxQb3NpdGlvbj86IGJvb2xlYW4pIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGVsLm9wdGlvbnM7XG4gIGNvbnN0IHtbYXhpc106IHZhbHVlfSA9IGVsLmdldFByb3BzKFtheGlzXSwgdXNlRmluYWxQb3NpdGlvbik7XG5cbiAgcmV0dXJuIChNYXRoLmFicyhwb3MgLSB2YWx1ZSkgPCBvcHRpb25zLnJhZGl1cyArIG9wdGlvbnMuaGl0UmFkaXVzKTtcbn1cblxuZXhwb3J0IHR5cGUgUG9pbnRQcm9wcyA9IFBvaW50XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvaW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ8UG9pbnRQcm9wcywgUG9pbnRPcHRpb25zICYgUG9pbnRIb3Zlck9wdGlvbnM+IHtcblxuICBzdGF0aWMgaWQgPSAncG9pbnQnO1xuXG4gIHBhcnNlZDogQ2FydGVzaWFuUGFyc2VkRGF0YTtcbiAgc2tpcD86IGJvb2xlYW47XG4gIHN0b3A/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGJvcmRlcldpZHRoOiAxLFxuICAgIGhpdFJhZGl1czogMSxcbiAgICBob3ZlckJvcmRlcldpZHRoOiAxLFxuICAgIGhvdmVyUmFkaXVzOiA0LFxuICAgIHBvaW50U3R5bGU6ICdjaXJjbGUnLFxuICAgIHJhZGl1czogMyxcbiAgICByb3RhdGlvbjogMFxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJyxcbiAgICBib3JkZXJDb2xvcjogJ2JvcmRlckNvbG9yJ1xuICB9O1xuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYXJzZWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5za2lwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc3RvcCA9IHVuZGVmaW5lZDtcblxuICAgIGlmIChjZmcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICB9XG4gIH1cblxuICBpblJhbmdlKG1vdXNlWDogbnVtYmVyLCBtb3VzZVk6IG51bWJlciwgdXNlRmluYWxQb3NpdGlvbj86IGJvb2xlYW4pIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHt4LCB5fSA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgcmV0dXJuICgoTWF0aC5wb3cobW91c2VYIC0geCwgMikgKyBNYXRoLnBvdyhtb3VzZVkgLSB5LCAyKSkgPCBNYXRoLnBvdyhvcHRpb25zLmhpdFJhZGl1cyArIG9wdGlvbnMucmFkaXVzLCAyKSk7XG4gIH1cblxuICBpblhSYW5nZShtb3VzZVg6IG51bWJlciwgdXNlRmluYWxQb3NpdGlvbj86IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBtb3VzZVgsICd4JywgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cblxuICBpbllSYW5nZShtb3VzZVk6IG51bWJlciwgdXNlRmluYWxQb3NpdGlvbj86IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBtb3VzZVksICd5JywgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cblxuICBnZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uPzogYm9vbGVhbikge1xuICAgIGNvbnN0IHt4LCB5fSA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgcmV0dXJuIHt4LCB5fTtcbiAgfVxuXG4gIHNpemUob3B0aW9ucz86IFBhcnRpYWw8UG9pbnRPcHRpb25zICYgUG9pbnRIb3Zlck9wdGlvbnM+KSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgIGxldCByYWRpdXMgPSBvcHRpb25zLnJhZGl1cyB8fCAwO1xuICAgIHJhZGl1cyA9IE1hdGgubWF4KHJhZGl1cywgcmFkaXVzICYmIG9wdGlvbnMuaG92ZXJSYWRpdXMgfHwgMCk7XG4gICAgY29uc3QgYm9yZGVyV2lkdGggPSByYWRpdXMgJiYgb3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwO1xuICAgIHJldHVybiAocmFkaXVzICsgYm9yZGVyV2lkdGgpICogMjtcbiAgfVxuXG4gIGRyYXcoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGFyZWE6IENoYXJ0QXJlYSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBpZiAodGhpcy5za2lwIHx8IG9wdGlvbnMucmFkaXVzIDwgMC4xIHx8ICFfaXNQb2ludEluQXJlYSh0aGlzLCBhcmVhLCB0aGlzLnNpemUob3B0aW9ucykgLyAyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG4gICAgY3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgIGRyYXdQb2ludChjdHgsIG9wdGlvbnMsIHRoaXMueCwgdGhpcy55KTtcbiAgfVxuXG4gIGdldFJhbmdlKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgfHwge307XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBGYWxsYmFja3Mgc2hvdWxkIG5ldmVyIGJlIGhpdCBpbiBwcmFjdGljZVxuICAgIHJldHVybiBvcHRpb25zLnJhZGl1cyArIG9wdGlvbnMuaGl0UmFkaXVzO1xuICB9XG59XG4iLCAiaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi4vY29yZS9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IHtpc09iamVjdCwgX2lzQmV0d2VlbiwgX2xpbWl0VmFsdWV9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHthZGRSb3VuZGVkUmVjdFBhdGh9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHt0b1RSQkwsIHRvVFJCTENvcm5lcnN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLmpzJztcblxuLyoqIEB0eXBlZGVmIHt7IHg6IG51bWJlciwgeTogbnVtYmVyLCBiYXNlOiBudW1iZXIsIGhvcml6b250YWw6IGJvb2xlYW4sIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyIH19IEJhclByb3BzICovXG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgYm91bmRzIG9mIHRoZSBiYXIgcmVnYXJkbGVzcyBvZiB0aGUgb3JpZW50YXRpb25cbiAqIEBwYXJhbSB7QmFyRWxlbWVudH0gYmFyIHRoZSBiYXJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dXG4gKiBAcmV0dXJuIHtvYmplY3R9IGJvdW5kcyBvZiB0aGUgYmFyXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRCYXJCb3VuZHMoYmFyLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGNvbnN0IHt4LCB5LCBiYXNlLCB3aWR0aCwgaGVpZ2h0fSA9IC8qKiBAdHlwZSB7QmFyUHJvcHN9ICovIChiYXIuZ2V0UHJvcHMoWyd4JywgJ3knLCAnYmFzZScsICd3aWR0aCcsICdoZWlnaHQnXSwgdXNlRmluYWxQb3NpdGlvbikpO1xuXG4gIGxldCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIGhhbGY7XG5cbiAgaWYgKGJhci5ob3Jpem9udGFsKSB7XG4gICAgaGFsZiA9IGhlaWdodCAvIDI7XG4gICAgbGVmdCA9IE1hdGgubWluKHgsIGJhc2UpO1xuICAgIHJpZ2h0ID0gTWF0aC5tYXgoeCwgYmFzZSk7XG4gICAgdG9wID0geSAtIGhhbGY7XG4gICAgYm90dG9tID0geSArIGhhbGY7XG4gIH0gZWxzZSB7XG4gICAgaGFsZiA9IHdpZHRoIC8gMjtcbiAgICBsZWZ0ID0geCAtIGhhbGY7XG4gICAgcmlnaHQgPSB4ICsgaGFsZjtcbiAgICB0b3AgPSBNYXRoLm1pbih5LCBiYXNlKTtcbiAgICBib3R0b20gPSBNYXRoLm1heCh5LCBiYXNlKTtcbiAgfVxuXG4gIHJldHVybiB7bGVmdCwgdG9wLCByaWdodCwgYm90dG9tfTtcbn1cblxuZnVuY3Rpb24gc2tpcE9yTGltaXQoc2tpcCwgdmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBza2lwID8gMCA6IF9saW1pdFZhbHVlKHZhbHVlLCBtaW4sIG1heCk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQm9yZGVyV2lkdGgoYmFyLCBtYXhXLCBtYXhIKSB7XG4gIGNvbnN0IHZhbHVlID0gYmFyLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gIGNvbnN0IHNraXAgPSBiYXIuYm9yZGVyU2tpcHBlZDtcbiAgY29uc3QgbyA9IHRvVFJCTCh2YWx1ZSk7XG5cbiAgcmV0dXJuIHtcbiAgICB0OiBza2lwT3JMaW1pdChza2lwLnRvcCwgby50b3AsIDAsIG1heEgpLFxuICAgIHI6IHNraXBPckxpbWl0KHNraXAucmlnaHQsIG8ucmlnaHQsIDAsIG1heFcpLFxuICAgIGI6IHNraXBPckxpbWl0KHNraXAuYm90dG9tLCBvLmJvdHRvbSwgMCwgbWF4SCksXG4gICAgbDogc2tpcE9yTGltaXQoc2tpcC5sZWZ0LCBvLmxlZnQsIDAsIG1heFcpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlQm9yZGVyUmFkaXVzKGJhciwgbWF4VywgbWF4SCkge1xuICBjb25zdCB7ZW5hYmxlQm9yZGVyUmFkaXVzfSA9IGJhci5nZXRQcm9wcyhbJ2VuYWJsZUJvcmRlclJhZGl1cyddKTtcbiAgY29uc3QgdmFsdWUgPSBiYXIub3B0aW9ucy5ib3JkZXJSYWRpdXM7XG4gIGNvbnN0IG8gPSB0b1RSQkxDb3JuZXJzKHZhbHVlKTtcbiAgY29uc3QgbWF4UiA9IE1hdGgubWluKG1heFcsIG1heEgpO1xuICBjb25zdCBza2lwID0gYmFyLmJvcmRlclNraXBwZWQ7XG5cbiAgLy8gSWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdCwgYXNzdW1lIHRoZSB1c2VyIGtub3dzIHdoYXQgdGhleSBhcmUgZG9pbmdcbiAgLy8gYW5kIGFwcGx5IGFzIGRpcmVjdGVkLlxuICBjb25zdCBlbmFibGVCb3JkZXIgPSBlbmFibGVCb3JkZXJSYWRpdXMgfHwgaXNPYmplY3QodmFsdWUpO1xuXG4gIHJldHVybiB7XG4gICAgdG9wTGVmdDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLnRvcCB8fCBza2lwLmxlZnQsIG8udG9wTGVmdCwgMCwgbWF4UiksXG4gICAgdG9wUmlnaHQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC50b3AgfHwgc2tpcC5yaWdodCwgby50b3BSaWdodCwgMCwgbWF4UiksXG4gICAgYm90dG9tTGVmdDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLmJvdHRvbSB8fCBza2lwLmxlZnQsIG8uYm90dG9tTGVmdCwgMCwgbWF4UiksXG4gICAgYm90dG9tUmlnaHQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC5ib3R0b20gfHwgc2tpcC5yaWdodCwgby5ib3R0b21SaWdodCwgMCwgbWF4UilcbiAgfTtcbn1cblxuZnVuY3Rpb24gYm91bmRpbmdSZWN0cyhiYXIpIHtcbiAgY29uc3QgYm91bmRzID0gZ2V0QmFyQm91bmRzKGJhcik7XG4gIGNvbnN0IHdpZHRoID0gYm91bmRzLnJpZ2h0IC0gYm91bmRzLmxlZnQ7XG4gIGNvbnN0IGhlaWdodCA9IGJvdW5kcy5ib3R0b20gLSBib3VuZHMudG9wO1xuICBjb25zdCBib3JkZXIgPSBwYXJzZUJvcmRlcldpZHRoKGJhciwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcbiAgY29uc3QgcmFkaXVzID0gcGFyc2VCb3JkZXJSYWRpdXMoYmFyLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuXG4gIHJldHVybiB7XG4gICAgb3V0ZXI6IHtcbiAgICAgIHg6IGJvdW5kcy5sZWZ0LFxuICAgICAgeTogYm91bmRzLnRvcCxcbiAgICAgIHc6IHdpZHRoLFxuICAgICAgaDogaGVpZ2h0LFxuICAgICAgcmFkaXVzXG4gICAgfSxcbiAgICBpbm5lcjoge1xuICAgICAgeDogYm91bmRzLmxlZnQgKyBib3JkZXIubCxcbiAgICAgIHk6IGJvdW5kcy50b3AgKyBib3JkZXIudCxcbiAgICAgIHc6IHdpZHRoIC0gYm9yZGVyLmwgLSBib3JkZXIucixcbiAgICAgIGg6IGhlaWdodCAtIGJvcmRlci50IC0gYm9yZGVyLmIsXG4gICAgICByYWRpdXM6IHtcbiAgICAgICAgdG9wTGVmdDogTWF0aC5tYXgoMCwgcmFkaXVzLnRvcExlZnQgLSBNYXRoLm1heChib3JkZXIudCwgYm9yZGVyLmwpKSxcbiAgICAgICAgdG9wUmlnaHQ6IE1hdGgubWF4KDAsIHJhZGl1cy50b3BSaWdodCAtIE1hdGgubWF4KGJvcmRlci50LCBib3JkZXIucikpLFxuICAgICAgICBib3R0b21MZWZ0OiBNYXRoLm1heCgwLCByYWRpdXMuYm90dG9tTGVmdCAtIE1hdGgubWF4KGJvcmRlci5iLCBib3JkZXIubCkpLFxuICAgICAgICBib3R0b21SaWdodDogTWF0aC5tYXgoMCwgcmFkaXVzLmJvdHRvbVJpZ2h0IC0gTWF0aC5tYXgoYm9yZGVyLmIsIGJvcmRlci5yKSksXG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpblJhbmdlKGJhciwgeCwgeSwgdXNlRmluYWxQb3NpdGlvbikge1xuICBjb25zdCBza2lwWCA9IHggPT09IG51bGw7XG4gIGNvbnN0IHNraXBZID0geSA9PT0gbnVsbDtcbiAgY29uc3Qgc2tpcEJvdGggPSBza2lwWCAmJiBza2lwWTtcbiAgY29uc3QgYm91bmRzID0gYmFyICYmICFza2lwQm90aCAmJiBnZXRCYXJCb3VuZHMoYmFyLCB1c2VGaW5hbFBvc2l0aW9uKTtcblxuICByZXR1cm4gYm91bmRzXG5cdFx0JiYgKHNraXBYIHx8IF9pc0JldHdlZW4oeCwgYm91bmRzLmxlZnQsIGJvdW5kcy5yaWdodCkpXG5cdFx0JiYgKHNraXBZIHx8IF9pc0JldHdlZW4oeSwgYm91bmRzLnRvcCwgYm91bmRzLmJvdHRvbSkpO1xufVxuXG5mdW5jdGlvbiBoYXNSYWRpdXMocmFkaXVzKSB7XG4gIHJldHVybiByYWRpdXMudG9wTGVmdCB8fCByYWRpdXMudG9wUmlnaHQgfHwgcmFkaXVzLmJvdHRvbUxlZnQgfHwgcmFkaXVzLmJvdHRvbVJpZ2h0O1xufVxuXG4vKipcbiAqIEFkZCBhIHBhdGggb2YgYSByZWN0YW5nbGUgdG8gdGhlIGN1cnJlbnQgc3ViLXBhdGhcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dFxuICogQHBhcmFtIHsqfSByZWN0IEJvdW5kaW5nIHJlY3RcbiAqL1xuZnVuY3Rpb24gYWRkTm9ybWFsUmVjdFBhdGgoY3R4LCByZWN0KSB7XG4gIGN0eC5yZWN0KHJlY3QueCwgcmVjdC55LCByZWN0LncsIHJlY3QuaCk7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZWN0KHJlY3QsIGFtb3VudCwgcmVmUmVjdCA9IHt9KSB7XG4gIGNvbnN0IHggPSByZWN0LnggIT09IHJlZlJlY3QueCA/IC1hbW91bnQgOiAwO1xuICBjb25zdCB5ID0gcmVjdC55ICE9PSByZWZSZWN0LnkgPyAtYW1vdW50IDogMDtcbiAgY29uc3QgdyA9IChyZWN0LnggKyByZWN0LncgIT09IHJlZlJlY3QueCArIHJlZlJlY3QudyA/IGFtb3VudCA6IDApIC0geDtcbiAgY29uc3QgaCA9IChyZWN0LnkgKyByZWN0LmggIT09IHJlZlJlY3QueSArIHJlZlJlY3QuaCA/IGFtb3VudCA6IDApIC0geTtcbiAgcmV0dXJuIHtcbiAgICB4OiByZWN0LnggKyB4LFxuICAgIHk6IHJlY3QueSArIHksXG4gICAgdzogcmVjdC53ICsgdyxcbiAgICBoOiByZWN0LmggKyBoLFxuICAgIHJhZGl1czogcmVjdC5yYWRpdXNcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuXG4gIHN0YXRpYyBpZCA9ICdiYXInO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGJvcmRlclNraXBwZWQ6ICdzdGFydCcsXG4gICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgIGluZmxhdGVBbW91bnQ6ICdhdXRvJyxcbiAgICBwb2ludFN0eWxlOiB1bmRlZmluZWRcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0Um91dGVzID0ge1xuICAgIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXG4gICAgYm9yZGVyQ29sb3I6ICdib3JkZXJDb2xvcidcbiAgfTtcblxuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaG9yaXpvbnRhbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJhc2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmluZmxhdGVBbW91bnQgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoY2ZnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgfVxuICB9XG5cbiAgZHJhdyhjdHgpIHtcbiAgICBjb25zdCB7aW5mbGF0ZUFtb3VudCwgb3B0aW9uczoge2JvcmRlckNvbG9yLCBiYWNrZ3JvdW5kQ29sb3J9fSA9IHRoaXM7XG4gICAgY29uc3Qge2lubmVyLCBvdXRlcn0gPSBib3VuZGluZ1JlY3RzKHRoaXMpO1xuICAgIGNvbnN0IGFkZFJlY3RQYXRoID0gaGFzUmFkaXVzKG91dGVyLnJhZGl1cykgPyBhZGRSb3VuZGVkUmVjdFBhdGggOiBhZGROb3JtYWxSZWN0UGF0aDtcblxuICAgIGN0eC5zYXZlKCk7XG5cbiAgICBpZiAob3V0ZXIudyAhPT0gaW5uZXIudyB8fCBvdXRlci5oICE9PSBpbm5lci5oKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBhZGRSZWN0UGF0aChjdHgsIGluZmxhdGVSZWN0KG91dGVyLCBpbmZsYXRlQW1vdW50LCBpbm5lcikpO1xuICAgICAgY3R4LmNsaXAoKTtcbiAgICAgIGFkZFJlY3RQYXRoKGN0eCwgaW5mbGF0ZVJlY3QoaW5uZXIsIC1pbmZsYXRlQW1vdW50LCBvdXRlcikpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJvcmRlckNvbG9yO1xuICAgICAgY3R4LmZpbGwoJ2V2ZW5vZGQnKTtcbiAgICB9XG5cbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgYWRkUmVjdFBhdGgoY3R4LCBpbmZsYXRlUmVjdChpbm5lciwgaW5mbGF0ZUFtb3VudCkpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgY3R4LmZpbGwoKTtcblxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cblxuICBpblJhbmdlKG1vdXNlWCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbW91c2VYLCBtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG5cbiAgaW5YUmFuZ2UobW91c2VYLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbW91c2VYLCBudWxsLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuXG4gIGluWVJhbmdlKG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlKHRoaXMsIG51bGwsIG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cblxuICBnZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3Qge3gsIHksIGJhc2UsIGhvcml6b250YWx9ID0gLyoqIEB0eXBlIHtCYXJQcm9wc30gKi8gKHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knLCAnYmFzZScsICdob3Jpem9udGFsJ10sIHVzZUZpbmFsUG9zaXRpb24pKTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogaG9yaXpvbnRhbCA/ICh4ICsgYmFzZSkgLyAyIDogeCxcbiAgICAgIHk6IGhvcml6b250YWwgPyB5IDogKHkgKyBiYXNlKSAvIDJcbiAgICB9O1xuICB9XG5cbiAgZ2V0UmFuZ2UoYXhpcykge1xuICAgIHJldHVybiBheGlzID09PSAneCcgPyB0aGlzLndpZHRoIC8gMiA6IHRoaXMuaGVpZ2h0IC8gMjtcbiAgfVxufVxuIiwgImltcG9ydCB7RG91Z2hudXRDb250cm9sbGVyLCBQb2xhckFyZWFDb250cm9sbGVyfSBmcm9tICcuLi9pbmRleC5qcyc7XG5pbXBvcnQgdHlwZSB7Q2hhcnQsIENoYXJ0RGF0YXNldH0gZnJvbSAnLi4vdHlwZXMuanMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbG9yc1BsdWdpbk9wdGlvbnMge1xuICBlbmFibGVkPzogYm9vbGVhbjtcbiAgZm9yY2VPdmVycmlkZT86IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBDb2xvcnNEZXNjcmlwdG9yIHtcbiAgYmFja2dyb3VuZENvbG9yPzogdW5rbm93bjtcbiAgYm9yZGVyQ29sb3I/OiB1bmtub3duO1xufVxuXG5jb25zdCBCT1JERVJfQ09MT1JTID0gW1xuICAncmdiKDU0LCAxNjIsIDIzNSknLCAvLyBibHVlXG4gICdyZ2IoMjU1LCA5OSwgMTMyKScsIC8vIHJlZFxuICAncmdiKDI1NSwgMTU5LCA2NCknLCAvLyBvcmFuZ2VcbiAgJ3JnYigyNTUsIDIwNSwgODYpJywgLy8geWVsbG93XG4gICdyZ2IoNzUsIDE5MiwgMTkyKScsIC8vIGdyZWVuXG4gICdyZ2IoMTUzLCAxMDIsIDI1NSknLCAvLyBwdXJwbGVcbiAgJ3JnYigyMDEsIDIwMywgMjA3KScgLy8gZ3JleVxuXTtcblxuLy8gQm9yZGVyIGNvbG9ycyB3aXRoIDUwJSB0cmFuc3BhcmVuY3lcbmNvbnN0IEJBQ0tHUk9VTkRfQ09MT1JTID0gLyogI19fUFVSRV9fICovIEJPUkRFUl9DT0xPUlMubWFwKGNvbG9yID0+IGNvbG9yLnJlcGxhY2UoJ3JnYignLCAncmdiYSgnKS5yZXBsYWNlKCcpJywgJywgMC41KScpKTtcblxuZnVuY3Rpb24gZ2V0Qm9yZGVyQ29sb3IoaTogbnVtYmVyKSB7XG4gIHJldHVybiBCT1JERVJfQ09MT1JTW2kgJSBCT1JERVJfQ09MT1JTLmxlbmd0aF07XG59XG5cbmZ1bmN0aW9uIGdldEJhY2tncm91bmRDb2xvcihpOiBudW1iZXIpIHtcbiAgcmV0dXJuIEJBQ0tHUk9VTkRfQ09MT1JTW2kgJSBCQUNLR1JPVU5EX0NPTE9SUy5sZW5ndGhdO1xufVxuXG5mdW5jdGlvbiBjb2xvcml6ZURlZmF1bHREYXRhc2V0KGRhdGFzZXQ6IENoYXJ0RGF0YXNldCwgaTogbnVtYmVyKSB7XG4gIGRhdGFzZXQuYm9yZGVyQ29sb3IgPSBnZXRCb3JkZXJDb2xvcihpKTtcbiAgZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3IgPSBnZXRCYWNrZ3JvdW5kQ29sb3IoaSk7XG5cbiAgcmV0dXJuICsraTtcbn1cblxuZnVuY3Rpb24gY29sb3JpemVEb3VnaG51dERhdGFzZXQoZGF0YXNldDogQ2hhcnREYXRhc2V0LCBpOiBudW1iZXIpIHtcbiAgZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3IgPSBkYXRhc2V0LmRhdGEubWFwKCgpID0+IGdldEJvcmRlckNvbG9yKGkrKykpO1xuXG4gIHJldHVybiBpO1xufVxuXG5mdW5jdGlvbiBjb2xvcml6ZVBvbGFyQXJlYURhdGFzZXQoZGF0YXNldDogQ2hhcnREYXRhc2V0LCBpOiBudW1iZXIpIHtcbiAgZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3IgPSBkYXRhc2V0LmRhdGEubWFwKCgpID0+IGdldEJhY2tncm91bmRDb2xvcihpKyspKTtcblxuICByZXR1cm4gaTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29sb3JpemVyKGNoYXJ0OiBDaGFydCkge1xuICBsZXQgaSA9IDA7XG5cbiAgcmV0dXJuIChkYXRhc2V0OiBDaGFydERhdGFzZXQsIGRhdGFzZXRJbmRleDogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlcjtcblxuICAgIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgRG91Z2hudXRDb250cm9sbGVyKSB7XG4gICAgICBpID0gY29sb3JpemVEb3VnaG51dERhdGFzZXQoZGF0YXNldCwgaSk7XG4gICAgfSBlbHNlIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgUG9sYXJBcmVhQ29udHJvbGxlcikge1xuICAgICAgaSA9IGNvbG9yaXplUG9sYXJBcmVhRGF0YXNldChkYXRhc2V0LCBpKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRyb2xsZXIpIHtcbiAgICAgIGkgPSBjb2xvcml6ZURlZmF1bHREYXRhc2V0KGRhdGFzZXQsIGkpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnNDb2xvcnNEZWZpbml0aW9ucyhcbiAgZGVzY3JpcHRvcnM6IENvbG9yc0Rlc2NyaXB0b3JbXSB8IFJlY29yZDxzdHJpbmcsIENvbG9yc0Rlc2NyaXB0b3I+XG4pIHtcbiAgbGV0IGs6IG51bWJlciB8IHN0cmluZztcblxuICBmb3IgKGsgaW4gZGVzY3JpcHRvcnMpIHtcbiAgICBpZiAoZGVzY3JpcHRvcnNba10uYm9yZGVyQ29sb3IgfHwgZGVzY3JpcHRvcnNba10uYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zQ29sb3JzRGVmaW5pdGlvbihcbiAgZGVzY3JpcHRvcjogQ29sb3JzRGVzY3JpcHRvclxuKSB7XG4gIHJldHVybiBkZXNjcmlwdG9yICYmIChkZXNjcmlwdG9yLmJvcmRlckNvbG9yIHx8IGRlc2NyaXB0b3IuYmFja2dyb3VuZENvbG9yKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpZDogJ2NvbG9ycycsXG5cbiAgZGVmYXVsdHM6IHtcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGZvcmNlT3ZlcnJpZGU6IGZhbHNlXG4gIH0gYXMgQ29sb3JzUGx1Z2luT3B0aW9ucyxcblxuICBiZWZvcmVMYXlvdXQoY2hhcnQ6IENoYXJ0LCBfYXJncywgb3B0aW9uczogQ29sb3JzUGx1Z2luT3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5lbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgZGF0YToge2RhdGFzZXRzfSxcbiAgICAgIG9wdGlvbnM6IGNoYXJ0T3B0aW9uc1xuICAgIH0gPSBjaGFydC5jb25maWc7XG4gICAgY29uc3Qge2VsZW1lbnRzfSA9IGNoYXJ0T3B0aW9ucztcblxuICAgIGlmICghb3B0aW9ucy5mb3JjZU92ZXJyaWRlICYmIChjb250YWluc0NvbG9yc0RlZmluaXRpb25zKGRhdGFzZXRzKSB8fCBjb250YWluc0NvbG9yc0RlZmluaXRpb24oY2hhcnRPcHRpb25zKSB8fCAoZWxlbWVudHMgJiYgY29udGFpbnNDb2xvcnNEZWZpbml0aW9ucyhlbGVtZW50cykpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbG9yaXplciA9IGdldENvbG9yaXplcihjaGFydCk7XG5cbiAgICBkYXRhc2V0cy5mb3JFYWNoKGNvbG9yaXplcik7XG4gIH1cbn07XG4iLCAiaW1wb3J0IHtfbGltaXRWYWx1ZSwgX2xvb2t1cEJ5S2V5LCBpc051bGxPclVuZGVmLCByZXNvbHZlfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuZnVuY3Rpb24gbHR0YkRlY2ltYXRpb24oZGF0YSwgc3RhcnQsIGNvdW50LCBhdmFpbGFibGVXaWR0aCwgb3B0aW9ucykge1xuICAvKipcbiAgICogSW1wbGVtZW50YXRpb24gb2YgdGhlIExhcmdlc3QgVHJpYW5nbGUgVGhyZWUgQnVja2V0cyBhbGdvcml0aG0uXG4gICAqXG4gICAqIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gdGhlIG9yaWdpbmFsIGltcGxlbWVudGF0aW9uIGJ5IFN2ZWlubiBTdGVpbmFyc3NvblxuICAgKiBpbiBodHRwczovL2dpdGh1Yi5jb20vc3ZlaW5uLXN0ZWluYXJzc29uL2Zsb3QtZG93bnNhbXBsZS9ibG9iL21hc3Rlci9qcXVlcnkuZmxvdC5kb3duc2FtcGxlLmpzXG4gICAqXG4gICAqIFRoZSBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiBpcyBNSVQgbGljZW5zZWQuXG4gICAqL1xuICBjb25zdCBzYW1wbGVzID0gb3B0aW9ucy5zYW1wbGVzIHx8IGF2YWlsYWJsZVdpZHRoO1xuICAvLyBUaGVyZSBhcmUgbGVzcyBwb2ludHMgdGhhbiB0aGUgdGhyZXNob2xkLCByZXR1cm5pbmcgdGhlIHdob2xlIGFycmF5XG4gIGlmIChzYW1wbGVzID49IGNvdW50KSB7XG4gICAgcmV0dXJuIGRhdGEuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgY291bnQpO1xuICB9XG5cbiAgY29uc3QgZGVjaW1hdGVkID0gW107XG5cbiAgY29uc3QgYnVja2V0V2lkdGggPSAoY291bnQgLSAyKSAvIChzYW1wbGVzIC0gMik7XG4gIGxldCBzYW1wbGVkSW5kZXggPSAwO1xuICBjb25zdCBlbmRJbmRleCA9IHN0YXJ0ICsgY291bnQgLSAxO1xuICAvLyBTdGFydGluZyBmcm9tIG9mZnNldFxuICBsZXQgYSA9IHN0YXJ0O1xuICBsZXQgaSwgbWF4QXJlYVBvaW50LCBtYXhBcmVhLCBhcmVhLCBuZXh0QTtcblxuICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gZGF0YVthXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc2FtcGxlcyAtIDI7IGkrKykge1xuICAgIGxldCBhdmdYID0gMDtcbiAgICBsZXQgYXZnWSA9IDA7XG4gICAgbGV0IGo7XG5cbiAgICAvLyBBZGRpbmcgb2Zmc2V0XG4gICAgY29uc3QgYXZnUmFuZ2VTdGFydCA9IE1hdGguZmxvb3IoKGkgKyAxKSAqIGJ1Y2tldFdpZHRoKSArIDEgKyBzdGFydDtcbiAgICBjb25zdCBhdmdSYW5nZUVuZCA9IE1hdGgubWluKE1hdGguZmxvb3IoKGkgKyAyKSAqIGJ1Y2tldFdpZHRoKSArIDEsIGNvdW50KSArIHN0YXJ0O1xuICAgIGNvbnN0IGF2Z1JhbmdlTGVuZ3RoID0gYXZnUmFuZ2VFbmQgLSBhdmdSYW5nZVN0YXJ0O1xuXG4gICAgZm9yIChqID0gYXZnUmFuZ2VTdGFydDsgaiA8IGF2Z1JhbmdlRW5kOyBqKyspIHtcbiAgICAgIGF2Z1ggKz0gZGF0YVtqXS54O1xuICAgICAgYXZnWSArPSBkYXRhW2pdLnk7XG4gICAgfVxuXG4gICAgYXZnWCAvPSBhdmdSYW5nZUxlbmd0aDtcbiAgICBhdmdZIC89IGF2Z1JhbmdlTGVuZ3RoO1xuXG4gICAgLy8gQWRkaW5nIG9mZnNldFxuICAgIGNvbnN0IHJhbmdlT2ZmcyA9IE1hdGguZmxvb3IoaSAqIGJ1Y2tldFdpZHRoKSArIDEgKyBzdGFydDtcbiAgICBjb25zdCByYW5nZVRvID0gTWF0aC5taW4oTWF0aC5mbG9vcigoaSArIDEpICogYnVja2V0V2lkdGgpICsgMSwgY291bnQpICsgc3RhcnQ7XG4gICAgY29uc3Qge3g6IHBvaW50QXgsIHk6IHBvaW50QXl9ID0gZGF0YVthXTtcblxuICAgIC8vIE5vdGUgdGhhdCB0aGlzIGlzIGNoYW5nZWQgZnJvbSB0aGUgb3JpZ2luYWwgYWxnb3JpdGhtIHdoaWNoIGluaXRpYWxpemVzIHRoZXNlXG4gICAgLy8gdmFsdWVzIHRvIDEuIFRoZSByZWFzb24gZm9yIHRoaXMgY2hhbmdlIGlzIHRoYXQgaWYgdGhlIGFyZWEgaXMgc21hbGwsIG5leHRBXG4gICAgLy8gd291bGQgbmV2ZXIgYmUgc2V0IGFuZCB0aHVzIGEgY3Jhc2ggd291bGQgb2NjdXIgaW4gdGhlIG5leHQgbG9vcCBhcyBgYWAgd291bGQgYmVjb21lXG4gICAgLy8gYHVuZGVmaW5lZGAuIFNpbmNlIHRoZSBhcmVhIGlzIGFsd2F5cyBwb3NpdGl2ZSwgYnV0IGNvdWxkIGJlIDAgaW4gdGhlIGNhc2Ugb2YgYSBmbGF0IHRyYWNlLFxuICAgIC8vIGluaXRpYWxpemluZyB3aXRoIGEgbmVnYXRpdmUgbnVtYmVyIGlzIHRoZSBjb3JyZWN0IHNvbHV0aW9uLlxuICAgIG1heEFyZWEgPSBhcmVhID0gLTE7XG5cbiAgICBmb3IgKGogPSByYW5nZU9mZnM7IGogPCByYW5nZVRvOyBqKyspIHtcbiAgICAgIGFyZWEgPSAwLjUgKiBNYXRoLmFicyhcbiAgICAgICAgKHBvaW50QXggLSBhdmdYKSAqIChkYXRhW2pdLnkgLSBwb2ludEF5KSAtXG4gICAgICAgIChwb2ludEF4IC0gZGF0YVtqXS54KSAqIChhdmdZIC0gcG9pbnRBeSlcbiAgICAgICk7XG5cbiAgICAgIGlmIChhcmVhID4gbWF4QXJlYSkge1xuICAgICAgICBtYXhBcmVhID0gYXJlYTtcbiAgICAgICAgbWF4QXJlYVBvaW50ID0gZGF0YVtqXTtcbiAgICAgICAgbmV4dEEgPSBqO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRlY2ltYXRlZFtzYW1wbGVkSW5kZXgrK10gPSBtYXhBcmVhUG9pbnQ7XG4gICAgYSA9IG5leHRBO1xuICB9XG5cbiAgLy8gSW5jbHVkZSB0aGUgbGFzdCBwb2ludFxuICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gZGF0YVtlbmRJbmRleF07XG5cbiAgcmV0dXJuIGRlY2ltYXRlZDtcbn1cblxuZnVuY3Rpb24gbWluTWF4RGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoKSB7XG4gIGxldCBhdmdYID0gMDtcbiAgbGV0IGNvdW50WCA9IDA7XG4gIGxldCBpLCBwb2ludCwgeCwgeSwgcHJldlgsIG1pbkluZGV4LCBtYXhJbmRleCwgc3RhcnRJbmRleCwgbWluWSwgbWF4WTtcbiAgY29uc3QgZGVjaW1hdGVkID0gW107XG4gIGNvbnN0IGVuZEluZGV4ID0gc3RhcnQgKyBjb3VudCAtIDE7XG5cbiAgY29uc3QgeE1pbiA9IGRhdGFbc3RhcnRdLng7XG4gIGNvbnN0IHhNYXggPSBkYXRhW2VuZEluZGV4XS54O1xuICBjb25zdCBkeCA9IHhNYXggLSB4TWluO1xuXG4gIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgcG9pbnQgPSBkYXRhW2ldO1xuICAgIHggPSAocG9pbnQueCAtIHhNaW4pIC8gZHggKiBhdmFpbGFibGVXaWR0aDtcbiAgICB5ID0gcG9pbnQueTtcbiAgICBjb25zdCB0cnVuY1ggPSB4IHwgMDtcblxuICAgIGlmICh0cnVuY1ggPT09IHByZXZYKSB7XG4gICAgICAvLyBEZXRlcm1pbmUgYG1pbllgIC8gYG1heFlgIGFuZCBgYXZnWGAgd2hpbGUgd2Ugc3RheSB3aXRoaW4gc2FtZSB4LXBvc2l0aW9uXG4gICAgICBpZiAoeSA8IG1pblkpIHtcbiAgICAgICAgbWluWSA9IHk7XG4gICAgICAgIG1pbkluZGV4ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoeSA+IG1heFkpIHtcbiAgICAgICAgbWF4WSA9IHk7XG4gICAgICAgIG1heEluZGV4ID0gaTtcbiAgICAgIH1cbiAgICAgIC8vIEZvciBmaXJzdCBwb2ludCBpbiBncm91cCwgY291bnRYIGlzIGAwYCwgc28gYXZlcmFnZSB3aWxsIGJlIGB4YCAvIDEuXG4gICAgICAvLyBVc2UgcG9pbnQueCBoZXJlIGJlY2F1c2Ugd2UncmUgY29tcHV0aW5nIHRoZSBhdmVyYWdlIGRhdGEgYHhgIHZhbHVlXG4gICAgICBhdmdYID0gKGNvdW50WCAqIGF2Z1ggKyBwb2ludC54KSAvICsrY291bnRYO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQdXNoIHVwIHRvIDQgcG9pbnRzLCAzIGZvciB0aGUgbGFzdCBpbnRlcnZhbCBhbmQgdGhlIGZpcnN0IHBvaW50IGZvciB0aGlzIGludGVydmFsXG4gICAgICBjb25zdCBsYXN0SW5kZXggPSBpIC0gMTtcblxuICAgICAgaWYgKCFpc051bGxPclVuZGVmKG1pbkluZGV4KSAmJiAhaXNOdWxsT3JVbmRlZihtYXhJbmRleCkpIHtcbiAgICAgICAgLy8gVGhlIGludGVydmFsIGlzIGRlZmluZWQgYnkgNCBwb2ludHM6IHN0YXJ0LCBtaW4sIG1heCwgZW5kLlxuICAgICAgICAvLyBUaGUgc3RhcnRpbmcgcG9pbnQgaXMgYWxyZWFkeSBjb25zaWRlcmVkIGF0IHRoaXMgcG9pbnQsIHNvIHdlIG5lZWQgdG8gZGV0ZXJtaW5lIHdoaWNoXG4gICAgICAgIC8vIG9mIHRoZSBvdGhlciBwb2ludHMgdG8gYWRkLiBXZSBuZWVkIHRvIHNvcnQgdGhlc2UgcG9pbnRzIHRvIGVuc3VyZSB0aGUgZGVjaW1hdGVkIGRhdGFcbiAgICAgICAgLy8gaXMgc3RpbGwgc29ydGVkIGFuZCB0aGVuIGVuc3VyZSB0aGVyZSBhcmUgbm8gZHVwbGljYXRlcy5cbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlSW5kZXgxID0gTWF0aC5taW4obWluSW5kZXgsIG1heEluZGV4KTtcbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlSW5kZXgyID0gTWF0aC5tYXgobWluSW5kZXgsIG1heEluZGV4KTtcblxuICAgICAgICBpZiAoaW50ZXJtZWRpYXRlSW5kZXgxICE9PSBzdGFydEluZGV4ICYmIGludGVybWVkaWF0ZUluZGV4MSAhPT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgZGVjaW1hdGVkLnB1c2goe1xuICAgICAgICAgICAgLi4uZGF0YVtpbnRlcm1lZGlhdGVJbmRleDFdLFxuICAgICAgICAgICAgeDogYXZnWCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJtZWRpYXRlSW5kZXgyICE9PSBzdGFydEluZGV4ICYmIGludGVybWVkaWF0ZUluZGV4MiAhPT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgZGVjaW1hdGVkLnB1c2goe1xuICAgICAgICAgICAgLi4uZGF0YVtpbnRlcm1lZGlhdGVJbmRleDJdLFxuICAgICAgICAgICAgeDogYXZnWFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGxhc3RJbmRleCA9PT0gc3RhcnRJbmRleCB3aWxsIG9jY3VyIHdoZW4gYSByYW5nZSBoYXMgb25seSAxIHBvaW50IHdoaWNoIGNvdWxkXG4gICAgICAvLyBoYXBwZW4gd2l0aCB2ZXJ5IHVuZXZlbiBkYXRhXG4gICAgICBpZiAoaSA+IDAgJiYgbGFzdEluZGV4ICE9PSBzdGFydEluZGV4KSB7XG4gICAgICAgIC8vIExhc3QgcG9pbnQgaW4gdGhlIHByZXZpb3VzIGludGVydmFsXG4gICAgICAgIGRlY2ltYXRlZC5wdXNoKGRhdGFbbGFzdEluZGV4XSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFN0YXJ0IG9mIHRoZSBuZXcgaW50ZXJ2YWxcbiAgICAgIGRlY2ltYXRlZC5wdXNoKHBvaW50KTtcbiAgICAgIHByZXZYID0gdHJ1bmNYO1xuICAgICAgY291bnRYID0gMDtcbiAgICAgIG1pblkgPSBtYXhZID0geTtcbiAgICAgIG1pbkluZGV4ID0gbWF4SW5kZXggPSBzdGFydEluZGV4ID0gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVjaW1hdGVkO1xufVxuXG5mdW5jdGlvbiBjbGVhbkRlY2ltYXRlZERhdGFzZXQoZGF0YXNldCkge1xuICBpZiAoZGF0YXNldC5fZGVjaW1hdGVkKSB7XG4gICAgY29uc3QgZGF0YSA9IGRhdGFzZXQuX2RhdGE7XG4gICAgZGVsZXRlIGRhdGFzZXQuX2RlY2ltYXRlZDtcbiAgICBkZWxldGUgZGF0YXNldC5fZGF0YTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGF0YXNldCwgJ2RhdGEnLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZGF0YSxcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhbkRlY2ltYXRlZERhdGEoY2hhcnQpIHtcbiAgY2hhcnQuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKChkYXRhc2V0KSA9PiB7XG4gICAgY2xlYW5EZWNpbWF0ZWREYXRhc2V0KGRhdGFzZXQpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50c1NpbXBsaWZpZWQobWV0YSwgcG9pbnRzKSB7XG4gIGNvbnN0IHBvaW50Q291bnQgPSBwb2ludHMubGVuZ3RoO1xuXG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBjb3VudDtcblxuICBjb25zdCB7aVNjYWxlfSA9IG1ldGE7XG4gIGNvbnN0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSBpU2NhbGUuZ2V0VXNlckJvdW5kcygpO1xuXG4gIGlmIChtaW5EZWZpbmVkKSB7XG4gICAgc3RhcnQgPSBfbGltaXRWYWx1ZShfbG9va3VwQnlLZXkocG9pbnRzLCBpU2NhbGUuYXhpcywgbWluKS5sbywgMCwgcG9pbnRDb3VudCAtIDEpO1xuICB9XG4gIGlmIChtYXhEZWZpbmVkKSB7XG4gICAgY291bnQgPSBfbGltaXRWYWx1ZShfbG9va3VwQnlLZXkocG9pbnRzLCBpU2NhbGUuYXhpcywgbWF4KS5oaSArIDEsIHN0YXJ0LCBwb2ludENvdW50KSAtIHN0YXJ0O1xuICB9IGVsc2Uge1xuICAgIGNvdW50ID0gcG9pbnRDb3VudCAtIHN0YXJ0O1xuICB9XG5cbiAgcmV0dXJuIHtzdGFydCwgY291bnR9O1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlkOiAnZGVjaW1hdGlvbicsXG5cbiAgZGVmYXVsdHM6IHtcbiAgICBhbGdvcml0aG06ICdtaW4tbWF4JyxcbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgfSxcblxuICBiZWZvcmVFbGVtZW50c1VwZGF0ZTogKGNoYXJ0LCBhcmdzLCBvcHRpb25zKSA9PiB7XG4gICAgaWYgKCFvcHRpb25zLmVuYWJsZWQpIHtcbiAgICAgIC8vIFRoZSBkZWNpbWF0aW9uIHBsdWdpbiBtYXkgaGF2ZSBiZWVuIHByZXZpb3VzbHkgZW5hYmxlZC4gTmVlZCB0byByZW1vdmUgb2xkIGBkYXRhc2V0Ll9kYXRhYCBoYW5kbGVyc1xuICAgICAgY2xlYW5EZWNpbWF0ZWREYXRhKGNoYXJ0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBBc3N1bWUgdGhlIGVudGlyZSBjaGFydCBpcyBhdmFpbGFibGUgdG8gc2hvdyBhIGZldyBtb3JlIHBvaW50cyB0aGFuIG5lZWRlZFxuICAgIGNvbnN0IGF2YWlsYWJsZVdpZHRoID0gY2hhcnQud2lkdGg7XG5cbiAgICBjaGFydC5kYXRhLmRhdGFzZXRzLmZvckVhY2goKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkgPT4ge1xuICAgICAgY29uc3Qge19kYXRhLCBpbmRleEF4aXN9ID0gZGF0YXNldDtcbiAgICAgIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgICAgY29uc3QgZGF0YSA9IF9kYXRhIHx8IGRhdGFzZXQuZGF0YTtcblxuICAgICAgaWYgKHJlc29sdmUoW2luZGV4QXhpcywgY2hhcnQub3B0aW9ucy5pbmRleEF4aXNdKSA9PT0gJ3knKSB7XG4gICAgICAgIC8vIERlY2ltYXRpb24gaXMgb25seSBzdXBwb3J0ZWQgZm9yIGxpbmVzIHRoYXQgaGF2ZSBhbiBYIGluZGV4QXhpc1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghbWV0YS5jb250cm9sbGVyLnN1cHBvcnRzRGVjaW1hdGlvbikge1xuICAgICAgICAvLyBPbmx5IGxpbmUgZGF0YXNldHMgYXJlIHN1cHBvcnRlZFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHhBeGlzID0gY2hhcnQuc2NhbGVzW21ldGEueEF4aXNJRF07XG4gICAgICBpZiAoeEF4aXMudHlwZSAhPT0gJ2xpbmVhcicgJiYgeEF4aXMudHlwZSAhPT0gJ3RpbWUnKSB7XG4gICAgICAgIC8vIE9ubHkgbGluZWFyIGludGVycG9sYXRpb24gaXMgc3VwcG9ydGVkXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoYXJ0Lm9wdGlvbnMucGFyc2luZykge1xuICAgICAgICAvLyBQbHVnaW4gb25seSBzdXBwb3J0cyBkYXRhIHRoYXQgZG9lcyBub3QgbmVlZCBwYXJzaW5nXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IHtzdGFydCwgY291bnR9ID0gZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50c1NpbXBsaWZpZWQobWV0YSwgZGF0YSk7XG4gICAgICBjb25zdCB0aHJlc2hvbGQgPSBvcHRpb25zLnRocmVzaG9sZCB8fCA0ICogYXZhaWxhYmxlV2lkdGg7XG4gICAgICBpZiAoY291bnQgPD0gdGhyZXNob2xkKSB7XG4gICAgICAgIC8vIE5vIGRlY2ltYXRpb24gaXMgcmVxdWlyZWQgdW50aWwgd2UgYXJlIGFib3ZlIHRoaXMgdGhyZXNob2xkXG4gICAgICAgIGNsZWFuRGVjaW1hdGVkRGF0YXNldChkYXRhc2V0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZihfZGF0YSkpIHtcbiAgICAgICAgLy8gRmlyc3QgdGltZSB3ZSBhcmUgc2VlaW5nIHRoaXMgZGF0YXNldFxuICAgICAgICAvLyBXZSBvdmVycmlkZSB0aGUgJ2RhdGEnIHByb3BlcnR5IHdpdGggYSBzZXR0ZXIgdGhhdCBzdG9yZXMgdGhlXG4gICAgICAgIC8vIHJhdyBkYXRhIGluIF9kYXRhLCBidXQgcmVhZHMgdGhlIGRlY2ltYXRlZCBkYXRhIGZyb20gX2RlY2ltYXRlZFxuICAgICAgICBkYXRhc2V0Ll9kYXRhID0gZGF0YTtcbiAgICAgICAgZGVsZXRlIGRhdGFzZXQuZGF0YTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRhdGFzZXQsICdkYXRhJywge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVjaW1hdGVkO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB0aGlzLl9kYXRhID0gZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBQb2ludCB0aGUgY2hhcnQgdG8gdGhlIGRlY2ltYXRlZCBkYXRhXG4gICAgICBsZXQgZGVjaW1hdGVkO1xuICAgICAgc3dpdGNoIChvcHRpb25zLmFsZ29yaXRobSkge1xuICAgICAgY2FzZSAnbHR0Yic6XG4gICAgICAgIGRlY2ltYXRlZCA9IGx0dGJEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgsIG9wdGlvbnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21pbi1tYXgnOlxuICAgICAgICBkZWNpbWF0ZWQgPSBtaW5NYXhEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGVjaW1hdGlvbiBhbGdvcml0aG0gJyR7b3B0aW9ucy5hbGdvcml0aG19J2ApO1xuICAgICAgfVxuXG4gICAgICBkYXRhc2V0Ll9kZWNpbWF0ZWQgPSBkZWNpbWF0ZWQ7XG4gICAgfSk7XG4gIH0sXG5cbiAgZGVzdHJveShjaGFydCkge1xuICAgIGNsZWFuRGVjaW1hdGVkRGF0YShjaGFydCk7XG4gIH1cbn07XG4iLCAiaW1wb3J0IHtfYm91bmRTZWdtZW50LCBfYm91bmRTZWdtZW50cywgX25vcm1hbGl6ZUFuZ2xlfSBmcm9tICcuLi8uLi9oZWxwZXJzL2luZGV4LmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIF9zZWdtZW50cyhsaW5lLCB0YXJnZXQsIHByb3BlcnR5KSB7XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgY29uc3QgcG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IHRwb2ludHMgPSB0YXJnZXQucG9pbnRzO1xuICBjb25zdCBwYXJ0cyA9IFtdO1xuXG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgIGxldCB7c3RhcnQsIGVuZH0gPSBzZWdtZW50O1xuICAgIGVuZCA9IF9maW5kU2VnbWVudEVuZChzdGFydCwgZW5kLCBwb2ludHMpO1xuXG4gICAgY29uc3QgYm91bmRzID0gX2dldEJvdW5kcyhwcm9wZXJ0eSwgcG9pbnRzW3N0YXJ0XSwgcG9pbnRzW2VuZF0sIHNlZ21lbnQubG9vcCk7XG5cbiAgICBpZiAoIXRhcmdldC5zZWdtZW50cykge1xuICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBib3VuZGFyeSBub3Qgc3VwcG9ydGluZyBgc2VnbWVudHNgIChzaW1wbGVBcmMpXG4gICAgICAvLyBCb3VuZHMgYXJlIHByb3ZpZGVkIGFzIGB0YXJnZXRgIGZvciBwYXJ0aWFsIGNpcmNsZSwgb3IgdW5kZWZpbmVkIGZvciBmdWxsIGNpcmNsZVxuICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgIHNvdXJjZTogc2VnbWVudCxcbiAgICAgICAgdGFyZ2V0OiBib3VuZHMsXG4gICAgICAgIHN0YXJ0OiBwb2ludHNbc3RhcnRdLFxuICAgICAgICBlbmQ6IHBvaW50c1tlbmRdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIEdldCBhbGwgc2VnbWVudHMgZnJvbSBgdGFyZ2V0YCB0aGF0IGludGVyc2VjdCB0aGUgYm91bmRzIG9mIGN1cnJlbnQgc2VnbWVudCBvZiBgbGluZWBcbiAgICBjb25zdCB0YXJnZXRTZWdtZW50cyA9IF9ib3VuZFNlZ21lbnRzKHRhcmdldCwgYm91bmRzKTtcblxuICAgIGZvciAoY29uc3QgdGd0IG9mIHRhcmdldFNlZ21lbnRzKSB7XG4gICAgICBjb25zdCBzdWJCb3VuZHMgPSBfZ2V0Qm91bmRzKHByb3BlcnR5LCB0cG9pbnRzW3RndC5zdGFydF0sIHRwb2ludHNbdGd0LmVuZF0sIHRndC5sb29wKTtcbiAgICAgIGNvbnN0IGZpbGxTb3VyY2VzID0gX2JvdW5kU2VnbWVudChzZWdtZW50LCBwb2ludHMsIHN1YkJvdW5kcyk7XG5cbiAgICAgIGZvciAoY29uc3QgZmlsbFNvdXJjZSBvZiBmaWxsU291cmNlcykge1xuICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICBzb3VyY2U6IGZpbGxTb3VyY2UsXG4gICAgICAgICAgdGFyZ2V0OiB0Z3QsXG4gICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgIFtwcm9wZXJ0eV06IF9nZXRFZGdlKGJvdW5kcywgc3ViQm91bmRzLCAnc3RhcnQnLCBNYXRoLm1heClcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVuZDoge1xuICAgICAgICAgICAgW3Byb3BlcnR5XTogX2dldEVkZ2UoYm91bmRzLCBzdWJCb3VuZHMsICdlbmQnLCBNYXRoLm1pbilcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGFydHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0Qm91bmRzKHByb3BlcnR5LCBmaXJzdCwgbGFzdCwgbG9vcCkge1xuICBpZiAobG9vcCkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgc3RhcnQgPSBmaXJzdFtwcm9wZXJ0eV07XG4gIGxldCBlbmQgPSBsYXN0W3Byb3BlcnR5XTtcblxuICBpZiAocHJvcGVydHkgPT09ICdhbmdsZScpIHtcbiAgICBzdGFydCA9IF9ub3JtYWxpemVBbmdsZShzdGFydCk7XG4gICAgZW5kID0gX25vcm1hbGl6ZUFuZ2xlKGVuZCk7XG4gIH1cbiAgcmV0dXJuIHtwcm9wZXJ0eSwgc3RhcnQsIGVuZH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfcG9pbnRzRnJvbVNlZ21lbnRzKGJvdW5kYXJ5LCBsaW5lKSB7XG4gIGNvbnN0IHt4ID0gbnVsbCwgeSA9IG51bGx9ID0gYm91bmRhcnkgfHwge307XG4gIGNvbnN0IGxpbmVQb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3QgcG9pbnRzID0gW107XG4gIGxpbmUuc2VnbWVudHMuZm9yRWFjaCgoe3N0YXJ0LCBlbmR9KSA9PiB7XG4gICAgZW5kID0gX2ZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIGxpbmVQb2ludHMpO1xuICAgIGNvbnN0IGZpcnN0ID0gbGluZVBvaW50c1tzdGFydF07XG4gICAgY29uc3QgbGFzdCA9IGxpbmVQb2ludHNbZW5kXTtcbiAgICBpZiAoeSAhPT0gbnVsbCkge1xuICAgICAgcG9pbnRzLnB1c2goe3g6IGZpcnN0LngsIHl9KTtcbiAgICAgIHBvaW50cy5wdXNoKHt4OiBsYXN0LngsIHl9KTtcbiAgICB9IGVsc2UgaWYgKHggIT09IG51bGwpIHtcbiAgICAgIHBvaW50cy5wdXNoKHt4LCB5OiBmaXJzdC55fSk7XG4gICAgICBwb2ludHMucHVzaCh7eCwgeTogbGFzdC55fSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHBvaW50cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9maW5kU2VnbWVudEVuZChzdGFydCwgZW5kLCBwb2ludHMpIHtcbiAgZm9yICg7ZW5kID4gc3RhcnQ7IGVuZC0tKSB7XG4gICAgY29uc3QgcG9pbnQgPSBwb2ludHNbZW5kXTtcbiAgICBpZiAoIWlzTmFOKHBvaW50LngpICYmICFpc05hTihwb2ludC55KSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbmQ7XG59XG5cbmZ1bmN0aW9uIF9nZXRFZGdlKGEsIGIsIHByb3AsIGZuKSB7XG4gIGlmIChhICYmIGIpIHtcbiAgICByZXR1cm4gZm4oYVtwcm9wXSwgYltwcm9wXSk7XG4gIH1cbiAgcmV0dXJuIGEgPyBhW3Byb3BdIDogYiA/IGJbcHJvcF0gOiAwO1xufVxuIiwgIi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2NvcmUvY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vY29yZS9jb3JlLnNjYWxlLmpzJykuZGVmYXVsdCB9IFNjYWxlXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vZWxlbWVudHMvZWxlbWVudC5wb2ludC5qcycpLmRlZmF1bHQgfSBQb2ludEVsZW1lbnRcbiAqL1xuXG5pbXBvcnQge0xpbmVFbGVtZW50fSBmcm9tICcuLi8uLi9lbGVtZW50cy9pbmRleC5qcyc7XG5pbXBvcnQge2lzQXJyYXl9IGZyb20gJy4uLy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtfcG9pbnRzRnJvbVNlZ21lbnRzfSBmcm9tICcuL2ZpbGxlci5zZWdtZW50LmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge1BvaW50RWxlbWVudFtdIHwgeyB4OiBudW1iZXI7IHk6IG51bWJlcjsgfX0gYm91bmRhcnlcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmVcbiAqIEByZXR1cm4ge0xpbmVFbGVtZW50P31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9jcmVhdGVCb3VuZGFyeUxpbmUoYm91bmRhcnksIGxpbmUpIHtcbiAgbGV0IHBvaW50cyA9IFtdO1xuICBsZXQgX2xvb3AgPSBmYWxzZTtcblxuICBpZiAoaXNBcnJheShib3VuZGFyeSkpIHtcbiAgICBfbG9vcCA9IHRydWU7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHBvaW50cyA9IGJvdW5kYXJ5O1xuICB9IGVsc2Uge1xuICAgIHBvaW50cyA9IF9wb2ludHNGcm9tU2VnbWVudHMoYm91bmRhcnksIGxpbmUpO1xuICB9XG5cbiAgcmV0dXJuIHBvaW50cy5sZW5ndGggPyBuZXcgTGluZUVsZW1lbnQoe1xuICAgIHBvaW50cyxcbiAgICBvcHRpb25zOiB7dGVuc2lvbjogMH0sXG4gICAgX2xvb3AsXG4gICAgX2Z1bGxMb29wOiBfbG9vcFxuICB9KSA6IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfc2hvdWxkQXBwbHlGaWxsKHNvdXJjZSkge1xuICByZXR1cm4gc291cmNlICYmIHNvdXJjZS5maWxsICE9PSBmYWxzZTtcbn1cbiIsICJpbXBvcnQge2lzT2JqZWN0LCBpc0Zpbml0ZSwgdmFsdWVPckRlZmF1bHR9IGZyb20gJy4uLy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vY29yZS9jb3JlLnNjYWxlLmpzJykuZGVmYXVsdCB9IFNjYWxlXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vZWxlbWVudHMvZWxlbWVudC5saW5lLmpzJykuZGVmYXVsdCB9IExpbmVFbGVtZW50XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vdHlwZXMvaW5kZXguanMnKS5GaWxsVGFyZ2V0IH0gRmlsbFRhcmdldFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL3R5cGVzL2luZGV4LmpzJykuQ29tcGxleEZpbGxUYXJnZXQgfSBDb21wbGV4RmlsbFRhcmdldFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBfcmVzb2x2ZVRhcmdldChzb3VyY2VzLCBpbmRleCwgcHJvcGFnYXRlKSB7XG4gIGNvbnN0IHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICBsZXQgZmlsbCA9IHNvdXJjZS5maWxsO1xuICBjb25zdCB2aXNpdGVkID0gW2luZGV4XTtcbiAgbGV0IHRhcmdldDtcblxuICBpZiAoIXByb3BhZ2F0ZSkge1xuICAgIHJldHVybiBmaWxsO1xuICB9XG5cbiAgd2hpbGUgKGZpbGwgIT09IGZhbHNlICYmIHZpc2l0ZWQuaW5kZXhPZihmaWxsKSA9PT0gLTEpIHtcbiAgICBpZiAoIWlzRmluaXRlKGZpbGwpKSB7XG4gICAgICByZXR1cm4gZmlsbDtcbiAgICB9XG5cbiAgICB0YXJnZXQgPSBzb3VyY2VzW2ZpbGxdO1xuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldC52aXNpYmxlKSB7XG4gICAgICByZXR1cm4gZmlsbDtcbiAgICB9XG5cbiAgICB2aXNpdGVkLnB1c2goZmlsbCk7XG4gICAgZmlsbCA9IHRhcmdldC5maWxsO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZGVjb2RlRmlsbChsaW5lLCBpbmRleCwgY291bnQpIHtcbiAgLyoqIEB0eXBlIHtzdHJpbmcgfCB7dmFsdWU6IG51bWJlcn19ICovXG4gIGNvbnN0IGZpbGwgPSBwYXJzZUZpbGxPcHRpb24obGluZSk7XG5cbiAgaWYgKGlzT2JqZWN0KGZpbGwpKSB7XG4gICAgcmV0dXJuIGlzTmFOKGZpbGwudmFsdWUpID8gZmFsc2UgOiBmaWxsO1xuICB9XG5cbiAgbGV0IHRhcmdldCA9IHBhcnNlRmxvYXQoZmlsbCk7XG5cbiAgaWYgKGlzRmluaXRlKHRhcmdldCkgJiYgTWF0aC5mbG9vcih0YXJnZXQpID09PSB0YXJnZXQpIHtcbiAgICByZXR1cm4gZGVjb2RlVGFyZ2V0SW5kZXgoZmlsbFswXSwgaW5kZXgsIHRhcmdldCwgY291bnQpO1xuICB9XG5cbiAgcmV0dXJuIFsnb3JpZ2luJywgJ3N0YXJ0JywgJ2VuZCcsICdzdGFjaycsICdzaGFwZSddLmluZGV4T2YoZmlsbCkgPj0gMCAmJiBmaWxsO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVUYXJnZXRJbmRleChmaXJzdENoLCBpbmRleCwgdGFyZ2V0LCBjb3VudCkge1xuICBpZiAoZmlyc3RDaCA9PT0gJy0nIHx8IGZpcnN0Q2ggPT09ICcrJykge1xuICAgIHRhcmdldCA9IGluZGV4ICsgdGFyZ2V0O1xuICB9XG5cbiAgaWYgKHRhcmdldCA9PT0gaW5kZXggfHwgdGFyZ2V0IDwgMCB8fCB0YXJnZXQgPj0gY291bnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RmlsbFRhcmdldCB8IENvbXBsZXhGaWxsVGFyZ2V0fSBmaWxsXG4gKiBAcGFyYW0ge1NjYWxlfSBzY2FsZVxuICogQHJldHVybnMge251bWJlciB8IG51bGx9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0VGFyZ2V0UGl4ZWwoZmlsbCwgc2NhbGUpIHtcbiAgbGV0IHBpeGVsID0gbnVsbDtcbiAgaWYgKGZpbGwgPT09ICdzdGFydCcpIHtcbiAgICBwaXhlbCA9IHNjYWxlLmJvdHRvbTtcbiAgfSBlbHNlIGlmIChmaWxsID09PSAnZW5kJykge1xuICAgIHBpeGVsID0gc2NhbGUudG9wO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGZpbGwpKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHBpeGVsID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShmaWxsLnZhbHVlKTtcbiAgfSBlbHNlIGlmIChzY2FsZS5nZXRCYXNlUGl4ZWwpIHtcbiAgICBwaXhlbCA9IHNjYWxlLmdldEJhc2VQaXhlbCgpO1xuICB9XG4gIHJldHVybiBwaXhlbDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZpbGxUYXJnZXQgfCBDb21wbGV4RmlsbFRhcmdldH0gZmlsbFxuICogQHBhcmFtIHtTY2FsZX0gc2NhbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFZhbHVlXG4gKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2dldFRhcmdldFZhbHVlKGZpbGwsIHNjYWxlLCBzdGFydFZhbHVlKSB7XG4gIGxldCB2YWx1ZTtcblxuICBpZiAoZmlsbCA9PT0gJ3N0YXJ0Jykge1xuICAgIHZhbHVlID0gc3RhcnRWYWx1ZTtcbiAgfSBlbHNlIGlmIChmaWxsID09PSAnZW5kJykge1xuICAgIHZhbHVlID0gc2NhbGUub3B0aW9ucy5yZXZlcnNlID8gc2NhbGUubWluIDogc2NhbGUubWF4O1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGZpbGwpKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHZhbHVlID0gZmlsbC52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IHNjYWxlLmdldEJhc2VWYWx1ZSgpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRmlsbE9wdGlvbihsaW5lKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBsaW5lLm9wdGlvbnM7XG4gIGNvbnN0IGZpbGxPcHRpb24gPSBvcHRpb25zLmZpbGw7XG4gIGxldCBmaWxsID0gdmFsdWVPckRlZmF1bHQoZmlsbE9wdGlvbiAmJiBmaWxsT3B0aW9uLnRhcmdldCwgZmlsbE9wdGlvbik7XG5cbiAgaWYgKGZpbGwgPT09IHVuZGVmaW5lZCkge1xuICAgIGZpbGwgPSAhIW9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICB9XG5cbiAgaWYgKGZpbGwgPT09IGZhbHNlIHx8IGZpbGwgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoZmlsbCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiAnb3JpZ2luJztcbiAgfVxuICByZXR1cm4gZmlsbDtcbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9jb3JlL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2NvcmUvY29yZS5zY2FsZS5qcycpLmRlZmF1bHQgfSBTY2FsZVxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2VsZW1lbnRzL2VsZW1lbnQucG9pbnQuanMnKS5kZWZhdWx0IH0gUG9pbnRFbGVtZW50XG4gKi9cblxuaW1wb3J0IHtMaW5lRWxlbWVudH0gZnJvbSAnLi4vLi4vZWxlbWVudHMvaW5kZXguanMnO1xuaW1wb3J0IHtfaXNCZXR3ZWVufSBmcm9tICcuLi8uLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7X2NyZWF0ZUJvdW5kYXJ5TGluZX0gZnJvbSAnLi9maWxsZXIuaGVscGVyLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge3sgY2hhcnQ6IENoYXJ0OyBzY2FsZTogU2NhbGU7IGluZGV4OiBudW1iZXI7IGxpbmU6IExpbmVFbGVtZW50OyB9fSBzb3VyY2VcbiAqIEByZXR1cm4ge0xpbmVFbGVtZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2J1aWxkU3RhY2tMaW5lKHNvdXJjZSkge1xuICBjb25zdCB7c2NhbGUsIGluZGV4LCBsaW5lfSA9IHNvdXJjZTtcbiAgY29uc3QgcG9pbnRzID0gW107XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgY29uc3Qgc291cmNlUG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IGxpbmVzQmVsb3cgPSBnZXRMaW5lc0JlbG93KHNjYWxlLCBpbmRleCk7XG4gIGxpbmVzQmVsb3cucHVzaChfY3JlYXRlQm91bmRhcnlMaW5lKHt4OiBudWxsLCB5OiBzY2FsZS5ib3R0b219LCBsaW5lKSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICBmb3IgKGxldCBqID0gc2VnbWVudC5zdGFydDsgaiA8PSBzZWdtZW50LmVuZDsgaisrKSB7XG4gICAgICBhZGRQb2ludHNCZWxvdyhwb2ludHMsIHNvdXJjZVBvaW50c1tqXSwgbGluZXNCZWxvdyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgTGluZUVsZW1lbnQoe3BvaW50cywgb3B0aW9uczoge319KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NjYWxlfSBzY2FsZVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcmV0dXJuIHtMaW5lRWxlbWVudFtdfVxuICovXG5mdW5jdGlvbiBnZXRMaW5lc0JlbG93KHNjYWxlLCBpbmRleCkge1xuICBjb25zdCBiZWxvdyA9IFtdO1xuICBjb25zdCBtZXRhcyA9IHNjYWxlLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCdsaW5lJyk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXRhcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG1ldGEgPSBtZXRhc1tpXTtcbiAgICBpZiAobWV0YS5pbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoIW1ldGEuaGlkZGVuKSB7XG4gICAgICBiZWxvdy51bnNoaWZ0KG1ldGEuZGF0YXNldCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBiZWxvdztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1BvaW50RWxlbWVudFtdfSBwb2ludHNcbiAqIEBwYXJhbSB7UG9pbnRFbGVtZW50fSBzb3VyY2VQb2ludFxuICogQHBhcmFtIHtMaW5lRWxlbWVudFtdfSBsaW5lc0JlbG93XG4gKi9cbmZ1bmN0aW9uIGFkZFBvaW50c0JlbG93KHBvaW50cywgc291cmNlUG9pbnQsIGxpbmVzQmVsb3cpIHtcbiAgY29uc3QgcG9zdHBvbmVkID0gW107XG4gIGZvciAobGV0IGogPSAwOyBqIDwgbGluZXNCZWxvdy5sZW5ndGg7IGorKykge1xuICAgIGNvbnN0IGxpbmUgPSBsaW5lc0JlbG93W2pdO1xuICAgIGNvbnN0IHtmaXJzdCwgbGFzdCwgcG9pbnR9ID0gZmluZFBvaW50KGxpbmUsIHNvdXJjZVBvaW50LCAneCcpO1xuXG4gICAgaWYgKCFwb2ludCB8fCAoZmlyc3QgJiYgbGFzdCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoZmlyc3QpIHtcbiAgICAgIC8vIEZpcnN0IHBvaW50IG9mIGFuIHNlZ21lbnQgLT4gbmVlZCB0byBhZGQgYW5vdGhlciBwb2ludCBiZWZvcmUgdGhpcyxcbiAgICAgIC8vIGZyb20gbmV4dCBsaW5lIGJlbG93LlxuICAgICAgcG9zdHBvbmVkLnVuc2hpZnQocG9pbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludHMucHVzaChwb2ludCk7XG4gICAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgLy8gSW4gdGhlIG1pZGRsZSBvZiBhbiBzZWdtZW50LCBubyBuZWVkIHRvIGFkZCBtb3JlIHBvaW50cy5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBvaW50cy5wdXNoKC4uLnBvc3Rwb25lZCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICogQHBhcmFtIHtQb2ludEVsZW1lbnR9IHNvdXJjZVBvaW50XG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAqIEByZXR1cm5zIHt7cG9pbnQ/OiBQb2ludEVsZW1lbnQsIGZpcnN0PzogYm9vbGVhbiwgbGFzdD86IGJvb2xlYW59fVxuICovXG5mdW5jdGlvbiBmaW5kUG9pbnQobGluZSwgc291cmNlUG9pbnQsIHByb3BlcnR5KSB7XG4gIGNvbnN0IHBvaW50ID0gbGluZS5pbnRlcnBvbGF0ZShzb3VyY2VQb2ludCwgcHJvcGVydHkpO1xuICBpZiAoIXBvaW50KSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgY29uc3QgcG9pbnRWYWx1ZSA9IHBvaW50W3Byb3BlcnR5XTtcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuICBjb25zdCBsaW5lUG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGxldCBmaXJzdCA9IGZhbHNlO1xuICBsZXQgbGFzdCA9IGZhbHNlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgIGNvbnN0IGZpcnN0VmFsdWUgPSBsaW5lUG9pbnRzW3NlZ21lbnQuc3RhcnRdW3Byb3BlcnR5XTtcbiAgICBjb25zdCBsYXN0VmFsdWUgPSBsaW5lUG9pbnRzW3NlZ21lbnQuZW5kXVtwcm9wZXJ0eV07XG4gICAgaWYgKF9pc0JldHdlZW4ocG9pbnRWYWx1ZSwgZmlyc3RWYWx1ZSwgbGFzdFZhbHVlKSkge1xuICAgICAgZmlyc3QgPSBwb2ludFZhbHVlID09PSBmaXJzdFZhbHVlO1xuICAgICAgbGFzdCA9IHBvaW50VmFsdWUgPT09IGxhc3RWYWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge2ZpcnN0LCBsYXN0LCBwb2ludH07XG59XG4iLCAiaW1wb3J0IHtUQVV9IGZyb20gJy4uLy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG4vLyBUT0RPOiB1c2UgZWxlbWVudHMuQXJjRWxlbWVudCBpbnN0ZWFkXG5leHBvcnQgY2xhc3Mgc2ltcGxlQXJjIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHRoaXMueCA9IG9wdHMueDtcbiAgICB0aGlzLnkgPSBvcHRzLnk7XG4gICAgdGhpcy5yYWRpdXMgPSBvcHRzLnJhZGl1cztcbiAgfVxuXG4gIHBhdGhTZWdtZW50KGN0eCwgYm91bmRzLCBvcHRzKSB7XG4gICAgY29uc3Qge3gsIHksIHJhZGl1c30gPSB0aGlzO1xuICAgIGJvdW5kcyA9IGJvdW5kcyB8fCB7c3RhcnQ6IDAsIGVuZDogVEFVfTtcbiAgICBjdHguYXJjKHgsIHksIHJhZGl1cywgYm91bmRzLmVuZCwgYm91bmRzLnN0YXJ0LCB0cnVlKTtcbiAgICByZXR1cm4gIW9wdHMuYm91bmRzO1xuICB9XG5cbiAgaW50ZXJwb2xhdGUocG9pbnQpIHtcbiAgICBjb25zdCB7eCwgeSwgcmFkaXVzfSA9IHRoaXM7XG4gICAgY29uc3QgYW5nbGUgPSBwb2ludC5hbmdsZTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCArIE1hdGguY29zKGFuZ2xlKSAqIHJhZGl1cyxcbiAgICAgIHk6IHkgKyBNYXRoLnNpbihhbmdsZSkgKiByYWRpdXMsXG4gICAgICBhbmdsZVxuICAgIH07XG4gIH1cbn1cbiIsICJpbXBvcnQge2lzRmluaXRlfSBmcm9tICcuLi8uLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7X2NyZWF0ZUJvdW5kYXJ5TGluZX0gZnJvbSAnLi9maWxsZXIuaGVscGVyLmpzJztcbmltcG9ydCB7X2dldFRhcmdldFBpeGVsLCBfZ2V0VGFyZ2V0VmFsdWV9IGZyb20gJy4vZmlsbGVyLm9wdGlvbnMuanMnO1xuaW1wb3J0IHtfYnVpbGRTdGFja0xpbmV9IGZyb20gJy4vZmlsbGVyLnRhcmdldC5zdGFjay5qcyc7XG5pbXBvcnQge3NpbXBsZUFyY30gZnJvbSAnLi9zaW1wbGVBcmMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9jb3JlL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2NvcmUvY29yZS5zY2FsZS5qcycpLmRlZmF1bHQgfSBTY2FsZVxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2VsZW1lbnRzL2VsZW1lbnQucG9pbnQuanMnKS5kZWZhdWx0IH0gUG9pbnRFbGVtZW50XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIF9nZXRUYXJnZXQoc291cmNlKSB7XG4gIGNvbnN0IHtjaGFydCwgZmlsbCwgbGluZX0gPSBzb3VyY2U7XG5cbiAgaWYgKGlzRmluaXRlKGZpbGwpKSB7XG4gICAgcmV0dXJuIGdldExpbmVCeUluZGV4KGNoYXJ0LCBmaWxsKTtcbiAgfVxuXG4gIGlmIChmaWxsID09PSAnc3RhY2snKSB7XG4gICAgcmV0dXJuIF9idWlsZFN0YWNrTGluZShzb3VyY2UpO1xuICB9XG5cbiAgaWYgKGZpbGwgPT09ICdzaGFwZScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IGJvdW5kYXJ5ID0gY29tcHV0ZUJvdW5kYXJ5KHNvdXJjZSk7XG5cbiAgaWYgKGJvdW5kYXJ5IGluc3RhbmNlb2Ygc2ltcGxlQXJjKSB7XG4gICAgcmV0dXJuIGJvdW5kYXJ5O1xuICB9XG5cbiAgcmV0dXJuIF9jcmVhdGVCb3VuZGFyeUxpbmUoYm91bmRhcnksIGxpbmUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqL1xuZnVuY3Rpb24gZ2V0TGluZUJ5SW5kZXgoY2hhcnQsIGluZGV4KSB7XG4gIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpbmRleCk7XG4gIGNvbnN0IHZpc2libGUgPSBtZXRhICYmIGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaW5kZXgpO1xuICByZXR1cm4gdmlzaWJsZSA/IG1ldGEuZGF0YXNldCA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVCb3VuZGFyeShzb3VyY2UpIHtcbiAgY29uc3Qgc2NhbGUgPSBzb3VyY2Uuc2NhbGUgfHwge307XG5cbiAgaWYgKHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSkge1xuICAgIHJldHVybiBjb21wdXRlQ2lyY3VsYXJCb3VuZGFyeShzb3VyY2UpO1xuICB9XG4gIHJldHVybiBjb21wdXRlTGluZWFyQm91bmRhcnkoc291cmNlKTtcbn1cblxuXG5mdW5jdGlvbiBjb21wdXRlTGluZWFyQm91bmRhcnkoc291cmNlKSB7XG4gIGNvbnN0IHtzY2FsZSA9IHt9LCBmaWxsfSA9IHNvdXJjZTtcbiAgY29uc3QgcGl4ZWwgPSBfZ2V0VGFyZ2V0UGl4ZWwoZmlsbCwgc2NhbGUpO1xuXG4gIGlmIChpc0Zpbml0ZShwaXhlbCkpIHtcbiAgICBjb25zdCBob3Jpem9udGFsID0gc2NhbGUuaXNIb3Jpem9udGFsKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogaG9yaXpvbnRhbCA/IHBpeGVsIDogbnVsbCxcbiAgICAgIHk6IGhvcml6b250YWwgPyBudWxsIDogcGl4ZWxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVDaXJjdWxhckJvdW5kYXJ5KHNvdXJjZSkge1xuICBjb25zdCB7c2NhbGUsIGZpbGx9ID0gc291cmNlO1xuICBjb25zdCBvcHRpb25zID0gc2NhbGUub3B0aW9ucztcbiAgY29uc3QgbGVuZ3RoID0gc2NhbGUuZ2V0TGFiZWxzKCkubGVuZ3RoO1xuICBjb25zdCBzdGFydCA9IG9wdGlvbnMucmV2ZXJzZSA/IHNjYWxlLm1heCA6IHNjYWxlLm1pbjtcbiAgY29uc3QgdmFsdWUgPSBfZ2V0VGFyZ2V0VmFsdWUoZmlsbCwgc2NhbGUsIHN0YXJ0KTtcbiAgY29uc3QgdGFyZ2V0ID0gW107XG5cbiAgaWYgKG9wdGlvbnMuZ3JpZC5jaXJjdWxhcikge1xuICAgIGNvbnN0IGNlbnRlciA9IHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSgwLCBzdGFydCk7XG4gICAgcmV0dXJuIG5ldyBzaW1wbGVBcmMoe1xuICAgICAgeDogY2VudGVyLngsXG4gICAgICB5OiBjZW50ZXIueSxcbiAgICAgIHJhZGl1czogc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpXG4gICAgfSk7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdGFyZ2V0LnB1c2goc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGksIHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuIiwgImltcG9ydCB7Y2xpcEFyZWEsIHVuY2xpcEFyZWF9IGZyb20gJy4uLy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtfZmluZFNlZ21lbnRFbmQsIF9nZXRCb3VuZHMsIF9zZWdtZW50c30gZnJvbSAnLi9maWxsZXIuc2VnbWVudC5qcyc7XG5pbXBvcnQge19nZXRUYXJnZXR9IGZyb20gJy4vZmlsbGVyLnRhcmdldC5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBfZHJhd2ZpbGwoY3R4LCBzb3VyY2UsIGFyZWEpIHtcbiAgY29uc3QgdGFyZ2V0ID0gX2dldFRhcmdldChzb3VyY2UpO1xuICBjb25zdCB7bGluZSwgc2NhbGUsIGF4aXN9ID0gc291cmNlO1xuICBjb25zdCBsaW5lT3B0cyA9IGxpbmUub3B0aW9ucztcbiAgY29uc3QgZmlsbE9wdGlvbiA9IGxpbmVPcHRzLmZpbGw7XG4gIGNvbnN0IGNvbG9yID0gbGluZU9wdHMuYmFja2dyb3VuZENvbG9yO1xuICBjb25zdCB7YWJvdmUgPSBjb2xvciwgYmVsb3cgPSBjb2xvcn0gPSBmaWxsT3B0aW9uIHx8IHt9O1xuICBpZiAodGFyZ2V0ICYmIGxpbmUucG9pbnRzLmxlbmd0aCkge1xuICAgIGNsaXBBcmVhKGN0eCwgYXJlYSk7XG4gICAgZG9GaWxsKGN0eCwge2xpbmUsIHRhcmdldCwgYWJvdmUsIGJlbG93LCBhcmVhLCBzY2FsZSwgYXhpc30pO1xuICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkb0ZpbGwoY3R4LCBjZmcpIHtcbiAgY29uc3Qge2xpbmUsIHRhcmdldCwgYWJvdmUsIGJlbG93LCBhcmVhLCBzY2FsZX0gPSBjZmc7XG4gIGNvbnN0IHByb3BlcnR5ID0gbGluZS5fbG9vcCA/ICdhbmdsZScgOiBjZmcuYXhpcztcblxuICBjdHguc2F2ZSgpO1xuXG4gIGlmIChwcm9wZXJ0eSA9PT0gJ3gnICYmIGJlbG93ICE9PSBhYm92ZSkge1xuICAgIGNsaXBWZXJ0aWNhbChjdHgsIHRhcmdldCwgYXJlYS50b3ApO1xuICAgIGZpbGwoY3R4LCB7bGluZSwgdGFyZ2V0LCBjb2xvcjogYWJvdmUsIHNjYWxlLCBwcm9wZXJ0eX0pO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjbGlwVmVydGljYWwoY3R4LCB0YXJnZXQsIGFyZWEuYm90dG9tKTtcbiAgfVxuICBmaWxsKGN0eCwge2xpbmUsIHRhcmdldCwgY29sb3I6IGJlbG93LCBzY2FsZSwgcHJvcGVydHl9KTtcblxuICBjdHgucmVzdG9yZSgpO1xufVxuXG5mdW5jdGlvbiBjbGlwVmVydGljYWwoY3R4LCB0YXJnZXQsIGNsaXBZKSB7XG4gIGNvbnN0IHtzZWdtZW50cywgcG9pbnRzfSA9IHRhcmdldDtcbiAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgbGV0IGxpbmVMb29wID0gZmFsc2U7XG5cbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBjb25zdCB7c3RhcnQsIGVuZH0gPSBzZWdtZW50O1xuICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBwb2ludHNbc3RhcnRdO1xuICAgIGNvbnN0IGxhc3RQb2ludCA9IHBvaW50c1tfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgcG9pbnRzKV07XG4gICAgaWYgKGZpcnN0KSB7XG4gICAgICBjdHgubW92ZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcbiAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5saW5lVG8oZmlyc3RQb2ludC54LCBjbGlwWSk7XG4gICAgICBjdHgubGluZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcbiAgICB9XG4gICAgbGluZUxvb3AgPSAhIXRhcmdldC5wYXRoU2VnbWVudChjdHgsIHNlZ21lbnQsIHttb3ZlOiBsaW5lTG9vcH0pO1xuICAgIGlmIChsaW5lTG9vcCkge1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHgubGluZVRvKGxhc3RQb2ludC54LCBjbGlwWSk7XG4gICAgfVxuICB9XG5cbiAgY3R4LmxpbmVUbyh0YXJnZXQuZmlyc3QoKS54LCBjbGlwWSk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LmNsaXAoKTtcbn1cblxuZnVuY3Rpb24gZmlsbChjdHgsIGNmZykge1xuICBjb25zdCB7bGluZSwgdGFyZ2V0LCBwcm9wZXJ0eSwgY29sb3IsIHNjYWxlfSA9IGNmZztcbiAgY29uc3Qgc2VnbWVudHMgPSBfc2VnbWVudHMobGluZSwgdGFyZ2V0LCBwcm9wZXJ0eSk7XG5cbiAgZm9yIChjb25zdCB7c291cmNlOiBzcmMsIHRhcmdldDogdGd0LCBzdGFydCwgZW5kfSBvZiBzZWdtZW50cykge1xuICAgIGNvbnN0IHtzdHlsZToge2JhY2tncm91bmRDb2xvciA9IGNvbG9yfSA9IHt9fSA9IHNyYztcbiAgICBjb25zdCBub3RTaGFwZSA9IHRhcmdldCAhPT0gdHJ1ZTtcblxuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcblxuICAgIGNsaXBCb3VuZHMoY3R4LCBzY2FsZSwgbm90U2hhcGUgJiYgX2dldEJvdW5kcyhwcm9wZXJ0eSwgc3RhcnQsIGVuZCkpO1xuXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgY29uc3QgbGluZUxvb3AgPSAhIWxpbmUucGF0aFNlZ21lbnQoY3R4LCBzcmMpO1xuXG4gICAgbGV0IGxvb3A7XG4gICAgaWYgKG5vdFNoYXBlKSB7XG4gICAgICBpZiAobGluZUxvb3ApIHtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJwb2xhdGVkTGluZVRvKGN0eCwgdGFyZ2V0LCBlbmQsIHByb3BlcnR5KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGFyZ2V0TG9vcCA9ICEhdGFyZ2V0LnBhdGhTZWdtZW50KGN0eCwgdGd0LCB7bW92ZTogbGluZUxvb3AsIHJldmVyc2U6IHRydWV9KTtcbiAgICAgIGxvb3AgPSBsaW5lTG9vcCAmJiB0YXJnZXRMb29wO1xuICAgICAgaWYgKCFsb29wKSB7XG4gICAgICAgIGludGVycG9sYXRlZExpbmVUbyhjdHgsIHRhcmdldCwgc3RhcnQsIHByb3BlcnR5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4LmZpbGwobG9vcCA/ICdldmVub2RkJyA6ICdub256ZXJvJyk7XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNsaXBCb3VuZHMoY3R4LCBzY2FsZSwgYm91bmRzKSB7XG4gIGNvbnN0IHt0b3AsIGJvdHRvbX0gPSBzY2FsZS5jaGFydC5jaGFydEFyZWE7XG4gIGNvbnN0IHtwcm9wZXJ0eSwgc3RhcnQsIGVuZH0gPSBib3VuZHMgfHwge307XG4gIGlmIChwcm9wZXJ0eSA9PT0gJ3gnKSB7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5yZWN0KHN0YXJ0LCB0b3AsIGVuZCAtIHN0YXJ0LCBib3R0b20gLSB0b3ApO1xuICAgIGN0eC5jbGlwKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW50ZXJwb2xhdGVkTGluZVRvKGN0eCwgdGFyZ2V0LCBwb2ludCwgcHJvcGVydHkpIHtcbiAgY29uc3QgaW50ZXJwb2xhdGVkUG9pbnQgPSB0YXJnZXQuaW50ZXJwb2xhdGUocG9pbnQsIHByb3BlcnR5KTtcbiAgaWYgKGludGVycG9sYXRlZFBvaW50KSB7XG4gICAgY3R4LmxpbmVUbyhpbnRlcnBvbGF0ZWRQb2ludC54LCBpbnRlcnBvbGF0ZWRQb2ludC55KTtcbiAgfVxufVxuXG4iLCAiLyoqXG4gKiBQbHVnaW4gYmFzZWQgb24gZGlzY3Vzc2lvbiBmcm9tIHRoZSBmb2xsb3dpbmcgQ2hhcnQuanMgaXNzdWVzOlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjM4MCNpc3N1ZWNvbW1lbnQtMjc5OTYxNTY5XG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yNDQwI2lzc3VlY29tbWVudC0yNTY0NjE4OTdcbiAqL1xuXG5pbXBvcnQgTGluZUVsZW1lbnQgZnJvbSAnLi4vLi4vZWxlbWVudHMvZWxlbWVudC5saW5lLmpzJztcbmltcG9ydCB7X2RyYXdmaWxsfSBmcm9tICcuL2ZpbGxlci5kcmF3aW5nLmpzJztcbmltcG9ydCB7X3Nob3VsZEFwcGx5RmlsbH0gZnJvbSAnLi9maWxsZXIuaGVscGVyLmpzJztcbmltcG9ydCB7X2RlY29kZUZpbGwsIF9yZXNvbHZlVGFyZ2V0fSBmcm9tICcuL2ZpbGxlci5vcHRpb25zLmpzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBpZDogJ2ZpbGxlcicsXG5cbiAgYWZ0ZXJEYXRhc2V0c1VwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjb3VudCA9IChjaGFydC5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGg7XG4gICAgY29uc3Qgc291cmNlcyA9IFtdO1xuICAgIGxldCBtZXRhLCBpLCBsaW5lLCBzb3VyY2U7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgbGluZSA9IG1ldGEuZGF0YXNldDtcbiAgICAgIHNvdXJjZSA9IG51bGw7XG5cbiAgICAgIGlmIChsaW5lICYmIGxpbmUub3B0aW9ucyAmJiBsaW5lIGluc3RhbmNlb2YgTGluZUVsZW1lbnQpIHtcbiAgICAgICAgc291cmNlID0ge1xuICAgICAgICAgIHZpc2libGU6IGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSksXG4gICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgZmlsbDogX2RlY29kZUZpbGwobGluZSwgaSwgY291bnQpLFxuICAgICAgICAgIGNoYXJ0LFxuICAgICAgICAgIGF4aXM6IG1ldGEuY29udHJvbGxlci5vcHRpb25zLmluZGV4QXhpcyxcbiAgICAgICAgICBzY2FsZTogbWV0YS52U2NhbGUsXG4gICAgICAgICAgbGluZSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbWV0YS4kZmlsbGVyID0gc291cmNlO1xuICAgICAgc291cmNlcy5wdXNoKHNvdXJjZSk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIHNvdXJjZSA9IHNvdXJjZXNbaV07XG4gICAgICBpZiAoIXNvdXJjZSB8fCBzb3VyY2UuZmlsbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHNvdXJjZS5maWxsID0gX3Jlc29sdmVUYXJnZXQoc291cmNlcywgaSwgb3B0aW9ucy5wcm9wYWdhdGUpO1xuICAgIH1cbiAgfSxcblxuICBiZWZvcmVEcmF3KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IGRyYXcgPSBvcHRpb25zLmRyYXdUaW1lID09PSAnYmVmb3JlRHJhdyc7XG4gICAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgY29uc3QgYXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICBmb3IgKGxldCBpID0gbWV0YXNldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IG1ldGFzZXRzW2ldLiRmaWxsZXI7XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc291cmNlLmxpbmUudXBkYXRlQ29udHJvbFBvaW50cyhhcmVhLCBzb3VyY2UuYXhpcyk7XG4gICAgICBpZiAoZHJhdyAmJiBzb3VyY2UuZmlsbCkge1xuICAgICAgICBfZHJhd2ZpbGwoY2hhcnQuY3R4LCBzb3VyY2UsIGFyZWEpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBiZWZvcmVEYXRhc2V0c0RyYXcoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuZHJhd1RpbWUgIT09ICdiZWZvcmVEYXRhc2V0c0RyYXcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgZm9yIChsZXQgaSA9IG1ldGFzZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBtZXRhc2V0c1tpXS4kZmlsbGVyO1xuXG4gICAgICBpZiAoX3Nob3VsZEFwcGx5RmlsbChzb3VyY2UpKSB7XG4gICAgICAgIF9kcmF3ZmlsbChjaGFydC5jdHgsIHNvdXJjZSwgY2hhcnQuY2hhcnRBcmVhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgYmVmb3JlRGF0YXNldERyYXcoY2hhcnQsIGFyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBhcmdzLm1ldGEuJGZpbGxlcjtcblxuICAgIGlmICghX3Nob3VsZEFwcGx5RmlsbChzb3VyY2UpIHx8IG9wdGlvbnMuZHJhd1RpbWUgIT09ICdiZWZvcmVEYXRhc2V0RHJhdycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBfZHJhd2ZpbGwoY2hhcnQuY3R4LCBzb3VyY2UsIGNoYXJ0LmNoYXJ0QXJlYSk7XG4gIH0sXG5cbiAgZGVmYXVsdHM6IHtcbiAgICBwcm9wYWdhdGU6IHRydWUsXG4gICAgZHJhd1RpbWU6ICdiZWZvcmVEYXRhc2V0RHJhdydcbiAgfVxufTtcbiIsICJpbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi4vY29yZS9jb3JlLmRlZmF1bHRzLmpzJztcbmltcG9ydCBFbGVtZW50IGZyb20gJy4uL2NvcmUvY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCBsYXlvdXRzIGZyb20gJy4uL2NvcmUvY29yZS5sYXlvdXRzLmpzJztcbmltcG9ydCB7YWRkUm91bmRlZFJlY3RQYXRoLCBkcmF3UG9pbnRMZWdlbmQsIHJlbmRlclRleHR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHtcbiAgX2lzQmV0d2VlbixcbiAgY2FsbGJhY2sgYXMgY2FsbCxcbiAgY2xpcEFyZWEsXG4gIGdldFJ0bEFkYXB0ZXIsXG4gIG92ZXJyaWRlVGV4dERpcmVjdGlvbixcbiAgcmVzdG9yZVRleHREaXJlY3Rpb24sXG4gIHRvRm9udCxcbiAgdG9QYWRkaW5nLFxuICB1bmNsaXBBcmVhLFxuICB2YWx1ZU9yRGVmYXVsdCxcbn0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge19hbGlnblN0YXJ0RW5kLCBfdGV4dFgsIF90b0xlZnRSaWdodENlbnRlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmV4dHJhcy5qcyc7XG5pbXBvcnQge3RvVFJCTENvcm5lcnN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5DaGFydEV2ZW50IH0gQ2hhcnRFdmVudFxuICovXG5cbmNvbnN0IGdldEJveFNpemUgPSAobGFiZWxPcHRzLCBmb250U2l6ZSkgPT4ge1xuICBsZXQge2JveEhlaWdodCA9IGZvbnRTaXplLCBib3hXaWR0aCA9IGZvbnRTaXplfSA9IGxhYmVsT3B0cztcblxuICBpZiAobGFiZWxPcHRzLnVzZVBvaW50U3R5bGUpIHtcbiAgICBib3hIZWlnaHQgPSBNYXRoLm1pbihib3hIZWlnaHQsIGZvbnRTaXplKTtcbiAgICBib3hXaWR0aCA9IGxhYmVsT3B0cy5wb2ludFN0eWxlV2lkdGggfHwgTWF0aC5taW4oYm94V2lkdGgsIGZvbnRTaXplKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYm94V2lkdGgsXG4gICAgYm94SGVpZ2h0LFxuICAgIGl0ZW1IZWlnaHQ6IE1hdGgubWF4KGZvbnRTaXplLCBib3hIZWlnaHQpXG4gIH07XG59O1xuXG5jb25zdCBpdGVtc0VxdWFsID0gKGEsIGIpID0+IGEgIT09IG51bGwgJiYgYiAhPT0gbnVsbCAmJiBhLmRhdGFzZXRJbmRleCA9PT0gYi5kYXRhc2V0SW5kZXggJiYgYS5pbmRleCA9PT0gYi5pbmRleDtcblxuZXhwb3J0IGNsYXNzIExlZ2VuZCBleHRlbmRzIEVsZW1lbnQge1xuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3sgY3R4OiBhbnk7IG9wdGlvbnM6IGFueTsgY2hhcnQ6IGFueTsgfX0gY29uZmlnXG5cdCAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fYWRkZWQgPSBmYWxzZTtcblxuICAgIC8vIENvbnRhaW5zIGhpdCBib3hlcyBmb3IgZWFjaCBkYXRhc2V0IChpbiBkYXRhc2V0IG9yZGVyKVxuICAgIHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcblxuICAgIC8qKlxuIFx0XHQgKiBAcHJpdmF0ZVxuIFx0XHQgKi9cbiAgICB0aGlzLl9ob3ZlcmVkSXRlbSA9IG51bGw7XG5cbiAgICAvLyBBcmUgd2UgaW4gZG91Z2hudXQgbW9kZSB3aGljaCBoYXMgYSBkaWZmZXJlbnQgZGF0YSB0eXBlXG4gICAgdGhpcy5kb3VnaG51dE1vZGUgPSBmYWxzZTtcblxuICAgIHRoaXMuY2hhcnQgPSBjb25maWcuY2hhcnQ7XG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG4gICAgdGhpcy5jdHggPSBjb25maWcuY3R4O1xuICAgIHRoaXMubGVnZW5kSXRlbXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jb2x1bW5TaXplcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxpbmVXaWR0aHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXhIZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXhXaWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRvcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvdHRvbSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxlZnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX21hcmdpbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZ1bGxTaXplID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdXBkYXRlKG1heFdpZHRoLCBtYXhIZWlnaHQsIG1hcmdpbnMpIHtcbiAgICB0aGlzLm1heFdpZHRoID0gbWF4V2lkdGg7XG4gICAgdGhpcy5tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XG4gICAgdGhpcy5fbWFyZ2lucyA9IG1hcmdpbnM7XG5cbiAgICB0aGlzLnNldERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLmJ1aWxkTGFiZWxzKCk7XG4gICAgdGhpcy5maXQoKTtcbiAgfVxuXG4gIHNldERpbWVuc2lvbnMoKSB7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLm1heFdpZHRoO1xuICAgICAgdGhpcy5sZWZ0ID0gdGhpcy5fbWFyZ2lucy5sZWZ0O1xuICAgICAgdGhpcy5yaWdodCA9IHRoaXMud2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQ7XG4gICAgICB0aGlzLnRvcCA9IHRoaXMuX21hcmdpbnMudG9wO1xuICAgICAgdGhpcy5ib3R0b20gPSB0aGlzLmhlaWdodDtcbiAgICB9XG4gIH1cblxuICBidWlsZExhYmVscygpIHtcbiAgICBjb25zdCBsYWJlbE9wdHMgPSB0aGlzLm9wdGlvbnMubGFiZWxzIHx8IHt9O1xuICAgIGxldCBsZWdlbmRJdGVtcyA9IGNhbGwobGFiZWxPcHRzLmdlbmVyYXRlTGFiZWxzLCBbdGhpcy5jaGFydF0sIHRoaXMpIHx8IFtdO1xuXG4gICAgaWYgKGxhYmVsT3B0cy5maWx0ZXIpIHtcbiAgICAgIGxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXMuZmlsdGVyKChpdGVtKSA9PiBsYWJlbE9wdHMuZmlsdGVyKGl0ZW0sIHRoaXMuY2hhcnQuZGF0YSkpO1xuICAgIH1cblxuICAgIGlmIChsYWJlbE9wdHMuc29ydCkge1xuICAgICAgbGVnZW5kSXRlbXMgPSBsZWdlbmRJdGVtcy5zb3J0KChhLCBiKSA9PiBsYWJlbE9wdHMuc29ydChhLCBiLCB0aGlzLmNoYXJ0LmRhdGEpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIGxlZ2VuZEl0ZW1zLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICB0aGlzLmxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXM7XG4gIH1cblxuICBmaXQoKSB7XG4gICAgY29uc3Qge29wdGlvbnMsIGN0eH0gPSB0aGlzO1xuXG4gICAgLy8gVGhlIGxlZ2VuZCBtYXkgbm90IGJlIGRpc3BsYXllZCBmb3IgYSB2YXJpZXR5IG9mIHJlYXNvbnMgaW5jbHVkaW5nXG4gICAgLy8gdGhlIGZhY3QgdGhhdCB0aGUgZGVmYXVsdHMgZ290IHNldCB0byBgZmFsc2VgLlxuICAgIC8vIFdoZW4gdGhlIGxlZ2VuZCBpcyBub3QgZGlzcGxheWVkLCB0aGVyZSBhcmUgbm8gZ3VhcmFudGVlcyB0aGF0IHRoZSBvcHRpb25zXG4gICAgLy8gYXJlIGNvcnJlY3RseSBmb3JtYXR0ZWQgc28gd2UgbmVlZCB0byBiYWlsIG91dCBhcyBlYXJseSBhcyBwb3NzaWJsZS5cbiAgICBpZiAoIW9wdGlvbnMuZGlzcGxheSkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBsYWJlbE9wdHMgPSBvcHRpb25zLmxhYmVscztcbiAgICBjb25zdCBsYWJlbEZvbnQgPSB0b0ZvbnQobGFiZWxPcHRzLmZvbnQpO1xuICAgIGNvbnN0IGZvbnRTaXplID0gbGFiZWxGb250LnNpemU7XG4gICAgY29uc3QgdGl0bGVIZWlnaHQgPSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKTtcbiAgICBjb25zdCB7Ym94V2lkdGgsIGl0ZW1IZWlnaHR9ID0gZ2V0Qm94U2l6ZShsYWJlbE9wdHMsIGZvbnRTaXplKTtcblxuICAgIGxldCB3aWR0aCwgaGVpZ2h0O1xuXG4gICAgY3R4LmZvbnQgPSBsYWJlbEZvbnQuc3RyaW5nO1xuXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHdpZHRoID0gdGhpcy5tYXhXaWR0aDsgLy8gZmlsbCBhbGwgdGhlIHdpZHRoXG4gICAgICBoZWlnaHQgPSB0aGlzLl9maXRSb3dzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpICsgMTA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlaWdodCA9IHRoaXMubWF4SGVpZ2h0OyAvLyBmaWxsIGFsbCB0aGUgaGVpZ2h0XG4gICAgICB3aWR0aCA9IHRoaXMuX2ZpdENvbHModGl0bGVIZWlnaHQsIGxhYmVsRm9udCwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpICsgMTA7XG4gICAgfVxuXG4gICAgdGhpcy53aWR0aCA9IE1hdGgubWluKHdpZHRoLCBvcHRpb25zLm1heFdpZHRoIHx8IHRoaXMubWF4V2lkdGgpO1xuICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5taW4oaGVpZ2h0LCBvcHRpb25zLm1heEhlaWdodCB8fCB0aGlzLm1heEhlaWdodCk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9maXRSb3dzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpIHtcbiAgICBjb25zdCB7Y3R4LCBtYXhXaWR0aCwgb3B0aW9uczoge2xhYmVsczoge3BhZGRpbmd9fX0gPSB0aGlzO1xuICAgIGNvbnN0IGhpdGJveGVzID0gdGhpcy5sZWdlbmRIaXRCb3hlcyA9IFtdO1xuICAgIC8vIFdpZHRoIG9mIGVhY2ggbGluZSBvZiBsZWdlbmQgYm94ZXMuIExhYmVscyB3cmFwIG9udG8gbXVsdGlwbGUgbGluZXMgd2hlbiB0aGVyZSBhcmUgdG9vIG1hbnkgdG8gZml0IG9uIG9uZVxuICAgIGNvbnN0IGxpbmVXaWR0aHMgPSB0aGlzLmxpbmVXaWR0aHMgPSBbMF07XG4gICAgY29uc3QgbGluZUhlaWdodCA9IGl0ZW1IZWlnaHQgKyBwYWRkaW5nO1xuICAgIGxldCB0b3RhbEhlaWdodCA9IHRpdGxlSGVpZ2h0O1xuXG4gICAgY3R4LnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cbiAgICBsZXQgcm93ID0gLTE7XG4gICAgbGV0IHRvcCA9IC1saW5lSGVpZ2h0O1xuICAgIHRoaXMubGVnZW5kSXRlbXMuZm9yRWFjaCgobGVnZW5kSXRlbSwgaSkgPT4ge1xuICAgICAgY29uc3QgaXRlbVdpZHRoID0gYm94V2lkdGggKyAoZm9udFNpemUgLyAyKSArIGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuXG4gICAgICBpZiAoaSA9PT0gMCB8fCBsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gMV0gKyBpdGVtV2lkdGggKyAyICogcGFkZGluZyA+IG1heFdpZHRoKSB7XG4gICAgICAgIHRvdGFsSGVpZ2h0ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgIGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAoaSA+IDAgPyAwIDogMSldID0gMDtcbiAgICAgICAgdG9wICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgIHJvdysrO1xuICAgICAgfVxuXG4gICAgICBoaXRib3hlc1tpXSA9IHtsZWZ0OiAwLCB0b3AsIHJvdywgd2lkdGg6IGl0ZW1XaWR0aCwgaGVpZ2h0OiBpdGVtSGVpZ2h0fTtcblxuICAgICAgbGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIDFdICs9IGl0ZW1XaWR0aCArIHBhZGRpbmc7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdG90YWxIZWlnaHQ7XG4gIH1cblxuICBfZml0Q29scyh0aXRsZUhlaWdodCwgbGFiZWxGb250LCBib3hXaWR0aCwgX2l0ZW1IZWlnaHQpIHtcbiAgICBjb25zdCB7Y3R4LCBtYXhIZWlnaHQsIG9wdGlvbnM6IHtsYWJlbHM6IHtwYWRkaW5nfX19ID0gdGhpcztcbiAgICBjb25zdCBoaXRib3hlcyA9IHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcbiAgICBjb25zdCBjb2x1bW5TaXplcyA9IHRoaXMuY29sdW1uU2l6ZXMgPSBbXTtcbiAgICBjb25zdCBoZWlnaHRMaW1pdCA9IG1heEhlaWdodCAtIHRpdGxlSGVpZ2h0O1xuXG4gICAgbGV0IHRvdGFsV2lkdGggPSBwYWRkaW5nO1xuICAgIGxldCBjdXJyZW50Q29sV2lkdGggPSAwO1xuICAgIGxldCBjdXJyZW50Q29sSGVpZ2h0ID0gMDtcblxuICAgIGxldCBsZWZ0ID0gMDtcbiAgICBsZXQgY29sID0gMDtcblxuICAgIHRoaXMubGVnZW5kSXRlbXMuZm9yRWFjaCgobGVnZW5kSXRlbSwgaSkgPT4ge1xuICAgICAgY29uc3Qge2l0ZW1XaWR0aCwgaXRlbUhlaWdodH0gPSBjYWxjdWxhdGVJdGVtU2l6ZShib3hXaWR0aCwgbGFiZWxGb250LCBjdHgsIGxlZ2VuZEl0ZW0sIF9pdGVtSGVpZ2h0KTtcblxuICAgICAgLy8gSWYgdG9vIHRhbGwsIGdvIHRvIG5ldyBjb2x1bW5cbiAgICAgIGlmIChpID4gMCAmJiBjdXJyZW50Q29sSGVpZ2h0ICsgaXRlbUhlaWdodCArIDIgKiBwYWRkaW5nID4gaGVpZ2h0TGltaXQpIHtcbiAgICAgICAgdG90YWxXaWR0aCArPSBjdXJyZW50Q29sV2lkdGggKyBwYWRkaW5nO1xuICAgICAgICBjb2x1bW5TaXplcy5wdXNoKHt3aWR0aDogY3VycmVudENvbFdpZHRoLCBoZWlnaHQ6IGN1cnJlbnRDb2xIZWlnaHR9KTsgLy8gcHJldmlvdXMgY29sdW1uIHNpemVcbiAgICAgICAgbGVmdCArPSBjdXJyZW50Q29sV2lkdGggKyBwYWRkaW5nO1xuICAgICAgICBjb2wrKztcbiAgICAgICAgY3VycmVudENvbFdpZHRoID0gY3VycmVudENvbEhlaWdodCA9IDA7XG4gICAgICB9XG5cbiAgICAgIC8vIFN0b3JlIHRoZSBoaXRib3ggd2lkdGggYW5kIGhlaWdodCBoZXJlLiBGaW5hbCBwb3NpdGlvbiB3aWxsIGJlIHVwZGF0ZWQgaW4gYGRyYXdgXG4gICAgICBoaXRib3hlc1tpXSA9IHtsZWZ0LCB0b3A6IGN1cnJlbnRDb2xIZWlnaHQsIGNvbCwgd2lkdGg6IGl0ZW1XaWR0aCwgaGVpZ2h0OiBpdGVtSGVpZ2h0fTtcblxuICAgICAgLy8gR2V0IG1heCB3aWR0aFxuICAgICAgY3VycmVudENvbFdpZHRoID0gTWF0aC5tYXgoY3VycmVudENvbFdpZHRoLCBpdGVtV2lkdGgpO1xuICAgICAgY3VycmVudENvbEhlaWdodCArPSBpdGVtSGVpZ2h0ICsgcGFkZGluZztcbiAgICB9KTtcblxuICAgIHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoO1xuICAgIGNvbHVtblNpemVzLnB1c2goe3dpZHRoOiBjdXJyZW50Q29sV2lkdGgsIGhlaWdodDogY3VycmVudENvbEhlaWdodH0pOyAvLyBwcmV2aW91cyBjb2x1bW4gc2l6ZVxuXG4gICAgcmV0dXJuIHRvdGFsV2lkdGg7XG4gIH1cblxuICBhZGp1c3RIaXRCb3hlcygpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgY29uc3Qge2xlZ2VuZEhpdEJveGVzOiBoaXRib3hlcywgb3B0aW9uczoge2FsaWduLCBsYWJlbHM6IHtwYWRkaW5nfSwgcnRsfX0gPSB0aGlzO1xuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIocnRsLCB0aGlzLmxlZnQsIHRoaXMud2lkdGgpO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBsZXQgcm93ID0gMDtcbiAgICAgIGxldCBsZWZ0ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMubGVmdCArIHBhZGRpbmcsIHRoaXMucmlnaHQgLSB0aGlzLmxpbmVXaWR0aHNbcm93XSk7XG4gICAgICBmb3IgKGNvbnN0IGhpdGJveCBvZiBoaXRib3hlcykge1xuICAgICAgICBpZiAocm93ICE9PSBoaXRib3gucm93KSB7XG4gICAgICAgICAgcm93ID0gaGl0Ym94LnJvdztcbiAgICAgICAgICBsZWZ0ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMubGVmdCArIHBhZGRpbmcsIHRoaXMucmlnaHQgLSB0aGlzLmxpbmVXaWR0aHNbcm93XSk7XG4gICAgICAgIH1cbiAgICAgICAgaGl0Ym94LnRvcCArPSB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZztcbiAgICAgICAgaGl0Ym94LmxlZnQgPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxIZWxwZXIueChsZWZ0KSwgaGl0Ym94LndpZHRoKTtcbiAgICAgICAgbGVmdCArPSBoaXRib3gud2lkdGggKyBwYWRkaW5nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgY29sID0gMDtcbiAgICAgIGxldCB0b3AgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gdGhpcy5jb2x1bW5TaXplc1tjb2xdLmhlaWdodCk7XG4gICAgICBmb3IgKGNvbnN0IGhpdGJveCBvZiBoaXRib3hlcykge1xuICAgICAgICBpZiAoaGl0Ym94LmNvbCAhPT0gY29sKSB7XG4gICAgICAgICAgY29sID0gaGl0Ym94LmNvbDtcbiAgICAgICAgICB0b3AgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gdGhpcy5jb2x1bW5TaXplc1tjb2xdLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgaGl0Ym94LnRvcCA9IHRvcDtcbiAgICAgICAgaGl0Ym94LmxlZnQgKz0gdGhpcy5sZWZ0ICsgcGFkZGluZztcbiAgICAgICAgaGl0Ym94LmxlZnQgPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxIZWxwZXIueChoaXRib3gubGVmdCksIGhpdGJveC53aWR0aCk7XG4gICAgICAgIHRvcCArPSBoaXRib3guaGVpZ2h0ICsgcGFkZGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpc0hvcml6b250YWwoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ3RvcCcgfHwgdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAnYm90dG9tJztcbiAgfVxuXG4gIGRyYXcoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICAgIGNsaXBBcmVhKGN0eCwgdGhpcyk7XG5cbiAgICAgIHRoaXMuX2RyYXcoKTtcblxuICAgICAgdW5jbGlwQXJlYShjdHgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2RyYXcoKSB7XG4gICAgY29uc3Qge29wdGlvbnM6IG9wdHMsIGNvbHVtblNpemVzLCBsaW5lV2lkdGhzLCBjdHh9ID0gdGhpcztcbiAgICBjb25zdCB7YWxpZ24sIGxhYmVsczogbGFiZWxPcHRzfSA9IG9wdHM7XG4gICAgY29uc3QgZGVmYXVsdENvbG9yID0gZGVmYXVsdHMuY29sb3I7XG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRzLnJ0bCwgdGhpcy5sZWZ0LCB0aGlzLndpZHRoKTtcbiAgICBjb25zdCBsYWJlbEZvbnQgPSB0b0ZvbnQobGFiZWxPcHRzLmZvbnQpO1xuICAgIGNvbnN0IHtwYWRkaW5nfSA9IGxhYmVsT3B0cztcbiAgICBjb25zdCBmb250U2l6ZSA9IGxhYmVsRm9udC5zaXplO1xuICAgIGNvbnN0IGhhbGZGb250U2l6ZSA9IGZvbnRTaXplIC8gMjtcbiAgICBsZXQgY3Vyc29yO1xuXG4gICAgdGhpcy5kcmF3VGl0bGUoKTtcblxuICAgIC8vIENhbnZhcyBzZXR1cFxuICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKCdsZWZ0Jyk7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGN0eC5saW5lV2lkdGggPSAwLjU7XG4gICAgY3R4LmZvbnQgPSBsYWJlbEZvbnQuc3RyaW5nO1xuXG4gICAgY29uc3Qge2JveFdpZHRoLCBib3hIZWlnaHQsIGl0ZW1IZWlnaHR9ID0gZ2V0Qm94U2l6ZShsYWJlbE9wdHMsIGZvbnRTaXplKTtcblxuICAgIC8vIGN1cnJlbnQgcG9zaXRpb25cbiAgICBjb25zdCBkcmF3TGVnZW5kQm94ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSkge1xuICAgICAgaWYgKGlzTmFOKGJveFdpZHRoKSB8fCBib3hXaWR0aCA8PSAwIHx8IGlzTmFOKGJveEhlaWdodCkgfHwgYm94SGVpZ2h0IDwgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB0aGUgY3R4IGZvciB0aGUgYm94XG4gICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICBjb25zdCBsaW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVXaWR0aCwgMSk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5maWxsU3R5bGUsIGRlZmF1bHRDb2xvcik7XG4gICAgICBjdHgubGluZUNhcCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZUNhcCwgJ2J1dHQnKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZURhc2hPZmZzZXQsIDApO1xuICAgICAgY3R4LmxpbmVKb2luID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lSm9pbiwgJ21pdGVyJyk7XG4gICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5zdHJva2VTdHlsZSwgZGVmYXVsdENvbG9yKTtcblxuICAgICAgY3R4LnNldExpbmVEYXNoKHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZURhc2gsIFtdKSk7XG5cbiAgICAgIGlmIChsYWJlbE9wdHMudXNlUG9pbnRTdHlsZSkge1xuICAgICAgICAvLyBSZWNhbGN1bGF0ZSB4IGFuZCB5IGZvciBkcmF3UG9pbnQoKSBiZWNhdXNlIGl0cyBleHBlY3RpbmdcbiAgICAgICAgLy8geCBhbmQgeSB0byBiZSBjZW50ZXIgb2YgZmlndXJlIChpbnN0ZWFkIG9mIHRvcCBsZWZ0KVxuICAgICAgICBjb25zdCBkcmF3T3B0aW9ucyA9IHtcbiAgICAgICAgICByYWRpdXM6IGJveEhlaWdodCAqIE1hdGguU1FSVDIgLyAyLFxuICAgICAgICAgIHBvaW50U3R5bGU6IGxlZ2VuZEl0ZW0ucG9pbnRTdHlsZSxcbiAgICAgICAgICByb3RhdGlvbjogbGVnZW5kSXRlbS5yb3RhdGlvbixcbiAgICAgICAgICBib3JkZXJXaWR0aDogbGluZVdpZHRoXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNlbnRlclggPSBydGxIZWxwZXIueFBsdXMoeCwgYm94V2lkdGggLyAyKTtcbiAgICAgICAgY29uc3QgY2VudGVyWSA9IHkgKyBoYWxmRm9udFNpemU7XG5cbiAgICAgICAgLy8gRHJhdyBwb2ludFN0eWxlIGFzIGxlZ2VuZCBzeW1ib2xcbiAgICAgICAgZHJhd1BvaW50TGVnZW5kKGN0eCwgZHJhd09wdGlvbnMsIGNlbnRlclgsIGNlbnRlclksIGxhYmVsT3B0cy5wb2ludFN0eWxlV2lkdGggJiYgYm94V2lkdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRHJhdyBib3ggYXMgbGVnZW5kIHN5bWJvbFxuICAgICAgICAvLyBBZGp1c3QgcG9zaXRpb24gd2hlbiBib3hIZWlnaHQgPCBmb250U2l6ZSAod2FudCBpdCBjZW50ZXJlZClcbiAgICAgICAgY29uc3QgeUJveFRvcCA9IHkgKyBNYXRoLm1heCgoZm9udFNpemUgLSBib3hIZWlnaHQpIC8gMiwgMCk7XG4gICAgICAgIGNvbnN0IHhCb3hMZWZ0ID0gcnRsSGVscGVyLmxlZnRGb3JMdHIoeCwgYm94V2lkdGgpO1xuICAgICAgICBjb25zdCBib3JkZXJSYWRpdXMgPSB0b1RSQkxDb3JuZXJzKGxlZ2VuZEl0ZW0uYm9yZGVyUmFkaXVzKTtcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgaWYgKE9iamVjdC52YWx1ZXMoYm9yZGVyUmFkaXVzKS5zb21lKHYgPT4gdiAhPT0gMCkpIHtcbiAgICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgICAgICB4OiB4Qm94TGVmdCxcbiAgICAgICAgICAgIHk6IHlCb3hUb3AsXG4gICAgICAgICAgICB3OiBib3hXaWR0aCxcbiAgICAgICAgICAgIGg6IGJveEhlaWdodCxcbiAgICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eC5yZWN0KHhCb3hMZWZ0LCB5Qm94VG9wLCBib3hXaWR0aCwgYm94SGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGlmIChsaW5lV2lkdGggIT09IDApIHtcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgZmlsbFRleHQgPSBmdW5jdGlvbih4LCB5LCBsZWdlbmRJdGVtKSB7XG4gICAgICByZW5kZXJUZXh0KGN0eCwgbGVnZW5kSXRlbS50ZXh0LCB4LCB5ICsgKGl0ZW1IZWlnaHQgLyAyKSwgbGFiZWxGb250LCB7XG4gICAgICAgIHN0cmlrZXRocm91Z2g6IGxlZ2VuZEl0ZW0uaGlkZGVuLFxuICAgICAgICB0ZXh0QWxpZ246IHJ0bEhlbHBlci50ZXh0QWxpZ24obGVnZW5kSXRlbS50ZXh0QWxpZ24pXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gSG9yaXpvbnRhbFxuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgdGl0bGVIZWlnaHQgPSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKTtcbiAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICBjdXJzb3IgPSB7XG4gICAgICAgIHg6IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gbGluZVdpZHRoc1swXSksXG4gICAgICAgIHk6IHRoaXMudG9wICsgcGFkZGluZyArIHRpdGxlSGVpZ2h0LFxuICAgICAgICBsaW5lOiAwXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJzb3IgPSB7XG4gICAgICAgIHg6IHRoaXMubGVmdCArIHBhZGRpbmcsXG4gICAgICAgIHk6IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSBjb2x1bW5TaXplc1swXS5oZWlnaHQpLFxuICAgICAgICBsaW5lOiAwXG4gICAgICB9O1xuICAgIH1cblxuICAgIG92ZXJyaWRlVGV4dERpcmVjdGlvbih0aGlzLmN0eCwgb3B0cy50ZXh0RGlyZWN0aW9uKTtcblxuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBpdGVtSGVpZ2h0ICsgcGFkZGluZztcbiAgICB0aGlzLmxlZ2VuZEl0ZW1zLmZvckVhY2goKGxlZ2VuZEl0ZW0sIGkpID0+IHtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxlZ2VuZEl0ZW0uZm9udENvbG9yOyAvLyBmb3Igc3RyaWtldGhyb3VnaCBlZmZlY3RcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBsZWdlbmRJdGVtLmZvbnRDb2xvcjsgLy8gcmVuZGVyIGluIGNvcnJlY3QgY29sb3VyXG5cbiAgICAgIGNvbnN0IHRleHRXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuICAgICAgY29uc3QgdGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbihsZWdlbmRJdGVtLnRleHRBbGlnbiB8fCAobGVnZW5kSXRlbS50ZXh0QWxpZ24gPSBsYWJlbE9wdHMudGV4dEFsaWduKSk7XG4gICAgICBjb25zdCB3aWR0aCA9IGJveFdpZHRoICsgaGFsZkZvbnRTaXplICsgdGV4dFdpZHRoO1xuICAgICAgbGV0IHggPSBjdXJzb3IueDtcbiAgICAgIGxldCB5ID0gY3Vyc29yLnk7XG5cbiAgICAgIHJ0bEhlbHBlci5zZXRXaWR0aCh0aGlzLndpZHRoKTtcblxuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICBpZiAoaSA+IDAgJiYgeCArIHdpZHRoICsgcGFkZGluZyA+IHRoaXMucmlnaHQpIHtcbiAgICAgICAgICB5ID0gY3Vyc29yLnkgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICBjdXJzb3IubGluZSsrO1xuICAgICAgICAgIHggPSBjdXJzb3IueCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gbGluZVdpZHRoc1tjdXJzb3IubGluZV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGkgPiAwICYmIHkgKyBsaW5lSGVpZ2h0ID4gdGhpcy5ib3R0b20pIHtcbiAgICAgICAgeCA9IGN1cnNvci54ID0geCArIGNvbHVtblNpemVzW2N1cnNvci5saW5lXS53aWR0aCArIHBhZGRpbmc7XG4gICAgICAgIGN1cnNvci5saW5lKys7XG4gICAgICAgIHkgPSBjdXJzb3IueSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSBjb2x1bW5TaXplc1tjdXJzb3IubGluZV0uaGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVhbFggPSBydGxIZWxwZXIueCh4KTtcblxuICAgICAgZHJhd0xlZ2VuZEJveChyZWFsWCwgeSwgbGVnZW5kSXRlbSk7XG5cbiAgICAgIHggPSBfdGV4dFgodGV4dEFsaWduLCB4ICsgYm94V2lkdGggKyBoYWxmRm9udFNpemUsIGlzSG9yaXpvbnRhbCA/IHggKyB3aWR0aCA6IHRoaXMucmlnaHQsIG9wdHMucnRsKTtcblxuICAgICAgLy8gRmlsbCB0aGUgYWN0dWFsIGxhYmVsXG4gICAgICBmaWxsVGV4dChydGxIZWxwZXIueCh4KSwgeSwgbGVnZW5kSXRlbSk7XG5cbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgY3Vyc29yLnggKz0gd2lkdGggKyBwYWRkaW5nO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGVnZW5kSXRlbS50ZXh0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBmb250TGluZUhlaWdodCA9IGxhYmVsRm9udC5saW5lSGVpZ2h0O1xuICAgICAgICBjdXJzb3IueSArPSBjYWxjdWxhdGVMZWdlbmRJdGVtSGVpZ2h0KGxlZ2VuZEl0ZW0sIGZvbnRMaW5lSGVpZ2h0KSArIHBhZGRpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJzb3IueSArPSBsaW5lSGVpZ2h0O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVzdG9yZVRleHREaXJlY3Rpb24odGhpcy5jdHgsIG9wdHMudGV4dERpcmVjdGlvbik7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd1RpdGxlKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGl0bGVPcHRzID0gb3B0cy50aXRsZTtcbiAgICBjb25zdCB0aXRsZUZvbnQgPSB0b0ZvbnQodGl0bGVPcHRzLmZvbnQpO1xuICAgIGNvbnN0IHRpdGxlUGFkZGluZyA9IHRvUGFkZGluZyh0aXRsZU9wdHMucGFkZGluZyk7XG5cbiAgICBpZiAoIXRpdGxlT3B0cy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRzLnJ0bCwgdGhpcy5sZWZ0LCB0aGlzLndpZHRoKTtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRpdGxlT3B0cy5wb3NpdGlvbjtcbiAgICBjb25zdCBoYWxmRm9udFNpemUgPSB0aXRsZUZvbnQuc2l6ZSAvIDI7XG4gICAgY29uc3QgdG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemUgPSB0aXRsZVBhZGRpbmcudG9wICsgaGFsZkZvbnRTaXplO1xuICAgIGxldCB5O1xuXG4gICAgLy8gVGhlc2UgZGVmYXVsdHMgYXJlIHVzZWQgd2hlbiB0aGUgbGVnZW5kIGlzIHZlcnRpY2FsLlxuICAgIC8vIFdoZW4gaG9yaXpvbnRhbCwgdGhleSBhcmUgY29tcHV0ZWQgYmVsb3cuXG4gICAgbGV0IGxlZnQgPSB0aGlzLmxlZnQ7XG4gICAgbGV0IG1heFdpZHRoID0gdGhpcy53aWR0aDtcblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAvLyBNb3ZlIGxlZnQgLyByaWdodCBzbyB0aGF0IHRoZSB0aXRsZSBpcyBhYm92ZSB0aGUgbGVnZW5kIGxpbmVzXG4gICAgICBtYXhXaWR0aCA9IE1hdGgubWF4KC4uLnRoaXMubGluZVdpZHRocyk7XG4gICAgICB5ID0gdGhpcy50b3AgKyB0b3BQYWRkaW5nUGx1c0hhbGZGb250U2l6ZTtcbiAgICAgIGxlZnQgPSBfYWxpZ25TdGFydEVuZChvcHRzLmFsaWduLCBsZWZ0LCB0aGlzLnJpZ2h0IC0gbWF4V2lkdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNb3ZlIGRvd24gc28gdGhhdCB0aGUgdGl0bGUgaXMgYWJvdmUgdGhlIGxlZ2VuZCBzdGFjayBpbiBldmVyeSBhbGlnbm1lbnRcbiAgICAgIGNvbnN0IG1heEhlaWdodCA9IHRoaXMuY29sdW1uU2l6ZXMucmVkdWNlKChhY2MsIHNpemUpID0+IE1hdGgubWF4KGFjYywgc2l6ZS5oZWlnaHQpLCAwKTtcbiAgICAgIHkgPSB0b3BQYWRkaW5nUGx1c0hhbGZGb250U2l6ZSArIF9hbGlnblN0YXJ0RW5kKG9wdHMuYWxpZ24sIHRoaXMudG9wLCB0aGlzLmJvdHRvbSAtIG1heEhlaWdodCAtIG9wdHMubGFiZWxzLnBhZGRpbmcgLSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKSk7XG4gICAgfVxuXG4gICAgLy8gTm93IHRoYXQgd2Uga25vdyB0aGUgbGVmdCBlZGdlIG9mIHRoZSBpbm5lciBsZWdlbmQgYm94LCBjb21wdXRlIHRoZSBjb3JyZWN0XG4gICAgLy8gWCBjb29yZGluYXRlIGZyb20gdGhlIHRpdGxlIGFsaWdubWVudFxuICAgIGNvbnN0IHggPSBfYWxpZ25TdGFydEVuZChwb3NpdGlvbiwgbGVmdCwgbGVmdCArIG1heFdpZHRoKTtcblxuICAgIC8vIENhbnZhcyBzZXR1cFxuICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKF90b0xlZnRSaWdodENlbnRlcihwb3NpdGlvbikpO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aXRsZU9wdHMuY29sb3I7XG4gICAgY3R4LmZpbGxTdHlsZSA9IHRpdGxlT3B0cy5jb2xvcjtcbiAgICBjdHguZm9udCA9IHRpdGxlRm9udC5zdHJpbmc7XG5cbiAgICByZW5kZXJUZXh0KGN0eCwgdGl0bGVPcHRzLnRleHQsIHgsIHksIHRpdGxlRm9udCk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jb21wdXRlVGl0bGVIZWlnaHQoKSB7XG4gICAgY29uc3QgdGl0bGVPcHRzID0gdGhpcy5vcHRpb25zLnRpdGxlO1xuICAgIGNvbnN0IHRpdGxlRm9udCA9IHRvRm9udCh0aXRsZU9wdHMuZm9udCk7XG4gICAgY29uc3QgdGl0bGVQYWRkaW5nID0gdG9QYWRkaW5nKHRpdGxlT3B0cy5wYWRkaW5nKTtcbiAgICByZXR1cm4gdGl0bGVPcHRzLmRpc3BsYXkgPyB0aXRsZUZvbnQubGluZUhlaWdodCArIHRpdGxlUGFkZGluZy5oZWlnaHQgOiAwO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0TGVnZW5kSXRlbUF0KHgsIHkpIHtcbiAgICBsZXQgaSwgaGl0Qm94LCBsaDtcblxuICAgIGlmIChfaXNCZXR3ZWVuKHgsIHRoaXMubGVmdCwgdGhpcy5yaWdodClcbiAgICAgICYmIF9pc0JldHdlZW4oeSwgdGhpcy50b3AsIHRoaXMuYm90dG9tKSkge1xuICAgICAgLy8gU2VlIGlmIHdlIGFyZSB0b3VjaGluZyBvbmUgb2YgdGhlIGRhdGFzZXQgYm94ZXNcbiAgICAgIGxoID0gdGhpcy5sZWdlbmRIaXRCb3hlcztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsaC5sZW5ndGg7ICsraSkge1xuICAgICAgICBoaXRCb3ggPSBsaFtpXTtcblxuICAgICAgICBpZiAoX2lzQmV0d2Vlbih4LCBoaXRCb3gubGVmdCwgaGl0Qm94LmxlZnQgKyBoaXRCb3gud2lkdGgpXG4gICAgICAgICAgJiYgX2lzQmV0d2Vlbih5LCBoaXRCb3gudG9wLCBoaXRCb3gudG9wICsgaGl0Qm94LmhlaWdodCkpIHtcbiAgICAgICAgICAvLyBUb3VjaGluZyBhbiBlbGVtZW50XG4gICAgICAgICAgcmV0dXJuIHRoaXMubGVnZW5kSXRlbXNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBIYW5kbGUgYW4gZXZlbnRcblx0ICogQHBhcmFtIHtDaGFydEV2ZW50fSBlIC0gVGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKi9cbiAgaGFuZGxlRXZlbnQoZSkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKCFpc0xpc3RlbmVkKGUudHlwZSwgb3B0cykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGFydCBldmVudCBhbHJlYWR5IGhhcyByZWxhdGl2ZSBwb3NpdGlvbiBpbiBpdFxuICAgIGNvbnN0IGhvdmVyZWRJdGVtID0gdGhpcy5fZ2V0TGVnZW5kSXRlbUF0KGUueCwgZS55KTtcblxuICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZW1vdmUnIHx8IGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgICAgY29uc3QgcHJldmlvdXMgPSB0aGlzLl9ob3ZlcmVkSXRlbTtcbiAgICAgIGNvbnN0IHNhbWVJdGVtID0gaXRlbXNFcXVhbChwcmV2aW91cywgaG92ZXJlZEl0ZW0pO1xuICAgICAgaWYgKHByZXZpb3VzICYmICFzYW1lSXRlbSkge1xuICAgICAgICBjYWxsKG9wdHMub25MZWF2ZSwgW2UsIHByZXZpb3VzLCB0aGlzXSwgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2hvdmVyZWRJdGVtID0gaG92ZXJlZEl0ZW07XG5cbiAgICAgIGlmIChob3ZlcmVkSXRlbSAmJiAhc2FtZUl0ZW0pIHtcbiAgICAgICAgY2FsbChvcHRzLm9uSG92ZXIsIFtlLCBob3ZlcmVkSXRlbSwgdGhpc10sIHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaG92ZXJlZEl0ZW0pIHtcbiAgICAgIGNhbGwob3B0cy5vbkNsaWNrLCBbZSwgaG92ZXJlZEl0ZW0sIHRoaXNdLCB0aGlzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlSXRlbVNpemUoYm94V2lkdGgsIGxhYmVsRm9udCwgY3R4LCBsZWdlbmRJdGVtLCBfaXRlbUhlaWdodCkge1xuICBjb25zdCBpdGVtV2lkdGggPSBjYWxjdWxhdGVJdGVtV2lkdGgobGVnZW5kSXRlbSwgYm94V2lkdGgsIGxhYmVsRm9udCwgY3R4KTtcbiAgY29uc3QgaXRlbUhlaWdodCA9IGNhbGN1bGF0ZUl0ZW1IZWlnaHQoX2l0ZW1IZWlnaHQsIGxlZ2VuZEl0ZW0sIGxhYmVsRm9udC5saW5lSGVpZ2h0KTtcbiAgcmV0dXJuIHtpdGVtV2lkdGgsIGl0ZW1IZWlnaHR9O1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVJdGVtV2lkdGgobGVnZW5kSXRlbSwgYm94V2lkdGgsIGxhYmVsRm9udCwgY3R4KSB7XG4gIGxldCBsZWdlbmRJdGVtVGV4dCA9IGxlZ2VuZEl0ZW0udGV4dDtcbiAgaWYgKGxlZ2VuZEl0ZW1UZXh0ICYmIHR5cGVvZiBsZWdlbmRJdGVtVGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICBsZWdlbmRJdGVtVGV4dCA9IGxlZ2VuZEl0ZW1UZXh0LnJlZHVjZSgoYSwgYikgPT4gYS5sZW5ndGggPiBiLmxlbmd0aCA/IGEgOiBiKTtcbiAgfVxuICByZXR1cm4gYm94V2lkdGggKyAobGFiZWxGb250LnNpemUgLyAyKSArIGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtVGV4dCkud2lkdGg7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUl0ZW1IZWlnaHQoX2l0ZW1IZWlnaHQsIGxlZ2VuZEl0ZW0sIGZvbnRMaW5lSGVpZ2h0KSB7XG4gIGxldCBpdGVtSGVpZ2h0ID0gX2l0ZW1IZWlnaHQ7XG4gIGlmICh0eXBlb2YgbGVnZW5kSXRlbS50ZXh0ICE9PSAnc3RyaW5nJykge1xuICAgIGl0ZW1IZWlnaHQgPSBjYWxjdWxhdGVMZWdlbmRJdGVtSGVpZ2h0KGxlZ2VuZEl0ZW0sIGZvbnRMaW5lSGVpZ2h0KTtcbiAgfVxuICByZXR1cm4gaXRlbUhlaWdodDtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlTGVnZW5kSXRlbUhlaWdodChsZWdlbmRJdGVtLCBmb250TGluZUhlaWdodCkge1xuICBjb25zdCBsYWJlbEhlaWdodCA9IGxlZ2VuZEl0ZW0udGV4dCA/IGxlZ2VuZEl0ZW0udGV4dC5sZW5ndGggOiAwO1xuICByZXR1cm4gZm9udExpbmVIZWlnaHQgKiBsYWJlbEhlaWdodDtcbn1cblxuZnVuY3Rpb24gaXNMaXN0ZW5lZCh0eXBlLCBvcHRzKSB7XG4gIGlmICgodHlwZSA9PT0gJ21vdXNlbW92ZScgfHwgdHlwZSA9PT0gJ21vdXNlb3V0JykgJiYgKG9wdHMub25Ib3ZlciB8fCBvcHRzLm9uTGVhdmUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKG9wdHMub25DbGljayAmJiAodHlwZSA9PT0gJ2NsaWNrJyB8fCB0eXBlID09PSAnbW91c2V1cCcpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlkOiAnbGVnZW5kJyxcblxuICAvKipcblx0ICogRm9yIHRlc3RzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZWxlbWVudDogTGVnZW5kLFxuXG4gIHN0YXJ0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZCA9IG5ldyBMZWdlbmQoe2N0eDogY2hhcnQuY3R4LCBvcHRpb25zLCBjaGFydH0pO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCBsZWdlbmQsIG9wdGlvbnMpO1xuICAgIGxheW91dHMuYWRkQm94KGNoYXJ0LCBsZWdlbmQpO1xuICB9LFxuXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBsYXlvdXRzLnJlbW92ZUJveChjaGFydCwgY2hhcnQubGVnZW5kKTtcbiAgICBkZWxldGUgY2hhcnQubGVnZW5kO1xuICB9LFxuXG4gIC8vIER1cmluZyB0aGUgYmVmb3JlVXBkYXRlIHN0ZXAsIHRoZSBsYXlvdXQgY29uZmlndXJhdGlvbiBuZWVkcyB0byBydW5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgaWYgdGhlIGxlZ2VuZCBwb3NpdGlvbiBjaGFuZ2VzICh2aWEgYW4gb3B0aW9uIHVwZGF0ZSlcbiAgLy8gdGhlIGxheW91dCBzeXN0ZW0gcmVzcGVjdHMgdGhlIGNoYW5nZS4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy83NTI3XG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsZWdlbmQgPSBjaGFydC5sZWdlbmQ7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIGxlZ2VuZCwgb3B0aW9ucyk7XG4gICAgbGVnZW5kLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuXG4gIC8vIFRoZSBsYWJlbHMgbmVlZCB0byBiZSBidWlsdCBhZnRlciBkYXRhc2V0cyBhcmUgdXBkYXRlZCB0byBlbnN1cmUgdGhhdCBjb2xvcnNcbiAgLy8gYW5kIG90aGVyIHN0eWxpbmcgYXJlIGNvcnJlY3QuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNjk2OFxuICBhZnRlclVwZGF0ZShjaGFydCkge1xuICAgIGNvbnN0IGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZDtcbiAgICBsZWdlbmQuYnVpbGRMYWJlbHMoKTtcbiAgICBsZWdlbmQuYWRqdXN0SGl0Qm94ZXMoKTtcbiAgfSxcblxuXG4gIGFmdGVyRXZlbnQoY2hhcnQsIGFyZ3MpIHtcbiAgICBpZiAoIWFyZ3MucmVwbGF5KSB7XG4gICAgICBjaGFydC5sZWdlbmQuaGFuZGxlRXZlbnQoYXJncy5ldmVudCk7XG4gICAgfVxuICB9LFxuXG4gIGRlZmF1bHRzOiB7XG4gICAgZGlzcGxheTogdHJ1ZSxcbiAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgYWxpZ246ICdjZW50ZXInLFxuICAgIGZ1bGxTaXplOiB0cnVlLFxuICAgIHJldmVyc2U6IGZhbHNlLFxuICAgIHdlaWdodDogMTAwMCxcblxuICAgIC8vIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGhhbmRsZVxuICAgIG9uQ2xpY2soZSwgbGVnZW5kSXRlbSwgbGVnZW5kKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGxlZ2VuZEl0ZW0uZGF0YXNldEluZGV4O1xuICAgICAgY29uc3QgY2kgPSBsZWdlbmQuY2hhcnQ7XG4gICAgICBpZiAoY2kuaXNEYXRhc2V0VmlzaWJsZShpbmRleCkpIHtcbiAgICAgICAgY2kuaGlkZShpbmRleCk7XG4gICAgICAgIGxlZ2VuZEl0ZW0uaGlkZGVuID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNpLnNob3coaW5kZXgpO1xuICAgICAgICBsZWdlbmRJdGVtLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBvbkhvdmVyOiBudWxsLFxuICAgIG9uTGVhdmU6IG51bGwsXG5cbiAgICBsYWJlbHM6IHtcbiAgICAgIGNvbG9yOiAoY3R4KSA9PiBjdHguY2hhcnQub3B0aW9ucy5jb2xvcixcbiAgICAgIGJveFdpZHRoOiA0MCxcbiAgICAgIHBhZGRpbmc6IDEwLFxuICAgICAgLy8gR2VuZXJhdGVzIGxhYmVscyBzaG93biBpbiB0aGUgbGVnZW5kXG4gICAgICAvLyBWYWxpZCBwcm9wZXJ0aWVzIHRvIHJldHVybjpcbiAgICAgIC8vIHRleHQgOiB0ZXh0IHRvIGRpc3BsYXlcbiAgICAgIC8vIGZpbGxTdHlsZSA6IGZpbGwgb2YgY29sb3VyZWQgYm94XG4gICAgICAvLyBzdHJva2VTdHlsZTogc3Ryb2tlIG9mIGNvbG91cmVkIGJveFxuICAgICAgLy8gaGlkZGVuIDogaWYgdGhpcyBsZWdlbmQgaXRlbSByZWZlcnMgdG8gYSBoaWRkZW4gaXRlbVxuICAgICAgLy8gbGluZUNhcCA6IGNhcCBzdHlsZSBmb3IgbGluZVxuICAgICAgLy8gbGluZURhc2hcbiAgICAgIC8vIGxpbmVEYXNoT2Zmc2V0IDpcbiAgICAgIC8vIGxpbmVKb2luIDpcbiAgICAgIC8vIGxpbmVXaWR0aCA6XG4gICAgICBnZW5lcmF0ZUxhYmVscyhjaGFydCkge1xuICAgICAgICBjb25zdCBkYXRhc2V0cyA9IGNoYXJ0LmRhdGEuZGF0YXNldHM7XG4gICAgICAgIGNvbnN0IHtsYWJlbHM6IHt1c2VQb2ludFN0eWxlLCBwb2ludFN0eWxlLCB0ZXh0QWxpZ24sIGNvbG9yLCB1c2VCb3JkZXJSYWRpdXMsIGJvcmRlclJhZGl1c319ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XG5cbiAgICAgICAgcmV0dXJuIGNoYXJ0Ll9nZXRTb3J0ZWREYXRhc2V0TWV0YXMoKS5tYXAoKG1ldGEpID0+IHtcbiAgICAgICAgICBjb25zdCBzdHlsZSA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZSh1c2VQb2ludFN0eWxlID8gMCA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgY29uc3QgYm9yZGVyV2lkdGggPSB0b1BhZGRpbmcoc3R5bGUuYm9yZGVyV2lkdGgpO1xuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IGRhdGFzZXRzW21ldGEuaW5kZXhdLmxhYmVsLFxuICAgICAgICAgICAgZmlsbFN0eWxlOiBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBmb250Q29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgaGlkZGVuOiAhbWV0YS52aXNpYmxlLFxuICAgICAgICAgICAgbGluZUNhcDogc3R5bGUuYm9yZGVyQ2FwU3R5bGUsXG4gICAgICAgICAgICBsaW5lRGFzaDogc3R5bGUuYm9yZGVyRGFzaCxcbiAgICAgICAgICAgIGxpbmVEYXNoT2Zmc2V0OiBzdHlsZS5ib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgICAgICAgbGluZUpvaW46IHN0eWxlLmJvcmRlckpvaW5TdHlsZSxcbiAgICAgICAgICAgIGxpbmVXaWR0aDogKGJvcmRlcldpZHRoLndpZHRoICsgYm9yZGVyV2lkdGguaGVpZ2h0KSAvIDQsXG4gICAgICAgICAgICBzdHJva2VTdHlsZTogc3R5bGUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICBwb2ludFN0eWxlOiBwb2ludFN0eWxlIHx8IHN0eWxlLnBvaW50U3R5bGUsXG4gICAgICAgICAgICByb3RhdGlvbjogc3R5bGUucm90YXRpb24sXG4gICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbiB8fCBzdHlsZS50ZXh0QWxpZ24sXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IHVzZUJvcmRlclJhZGl1cyAmJiAoYm9yZGVyUmFkaXVzIHx8IHN0eWxlLmJvcmRlclJhZGl1cyksXG5cbiAgICAgICAgICAgIC8vIEJlbG93IGlzIGV4dHJhIGRhdGEgdXNlZCBmb3IgdG9nZ2xpbmcgdGhlIGRhdGFzZXRzXG4gICAgICAgICAgICBkYXRhc2V0SW5kZXg6IG1ldGEuaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdGl0bGU6IHtcbiAgICAgIGNvbG9yOiAoY3R4KSA9PiBjdHguY2hhcnQub3B0aW9ucy5jb2xvcixcbiAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgcG9zaXRpb246ICdjZW50ZXInLFxuICAgICAgdGV4dDogJycsXG4gICAgfVxuICB9LFxuXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiAhbmFtZS5zdGFydHNXaXRoKCdvbicpLFxuICAgIGxhYmVsczoge1xuICAgICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiAhWydnZW5lcmF0ZUxhYmVscycsICdmaWx0ZXInLCAnc29ydCddLmluY2x1ZGVzKG5hbWUpLFxuICAgIH1cbiAgfSxcbn07XG4iLCAiaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi4vY29yZS9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IGxheW91dHMgZnJvbSAnLi4vY29yZS9jb3JlLmxheW91dHMuanMnO1xuaW1wb3J0IHtQSSwgaXNBcnJheSwgdG9QYWRkaW5nLCB0b0ZvbnR9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtfdG9MZWZ0UmlnaHRDZW50ZXIsIF9hbGlnblN0YXJ0RW5kfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLmpzJztcbmltcG9ydCB7cmVuZGVyVGV4dH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNhbnZhcy5qcyc7XG5cbmV4cG9ydCBjbGFzcyBUaXRsZSBleHRlbmRzIEVsZW1lbnQge1xuICAvKipcblx0ICogQHBhcmFtIHt7IGN0eDogYW55OyBvcHRpb25zOiBhbnk7IGNoYXJ0OiBhbnk7IH19IGNvbmZpZ1xuXHQgKi9cbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuY2hhcnQgPSBjb25maWcuY2hhcnQ7XG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG4gICAgdGhpcy5jdHggPSBjb25maWcuY3R4O1xuICAgIHRoaXMuX3BhZGRpbmcgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2VpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZnVsbFNpemUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICB1cGRhdGUobWF4V2lkdGgsIG1heEhlaWdodCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICB0aGlzLmxlZnQgPSAwO1xuICAgIHRoaXMudG9wID0gMDtcblxuICAgIGlmICghb3B0cy5kaXNwbGF5KSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSB0aGlzLnJpZ2h0ID0gdGhpcy5ib3R0b20gPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMud2lkdGggPSB0aGlzLnJpZ2h0ID0gbWF4V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLmJvdHRvbSA9IG1heEhlaWdodDtcblxuICAgIGNvbnN0IGxpbmVDb3VudCA9IGlzQXJyYXkob3B0cy50ZXh0KSA/IG9wdHMudGV4dC5sZW5ndGggOiAxO1xuICAgIHRoaXMuX3BhZGRpbmcgPSB0b1BhZGRpbmcob3B0cy5wYWRkaW5nKTtcbiAgICBjb25zdCB0ZXh0U2l6ZSA9IGxpbmVDb3VudCAqIHRvRm9udChvcHRzLmZvbnQpLmxpbmVIZWlnaHQgKyB0aGlzLl9wYWRkaW5nLmhlaWdodDtcblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aGlzLmhlaWdodCA9IHRleHRTaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndpZHRoID0gdGV4dFNpemU7XG4gICAgfVxuICB9XG5cbiAgaXNIb3Jpem9udGFsKCkge1xuICAgIGNvbnN0IHBvcyA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcbiAgICByZXR1cm4gcG9zID09PSAndG9wJyB8fCBwb3MgPT09ICdib3R0b20nO1xuICB9XG5cbiAgX2RyYXdBcmdzKG9mZnNldCkge1xuICAgIGNvbnN0IHt0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQsIG9wdGlvbnN9ID0gdGhpcztcbiAgICBjb25zdCBhbGlnbiA9IG9wdGlvbnMuYWxpZ247XG4gICAgbGV0IHJvdGF0aW9uID0gMDtcbiAgICBsZXQgbWF4V2lkdGgsIHRpdGxlWCwgdGl0bGVZO1xuXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRpdGxlWCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBsZWZ0LCByaWdodCk7XG4gICAgICB0aXRsZVkgPSB0b3AgKyBvZmZzZXQ7XG4gICAgICBtYXhXaWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICB0aXRsZVggPSBsZWZ0ICsgb2Zmc2V0O1xuICAgICAgICB0aXRsZVkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgYm90dG9tLCB0b3ApO1xuICAgICAgICByb3RhdGlvbiA9IFBJICogLTAuNTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpdGxlWCA9IHJpZ2h0IC0gb2Zmc2V0O1xuICAgICAgICB0aXRsZVkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdG9wLCBib3R0b20pO1xuICAgICAgICByb3RhdGlvbiA9IFBJICogMC41O1xuICAgICAgfVxuICAgICAgbWF4V2lkdGggPSBib3R0b20gLSB0b3A7XG4gICAgfVxuICAgIHJldHVybiB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn07XG4gIH1cblxuICBkcmF3KCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBpZiAoIW9wdHMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGZvbnRPcHRzID0gdG9Gb250KG9wdHMuZm9udCk7XG4gICAgY29uc3QgbGluZUhlaWdodCA9IGZvbnRPcHRzLmxpbmVIZWlnaHQ7XG4gICAgY29uc3Qgb2Zmc2V0ID0gbGluZUhlaWdodCAvIDIgKyB0aGlzLl9wYWRkaW5nLnRvcDtcbiAgICBjb25zdCB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn0gPSB0aGlzLl9kcmF3QXJncyhvZmZzZXQpO1xuXG4gICAgcmVuZGVyVGV4dChjdHgsIG9wdHMudGV4dCwgMCwgMCwgZm9udE9wdHMsIHtcbiAgICAgIGNvbG9yOiBvcHRzLmNvbG9yLFxuICAgICAgbWF4V2lkdGgsXG4gICAgICByb3RhdGlvbixcbiAgICAgIHRleHRBbGlnbjogX3RvTGVmdFJpZ2h0Q2VudGVyKG9wdHMuYWxpZ24pLFxuICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICAgIHRyYW5zbGF0aW9uOiBbdGl0bGVYLCB0aXRsZVldLFxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRpdGxlKGNoYXJ0LCB0aXRsZU9wdHMpIHtcbiAgY29uc3QgdGl0bGUgPSBuZXcgVGl0bGUoe1xuICAgIGN0eDogY2hhcnQuY3R4LFxuICAgIG9wdGlvbnM6IHRpdGxlT3B0cyxcbiAgICBjaGFydFxuICB9KTtcblxuICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIHRpdGxlT3B0cyk7XG4gIGxheW91dHMuYWRkQm94KGNoYXJ0LCB0aXRsZSk7XG4gIGNoYXJ0LnRpdGxlQmxvY2sgPSB0aXRsZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpZDogJ3RpdGxlJyxcblxuICAvKipcblx0ICogRm9yIHRlc3RzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZWxlbWVudDogVGl0bGUsXG5cbiAgc3RhcnQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY3JlYXRlVGl0bGUoY2hhcnQsIG9wdGlvbnMpO1xuICB9LFxuXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBjb25zdCB0aXRsZUJsb2NrID0gY2hhcnQudGl0bGVCbG9jaztcbiAgICBsYXlvdXRzLnJlbW92ZUJveChjaGFydCwgdGl0bGVCbG9jayk7XG4gICAgZGVsZXRlIGNoYXJ0LnRpdGxlQmxvY2s7XG4gIH0sXG5cbiAgYmVmb3JlVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gY2hhcnQudGl0bGVCbG9jaztcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIG9wdGlvbnMpO1xuICAgIHRpdGxlLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuXG4gIGRlZmF1bHRzOiB7XG4gICAgYWxpZ246ICdjZW50ZXInLFxuICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgIGZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ2JvbGQnLFxuICAgIH0sXG4gICAgZnVsbFNpemU6IHRydWUsXG4gICAgcGFkZGluZzogMTAsXG4gICAgcG9zaXRpb246ICd0b3AnLFxuICAgIHRleHQ6ICcnLFxuICAgIHdlaWdodDogMjAwMCAgICAgICAgIC8vIGJ5IGRlZmF1bHQgZ3JlYXRlciB0aGFuIGxlZ2VuZCAoMTAwMCkgdG8gYmUgYWJvdmVcbiAgfSxcblxuICBkZWZhdWx0Um91dGVzOiB7XG4gICAgY29sb3I6ICdjb2xvcidcbiAgfSxcblxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiB0cnVlLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICB9LFxufTtcbiIsICJpbXBvcnQge1RpdGxlfSBmcm9tICcuL3BsdWdpbi50aXRsZS5qcyc7XG5pbXBvcnQgbGF5b3V0cyBmcm9tICcuLi9jb3JlL2NvcmUubGF5b3V0cy5qcyc7XG5cbmNvbnN0IG1hcCA9IG5ldyBXZWFrTWFwKCk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaWQ6ICdzdWJ0aXRsZScsXG5cbiAgc3RhcnQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGl0bGUgPSBuZXcgVGl0bGUoe1xuICAgICAgY3R4OiBjaGFydC5jdHgsXG4gICAgICBvcHRpb25zLFxuICAgICAgY2hhcnRcbiAgICB9KTtcblxuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgb3B0aW9ucyk7XG4gICAgbGF5b3V0cy5hZGRCb3goY2hhcnQsIHRpdGxlKTtcbiAgICBtYXAuc2V0KGNoYXJ0LCB0aXRsZSk7XG4gIH0sXG5cbiAgc3RvcChjaGFydCkge1xuICAgIGxheW91dHMucmVtb3ZlQm94KGNoYXJ0LCBtYXAuZ2V0KGNoYXJ0KSk7XG4gICAgbWFwLmRlbGV0ZShjaGFydCk7XG4gIH0sXG5cbiAgYmVmb3JlVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gbWFwLmdldChjaGFydCk7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCBvcHRpb25zKTtcbiAgICB0aXRsZS5vcHRpb25zID0gb3B0aW9ucztcbiAgfSxcblxuICBkZWZhdWx0czoge1xuICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICBmb250OiB7XG4gICAgICB3ZWlnaHQ6ICdub3JtYWwnLFxuICAgIH0sXG4gICAgZnVsbFNpemU6IHRydWUsXG4gICAgcGFkZGluZzogMCxcbiAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgdGV4dDogJycsXG4gICAgd2VpZ2h0OiAxNTAwICAgICAgICAgLy8gYnkgZGVmYXVsdCBncmVhdGVyIHRoYW4gbGVnZW5kICgxMDAwKSBhbmQgc21hbGxlciB0aGFuIHRpdGxlICgyMDAwKVxuICB9LFxuXG4gIGRlZmF1bHRSb3V0ZXM6IHtcbiAgICBjb2xvcjogJ2NvbG9yJ1xuICB9LFxuXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IHRydWUsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gIH0sXG59O1xuIiwgImltcG9ydCBBbmltYXRpb25zIGZyb20gJy4uL2NvcmUvY29yZS5hbmltYXRpb25zLmpzJztcbmltcG9ydCBFbGVtZW50IGZyb20gJy4uL2NvcmUvY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCB7YWRkUm91bmRlZFJlY3RQYXRofSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB7ZWFjaCwgbm9vcCwgaXNOdWxsT3JVbmRlZiwgaXNBcnJheSwgX2VsZW1lbnRzRXF1YWwsIGlzT2JqZWN0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge3RvRm9udCwgdG9QYWRkaW5nLCB0b1RSQkxDb3JuZXJzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5pbXBvcnQge2dldFJ0bEFkYXB0ZXIsIG92ZXJyaWRlVGV4dERpcmVjdGlvbiwgcmVzdG9yZVRleHREaXJlY3Rpb259IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5ydGwuanMnO1xuaW1wb3J0IHtkaXN0YW5jZUJldHdlZW5Qb2ludHMsIF9saW1pdFZhbHVlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge2NyZWF0ZUNvbnRleHQsIGRyYXdQb2ludH0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3BsYXRmb3JtL3BsYXRmb3JtLmJhc2UuanMnKS5DaGFydCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5DaGFydEV2ZW50IH0gQ2hhcnRFdmVudFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQWN0aXZlRWxlbWVudCB9IEFjdGl2ZUVsZW1lbnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9jb3JlL2NvcmUuaW50ZXJhY3Rpb24uanMnKS5JbnRlcmFjdGlvbkl0ZW0gfSBJbnRlcmFjdGlvbkl0ZW1cbiAqL1xuXG5jb25zdCBwb3NpdGlvbmVycyA9IHtcbiAgLyoqXG5cdCAqIEF2ZXJhZ2UgbW9kZSBwbGFjZXMgdGhlIHRvb2x0aXAgYXQgdGhlIGF2ZXJhZ2UgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnRzIHNob3duXG5cdCAqL1xuICBhdmVyYWdlKGl0ZW1zKSB7XG4gICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgaSwgbGVuO1xuICAgIGxldCB4U2V0ID0gbmV3IFNldCgpO1xuICAgIGxldCB5ID0gMDtcbiAgICBsZXQgY291bnQgPSAwO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IGVsID0gaXRlbXNbaV0uZWxlbWVudDtcbiAgICAgIGlmIChlbCAmJiBlbC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGNvbnN0IHBvcyA9IGVsLnRvb2x0aXBQb3NpdGlvbigpO1xuICAgICAgICB4U2V0LmFkZChwb3MueCk7XG4gICAgICAgIHkgKz0gcG9zLnk7XG4gICAgICAgICsrY291bnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgeEF2ZXJhZ2UgPSBbLi4ueFNldF0ucmVkdWNlKChhLCBiKSA9PiBhICsgYikgLyB4U2V0LnNpemU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogeEF2ZXJhZ2UsXG4gICAgICB5OiB5IC8gY291bnRcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuXHQgKiBHZXRzIHRoZSB0b29sdGlwIHBvc2l0aW9uIG5lYXJlc3Qgb2YgdGhlIGl0ZW0gbmVhcmVzdCB0byB0aGUgZXZlbnQgcG9zaXRpb25cblx0ICovXG4gIG5lYXJlc3QoaXRlbXMsIGV2ZW50UG9zaXRpb24pIHtcbiAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCB4ID0gZXZlbnRQb3NpdGlvbi54O1xuICAgIGxldCB5ID0gZXZlbnRQb3NpdGlvbi55O1xuICAgIGxldCBtaW5EaXN0YW5jZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgaSwgbGVuLCBuZWFyZXN0RWxlbWVudDtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb25zdCBlbCA9IGl0ZW1zW2ldLmVsZW1lbnQ7XG4gICAgICBpZiAoZWwgJiYgZWwuaGFzVmFsdWUoKSkge1xuICAgICAgICBjb25zdCBjZW50ZXIgPSBlbC5nZXRDZW50ZXJQb2ludCgpO1xuICAgICAgICBjb25zdCBkID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKGV2ZW50UG9zaXRpb24sIGNlbnRlcik7XG5cbiAgICAgICAgaWYgKGQgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgICAgIG1pbkRpc3RhbmNlID0gZDtcbiAgICAgICAgICBuZWFyZXN0RWxlbWVudCA9IGVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5lYXJlc3RFbGVtZW50KSB7XG4gICAgICBjb25zdCB0cCA9IG5lYXJlc3RFbGVtZW50LnRvb2x0aXBQb3NpdGlvbigpO1xuICAgICAgeCA9IHRwLng7XG4gICAgICB5ID0gdHAueTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9O1xuICB9XG59O1xuXG4vLyBIZWxwZXIgdG8gcHVzaCBvciBjb25jYXQgYmFzZWQgb24gaWYgdGhlIDJuZCBwYXJhbWV0ZXIgaXMgYW4gYXJyYXkgb3Igbm90XG5mdW5jdGlvbiBwdXNoT3JDb25jYXQoYmFzZSwgdG9QdXNoKSB7XG4gIGlmICh0b1B1c2gpIHtcbiAgICBpZiAoaXNBcnJheSh0b1B1c2gpKSB7XG4gICAgICAvLyBiYXNlID0gYmFzZS5jb25jYXQodG9QdXNoKTtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGJhc2UsIHRvUHVzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2UucHVzaCh0b1B1c2gpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBiYXNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYXJyYXkgb2Ygc3RyaW5ncyBzcGxpdCBieSBuZXdsaW5lXG4gKiBAcGFyYW0geyp9IHN0ciAtIFRoZSB2YWx1ZSB0byBzcGxpdCBieSBuZXdsaW5lLlxuICogQHJldHVybnMge3N0cmluZ3xzdHJpbmdbXX0gdmFsdWUgaWYgbmV3bGluZSBwcmVzZW50IC0gUmV0dXJuZWQgZnJvbSBTdHJpbmcgc3BsaXQoKSBtZXRob2RcbiAqIEBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBzcGxpdE5ld2xpbmVzKHN0cikge1xuICBpZiAoKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnIHx8IHN0ciBpbnN0YW5jZW9mIFN0cmluZykgJiYgc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICByZXR1cm4gc3RyLnNwbGl0KCdcXG4nKTtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuXG5cbi8qKlxuICogUHJpdmF0ZSBoZWxwZXIgdG8gY3JlYXRlIGEgdG9vbHRpcCBpdGVtIG1vZGVsXG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuICogQHBhcmFtIHtBY3RpdmVFbGVtZW50fSBpdGVtIC0ge2VsZW1lbnQsIGluZGV4LCBkYXRhc2V0SW5kZXh9IHRvIGNyZWF0ZSB0aGUgdG9vbHRpcCBpdGVtIGZvclxuICogQHJldHVybiBuZXcgdG9vbHRpcCBpdGVtXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXBJdGVtKGNoYXJ0LCBpdGVtKSB7XG4gIGNvbnN0IHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSA9IGl0ZW07XG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXI7XG4gIGNvbnN0IHtsYWJlbCwgdmFsdWV9ID0gY29udHJvbGxlci5nZXRMYWJlbEFuZFZhbHVlKGluZGV4KTtcblxuICByZXR1cm4ge1xuICAgIGNoYXJ0LFxuICAgIGxhYmVsLFxuICAgIHBhcnNlZDogY29udHJvbGxlci5nZXRQYXJzZWQoaW5kZXgpLFxuICAgIHJhdzogY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdLFxuICAgIGZvcm1hdHRlZFZhbHVlOiB2YWx1ZSxcbiAgICBkYXRhc2V0OiBjb250cm9sbGVyLmdldERhdGFzZXQoKSxcbiAgICBkYXRhSW5kZXg6IGluZGV4LFxuICAgIGRhdGFzZXRJbmRleCxcbiAgICBlbGVtZW50XG4gIH07XG59XG5cbi8qKlxuICogR2V0IHRoZSBzaXplIG9mIHRoZSB0b29sdGlwXG4gKi9cbmZ1bmN0aW9uIGdldFRvb2x0aXBTaXplKHRvb2x0aXAsIG9wdGlvbnMpIHtcbiAgY29uc3QgY3R4ID0gdG9vbHRpcC5jaGFydC5jdHg7XG4gIGNvbnN0IHtib2R5LCBmb290ZXIsIHRpdGxlfSA9IHRvb2x0aXA7XG4gIGNvbnN0IHtib3hXaWR0aCwgYm94SGVpZ2h0fSA9IG9wdGlvbnM7XG4gIGNvbnN0IGJvZHlGb250ID0gdG9Gb250KG9wdGlvbnMuYm9keUZvbnQpO1xuICBjb25zdCB0aXRsZUZvbnQgPSB0b0ZvbnQob3B0aW9ucy50aXRsZUZvbnQpO1xuICBjb25zdCBmb290ZXJGb250ID0gdG9Gb250KG9wdGlvbnMuZm9vdGVyRm9udCk7XG4gIGNvbnN0IHRpdGxlTGluZUNvdW50ID0gdGl0bGUubGVuZ3RoO1xuICBjb25zdCBmb290ZXJMaW5lQ291bnQgPSBmb290ZXIubGVuZ3RoO1xuICBjb25zdCBib2R5TGluZUl0ZW1Db3VudCA9IGJvZHkubGVuZ3RoO1xuXG4gIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcbiAgbGV0IGhlaWdodCA9IHBhZGRpbmcuaGVpZ2h0O1xuICBsZXQgd2lkdGggPSAwO1xuXG4gIC8vIENvdW50IG9mIGFsbCBsaW5lcyBpbiB0aGUgYm9keVxuICBsZXQgY29tYmluZWRCb2R5TGVuZ3RoID0gYm9keS5yZWR1Y2UoKGNvdW50LCBib2R5SXRlbSkgPT4gY291bnQgKyBib2R5SXRlbS5iZWZvcmUubGVuZ3RoICsgYm9keUl0ZW0ubGluZXMubGVuZ3RoICsgYm9keUl0ZW0uYWZ0ZXIubGVuZ3RoLCAwKTtcbiAgY29tYmluZWRCb2R5TGVuZ3RoICs9IHRvb2x0aXAuYmVmb3JlQm9keS5sZW5ndGggKyB0b29sdGlwLmFmdGVyQm9keS5sZW5ndGg7XG5cbiAgaWYgKHRpdGxlTGluZUNvdW50KSB7XG4gICAgaGVpZ2h0ICs9IHRpdGxlTGluZUNvdW50ICogdGl0bGVGb250LmxpbmVIZWlnaHRcblx0XHRcdCsgKHRpdGxlTGluZUNvdW50IC0gMSkgKiBvcHRpb25zLnRpdGxlU3BhY2luZ1xuXHRcdFx0KyBvcHRpb25zLnRpdGxlTWFyZ2luQm90dG9tO1xuICB9XG4gIGlmIChjb21iaW5lZEJvZHlMZW5ndGgpIHtcbiAgICAvLyBCb2R5IGxpbmVzIG1heSBpbmNsdWRlIHNvbWUgZXh0cmEgaGVpZ2h0IGRlcGVuZGluZyBvbiBib3hIZWlnaHRcbiAgICBjb25zdCBib2R5TGluZUhlaWdodCA9IG9wdGlvbnMuZGlzcGxheUNvbG9ycyA/IE1hdGgubWF4KGJveEhlaWdodCwgYm9keUZvbnQubGluZUhlaWdodCkgOiBib2R5Rm9udC5saW5lSGVpZ2h0O1xuICAgIGhlaWdodCArPSBib2R5TGluZUl0ZW1Db3VudCAqIGJvZHlMaW5lSGVpZ2h0XG5cdFx0XHQrIChjb21iaW5lZEJvZHlMZW5ndGggLSBib2R5TGluZUl0ZW1Db3VudCkgKiBib2R5Rm9udC5saW5lSGVpZ2h0XG5cdFx0XHQrIChjb21iaW5lZEJvZHlMZW5ndGggLSAxKSAqIG9wdGlvbnMuYm9keVNwYWNpbmc7XG4gIH1cbiAgaWYgKGZvb3RlckxpbmVDb3VudCkge1xuICAgIGhlaWdodCArPSBvcHRpb25zLmZvb3Rlck1hcmdpblRvcFxuXHRcdFx0KyBmb290ZXJMaW5lQ291bnQgKiBmb290ZXJGb250LmxpbmVIZWlnaHRcblx0XHRcdCsgKGZvb3RlckxpbmVDb3VudCAtIDEpICogb3B0aW9ucy5mb290ZXJTcGFjaW5nO1xuICB9XG5cbiAgLy8gVGl0bGUgd2lkdGhcbiAgbGV0IHdpZHRoUGFkZGluZyA9IDA7XG4gIGNvbnN0IG1heExpbmVXaWR0aCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICB3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCBjdHgubWVhc3VyZVRleHQobGluZSkud2lkdGggKyB3aWR0aFBhZGRpbmcpO1xuICB9O1xuXG4gIGN0eC5zYXZlKCk7XG5cbiAgY3R4LmZvbnQgPSB0aXRsZUZvbnQuc3RyaW5nO1xuICBlYWNoKHRvb2x0aXAudGl0bGUsIG1heExpbmVXaWR0aCk7XG5cbiAgLy8gQm9keSB3aWR0aFxuICBjdHguZm9udCA9IGJvZHlGb250LnN0cmluZztcbiAgZWFjaCh0b29sdGlwLmJlZm9yZUJvZHkuY29uY2F0KHRvb2x0aXAuYWZ0ZXJCb2R5KSwgbWF4TGluZVdpZHRoKTtcblxuICAvLyBCb2R5IGxpbmVzIG1heSBpbmNsdWRlIHNvbWUgZXh0cmEgd2lkdGggZHVlIHRvIHRoZSBjb2xvciBib3hcbiAgd2lkdGhQYWRkaW5nID0gb3B0aW9ucy5kaXNwbGF5Q29sb3JzID8gKGJveFdpZHRoICsgMiArIG9wdGlvbnMuYm94UGFkZGluZykgOiAwO1xuICBlYWNoKGJvZHksIChib2R5SXRlbSkgPT4ge1xuICAgIGVhY2goYm9keUl0ZW0uYmVmb3JlLCBtYXhMaW5lV2lkdGgpO1xuICAgIGVhY2goYm9keUl0ZW0ubGluZXMsIG1heExpbmVXaWR0aCk7XG4gICAgZWFjaChib2R5SXRlbS5hZnRlciwgbWF4TGluZVdpZHRoKTtcbiAgfSk7XG5cbiAgLy8gUmVzZXQgYmFjayB0byAwXG4gIHdpZHRoUGFkZGluZyA9IDA7XG5cbiAgLy8gRm9vdGVyIHdpZHRoXG4gIGN0eC5mb250ID0gZm9vdGVyRm9udC5zdHJpbmc7XG4gIGVhY2godG9vbHRpcC5mb290ZXIsIG1heExpbmVXaWR0aCk7XG5cbiAgY3R4LnJlc3RvcmUoKTtcblxuICAvLyBBZGQgcGFkZGluZ1xuICB3aWR0aCArPSBwYWRkaW5nLndpZHRoO1xuXG4gIHJldHVybiB7d2lkdGgsIGhlaWdodH07XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZVlBbGlnbihjaGFydCwgc2l6ZSkge1xuICBjb25zdCB7eSwgaGVpZ2h0fSA9IHNpemU7XG5cbiAgaWYgKHkgPCBoZWlnaHQgLyAyKSB7XG4gICAgcmV0dXJuICd0b3AnO1xuICB9IGVsc2UgaWYgKHkgPiAoY2hhcnQuaGVpZ2h0IC0gaGVpZ2h0IC8gMikpIHtcbiAgICByZXR1cm4gJ2JvdHRvbSc7XG4gIH1cbiAgcmV0dXJuICdjZW50ZXInO1xufVxuXG5mdW5jdGlvbiBkb2VzTm90Rml0V2l0aEFsaWduKHhBbGlnbiwgY2hhcnQsIG9wdGlvbnMsIHNpemUpIHtcbiAgY29uc3Qge3gsIHdpZHRofSA9IHNpemU7XG4gIGNvbnN0IGNhcmV0ID0gb3B0aW9ucy5jYXJldFNpemUgKyBvcHRpb25zLmNhcmV0UGFkZGluZztcbiAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnICYmIHggKyB3aWR0aCArIGNhcmV0ID4gY2hhcnQud2lkdGgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh4QWxpZ24gPT09ICdyaWdodCcgJiYgeCAtIHdpZHRoIC0gY2FyZXQgPCAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5lWEFsaWduKGNoYXJ0LCBvcHRpb25zLCBzaXplLCB5QWxpZ24pIHtcbiAgY29uc3Qge3gsIHdpZHRofSA9IHNpemU7XG4gIGNvbnN0IHt3aWR0aDogY2hhcnRXaWR0aCwgY2hhcnRBcmVhOiB7bGVmdCwgcmlnaHR9fSA9IGNoYXJ0O1xuICBsZXQgeEFsaWduID0gJ2NlbnRlcic7XG5cbiAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4QWxpZ24gPSB4IDw9IChsZWZ0ICsgcmlnaHQpIC8gMiA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gIH0gZWxzZSBpZiAoeCA8PSB3aWR0aCAvIDIpIHtcbiAgICB4QWxpZ24gPSAnbGVmdCc7XG4gIH0gZWxzZSBpZiAoeCA+PSBjaGFydFdpZHRoIC0gd2lkdGggLyAyKSB7XG4gICAgeEFsaWduID0gJ3JpZ2h0JztcbiAgfVxuXG4gIGlmIChkb2VzTm90Rml0V2l0aEFsaWduKHhBbGlnbiwgY2hhcnQsIG9wdGlvbnMsIHNpemUpKSB7XG4gICAgeEFsaWduID0gJ2NlbnRlcic7XG4gIH1cblxuICByZXR1cm4geEFsaWduO1xufVxuXG4vKipcbiAqIEhlbHBlciB0byBnZXQgdGhlIGFsaWdubWVudCBvZiBhIHRvb2x0aXAgZ2l2ZW4gdGhlIHNpemVcbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lQWxpZ25tZW50KGNoYXJ0LCBvcHRpb25zLCBzaXplKSB7XG4gIGNvbnN0IHlBbGlnbiA9IHNpemUueUFsaWduIHx8IG9wdGlvbnMueUFsaWduIHx8IGRldGVybWluZVlBbGlnbihjaGFydCwgc2l6ZSk7XG5cbiAgcmV0dXJuIHtcbiAgICB4QWxpZ246IHNpemUueEFsaWduIHx8IG9wdGlvbnMueEFsaWduIHx8IGRldGVybWluZVhBbGlnbihjaGFydCwgb3B0aW9ucywgc2l6ZSwgeUFsaWduKSxcbiAgICB5QWxpZ25cbiAgfTtcbn1cblxuZnVuY3Rpb24gYWxpZ25YKHNpemUsIHhBbGlnbikge1xuICBsZXQge3gsIHdpZHRofSA9IHNpemU7XG4gIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB4IC09IHdpZHRoO1xuICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4IC09ICh3aWR0aCAvIDIpO1xuICB9XG4gIHJldHVybiB4O1xufVxuXG5mdW5jdGlvbiBhbGlnblkoc2l6ZSwgeUFsaWduLCBwYWRkaW5nQW5kU2l6ZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gIGxldCB7eSwgaGVpZ2h0fSA9IHNpemU7XG4gIGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG4gICAgeSArPSBwYWRkaW5nQW5kU2l6ZTtcbiAgfSBlbHNlIGlmICh5QWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgeSAtPSBoZWlnaHQgKyBwYWRkaW5nQW5kU2l6ZTtcbiAgfSBlbHNlIHtcbiAgICB5IC09IChoZWlnaHQgLyAyKTtcbiAgfVxuICByZXR1cm4geTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IHRoZSBsb2NhdGlvbiBhIHRvb2x0aXAgbmVlZHMgdG8gYmUgcGxhY2VkIGF0IGdpdmVuIHRoZSBpbml0aWFsIHBvc2l0aW9uICh2aWEgdGhlIHZtKSBhbmQgdGhlIHNpemUgYW5kIGFsaWdubWVudFxuICovXG5mdW5jdGlvbiBnZXRCYWNrZ3JvdW5kUG9pbnQob3B0aW9ucywgc2l6ZSwgYWxpZ25tZW50LCBjaGFydCkge1xuICBjb25zdCB7Y2FyZXRTaXplLCBjYXJldFBhZGRpbmcsIGNvcm5lclJhZGl1c30gPSBvcHRpb25zO1xuICBjb25zdCB7eEFsaWduLCB5QWxpZ259ID0gYWxpZ25tZW50O1xuICBjb25zdCBwYWRkaW5nQW5kU2l6ZSA9IGNhcmV0U2l6ZSArIGNhcmV0UGFkZGluZztcbiAgY29uc3Qge3RvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodH0gPSB0b1RSQkxDb3JuZXJzKGNvcm5lclJhZGl1cyk7XG5cbiAgbGV0IHggPSBhbGlnblgoc2l6ZSwgeEFsaWduKTtcbiAgY29uc3QgeSA9IGFsaWduWShzaXplLCB5QWxpZ24sIHBhZGRpbmdBbmRTaXplKTtcblxuICBpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuICAgIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgeCArPSBwYWRkaW5nQW5kU2l6ZTtcbiAgICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgeCAtPSBwYWRkaW5nQW5kU2l6ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICB4IC09IE1hdGgubWF4KHRvcExlZnQsIGJvdHRvbUxlZnQpICsgY2FyZXRTaXplO1xuICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHggKz0gTWF0aC5tYXgodG9wUmlnaHQsIGJvdHRvbVJpZ2h0KSArIGNhcmV0U2l6ZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogX2xpbWl0VmFsdWUoeCwgMCwgY2hhcnQud2lkdGggLSBzaXplLndpZHRoKSxcbiAgICB5OiBfbGltaXRWYWx1ZSh5LCAwLCBjaGFydC5oZWlnaHQgLSBzaXplLmhlaWdodClcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0QWxpZ25lZFgodG9vbHRpcCwgYWxpZ24sIG9wdGlvbnMpIHtcbiAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuXG4gIHJldHVybiBhbGlnbiA9PT0gJ2NlbnRlcidcbiAgICA/IHRvb2x0aXAueCArIHRvb2x0aXAud2lkdGggLyAyXG4gICAgOiBhbGlnbiA9PT0gJ3JpZ2h0J1xuICAgICAgPyB0b29sdGlwLnggKyB0b29sdGlwLndpZHRoIC0gcGFkZGluZy5yaWdodFxuICAgICAgOiB0b29sdGlwLnggKyBwYWRkaW5nLmxlZnQ7XG59XG5cbi8qKlxuICogSGVscGVyIHRvIGJ1aWxkIGJlZm9yZSBhbmQgYWZ0ZXIgYm9keSBsaW5lc1xuICovXG5mdW5jdGlvbiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhjYWxsYmFjaykge1xuICByZXR1cm4gcHVzaE9yQ29uY2F0KFtdLCBzcGxpdE5ld2xpbmVzKGNhbGxiYWNrKSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXBDb250ZXh0KHBhcmVudCwgdG9vbHRpcCwgdG9vbHRpcEl0ZW1zKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIHRvb2x0aXAsXG4gICAgdG9vbHRpcEl0ZW1zLFxuICAgIHR5cGU6ICd0b29sdGlwJ1xuICB9KTtcbn1cblxuZnVuY3Rpb24gb3ZlcnJpZGVDYWxsYmFja3MoY2FsbGJhY2tzLCBjb250ZXh0KSB7XG4gIGNvbnN0IG92ZXJyaWRlID0gY29udGV4dCAmJiBjb250ZXh0LmRhdGFzZXQgJiYgY29udGV4dC5kYXRhc2V0LnRvb2x0aXAgJiYgY29udGV4dC5kYXRhc2V0LnRvb2x0aXAuY2FsbGJhY2tzO1xuICByZXR1cm4gb3ZlcnJpZGUgPyBjYWxsYmFja3Mub3ZlcnJpZGUob3ZlcnJpZGUpIDogY2FsbGJhY2tzO1xufVxuXG5jb25zdCBkZWZhdWx0Q2FsbGJhY2tzID0ge1xuICAvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtcywgZGF0YSlcbiAgYmVmb3JlVGl0bGU6IG5vb3AsXG4gIHRpdGxlKHRvb2x0aXBJdGVtcykge1xuICAgIGlmICh0b29sdGlwSXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgaXRlbSA9IHRvb2x0aXBJdGVtc1swXTtcbiAgICAgIGNvbnN0IGxhYmVscyA9IGl0ZW0uY2hhcnQuZGF0YS5sYWJlbHM7XG4gICAgICBjb25zdCBsYWJlbENvdW50ID0gbGFiZWxzID8gbGFiZWxzLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0aGlzICYmIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubW9kZSA9PT0gJ2RhdGFzZXQnKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmRhdGFzZXQubGFiZWwgfHwgJyc7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW0ubGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0ubGFiZWw7XG4gICAgICB9IGVsc2UgaWYgKGxhYmVsQ291bnQgPiAwICYmIGl0ZW0uZGF0YUluZGV4IDwgbGFiZWxDb3VudCkge1xuICAgICAgICByZXR1cm4gbGFiZWxzW2l0ZW0uZGF0YUluZGV4XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH0sXG4gIGFmdGVyVGl0bGU6IG5vb3AsXG5cbiAgLy8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG4gIGJlZm9yZUJvZHk6IG5vb3AsXG5cbiAgLy8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcbiAgYmVmb3JlTGFiZWw6IG5vb3AsXG4gIGxhYmVsKHRvb2x0aXBJdGVtKSB7XG4gICAgaWYgKHRoaXMgJiYgdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5tb2RlID09PSAnZGF0YXNldCcpIHtcbiAgICAgIHJldHVybiB0b29sdGlwSXRlbS5sYWJlbCArICc6ICcgKyB0b29sdGlwSXRlbS5mb3JtYXR0ZWRWYWx1ZSB8fCB0b29sdGlwSXRlbS5mb3JtYXR0ZWRWYWx1ZTtcbiAgICB9XG5cbiAgICBsZXQgbGFiZWwgPSB0b29sdGlwSXRlbS5kYXRhc2V0LmxhYmVsIHx8ICcnO1xuXG4gICAgaWYgKGxhYmVsKSB7XG4gICAgICBsYWJlbCArPSAnOiAnO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHRvb2x0aXBJdGVtLmZvcm1hdHRlZFZhbHVlO1xuICAgIGlmICghaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgIGxhYmVsICs9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbGFiZWw7XG4gIH0sXG4gIGxhYmVsQ29sb3IodG9vbHRpcEl0ZW0pIHtcbiAgICBjb25zdCBtZXRhID0gdG9vbHRpcEl0ZW0uY2hhcnQuZ2V0RGF0YXNldE1ldGEodG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4KTtcbiAgICBjb25zdCBvcHRpb25zID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKHRvb2x0aXBJdGVtLmRhdGFJbmRleCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcbiAgICAgIGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxuICAgICAgYm9yZGVyRGFzaDogb3B0aW9ucy5ib3JkZXJEYXNoLFxuICAgICAgYm9yZGVyRGFzaE9mZnNldDogb3B0aW9ucy5ib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgIH07XG4gIH0sXG4gIGxhYmVsVGV4dENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYm9keUNvbG9yO1xuICB9LFxuICBsYWJlbFBvaW50U3R5bGUodG9vbHRpcEl0ZW0pIHtcbiAgICBjb25zdCBtZXRhID0gdG9vbHRpcEl0ZW0uY2hhcnQuZ2V0RGF0YXNldE1ldGEodG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4KTtcbiAgICBjb25zdCBvcHRpb25zID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKHRvb2x0aXBJdGVtLmRhdGFJbmRleCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvaW50U3R5bGU6IG9wdGlvbnMucG9pbnRTdHlsZSxcbiAgICAgIHJvdGF0aW9uOiBvcHRpb25zLnJvdGF0aW9uLFxuICAgIH07XG4gIH0sXG4gIGFmdGVyTGFiZWw6IG5vb3AsXG5cbiAgLy8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG4gIGFmdGVyQm9keTogbm9vcCxcblxuICAvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtcywgZGF0YSlcbiAgYmVmb3JlRm9vdGVyOiBub29wLFxuICBmb290ZXI6IG5vb3AsXG4gIGFmdGVyRm9vdGVyOiBub29wXG59O1xuXG4vKipcbiAqIEludm9rZSBjYWxsYmFjayBmcm9tIG9iamVjdCB3aXRoIGNvbnRleHQgYW5kIGFyZ3VtZW50cy5cbiAqIElmIGNhbGxiYWNrIHJldHVybnMgYHVuZGVmaW5lZGAsIHRoZW4gd2lsbCBiZSBpbnZva2VkIGRlZmF1bHQgY2FsbGJhY2suXG4gKiBAcGFyYW0ge1JlY29yZDxrZXlvZiB0eXBlb2YgZGVmYXVsdENhbGxiYWNrcywgRnVuY3Rpb24+fSBjYWxsYmFja3NcbiAqIEBwYXJhbSB7a2V5b2YgdHlwZW9mIGRlZmF1bHRDYWxsYmFja3N9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gY3R4XG4gKiBAcGFyYW0geyp9IGFyZ1xuICogQHJldHVybnMge2FueX1cbiAqL1xuZnVuY3Rpb24gaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soY2FsbGJhY2tzLCBuYW1lLCBjdHgsIGFyZykge1xuICBjb25zdCByZXN1bHQgPSBjYWxsYmFja3NbbmFtZV0uY2FsbChjdHgsIGFyZyk7XG5cbiAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRDYWxsYmFja3NbbmFtZV0uY2FsbChjdHgsIGFyZyk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgY2xhc3MgVG9vbHRpcCBleHRlbmRzIEVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAbmFtZXNwYWNlIENoYXJ0LlRvb2x0aXAucG9zaXRpb25lcnNcbiAgICovXG4gIHN0YXRpYyBwb3NpdGlvbmVycyA9IHBvc2l0aW9uZXJzO1xuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLm9wYWNpdHkgPSAwO1xuICAgIHRoaXMuX2FjdGl2ZSA9IFtdO1xuICAgIHRoaXMuX2V2ZW50UG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc2l6ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9jYWNoZWRBbmltYXRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3Rvb2x0aXBJdGVtcyA9IFtdO1xuICAgIHRoaXMuJGFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNoYXJ0ID0gY29uZmlnLmNoYXJ0O1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xuICAgIHRoaXMuZGF0YVBvaW50cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRpdGxlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYmVmb3JlQm9keSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvZHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5hZnRlckJvZHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mb290ZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy54QWxpZ24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy55QWxpZ24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy54ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2FyZXRYID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2FyZXRZID0gdW5kZWZpbmVkO1xuICAgIC8vIFRPRE86IFY0LCBtYWtlIHRoaXMgcHJpdmF0ZSwgcmVuYW1lIHRvIGBfbGFiZWxTdHlsZXNgLCBhbmQgY29tYmluZSB3aXRoIGBsYWJlbFBvaW50U3R5bGVzYFxuICAgIC8vIGFuZCBgbGFiZWxUZXh0Q29sb3JzYCB0byBjcmVhdGUgYSBzaW5nbGUgdmFyaWFibGVcbiAgICB0aGlzLmxhYmVsQ29sb3JzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGFiZWxQb2ludFN0eWxlcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxhYmVsVGV4dENvbG9ycyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGluaXRpYWxpemUob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5fY2FjaGVkQW5pbWF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVzb2x2ZUFuaW1hdGlvbnMoKSB7XG4gICAgY29uc3QgY2FjaGVkID0gdGhpcy5fY2FjaGVkQW5pbWF0aW9ucztcblxuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3Qgb3B0cyA9IG9wdGlvbnMuZW5hYmxlZCAmJiBjaGFydC5vcHRpb25zLmFuaW1hdGlvbiAmJiBvcHRpb25zLmFuaW1hdGlvbnM7XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IG5ldyBBbmltYXRpb25zKHRoaXMuY2hhcnQsIG9wdHMpO1xuICAgIGlmIChvcHRzLl9jYWNoZWFibGUpIHtcbiAgICAgIHRoaXMuX2NhY2hlZEFuaW1hdGlvbnMgPSBPYmplY3QuZnJlZXplKGFuaW1hdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBhbmltYXRpb25zO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQgfHxcblx0XHRcdCh0aGlzLiRjb250ZXh0ID0gY3JlYXRlVG9vbHRpcENvbnRleHQodGhpcy5jaGFydC5nZXRDb250ZXh0KCksIHRoaXMsIHRoaXMuX3Rvb2x0aXBJdGVtcykpO1xuICB9XG5cbiAgZ2V0VGl0bGUoY29udGV4dCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHtjYWxsYmFja3N9ID0gb3B0aW9ucztcblxuICAgIGNvbnN0IGJlZm9yZVRpdGxlID0gaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soY2FsbGJhY2tzLCAnYmVmb3JlVGl0bGUnLCB0aGlzLCBjb250ZXh0KTtcbiAgICBjb25zdCB0aXRsZSA9IGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKGNhbGxiYWNrcywgJ3RpdGxlJywgdGhpcywgY29udGV4dCk7XG4gICAgY29uc3QgYWZ0ZXJUaXRsZSA9IGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKGNhbGxiYWNrcywgJ2FmdGVyVGl0bGUnLCB0aGlzLCBjb250ZXh0KTtcblxuICAgIGxldCBsaW5lcyA9IFtdO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGJlZm9yZVRpdGxlKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXModGl0bGUpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhhZnRlclRpdGxlKSk7XG5cbiAgICByZXR1cm4gbGluZXM7XG4gIH1cblxuICBnZXRCZWZvcmVCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucykge1xuICAgIHJldHVybiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhcbiAgICAgIGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKG9wdGlvbnMuY2FsbGJhY2tzLCAnYmVmb3JlQm9keScsIHRoaXMsIHRvb2x0aXBJdGVtcylcbiAgICApO1xuICB9XG5cbiAgZ2V0Qm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Y2FsbGJhY2tzfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYm9keUl0ZW1zID0gW107XG5cbiAgICBlYWNoKHRvb2x0aXBJdGVtcywgKGNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IGJvZHlJdGVtID0ge1xuICAgICAgICBiZWZvcmU6IFtdLFxuICAgICAgICBsaW5lczogW10sXG4gICAgICAgIGFmdGVyOiBbXVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNjb3BlZCA9IG92ZXJyaWRlQ2FsbGJhY2tzKGNhbGxiYWNrcywgY29udGV4dCk7XG4gICAgICBwdXNoT3JDb25jYXQoYm9keUl0ZW0uYmVmb3JlLCBzcGxpdE5ld2xpbmVzKGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKHNjb3BlZCwgJ2JlZm9yZUxhYmVsJywgdGhpcywgY29udGV4dCkpKTtcbiAgICAgIHB1c2hPckNvbmNhdChib2R5SXRlbS5saW5lcywgaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soc2NvcGVkLCAnbGFiZWwnLCB0aGlzLCBjb250ZXh0KSk7XG4gICAgICBwdXNoT3JDb25jYXQoYm9keUl0ZW0uYWZ0ZXIsIHNwbGl0TmV3bGluZXMoaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soc2NvcGVkLCAnYWZ0ZXJMYWJlbCcsIHRoaXMsIGNvbnRleHQpKSk7XG5cbiAgICAgIGJvZHlJdGVtcy5wdXNoKGJvZHlJdGVtKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBib2R5SXRlbXM7XG4gIH1cblxuICBnZXRBZnRlckJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKFxuICAgICAgaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2sob3B0aW9ucy5jYWxsYmFja3MsICdhZnRlckJvZHknLCB0aGlzLCB0b29sdGlwSXRlbXMpXG4gICAgKTtcbiAgfVxuXG4gIC8vIEdldCB0aGUgZm9vdGVyIGFuZCBiZWZvcmVGb290ZXIgYW5kIGFmdGVyRm9vdGVyIGxpbmVzXG4gIGdldEZvb3Rlcih0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Y2FsbGJhY2tzfSA9IG9wdGlvbnM7XG5cbiAgICBjb25zdCBiZWZvcmVGb290ZXIgPSBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhjYWxsYmFja3MsICdiZWZvcmVGb290ZXInLCB0aGlzLCB0b29sdGlwSXRlbXMpO1xuICAgIGNvbnN0IGZvb3RlciA9IGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKGNhbGxiYWNrcywgJ2Zvb3RlcicsIHRoaXMsIHRvb2x0aXBJdGVtcyk7XG4gICAgY29uc3QgYWZ0ZXJGb290ZXIgPSBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhjYWxsYmFja3MsICdhZnRlckZvb3RlcicsIHRoaXMsIHRvb2x0aXBJdGVtcyk7XG5cbiAgICBsZXQgbGluZXMgPSBbXTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhiZWZvcmVGb290ZXIpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhmb290ZXIpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhhZnRlckZvb3RlcikpO1xuXG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY3JlYXRlSXRlbXMob3B0aW9ucykge1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5jaGFydC5kYXRhO1xuICAgIGNvbnN0IGxhYmVsQ29sb3JzID0gW107XG4gICAgY29uc3QgbGFiZWxQb2ludFN0eWxlcyA9IFtdO1xuICAgIGNvbnN0IGxhYmVsVGV4dENvbG9ycyA9IFtdO1xuICAgIGxldCB0b29sdGlwSXRlbXMgPSBbXTtcbiAgICBsZXQgaSwgbGVuO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gYWN0aXZlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0b29sdGlwSXRlbXMucHVzaChjcmVhdGVUb29sdGlwSXRlbSh0aGlzLmNoYXJ0LCBhY3RpdmVbaV0pKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdXNlciBwcm92aWRlZCBhIGZpbHRlciBmdW5jdGlvbiwgdXNlIGl0IHRvIG1vZGlmeSB0aGUgdG9vbHRpcCBpdGVtc1xuICAgIGlmIChvcHRpb25zLmZpbHRlcikge1xuICAgICAgdG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zLmZpbHRlcigoZWxlbWVudCwgaW5kZXgsIGFycmF5KSA9PiBvcHRpb25zLmZpbHRlcihlbGVtZW50LCBpbmRleCwgYXJyYXksIGRhdGEpKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdXNlciBwcm92aWRlZCBhIHNvcnRpbmcgZnVuY3Rpb24sIHVzZSBpdCB0byBtb2RpZnkgdGhlIHRvb2x0aXAgaXRlbXNcbiAgICBpZiAob3B0aW9ucy5pdGVtU29ydCkge1xuICAgICAgdG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zLnNvcnQoKGEsIGIpID0+IG9wdGlvbnMuaXRlbVNvcnQoYSwgYiwgZGF0YSkpO1xuICAgIH1cblxuICAgIC8vIERldGVybWluZSBjb2xvcnMgZm9yIGJveGVzXG4gICAgZWFjaCh0b29sdGlwSXRlbXMsIChjb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBzY29wZWQgPSBvdmVycmlkZUNhbGxiYWNrcyhvcHRpb25zLmNhbGxiYWNrcywgY29udGV4dCk7XG4gICAgICBsYWJlbENvbG9ycy5wdXNoKGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKHNjb3BlZCwgJ2xhYmVsQ29sb3InLCB0aGlzLCBjb250ZXh0KSk7XG4gICAgICBsYWJlbFBvaW50U3R5bGVzLnB1c2goaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soc2NvcGVkLCAnbGFiZWxQb2ludFN0eWxlJywgdGhpcywgY29udGV4dCkpO1xuICAgICAgbGFiZWxUZXh0Q29sb3JzLnB1c2goaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soc2NvcGVkLCAnbGFiZWxUZXh0Q29sb3InLCB0aGlzLCBjb250ZXh0KSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmxhYmVsQ29sb3JzID0gbGFiZWxDb2xvcnM7XG4gICAgdGhpcy5sYWJlbFBvaW50U3R5bGVzID0gbGFiZWxQb2ludFN0eWxlcztcbiAgICB0aGlzLmxhYmVsVGV4dENvbG9ycyA9IGxhYmVsVGV4dENvbG9ycztcbiAgICB0aGlzLmRhdGFQb2ludHMgPSB0b29sdGlwSXRlbXM7XG4gICAgcmV0dXJuIHRvb2x0aXBJdGVtcztcbiAgfVxuXG4gIHVwZGF0ZShjaGFuZ2VkLCByZXBsYXkpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcbiAgICBsZXQgcHJvcGVydGllcztcbiAgICBsZXQgdG9vbHRpcEl0ZW1zID0gW107XG5cbiAgICBpZiAoIWFjdGl2ZS5sZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLm9wYWNpdHkgIT09IDApIHtcbiAgICAgICAgcHJvcGVydGllcyA9IHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0aW9ucy5wb3NpdGlvbl0uY2FsbCh0aGlzLCBhY3RpdmUsIHRoaXMuX2V2ZW50UG9zaXRpb24pO1xuICAgICAgdG9vbHRpcEl0ZW1zID0gdGhpcy5fY3JlYXRlSXRlbXMob3B0aW9ucyk7XG5cbiAgICAgIHRoaXMudGl0bGUgPSB0aGlzLmdldFRpdGxlKHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLmJlZm9yZUJvZHkgPSB0aGlzLmdldEJlZm9yZUJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuYm9keSA9IHRoaXMuZ2V0Qm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5hZnRlckJvZHkgPSB0aGlzLmdldEFmdGVyQm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5mb290ZXIgPSB0aGlzLmdldEZvb3Rlcih0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuXG4gICAgICBjb25zdCBzaXplID0gdGhpcy5fc2l6ZSA9IGdldFRvb2x0aXBTaXplKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgY29uc3QgcG9zaXRpb25BbmRTaXplID0gT2JqZWN0LmFzc2lnbih7fSwgcG9zaXRpb24sIHNpemUpO1xuICAgICAgY29uc3QgYWxpZ25tZW50ID0gZGV0ZXJtaW5lQWxpZ25tZW50KHRoaXMuY2hhcnQsIG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSk7XG4gICAgICBjb25zdCBiYWNrZ3JvdW5kUG9pbnQgPSBnZXRCYWNrZ3JvdW5kUG9pbnQob3B0aW9ucywgcG9zaXRpb25BbmRTaXplLCBhbGlnbm1lbnQsIHRoaXMuY2hhcnQpO1xuXG4gICAgICB0aGlzLnhBbGlnbiA9IGFsaWdubWVudC54QWxpZ247XG4gICAgICB0aGlzLnlBbGlnbiA9IGFsaWdubWVudC55QWxpZ247XG5cbiAgICAgIHByb3BlcnRpZXMgPSB7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIHg6IGJhY2tncm91bmRQb2ludC54LFxuICAgICAgICB5OiBiYWNrZ3JvdW5kUG9pbnQueSxcbiAgICAgICAgd2lkdGg6IHNpemUud2lkdGgsXG4gICAgICAgIGhlaWdodDogc2l6ZS5oZWlnaHQsXG4gICAgICAgIGNhcmV0WDogcG9zaXRpb24ueCxcbiAgICAgICAgY2FyZXRZOiBwb3NpdGlvbi55XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMuX3Rvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcztcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKCkudXBkYXRlKHRoaXMsIHByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIGlmIChjaGFuZ2VkICYmIG9wdGlvbnMuZXh0ZXJuYWwpIHtcbiAgICAgIG9wdGlvbnMuZXh0ZXJuYWwuY2FsbCh0aGlzLCB7Y2hhcnQ6IHRoaXMuY2hhcnQsIHRvb2x0aXA6IHRoaXMsIHJlcGxheX0pO1xuICAgIH1cbiAgfVxuXG4gIGRyYXdDYXJldCh0b29sdGlwUG9pbnQsIGN0eCwgc2l6ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGNhcmV0UG9zaXRpb24gPSB0aGlzLmdldENhcmV0UG9zaXRpb24odG9vbHRpcFBvaW50LCBzaXplLCBvcHRpb25zKTtcblxuICAgIGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MSwgY2FyZXRQb3NpdGlvbi55MSk7XG4gICAgY3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngyLCBjYXJldFBvc2l0aW9uLnkyKTtcbiAgICBjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDMsIGNhcmV0UG9zaXRpb24ueTMpO1xuICB9XG5cbiAgZ2V0Q2FyZXRQb3NpdGlvbih0b29sdGlwUG9pbnQsIHNpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7eEFsaWduLCB5QWxpZ259ID0gdGhpcztcbiAgICBjb25zdCB7Y2FyZXRTaXplLCBjb3JuZXJSYWRpdXN9ID0gb3B0aW9ucztcbiAgICBjb25zdCB7dG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0fSA9IHRvVFJCTENvcm5lcnMoY29ybmVyUmFkaXVzKTtcbiAgICBjb25zdCB7eDogcHRYLCB5OiBwdFl9ID0gdG9vbHRpcFBvaW50O1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHNpemU7XG4gICAgbGV0IHgxLCB4MiwgeDMsIHkxLCB5MiwgeTM7XG5cbiAgICBpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgeTIgPSBwdFkgKyAoaGVpZ2h0IC8gMik7XG5cbiAgICAgIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICB4MSA9IHB0WDtcbiAgICAgICAgeDIgPSB4MSAtIGNhcmV0U2l6ZTtcblxuICAgICAgICAvLyBMZWZ0IGRyYXdzIGJvdHRvbSAtPiB0b3AsIHRoaXMgeTEgaXMgb24gdGhlIGJvdHRvbVxuICAgICAgICB5MSA9IHkyICsgY2FyZXRTaXplO1xuICAgICAgICB5MyA9IHkyIC0gY2FyZXRTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDEgPSBwdFggKyB3aWR0aDtcbiAgICAgICAgeDIgPSB4MSArIGNhcmV0U2l6ZTtcblxuICAgICAgICAvLyBSaWdodCBkcmF3cyB0b3AgLT4gYm90dG9tLCB0aHVzIHkxIGlzIG9uIHRoZSB0b3BcbiAgICAgICAgeTEgPSB5MiAtIGNhcmV0U2l6ZTtcbiAgICAgICAgeTMgPSB5MiArIGNhcmV0U2l6ZTtcbiAgICAgIH1cblxuICAgICAgeDMgPSB4MTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHgyID0gcHRYICsgTWF0aC5tYXgodG9wTGVmdCwgYm90dG9tTGVmdCkgKyAoY2FyZXRTaXplKTtcbiAgICAgIH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIHgyID0gcHRYICsgd2lkdGggLSBNYXRoLm1heCh0b3BSaWdodCwgYm90dG9tUmlnaHQpIC0gY2FyZXRTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDIgPSB0aGlzLmNhcmV0WDtcbiAgICAgIH1cblxuICAgICAgaWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgeTEgPSBwdFk7XG4gICAgICAgIHkyID0geTEgLSBjYXJldFNpemU7XG5cbiAgICAgICAgLy8gVG9wIGRyYXdzIGxlZnQgLT4gcmlnaHQsIHRodXMgeDEgaXMgb24gdGhlIGxlZnRcbiAgICAgICAgeDEgPSB4MiAtIGNhcmV0U2l6ZTtcbiAgICAgICAgeDMgPSB4MiArIGNhcmV0U2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkxID0gcHRZICsgaGVpZ2h0O1xuICAgICAgICB5MiA9IHkxICsgY2FyZXRTaXplO1xuXG4gICAgICAgIC8vIEJvdHRvbSBkcmF3cyByaWdodCAtPiBsZWZ0LCB0aHVzIHgxIGlzIG9uIHRoZSByaWdodFxuICAgICAgICB4MSA9IHgyICsgY2FyZXRTaXplO1xuICAgICAgICB4MyA9IHgyIC0gY2FyZXRTaXplO1xuICAgICAgfVxuICAgICAgeTMgPSB5MTtcbiAgICB9XG4gICAgcmV0dXJuIHt4MSwgeDIsIHgzLCB5MSwgeTIsIHkzfTtcbiAgfVxuXG4gIGRyYXdUaXRsZShwdCwgY3R4LCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGl0bGUgPSB0aGlzLnRpdGxlO1xuICAgIGNvbnN0IGxlbmd0aCA9IHRpdGxlLmxlbmd0aDtcbiAgICBsZXQgdGl0bGVGb250LCB0aXRsZVNwYWNpbmcsIGk7XG5cbiAgICBpZiAobGVuZ3RoKSB7XG4gICAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdGlvbnMucnRsLCB0aGlzLngsIHRoaXMud2lkdGgpO1xuXG4gICAgICBwdC54ID0gZ2V0QWxpZ25lZFgodGhpcywgb3B0aW9ucy50aXRsZUFsaWduLCBvcHRpb25zKTtcblxuICAgICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24ob3B0aW9ucy50aXRsZUFsaWduKTtcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuICAgICAgdGl0bGVGb250ID0gdG9Gb250KG9wdGlvbnMudGl0bGVGb250KTtcbiAgICAgIHRpdGxlU3BhY2luZyA9IG9wdGlvbnMudGl0bGVTcGFjaW5nO1xuXG4gICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy50aXRsZUNvbG9yO1xuICAgICAgY3R4LmZvbnQgPSB0aXRsZUZvbnQuc3RyaW5nO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3R4LmZpbGxUZXh0KHRpdGxlW2ldLCBydGxIZWxwZXIueChwdC54KSwgcHQueSArIHRpdGxlRm9udC5saW5lSGVpZ2h0IC8gMik7XG4gICAgICAgIHB0LnkgKz0gdGl0bGVGb250LmxpbmVIZWlnaHQgKyB0aXRsZVNwYWNpbmc7IC8vIExpbmUgSGVpZ2h0IGFuZCBzcGFjaW5nXG5cbiAgICAgICAgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICBwdC55ICs9IG9wdGlvbnMudGl0bGVNYXJnaW5Cb3R0b20gLSB0aXRsZVNwYWNpbmc7IC8vIElmIExhc3QsIGFkZCBtYXJnaW4sIHJlbW92ZSBzcGFjaW5nXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kcmF3Q29sb3JCb3goY3R4LCBwdCwgaSwgcnRsSGVscGVyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGFiZWxDb2xvciA9IHRoaXMubGFiZWxDb2xvcnNbaV07XG4gICAgY29uc3QgbGFiZWxQb2ludFN0eWxlID0gdGhpcy5sYWJlbFBvaW50U3R5bGVzW2ldO1xuICAgIGNvbnN0IHtib3hIZWlnaHQsIGJveFdpZHRofSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYm9keUZvbnQgPSB0b0ZvbnQob3B0aW9ucy5ib2R5Rm9udCk7XG4gICAgY29uc3QgY29sb3JYID0gZ2V0QWxpZ25lZFgodGhpcywgJ2xlZnQnLCBvcHRpb25zKTtcbiAgICBjb25zdCBydGxDb2xvclggPSBydGxIZWxwZXIueChjb2xvclgpO1xuICAgIGNvbnN0IHlPZmZTZXQgPSBib3hIZWlnaHQgPCBib2R5Rm9udC5saW5lSGVpZ2h0ID8gKGJvZHlGb250LmxpbmVIZWlnaHQgLSBib3hIZWlnaHQpIC8gMiA6IDA7XG4gICAgY29uc3QgY29sb3JZID0gcHQueSArIHlPZmZTZXQ7XG5cbiAgICBpZiAob3B0aW9ucy51c2VQb2ludFN0eWxlKSB7XG4gICAgICBjb25zdCBkcmF3T3B0aW9ucyA9IHtcbiAgICAgICAgcmFkaXVzOiBNYXRoLm1pbihib3hXaWR0aCwgYm94SGVpZ2h0KSAvIDIsIC8vIGZpdCB0aGUgY2lyY2xlIGluIHRoZSBib3hcbiAgICAgICAgcG9pbnRTdHlsZTogbGFiZWxQb2ludFN0eWxlLnBvaW50U3R5bGUsXG4gICAgICAgIHJvdGF0aW9uOiBsYWJlbFBvaW50U3R5bGUucm90YXRpb24sXG4gICAgICAgIGJvcmRlcldpZHRoOiAxXG4gICAgICB9O1xuICAgICAgLy8gUmVjYWxjdWxhdGUgeCBhbmQgeSBmb3IgZHJhd1BvaW50KCkgYmVjYXVzZSBpdHMgZXhwZWN0aW5nXG4gICAgICAvLyB4IGFuZCB5IHRvIGJlIGNlbnRlciBvZiBmaWd1cmUgKGluc3RlYWQgb2YgdG9wIGxlZnQpXG4gICAgICBjb25zdCBjZW50ZXJYID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsQ29sb3JYLCBib3hXaWR0aCkgKyBib3hXaWR0aCAvIDI7XG4gICAgICBjb25zdCBjZW50ZXJZID0gY29sb3JZICsgYm94SGVpZ2h0IC8gMjtcblxuICAgICAgLy8gRmlsbCB0aGUgcG9pbnQgd2l0aCB3aGl0ZSBzbyB0aGF0IGNvbG91cnMgbWVyZ2UgbmljZWx5IGlmIHRoZSBvcGFjaXR5IGlzIDwgMVxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5tdWx0aUtleUJhY2tncm91bmQ7XG4gICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5tdWx0aUtleUJhY2tncm91bmQ7XG4gICAgICBkcmF3UG9pbnQoY3R4LCBkcmF3T3B0aW9ucywgY2VudGVyWCwgY2VudGVyWSk7XG5cbiAgICAgIC8vIERyYXcgdGhlIHBvaW50XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsYWJlbENvbG9yLmJvcmRlckNvbG9yO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3IuYmFja2dyb3VuZENvbG9yO1xuICAgICAgZHJhd1BvaW50KGN0eCwgZHJhd09wdGlvbnMsIGNlbnRlclgsIGNlbnRlclkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCb3JkZXJcbiAgICAgIGN0eC5saW5lV2lkdGggPSBpc09iamVjdChsYWJlbENvbG9yLmJvcmRlcldpZHRoKSA/IE1hdGgubWF4KC4uLk9iamVjdC52YWx1ZXMobGFiZWxDb2xvci5ib3JkZXJXaWR0aCkpIDogKGxhYmVsQ29sb3IuYm9yZGVyV2lkdGggfHwgMSk7IC8vIFRPRE8sIHY0IHJlbW92ZSBmYWxsYmFja1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbGFiZWxDb2xvci5ib3JkZXJDb2xvcjtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChsYWJlbENvbG9yLmJvcmRlckRhc2ggfHwgW10pO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gbGFiZWxDb2xvci5ib3JkZXJEYXNoT2Zmc2V0IHx8IDA7XG5cbiAgICAgIC8vIEZpbGwgYSB3aGl0ZSByZWN0IHNvIHRoYXQgY29sb3VycyBtZXJnZSBuaWNlbHkgaWYgdGhlIG9wYWNpdHkgaXMgPCAxXG4gICAgICBjb25zdCBvdXRlclggPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxDb2xvclgsIGJveFdpZHRoKTtcbiAgICAgIGNvbnN0IGlubmVyWCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bEhlbHBlci54UGx1cyhydGxDb2xvclgsIDEpLCBib3hXaWR0aCAtIDIpO1xuICAgICAgY29uc3QgYm9yZGVyUmFkaXVzID0gdG9UUkJMQ29ybmVycyhsYWJlbENvbG9yLmJvcmRlclJhZGl1cyk7XG5cbiAgICAgIGlmIChPYmplY3QudmFsdWVzKGJvcmRlclJhZGl1cykuc29tZSh2ID0+IHYgIT09IDApKSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgICAgeDogb3V0ZXJYLFxuICAgICAgICAgIHk6IGNvbG9yWSxcbiAgICAgICAgICB3OiBib3hXaWR0aCxcbiAgICAgICAgICBoOiBib3hIZWlnaHQsXG4gICAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICAgIH0pO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgLy8gSW5uZXIgc3F1YXJlXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBsYWJlbENvbG9yLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgICAgeDogaW5uZXJYLFxuICAgICAgICAgIHk6IGNvbG9yWSArIDEsXG4gICAgICAgICAgdzogYm94V2lkdGggLSAyLFxuICAgICAgICAgIGg6IGJveEhlaWdodCAtIDIsXG4gICAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICAgIH0pO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm9ybWFsIHJlY3RcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgICBjdHguZmlsbFJlY3Qob3V0ZXJYLCBjb2xvclksIGJveFdpZHRoLCBib3hIZWlnaHQpO1xuICAgICAgICBjdHguc3Ryb2tlUmVjdChvdXRlclgsIGNvbG9yWSwgYm94V2lkdGgsIGJveEhlaWdodCk7XG4gICAgICAgIC8vIElubmVyIHNxdWFyZVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gbGFiZWxDb2xvci5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGN0eC5maWxsUmVjdChpbm5lclgsIGNvbG9yWSArIDEsIGJveFdpZHRoIC0gMiwgYm94SGVpZ2h0IC0gMik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVzdG9yZSBmaWxsU3R5bGVcbiAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5sYWJlbFRleHRDb2xvcnNbaV07XG4gIH1cblxuICBkcmF3Qm9keShwdCwgY3R4LCBvcHRpb25zKSB7XG4gICAgY29uc3Qge2JvZHl9ID0gdGhpcztcbiAgICBjb25zdCB7Ym9keVNwYWNpbmcsIGJvZHlBbGlnbiwgZGlzcGxheUNvbG9ycywgYm94SGVpZ2h0LCBib3hXaWR0aCwgYm94UGFkZGluZ30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJvZHlGb250ID0gdG9Gb250KG9wdGlvbnMuYm9keUZvbnQpO1xuICAgIGxldCBib2R5TGluZUhlaWdodCA9IGJvZHlGb250LmxpbmVIZWlnaHQ7XG4gICAgbGV0IHhMaW5lUGFkZGluZyA9IDA7XG5cbiAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdGlvbnMucnRsLCB0aGlzLngsIHRoaXMud2lkdGgpO1xuXG4gICAgY29uc3QgZmlsbExpbmVPZlRleHQgPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgICBjdHguZmlsbFRleHQobGluZSwgcnRsSGVscGVyLngocHQueCArIHhMaW5lUGFkZGluZyksIHB0LnkgKyBib2R5TGluZUhlaWdodCAvIDIpO1xuICAgICAgcHQueSArPSBib2R5TGluZUhlaWdodCArIGJvZHlTcGFjaW5nO1xuICAgIH07XG5cbiAgICBjb25zdCBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24oYm9keUFsaWduKTtcbiAgICBsZXQgYm9keUl0ZW0sIHRleHRDb2xvciwgbGluZXMsIGksIGosIGlsZW4sIGpsZW47XG5cbiAgICBjdHgudGV4dEFsaWduID0gYm9keUFsaWduO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBjdHguZm9udCA9IGJvZHlGb250LnN0cmluZztcblxuICAgIHB0LnggPSBnZXRBbGlnbmVkWCh0aGlzLCBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiwgb3B0aW9ucyk7XG5cbiAgICAvLyBCZWZvcmUgYm9keSBsaW5lc1xuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJvZHlDb2xvcjtcbiAgICBlYWNoKHRoaXMuYmVmb3JlQm9keSwgZmlsbExpbmVPZlRleHQpO1xuXG4gICAgeExpbmVQYWRkaW5nID0gZGlzcGxheUNvbG9ycyAmJiBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiAhPT0gJ3JpZ2h0J1xuICAgICAgPyBib2R5QWxpZ24gPT09ICdjZW50ZXInID8gKGJveFdpZHRoIC8gMiArIGJveFBhZGRpbmcpIDogKGJveFdpZHRoICsgMiArIGJveFBhZGRpbmcpXG4gICAgICA6IDA7XG5cbiAgICAvLyBEcmF3IGJvZHkgbGluZXMgbm93XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGJvZHkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBib2R5SXRlbSA9IGJvZHlbaV07XG4gICAgICB0ZXh0Q29sb3IgPSB0aGlzLmxhYmVsVGV4dENvbG9yc1tpXTtcblxuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRleHRDb2xvcjtcbiAgICAgIGVhY2goYm9keUl0ZW0uYmVmb3JlLCBmaWxsTGluZU9mVGV4dCk7XG5cbiAgICAgIGxpbmVzID0gYm9keUl0ZW0ubGluZXM7XG4gICAgICAvLyBEcmF3IExlZ2VuZC1saWtlIGJveGVzIGlmIG5lZWRlZFxuICAgICAgaWYgKGRpc3BsYXlDb2xvcnMgJiYgbGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX2RyYXdDb2xvckJveChjdHgsIHB0LCBpLCBydGxIZWxwZXIsIG9wdGlvbnMpO1xuICAgICAgICBib2R5TGluZUhlaWdodCA9IE1hdGgubWF4KGJvZHlGb250LmxpbmVIZWlnaHQsIGJveEhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSBsaW5lcy5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcbiAgICAgICAgZmlsbExpbmVPZlRleHQobGluZXNbal0pO1xuICAgICAgICAvLyBSZXNldCBmb3IgYW55IGxpbmVzIHRoYXQgZG9uJ3QgaW5jbHVkZSBjb2xvcmJveFxuICAgICAgICBib2R5TGluZUhlaWdodCA9IGJvZHlGb250LmxpbmVIZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIGVhY2goYm9keUl0ZW0uYWZ0ZXIsIGZpbGxMaW5lT2ZUZXh0KTtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBiYWNrIHRvIDAgZm9yIGFmdGVyIGJvZHlcbiAgICB4TGluZVBhZGRpbmcgPSAwO1xuICAgIGJvZHlMaW5lSGVpZ2h0ID0gYm9keUZvbnQubGluZUhlaWdodDtcblxuICAgIC8vIEFmdGVyIGJvZHkgbGluZXNcbiAgICBlYWNoKHRoaXMuYWZ0ZXJCb2R5LCBmaWxsTGluZU9mVGV4dCk7XG4gICAgcHQueSAtPSBib2R5U3BhY2luZzsgLy8gUmVtb3ZlIGxhc3QgYm9keSBzcGFjaW5nXG4gIH1cblxuICBkcmF3Rm9vdGVyKHB0LCBjdHgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBmb290ZXIgPSB0aGlzLmZvb3RlcjtcbiAgICBjb25zdCBsZW5ndGggPSBmb290ZXIubGVuZ3RoO1xuICAgIGxldCBmb290ZXJGb250LCBpO1xuXG4gICAgaWYgKGxlbmd0aCkge1xuICAgICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRpb25zLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKTtcblxuICAgICAgcHQueCA9IGdldEFsaWduZWRYKHRoaXMsIG9wdGlvbnMuZm9vdGVyQWxpZ24sIG9wdGlvbnMpO1xuICAgICAgcHQueSArPSBvcHRpb25zLmZvb3Rlck1hcmdpblRvcDtcblxuICAgICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24ob3B0aW9ucy5mb290ZXJBbGlnbik7XG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cbiAgICAgIGZvb3RlckZvbnQgPSB0b0ZvbnQob3B0aW9ucy5mb290ZXJGb250KTtcblxuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuZm9vdGVyQ29sb3I7XG4gICAgICBjdHguZm9udCA9IGZvb3RlckZvbnQuc3RyaW5nO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3R4LmZpbGxUZXh0KGZvb3RlcltpXSwgcnRsSGVscGVyLngocHQueCksIHB0LnkgKyBmb290ZXJGb250LmxpbmVIZWlnaHQgLyAyKTtcbiAgICAgICAgcHQueSArPSBmb290ZXJGb250LmxpbmVIZWlnaHQgKyBvcHRpb25zLmZvb3RlclNwYWNpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZHJhd0JhY2tncm91bmQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7eEFsaWduLCB5QWxpZ259ID0gdGhpcztcbiAgICBjb25zdCB7eCwgeX0gPSBwdDtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0b29sdGlwU2l6ZTtcbiAgICBjb25zdCB7dG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0fSA9IHRvVFJCTENvcm5lcnMob3B0aW9ucy5jb3JuZXJSYWRpdXMpO1xuXG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG4gICAgY3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMuYm9yZGVyV2lkdGg7XG5cbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyh4ICsgdG9wTGVmdCwgeSk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4ICsgd2lkdGggLSB0b3BSaWdodCwgeSk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyB0b3BSaWdodCk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicgJiYgeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gYm90dG9tUmlnaHQpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gYm90dG9tUmlnaHQsIHkgKyBoZWlnaHQpO1xuICAgIGlmICh5QWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCArIGJvdHRvbUxlZnQsIHkgKyBoZWlnaHQpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSBib3R0b21MZWZ0KTtcbiAgICBpZiAoeUFsaWduID09PSAnY2VudGVyJyAmJiB4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHgsIHkgKyB0b3BMZWZ0KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgdG9wTGVmdCwgeSk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgY3R4LmZpbGwoKTtcblxuICAgIGlmIChvcHRpb25zLmJvcmRlcldpZHRoID4gMCkge1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBVcGRhdGUgeC95IGFuaW1hdGlvbiB0YXJnZXRzIHdoZW4gX2FjdGl2ZSBlbGVtZW50cyBhcmUgYW5pbWF0aW5nIHRvb1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZUFuaW1hdGlvblRhcmdldChvcHRpb25zKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGFuaW1zID0gdGhpcy4kYW5pbWF0aW9ucztcbiAgICBjb25zdCBhbmltWCA9IGFuaW1zICYmIGFuaW1zLng7XG4gICAgY29uc3QgYW5pbVkgPSBhbmltcyAmJiBhbmltcy55O1xuICAgIGlmIChhbmltWCB8fCBhbmltWSkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbmVyc1tvcHRpb25zLnBvc2l0aW9uXS5jYWxsKHRoaXMsIHRoaXMuX2FjdGl2ZSwgdGhpcy5fZXZlbnRQb3NpdGlvbik7XG4gICAgICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpemUgPSB0aGlzLl9zaXplID0gZ2V0VG9vbHRpcFNpemUodGhpcywgb3B0aW9ucyk7XG4gICAgICBjb25zdCBwb3NpdGlvbkFuZFNpemUgPSBPYmplY3QuYXNzaWduKHt9LCBwb3NpdGlvbiwgdGhpcy5fc2l6ZSk7XG4gICAgICBjb25zdCBhbGlnbm1lbnQgPSBkZXRlcm1pbmVBbGlnbm1lbnQoY2hhcnQsIG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSk7XG4gICAgICBjb25zdCBwb2ludCA9IGdldEJhY2tncm91bmRQb2ludChvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUsIGFsaWdubWVudCwgY2hhcnQpO1xuICAgICAgaWYgKGFuaW1YLl90byAhPT0gcG9pbnQueCB8fCBhbmltWS5fdG8gIT09IHBvaW50LnkpIHtcbiAgICAgICAgdGhpcy54QWxpZ24gPSBhbGlnbm1lbnQueEFsaWduO1xuICAgICAgICB0aGlzLnlBbGlnbiA9IGFsaWdubWVudC55QWxpZ247XG4gICAgICAgIHRoaXMud2lkdGggPSBzaXplLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICAgICAgICB0aGlzLmNhcmV0WCA9IHBvc2l0aW9uLng7XG4gICAgICAgIHRoaXMuY2FyZXRZID0gcG9zaXRpb24ueTtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoKS51cGRhdGUodGhpcywgcG9pbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgdGhlIHRvb2x0aXAgd2lsbCBkcmF3IGFueXRoaW5nXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB0b29sdGlwIHdpbGwgcmVuZGVyXG4gICAqL1xuICBfd2lsbFJlbmRlcigpIHtcbiAgICByZXR1cm4gISF0aGlzLm9wYWNpdHk7XG4gIH1cblxuICBkcmF3KGN0eCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgbGV0IG9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG5cbiAgICBpZiAoIW9wYWNpdHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVBbmltYXRpb25UYXJnZXQob3B0aW9ucyk7XG5cbiAgICBjb25zdCB0b29sdGlwU2l6ZSA9IHtcbiAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgIH07XG4gICAgY29uc3QgcHQgPSB7XG4gICAgICB4OiB0aGlzLngsXG4gICAgICB5OiB0aGlzLnlcbiAgICB9O1xuXG4gICAgLy8gSUUxMS9FZGdlIGRvZXMgbm90IGxpa2UgdmVyeSBzbWFsbCBvcGFjaXRpZXMsIHNvIHNuYXAgdG8gMFxuICAgIG9wYWNpdHkgPSBNYXRoLmFicyhvcGFjaXR5KSA8IDFlLTMgPyAwIDogb3BhY2l0eTtcblxuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcblxuICAgIC8vIFRydXRoeS9mYWxzZXkgdmFsdWUgZm9yIGVtcHR5IHRvb2x0aXBcbiAgICBjb25zdCBoYXNUb29sdGlwQ29udGVudCA9IHRoaXMudGl0bGUubGVuZ3RoIHx8IHRoaXMuYmVmb3JlQm9keS5sZW5ndGggfHwgdGhpcy5ib2R5Lmxlbmd0aCB8fCB0aGlzLmFmdGVyQm9keS5sZW5ndGggfHwgdGhpcy5mb290ZXIubGVuZ3RoO1xuXG4gICAgaWYgKG9wdGlvbnMuZW5hYmxlZCAmJiBoYXNUb29sdGlwQ29udGVudCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XG5cbiAgICAgIC8vIERyYXcgQmFja2dyb3VuZFxuICAgICAgdGhpcy5kcmF3QmFja2dyb3VuZChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG5cbiAgICAgIG92ZXJyaWRlVGV4dERpcmVjdGlvbihjdHgsIG9wdGlvbnMudGV4dERpcmVjdGlvbik7XG5cbiAgICAgIHB0LnkgKz0gcGFkZGluZy50b3A7XG5cbiAgICAgIC8vIFRpdGxlc1xuICAgICAgdGhpcy5kcmF3VGl0bGUocHQsIGN0eCwgb3B0aW9ucyk7XG5cbiAgICAgIC8vIEJvZHlcbiAgICAgIHRoaXMuZHJhd0JvZHkocHQsIGN0eCwgb3B0aW9ucyk7XG5cbiAgICAgIC8vIEZvb3RlclxuICAgICAgdGhpcy5kcmF3Rm9vdGVyKHB0LCBjdHgsIG9wdGlvbnMpO1xuXG4gICAgICByZXN0b3JlVGV4dERpcmVjdGlvbihjdHgsIG9wdGlvbnMudGV4dERpcmVjdGlvbik7XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEdldCBhY3RpdmUgZWxlbWVudHMgaW4gdGhlIHRvb2x0aXBcblx0ICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiBlbGVtZW50cyB0aGF0IGFyZSBhY3RpdmUgaW4gdGhlIHRvb2x0aXBcblx0ICovXG4gIGdldEFjdGl2ZUVsZW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmUgfHwgW107XG4gIH1cblxuICAvKipcblx0ICogU2V0IGFjdGl2ZSBlbGVtZW50cyBpbiB0aGUgdG9vbHRpcFxuXHQgKiBAcGFyYW0ge2FycmF5fSBhY3RpdmVFbGVtZW50cyBBcnJheSBvZiBhY3RpdmUgZGF0YXNldEluZGV4L2luZGV4IHBhaXJzLlxuXHQgKiBAcGFyYW0ge29iamVjdH0gZXZlbnRQb3NpdGlvbiBTeW50aGV0aWMgZXZlbnQgcG9zaXRpb24gdXNlZCBpbiBwb3NpdGlvbmluZ1xuXHQgKi9cbiAgc2V0QWN0aXZlRWxlbWVudHMoYWN0aXZlRWxlbWVudHMsIGV2ZW50UG9zaXRpb24pIHtcbiAgICBjb25zdCBsYXN0QWN0aXZlID0gdGhpcy5fYWN0aXZlO1xuICAgIGNvbnN0IGFjdGl2ZSA9IGFjdGl2ZUVsZW1lbnRzLm1hcCgoe2RhdGFzZXRJbmRleCwgaW5kZXh9KSA9PiB7XG4gICAgICBjb25zdCBtZXRhID0gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXG4gICAgICBpZiAoIW1ldGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBhIGRhdGFzZXQgYXQgaW5kZXggJyArIGRhdGFzZXRJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGFzZXRJbmRleCxcbiAgICAgICAgZWxlbWVudDogbWV0YS5kYXRhW2luZGV4XSxcbiAgICAgICAgaW5kZXgsXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IGNoYW5nZWQgPSAhX2VsZW1lbnRzRXF1YWwobGFzdEFjdGl2ZSwgYWN0aXZlKTtcbiAgICBjb25zdCBwb3NpdGlvbkNoYW5nZWQgPSB0aGlzLl9wb3NpdGlvbkNoYW5nZWQoYWN0aXZlLCBldmVudFBvc2l0aW9uKTtcblxuICAgIGlmIChjaGFuZ2VkIHx8IHBvc2l0aW9uQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gYWN0aXZlO1xuICAgICAgdGhpcy5fZXZlbnRQb3NpdGlvbiA9IGV2ZW50UG9zaXRpb247XG4gICAgICB0aGlzLl9pZ25vcmVSZXBsYXlFdmVudHMgPSB0cnVlO1xuICAgICAgdGhpcy51cGRhdGUodHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEhhbmRsZSBhbiBldmVudFxuXHQgKiBAcGFyYW0ge0NoYXJ0RXZlbnR9IGUgLSBUaGUgZXZlbnQgdG8gaGFuZGxlXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlcGxheV0gLSBUaGlzIGlzIGEgcmVwbGF5ZWQgZXZlbnQgKGZyb20gdXBkYXRlKVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbkNoYXJ0QXJlYV0gLSBUaGUgZXZlbnQgaXMgaW5zaWRlIGNoYXJ0QXJlYVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdG9vbHRpcCBjaGFuZ2VkXG5cdCAqL1xuICBoYW5kbGVFdmVudChlLCByZXBsYXksIGluQ2hhcnRBcmVhID0gdHJ1ZSkge1xuICAgIGlmIChyZXBsYXkgJiYgdGhpcy5faWdub3JlUmVwbGF5RXZlbnRzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX2lnbm9yZVJlcGxheUV2ZW50cyA9IGZhbHNlO1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBsYXN0QWN0aXZlID0gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2dldEFjdGl2ZUVsZW1lbnRzKGUsIGxhc3RBY3RpdmUsIHJlcGxheSwgaW5DaGFydEFyZWEpO1xuXG4gICAgLy8gV2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgaXRlbXMgc2hvd24sIGJ1dCB0aGUgdG9vbHRpcCBwb3NpdGlvbiBpcyBuZWFyZXN0IG1vZGVcbiAgICAvLyBhbiB1cGRhdGUgbWF5IG5lZWQgdG8gYmUgbWFkZSBiZWNhdXNlIG91ciBwb3NpdGlvbiBtYXkgaGF2ZSBjaGFuZ2VkIGV2ZW4gdGhvdWdoXG4gICAgLy8gdGhlIGl0ZW1zIGFyZSB0aGUgc2FtZSBhcyBiZWZvcmUuXG4gICAgY29uc3QgcG9zaXRpb25DaGFuZ2VkID0gdGhpcy5fcG9zaXRpb25DaGFuZ2VkKGFjdGl2ZSwgZSk7XG5cbiAgICAvLyBSZW1lbWJlciBMYXN0IEFjdGl2ZXNcbiAgICBjb25zdCBjaGFuZ2VkID0gcmVwbGF5IHx8ICFfZWxlbWVudHNFcXVhbChhY3RpdmUsIGxhc3RBY3RpdmUpIHx8IHBvc2l0aW9uQ2hhbmdlZDtcblxuICAgIC8vIE9ubHkgaGFuZGxlIHRhcmdldCBldmVudCBvbiB0b29sdGlwIGNoYW5nZVxuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG5cbiAgICAgIGlmIChvcHRpb25zLmVuYWJsZWQgfHwgb3B0aW9ucy5leHRlcm5hbCkge1xuICAgICAgICB0aGlzLl9ldmVudFBvc2l0aW9uID0ge1xuICAgICAgICAgIHg6IGUueCxcbiAgICAgICAgICB5OiBlLnlcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnVwZGF0ZSh0cnVlLCByZXBsYXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEhlbHBlciBmb3IgZGV0ZXJtaW5pbmcgdGhlIGFjdGl2ZSBlbGVtZW50cyBmb3IgZXZlbnRcblx0ICogQHBhcmFtIHtDaGFydEV2ZW50fSBlIC0gVGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKiBAcGFyYW0ge0ludGVyYWN0aW9uSXRlbVtdfSBsYXN0QWN0aXZlIC0gUHJldmlvdXNseSBhY3RpdmUgZWxlbWVudHNcblx0ICogQHBhcmFtIHtib29sZWFufSBbcmVwbGF5XSAtIFRoaXMgaXMgYSByZXBsYXllZCBldmVudCAoZnJvbSB1cGRhdGUpXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luQ2hhcnRBcmVhXSAtIFRoZSBldmVudCBpcyBpbnNpZGUgY2hhcnRBcmVhXG5cdCAqIEByZXR1cm5zIHtJbnRlcmFjdGlvbkl0ZW1bXX0gLSBBY3RpdmUgZWxlbWVudHNcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCByZXBsYXksIGluQ2hhcnRBcmVhKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBpZiAoIWluQ2hhcnRBcmVhKSB7XG4gICAgICAvLyBMZXQgdXNlciBjb250cm9sIHRoZSBhY3RpdmUgZWxlbWVudHMgb3V0c2lkZSBjaGFydEFyZWEuIEVnLiB1c2luZyBMZWdlbmQuXG4gICAgICAvLyBCdXQgbWFrZSBzdXJlIHRoYXQgYWN0aXZlIGVsZW1lbnRzIGFyZSBzdGlsbCB2YWxpZC5cbiAgICAgIHJldHVybiBsYXN0QWN0aXZlLmZpbHRlcihpID0+XG4gICAgICAgIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tpLmRhdGFzZXRJbmRleF0gJiZcbiAgICAgICAgdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YShpLmRhdGFzZXRJbmRleCkuY29udHJvbGxlci5nZXRQYXJzZWQoaS5pbmRleCkgIT09IHVuZGVmaW5lZFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIEFjdGl2ZSBFbGVtZW50cyBmb3IgdG9vbHRpcHNcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmNoYXJ0LmdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgb3B0aW9ucy5tb2RlLCBvcHRpb25zLCByZXBsYXkpO1xuXG4gICAgaWYgKG9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgYWN0aXZlLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWN0aXZlO1xuICB9XG5cbiAgLyoqXG5cdCAqIERldGVybWluZSBpZiB0aGUgYWN0aXZlIGVsZW1lbnRzICsgZXZlbnQgY29tYmluYXRpb24gY2hhbmdlcyB0aGVcblx0ICogdG9vbHRpcCBwb3NpdGlvblxuXHQgKiBAcGFyYW0ge2FycmF5fSBhY3RpdmUgLSBBY3RpdmUgZWxlbWVudHNcblx0ICogQHBhcmFtIHtDaGFydEV2ZW50fSBlIC0gRXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhlIHBvc2l0aW9uIGNoYW5nZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcG9zaXRpb24gaGFzIGNoYW5nZWRcblx0ICovXG4gIF9wb3NpdGlvbkNoYW5nZWQoYWN0aXZlLCBlKSB7XG4gICAgY29uc3Qge2NhcmV0WCwgY2FyZXRZLCBvcHRpb25zfSA9IHRoaXM7XG4gICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbmVyc1tvcHRpb25zLnBvc2l0aW9uXS5jYWxsKHRoaXMsIGFjdGl2ZSwgZSk7XG4gICAgcmV0dXJuIHBvc2l0aW9uICE9PSBmYWxzZSAmJiAoY2FyZXRYICE9PSBwb3NpdGlvbi54IHx8IGNhcmV0WSAhPT0gcG9zaXRpb24ueSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpZDogJ3Rvb2x0aXAnLFxuICBfZWxlbWVudDogVG9vbHRpcCxcbiAgcG9zaXRpb25lcnMsXG5cbiAgYWZ0ZXJJbml0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBjaGFydC50b29sdGlwID0gbmV3IFRvb2x0aXAoe2NoYXJ0LCBvcHRpb25zfSk7XG4gICAgfVxuICB9LFxuXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAoY2hhcnQudG9vbHRpcCkge1xuICAgICAgY2hhcnQudG9vbHRpcC5pbml0aWFsaXplKG9wdGlvbnMpO1xuICAgIH1cbiAgfSxcblxuICByZXNldChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAoY2hhcnQudG9vbHRpcCkge1xuICAgICAgY2hhcnQudG9vbHRpcC5pbml0aWFsaXplKG9wdGlvbnMpO1xuICAgIH1cbiAgfSxcblxuICBhZnRlckRyYXcoY2hhcnQpIHtcbiAgICBjb25zdCB0b29sdGlwID0gY2hhcnQudG9vbHRpcDtcblxuICAgIGlmICh0b29sdGlwICYmIHRvb2x0aXAuX3dpbGxSZW5kZXIoKSkge1xuICAgICAgY29uc3QgYXJncyA9IHtcbiAgICAgICAgdG9vbHRpcFxuICAgICAgfTtcblxuICAgICAgaWYgKGNoYXJ0Lm5vdGlmeVBsdWdpbnMoJ2JlZm9yZVRvb2x0aXBEcmF3Jywgey4uLmFyZ3MsIGNhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0b29sdGlwLmRyYXcoY2hhcnQuY3R4KTtcblxuICAgICAgY2hhcnQubm90aWZ5UGx1Z2lucygnYWZ0ZXJUb29sdGlwRHJhdycsIGFyZ3MpO1xuICAgIH1cbiAgfSxcblxuICBhZnRlckV2ZW50KGNoYXJ0LCBhcmdzKSB7XG4gICAgaWYgKGNoYXJ0LnRvb2x0aXApIHtcbiAgICAgIC8vIElmIHRoZSBldmVudCBpcyByZXBsYXllZCBmcm9tIGB1cGRhdGVgLCB3ZSBzaG91bGQgZXZhbHVhdGUgd2l0aCB0aGUgZmluYWwgcG9zaXRpb25zLlxuICAgICAgY29uc3QgdXNlRmluYWxQb3NpdGlvbiA9IGFyZ3MucmVwbGF5O1xuICAgICAgaWYgKGNoYXJ0LnRvb2x0aXAuaGFuZGxlRXZlbnQoYXJncy5ldmVudCwgdXNlRmluYWxQb3NpdGlvbiwgYXJncy5pbkNoYXJ0QXJlYSkpIHtcbiAgICAgICAgLy8gbm90aWZ5IGNoYXJ0IGFib3V0IHRoZSBjaGFuZ2UsIHNvIGl0IHdpbGwgcmVuZGVyXG4gICAgICAgIGFyZ3MuY2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGRlZmF1bHRzOiB7XG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBleHRlcm5hbDogbnVsbCxcbiAgICBwb3NpdGlvbjogJ2F2ZXJhZ2UnLFxuICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMC44KScsXG4gICAgdGl0bGVDb2xvcjogJyNmZmYnLFxuICAgIHRpdGxlRm9udDoge1xuICAgICAgd2VpZ2h0OiAnYm9sZCcsXG4gICAgfSxcbiAgICB0aXRsZVNwYWNpbmc6IDIsXG4gICAgdGl0bGVNYXJnaW5Cb3R0b206IDYsXG4gICAgdGl0bGVBbGlnbjogJ2xlZnQnLFxuICAgIGJvZHlDb2xvcjogJyNmZmYnLFxuICAgIGJvZHlTcGFjaW5nOiAyLFxuICAgIGJvZHlGb250OiB7XG4gICAgfSxcbiAgICBib2R5QWxpZ246ICdsZWZ0JyxcbiAgICBmb290ZXJDb2xvcjogJyNmZmYnLFxuICAgIGZvb3RlclNwYWNpbmc6IDIsXG4gICAgZm9vdGVyTWFyZ2luVG9wOiA2LFxuICAgIGZvb3RlckZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ2JvbGQnLFxuICAgIH0sXG4gICAgZm9vdGVyQWxpZ246ICdsZWZ0JyxcbiAgICBwYWRkaW5nOiA2LFxuICAgIGNhcmV0UGFkZGluZzogMixcbiAgICBjYXJldFNpemU6IDUsXG4gICAgY29ybmVyUmFkaXVzOiA2LFxuICAgIGJveEhlaWdodDogKGN0eCwgb3B0cykgPT4gb3B0cy5ib2R5Rm9udC5zaXplLFxuICAgIGJveFdpZHRoOiAoY3R4LCBvcHRzKSA9PiBvcHRzLmJvZHlGb250LnNpemUsXG4gICAgbXVsdGlLZXlCYWNrZ3JvdW5kOiAnI2ZmZicsXG4gICAgZGlzcGxheUNvbG9yczogdHJ1ZSxcbiAgICBib3hQYWRkaW5nOiAwLFxuICAgIGJvcmRlckNvbG9yOiAncmdiYSgwLDAsMCwwKScsXG4gICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBkdXJhdGlvbjogNDAwLFxuICAgICAgZWFzaW5nOiAnZWFzZU91dFF1YXJ0JyxcbiAgICB9LFxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ3dpZHRoJywgJ2hlaWdodCcsICdjYXJldFgnLCAnY2FyZXRZJ10sXG4gICAgICB9LFxuICAgICAgb3BhY2l0eToge1xuICAgICAgICBlYXNpbmc6ICdsaW5lYXInLFxuICAgICAgICBkdXJhdGlvbjogMjAwXG4gICAgICB9XG4gICAgfSxcbiAgICBjYWxsYmFja3M6IGRlZmF1bHRDYWxsYmFja3NcbiAgfSxcblxuICBkZWZhdWx0Um91dGVzOiB7XG4gICAgYm9keUZvbnQ6ICdmb250JyxcbiAgICBmb290ZXJGb250OiAnZm9udCcsXG4gICAgdGl0bGVGb250OiAnZm9udCdcbiAgfSxcblxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2ZpbHRlcicgJiYgbmFtZSAhPT0gJ2l0ZW1Tb3J0JyAmJiBuYW1lICE9PSAnZXh0ZXJuYWwnLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICAgIGNhbGxiYWNrczoge1xuICAgICAgX3NjcmlwdGFibGU6IGZhbHNlLFxuICAgICAgX2luZGV4YWJsZTogZmFsc2UsXG4gICAgfSxcbiAgICBhbmltYXRpb246IHtcbiAgICAgIF9mYWxsYmFjazogZmFsc2VcbiAgICB9LFxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIF9mYWxsYmFjazogJ2FuaW1hdGlvbidcbiAgICB9XG4gIH0sXG5cbiAgLy8gUmVzb2x2ZSBhZGRpdGlvbmFsbHkgZnJvbSBgaW50ZXJhY3Rpb25gIG9wdGlvbnMgYW5kIGRlZmF1bHRzLlxuICBhZGRpdGlvbmFsT3B0aW9uU2NvcGVzOiBbJ2ludGVyYWN0aW9uJ11cbn07XG4iLCAiaW1wb3J0IFNjYWxlIGZyb20gJy4uL2NvcmUvY29yZS5zY2FsZS5qcyc7XG5pbXBvcnQge2lzTnVsbE9yVW5kZWYsIHZhbHVlT3JEZWZhdWx0LCBfbGltaXRWYWx1ZX0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbmNvbnN0IGFkZElmU3RyaW5nID0gKGxhYmVscywgcmF3LCBpbmRleCwgYWRkZWRMYWJlbHMpID0+IHtcbiAgaWYgKHR5cGVvZiByYXcgPT09ICdzdHJpbmcnKSB7XG4gICAgaW5kZXggPSBsYWJlbHMucHVzaChyYXcpIC0gMTtcbiAgICBhZGRlZExhYmVscy51bnNoaWZ0KHtpbmRleCwgbGFiZWw6IHJhd30pO1xuICB9IGVsc2UgaWYgKGlzTmFOKHJhdykpIHtcbiAgICBpbmRleCA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIGluZGV4O1xufTtcblxuZnVuY3Rpb24gZmluZE9yQWRkTGFiZWwobGFiZWxzLCByYXcsIGluZGV4LCBhZGRlZExhYmVscykge1xuICBjb25zdCBmaXJzdCA9IGxhYmVscy5pbmRleE9mKHJhdyk7XG4gIGlmIChmaXJzdCA9PT0gLTEpIHtcbiAgICByZXR1cm4gYWRkSWZTdHJpbmcobGFiZWxzLCByYXcsIGluZGV4LCBhZGRlZExhYmVscyk7XG4gIH1cbiAgY29uc3QgbGFzdCA9IGxhYmVscy5sYXN0SW5kZXhPZihyYXcpO1xuICByZXR1cm4gZmlyc3QgIT09IGxhc3QgPyBpbmRleCA6IGZpcnN0O1xufVxuXG5jb25zdCB2YWxpZEluZGV4ID0gKGluZGV4LCBtYXgpID0+IGluZGV4ID09PSBudWxsID8gbnVsbCA6IF9saW1pdFZhbHVlKE1hdGgucm91bmQoaW5kZXgpLCAwLCBtYXgpO1xuXG5mdW5jdGlvbiBfZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuXG4gIGlmICh2YWx1ZSA+PSAwICYmIHZhbHVlIDwgbGFiZWxzLmxlbmd0aCkge1xuICAgIHJldHVybiBsYWJlbHNbdmFsdWVdO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2F0ZWdvcnlTY2FsZSBleHRlbmRzIFNjYWxlIHtcblxuICBzdGF0aWMgaWQgPSAnY2F0ZWdvcnknO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIHRpY2tzOiB7XG4gICAgICBjYWxsYmFjazogX2dldExhYmVsRm9yVmFsdWVcbiAgICB9XG4gIH07XG5cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoY2ZnKTtcblxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IDA7XG4gICAgdGhpcy5fYWRkZWRMYWJlbHMgPSBbXTtcbiAgfVxuXG4gIGluaXQoc2NhbGVPcHRpb25zKSB7XG4gICAgY29uc3QgYWRkZWQgPSB0aGlzLl9hZGRlZExhYmVscztcbiAgICBpZiAoYWRkZWQubGVuZ3RoKSB7XG4gICAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgICAgZm9yIChjb25zdCB7aW5kZXgsIGxhYmVsfSBvZiBhZGRlZCkge1xuICAgICAgICBpZiAobGFiZWxzW2luZGV4XSA9PT0gbGFiZWwpIHtcbiAgICAgICAgICBsYWJlbHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fYWRkZWRMYWJlbHMgPSBbXTtcbiAgICB9XG4gICAgc3VwZXIuaW5pdChzY2FsZU9wdGlvbnMpO1xuICB9XG5cbiAgcGFyc2UocmF3LCBpbmRleCkge1xuICAgIGlmIChpc051bGxPclVuZGVmKHJhdykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgIGluZGV4ID0gaXNGaW5pdGUoaW5kZXgpICYmIGxhYmVsc1tpbmRleF0gPT09IHJhdyA/IGluZGV4XG4gICAgICA6IGZpbmRPckFkZExhYmVsKGxhYmVscywgcmF3LCB2YWx1ZU9yRGVmYXVsdChpbmRleCwgcmF3KSwgdGhpcy5fYWRkZWRMYWJlbHMpO1xuICAgIHJldHVybiB2YWxpZEluZGV4KGluZGV4LCBsYWJlbHMubGVuZ3RoIC0gMSk7XG4gIH1cblxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHttaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGxldCB7bWluLCBtYXh9ID0gdGhpcy5nZXRNaW5NYXgodHJ1ZSk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmJvdW5kcyA9PT0gJ3RpY2tzJykge1xuICAgICAgaWYgKCFtaW5EZWZpbmVkKSB7XG4gICAgICAgIG1pbiA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoIW1heERlZmluZWQpIHtcbiAgICAgICAgbWF4ID0gdGhpcy5nZXRMYWJlbHMoKS5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubWluID0gbWluO1xuICAgIHRoaXMubWF4ID0gbWF4O1xuICB9XG5cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCBtaW4gPSB0aGlzLm1pbjtcbiAgICBjb25zdCBtYXggPSB0aGlzLm1heDtcbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9wdGlvbnMub2Zmc2V0O1xuICAgIGNvbnN0IHRpY2tzID0gW107XG4gICAgbGV0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG5cbiAgICAvLyBJZiB3ZSBhcmUgdmlld2luZyBzb21lIHN1YnNldCBvZiBsYWJlbHMsIHNsaWNlIHRoZSBvcmlnaW5hbCBhcnJheVxuICAgIGxhYmVscyA9IChtaW4gPT09IDAgJiYgbWF4ID09PSBsYWJlbHMubGVuZ3RoIC0gMSkgPyBsYWJlbHMgOiBsYWJlbHMuc2xpY2UobWluLCBtYXggKyAxKTtcblxuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSBNYXRoLm1heChsYWJlbHMubGVuZ3RoIC0gKG9mZnNldCA/IDAgOiAxKSwgMSk7XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHRoaXMubWluIC0gKG9mZnNldCA/IDAuNSA6IDApO1xuXG4gICAgZm9yIChsZXQgdmFsdWUgPSBtaW47IHZhbHVlIDw9IG1heDsgdmFsdWUrKykge1xuICAgICAgdGlja3MucHVzaCh7dmFsdWV9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG5cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiBfZ2V0TGFiZWxGb3JWYWx1ZS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBjb25maWd1cmUoKSB7XG4gICAgc3VwZXIuY29uZmlndXJlKCk7XG5cbiAgICBpZiAoIXRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIC8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB2ZXJ0aWNhbCBjYXRlZ29yeSBzY2FsZSByZXZlcnNlIGlzIGludmVydGVkLlxuICAgICAgdGhpcy5fcmV2ZXJzZVBpeGVscyA9ICF0aGlzLl9yZXZlcnNlUGl4ZWxzO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVzZWQgdG8gZ2V0IGRhdGEgdmFsdWUgbG9jYXRpb25zLiBWYWx1ZSBjYW4gZWl0aGVyIGJlIGFuIGluZGV4IG9yIGEgbnVtZXJpY2FsIHZhbHVlXG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBOYU4gOiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCgodmFsdWUgLSB0aGlzLl9zdGFydFZhbHVlKSAvIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG5cbiAgLy8gTXVzdCBvdmVycmlkZSBiYXNlIGltcGxlbWVudGF0aW9uIGJlY2F1c2UgaXQgY2FsbHMgZ2V0UGl4ZWxGb3JWYWx1ZVxuICAvLyBhbmQgY2F0ZWdvcnkgc2NhbGUgY2FuIGhhdmUgZHVwbGljYXRlIHZhbHVlc1xuICBnZXRQaXhlbEZvclRpY2soaW5kZXgpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRpY2tzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRpY2tzW2luZGV4XS52YWx1ZSk7XG4gIH1cblxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodGhpcy5fc3RhcnRWYWx1ZSArIHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAqIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG5cbiAgZ2V0QmFzZVBpeGVsKCkge1xuICAgIHJldHVybiB0aGlzLmJvdHRvbTtcbiAgfVxufVxuIiwgImltcG9ydCB7aXNOdWxsT3JVbmRlZn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHthbG1vc3RFcXVhbHMsIGFsbW9zdFdob2xlLCBuaWNlTnVtLCBfZGVjaW1hbFBsYWNlcywgX3NldE1pbkFuZE1heEJ5S2V5LCBzaWduLCB0b1JhZGlhbnN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCBTY2FsZSBmcm9tICcuLi9jb3JlL2NvcmUuc2NhbGUuanMnO1xuaW1wb3J0IHtmb3JtYXROdW1iZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5pbnRsLmpzJztcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHNldCBvZiBsaW5lYXIgdGlja3MgZm9yIGFuIGF4aXNcbiAqIDEuIElmIGdlbmVyYXRpb25PcHRpb25zLm1pbiwgZ2VuZXJhdGlvbk9wdGlvbnMubWF4LCBhbmQgZ2VuZXJhdGlvbk9wdGlvbnMuc3RlcCBhcmUgZGVmaW5lZDpcbiAqICAgIGlmIChtYXggLSBtaW4pIC8gc3RlcCBpcyBhbiBpbnRlZ2VyLCB0aWNrcyBhcmUgZ2VuZXJhdGVkIGFzIFttaW4sIG1pbiArIHN0ZXAsIC4uLiwgbWF4XVxuICogICAgTm90ZSB0aGF0IHRoZSBnZW5lcmF0aW9uT3B0aW9ucy5tYXhDb3VudCBzZXR0aW5nIGlzIHJlc3BlY3RlZCBpbiB0aGlzIHNjZW5hcmlvXG4gKlxuICogMi4gSWYgZ2VuZXJhdGlvbk9wdGlvbnMubWluLCBnZW5lcmF0aW9uT3B0aW9ucy5tYXgsIGFuZCBnZW5lcmF0aW9uT3B0aW9ucy5jb3VudCBpcyBkZWZpbmVkXG4gKiAgICBzcGFjaW5nID0gKG1heCAtIG1pbikgLyBjb3VudFxuICogICAgVGlja3MgYXJlIGdlbmVyYXRlZCBhcyBbbWluLCBtaW4gKyBzcGFjaW5nLCAuLi4sIG1heF1cbiAqXG4gKiAzLiBJZiBnZW5lcmF0aW9uT3B0aW9ucy5jb3VudCBpcyBkZWZpbmVkXG4gKiAgICBzcGFjaW5nID0gKG5pY2VNYXggLSBuaWNlTWluKSAvIGNvdW50XG4gKlxuICogNC4gQ29tcHV0ZSBvcHRpbWFsIHNwYWNpbmcgb2YgdGlja3MgdXNpbmcgbmljZU51bSBhbGdvcml0aG1cbiAqXG4gKiBAcGFyYW0gZ2VuZXJhdGlvbk9wdGlvbnMgdGhlIG9wdGlvbnMgdXNlZCB0byBnZW5lcmF0ZSB0aGUgdGlja3NcbiAqIEBwYXJhbSBkYXRhUmFuZ2UgdGhlIHJhbmdlIG9mIHRoZSBkYXRhXG4gKiBAcmV0dXJucyB7b2JqZWN0W119IGFycmF5IG9mIHRpY2sgb2JqZWN0c1xuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVRpY2tzKGdlbmVyYXRpb25PcHRpb25zLCBkYXRhUmFuZ2UpIHtcbiAgY29uc3QgdGlja3MgPSBbXTtcbiAgLy8gVG8gZ2V0IGEgXCJuaWNlXCIgdmFsdWUgZm9yIHRoZSB0aWNrIHNwYWNpbmcsIHdlIHdpbGwgdXNlIHRoZSBhcHByb3ByaWF0ZWx5IG5hbWVkXG4gIC8vIFwibmljZSBudW1iZXJcIiBhbGdvcml0aG0uIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84NTA2ODgxL25pY2UtbGFiZWwtYWxnb3JpdGhtLWZvci1jaGFydHMtd2l0aC1taW5pbXVtLXRpY2tzXG4gIC8vIGZvciBkZXRhaWxzLlxuXG4gIGNvbnN0IE1JTl9TUEFDSU5HID0gMWUtMTQ7XG4gIGNvbnN0IHtib3VuZHMsIHN0ZXAsIG1pbiwgbWF4LCBwcmVjaXNpb24sIGNvdW50LCBtYXhUaWNrcywgbWF4RGlnaXRzLCBpbmNsdWRlQm91bmRzfSA9IGdlbmVyYXRpb25PcHRpb25zO1xuICBjb25zdCB1bml0ID0gc3RlcCB8fCAxO1xuICBjb25zdCBtYXhTcGFjZXMgPSBtYXhUaWNrcyAtIDE7XG4gIGNvbnN0IHttaW46IHJtaW4sIG1heDogcm1heH0gPSBkYXRhUmFuZ2U7XG4gIGNvbnN0IG1pbkRlZmluZWQgPSAhaXNOdWxsT3JVbmRlZihtaW4pO1xuICBjb25zdCBtYXhEZWZpbmVkID0gIWlzTnVsbE9yVW5kZWYobWF4KTtcbiAgY29uc3QgY291bnREZWZpbmVkID0gIWlzTnVsbE9yVW5kZWYoY291bnQpO1xuICBjb25zdCBtaW5TcGFjaW5nID0gKHJtYXggLSBybWluKSAvIChtYXhEaWdpdHMgKyAxKTtcbiAgbGV0IHNwYWNpbmcgPSBuaWNlTnVtKChybWF4IC0gcm1pbikgLyBtYXhTcGFjZXMgLyB1bml0KSAqIHVuaXQ7XG4gIGxldCBmYWN0b3IsIG5pY2VNaW4sIG5pY2VNYXgsIG51bVNwYWNlcztcblxuICAvLyBCZXlvbmQgTUlOX1NQQUNJTkcgZmxvYXRpbmcgcG9pbnQgbnVtYmVycyBiZWluZyB0byBsb3NlIHByZWNpc2lvblxuICAvLyBzdWNoIHRoYXQgd2UgY2FuJ3QgZG8gdGhlIG1hdGggbmVjZXNzYXJ5IHRvIGdlbmVyYXRlIHRpY2tzXG4gIGlmIChzcGFjaW5nIDwgTUlOX1NQQUNJTkcgJiYgIW1pbkRlZmluZWQgJiYgIW1heERlZmluZWQpIHtcbiAgICByZXR1cm4gW3t2YWx1ZTogcm1pbn0sIHt2YWx1ZTogcm1heH1dO1xuICB9XG5cbiAgbnVtU3BhY2VzID0gTWF0aC5jZWlsKHJtYXggLyBzcGFjaW5nKSAtIE1hdGguZmxvb3Iocm1pbiAvIHNwYWNpbmcpO1xuICBpZiAobnVtU3BhY2VzID4gbWF4U3BhY2VzKSB7XG4gICAgLy8gSWYgdGhlIGNhbGN1bGF0ZWQgbnVtIG9mIHNwYWNlcyBleGNlZWRzIG1heE51bVNwYWNlcywgcmVjYWxjdWxhdGUgaXRcbiAgICBzcGFjaW5nID0gbmljZU51bShudW1TcGFjZXMgKiBzcGFjaW5nIC8gbWF4U3BhY2VzIC8gdW5pdCkgKiB1bml0O1xuICB9XG5cbiAgaWYgKCFpc051bGxPclVuZGVmKHByZWNpc2lvbikpIHtcbiAgICAvLyBJZiB0aGUgdXNlciBzcGVjaWZpZWQgYSBwcmVjaXNpb24sIHJvdW5kIHRvIHRoYXQgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzXG4gICAgZmFjdG9yID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbik7XG4gICAgc3BhY2luZyA9IE1hdGguY2VpbChzcGFjaW5nICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgfVxuXG4gIGlmIChib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICBuaWNlTWluID0gTWF0aC5mbG9vcihybWluIC8gc3BhY2luZykgKiBzcGFjaW5nO1xuICAgIG5pY2VNYXggPSBNYXRoLmNlaWwocm1heCAvIHNwYWNpbmcpICogc3BhY2luZztcbiAgfSBlbHNlIHtcbiAgICBuaWNlTWluID0gcm1pbjtcbiAgICBuaWNlTWF4ID0gcm1heDtcbiAgfVxuXG4gIGlmIChtaW5EZWZpbmVkICYmIG1heERlZmluZWQgJiYgc3RlcCAmJiBhbG1vc3RXaG9sZSgobWF4IC0gbWluKSAvIHN0ZXAsIHNwYWNpbmcgLyAxMDAwKSkge1xuICAgIC8vIENhc2UgMTogSWYgbWluLCBtYXggYW5kIHN0ZXBTaXplIGFyZSBzZXQgYW5kIHRoZXkgbWFrZSBhbiBldmVubHkgc3BhY2VkIHNjYWxlIHVzZSBpdC5cbiAgICAvLyBzcGFjaW5nID0gc3RlcDtcbiAgICAvLyBudW1TcGFjZXMgPSAobWF4IC0gbWluKSAvIHNwYWNpbmc7XG4gICAgLy8gTm90ZSB0aGF0IHdlIHJvdW5kIGhlcmUgdG8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIGFsbW9zdFdob2xlIHRyYW5zbGF0ZWQgYW4gRlAgZXJyb3JcbiAgICBudW1TcGFjZXMgPSBNYXRoLnJvdW5kKE1hdGgubWluKChtYXggLSBtaW4pIC8gc3BhY2luZywgbWF4VGlja3MpKTtcbiAgICBzcGFjaW5nID0gKG1heCAtIG1pbikgLyBudW1TcGFjZXM7XG4gICAgbmljZU1pbiA9IG1pbjtcbiAgICBuaWNlTWF4ID0gbWF4O1xuICB9IGVsc2UgaWYgKGNvdW50RGVmaW5lZCkge1xuICAgIC8vIENhc2VzIDIgJiAzLCB3ZSBoYXZlIGEgY291bnQgc3BlY2lmaWVkLiBIYW5kbGUgb3B0aW9uYWwgdXNlciBkZWZpbmVkIGVkZ2VzIHRvIHRoZSByYW5nZS5cbiAgICAvLyBTb21ldGltZXMgdGhlc2UgYXJlIG5vLW9wcywgYnV0IGl0IG1ha2VzIHRoZSBjb2RlIGEgbG90IGNsZWFyZXJcbiAgICAvLyBhbmQgd2hlbiBhIHVzZXIgZGVmaW5lZCByYW5nZSBpcyBzcGVjaWZpZWQsIHdlIHdhbnQgdGhlIGNvcnJlY3QgdGlja3NcbiAgICBuaWNlTWluID0gbWluRGVmaW5lZCA/IG1pbiA6IG5pY2VNaW47XG4gICAgbmljZU1heCA9IG1heERlZmluZWQgPyBtYXggOiBuaWNlTWF4O1xuICAgIG51bVNwYWNlcyA9IGNvdW50IC0gMTtcbiAgICBzcGFjaW5nID0gKG5pY2VNYXggLSBuaWNlTWluKSAvIG51bVNwYWNlcztcbiAgfSBlbHNlIHtcbiAgICAvLyBDYXNlIDRcbiAgICBudW1TcGFjZXMgPSAobmljZU1heCAtIG5pY2VNaW4pIC8gc3BhY2luZztcblxuICAgIC8vIElmIHZlcnkgY2xvc2UgdG8gb3VyIHJvdW5kZWQgdmFsdWUsIHVzZSBpdC5cbiAgICBpZiAoYWxtb3N0RXF1YWxzKG51bVNwYWNlcywgTWF0aC5yb3VuZChudW1TcGFjZXMpLCBzcGFjaW5nIC8gMTAwMCkpIHtcbiAgICAgIG51bVNwYWNlcyA9IE1hdGgucm91bmQobnVtU3BhY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbnVtU3BhY2VzID0gTWF0aC5jZWlsKG51bVNwYWNlcyk7XG4gICAgfVxuICB9XG5cbiAgLy8gVGhlIHNwYWNpbmcgd2lsbCBoYXZlIGNoYW5nZWQgaW4gY2FzZXMgMSwgMiwgYW5kIDMgc28gdGhlIGZhY3RvciBjYW5ub3QgYmUgY29tcHV0ZWRcbiAgLy8gdW50aWwgdGhpcyBwb2ludFxuICBjb25zdCBkZWNpbWFsUGxhY2VzID0gTWF0aC5tYXgoXG4gICAgX2RlY2ltYWxQbGFjZXMoc3BhY2luZyksXG4gICAgX2RlY2ltYWxQbGFjZXMobmljZU1pbilcbiAgKTtcbiAgZmFjdG9yID0gTWF0aC5wb3coMTAsIGlzTnVsbE9yVW5kZWYocHJlY2lzaW9uKSA/IGRlY2ltYWxQbGFjZXMgOiBwcmVjaXNpb24pO1xuICBuaWNlTWluID0gTWF0aC5yb3VuZChuaWNlTWluICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgbmljZU1heCA9IE1hdGgucm91bmQobmljZU1heCAqIGZhY3RvcikgLyBmYWN0b3I7XG5cbiAgbGV0IGogPSAwO1xuICBpZiAobWluRGVmaW5lZCkge1xuICAgIGlmIChpbmNsdWRlQm91bmRzICYmIG5pY2VNaW4gIT09IG1pbikge1xuICAgICAgdGlja3MucHVzaCh7dmFsdWU6IG1pbn0pO1xuXG4gICAgICBpZiAobmljZU1pbiA8IG1pbikge1xuICAgICAgICBqKys7IC8vIFNraXAgbmljZU1pblxuICAgICAgfVxuICAgICAgLy8gSWYgdGhlIG5leHQgbmljZSB0aWNrIGlzIGNsb3NlIHRvIG1pbiwgc2tpcCBpdFxuICAgICAgaWYgKGFsbW9zdEVxdWFscyhNYXRoLnJvdW5kKChuaWNlTWluICsgaiAqIHNwYWNpbmcpICogZmFjdG9yKSAvIGZhY3RvciwgbWluLCByZWxhdGl2ZUxhYmVsU2l6ZShtaW4sIG1pblNwYWNpbmcsIGdlbmVyYXRpb25PcHRpb25zKSkpIHtcbiAgICAgICAgaisrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmljZU1pbiA8IG1pbikge1xuICAgICAgaisrO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBqIDwgbnVtU3BhY2VzOyArK2opIHtcbiAgICBjb25zdCB0aWNrVmFsdWUgPSBNYXRoLnJvdW5kKChuaWNlTWluICsgaiAqIHNwYWNpbmcpICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgICBpZiAobWF4RGVmaW5lZCAmJiB0aWNrVmFsdWUgPiBtYXgpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aWNrcy5wdXNoKHt2YWx1ZTogdGlja1ZhbHVlfSk7XG4gIH1cblxuICBpZiAobWF4RGVmaW5lZCAmJiBpbmNsdWRlQm91bmRzICYmIG5pY2VNYXggIT09IG1heCkge1xuICAgIC8vIElmIHRoZSBwcmV2aW91cyB0aWNrIGlzIHRvbyBjbG9zZSB0byBtYXgsIHJlcGxhY2UgaXQgd2l0aCBtYXgsIGVsc2UgYWRkIG1heFxuICAgIGlmICh0aWNrcy5sZW5ndGggJiYgYWxtb3N0RXF1YWxzKHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlLCBtYXgsIHJlbGF0aXZlTGFiZWxTaXplKG1heCwgbWluU3BhY2luZywgZ2VuZXJhdGlvbk9wdGlvbnMpKSkge1xuICAgICAgdGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWUgPSBtYXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBtYXh9KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIW1heERlZmluZWQgfHwgbmljZU1heCA9PT0gbWF4KSB7XG4gICAgdGlja3MucHVzaCh7dmFsdWU6IG5pY2VNYXh9KTtcbiAgfVxuXG4gIHJldHVybiB0aWNrcztcbn1cblxuZnVuY3Rpb24gcmVsYXRpdmVMYWJlbFNpemUodmFsdWUsIG1pblNwYWNpbmcsIHtob3Jpem9udGFsLCBtaW5Sb3RhdGlvbn0pIHtcbiAgY29uc3QgcmFkID0gdG9SYWRpYW5zKG1pblJvdGF0aW9uKTtcbiAgY29uc3QgcmF0aW8gPSAoaG9yaXpvbnRhbCA/IE1hdGguc2luKHJhZCkgOiBNYXRoLmNvcyhyYWQpKSB8fCAwLjAwMTtcbiAgY29uc3QgbGVuZ3RoID0gMC43NSAqIG1pblNwYWNpbmcgKiAoJycgKyB2YWx1ZSkubGVuZ3RoO1xuICByZXR1cm4gTWF0aC5taW4obWluU3BhY2luZyAvIHJhdGlvLCBsZW5ndGgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5lYXJTY2FsZUJhc2UgZXh0ZW5kcyBTY2FsZSB7XG5cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoY2ZnKTtcblxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuc3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5lbmQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLl9lbmRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gMDtcbiAgfVxuXG4gIHBhcnNlKHJhdywgaW5kZXgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIGlmIChpc051bGxPclVuZGVmKHJhdykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoKHR5cGVvZiByYXcgPT09ICdudW1iZXInIHx8IHJhdyBpbnN0YW5jZW9mIE51bWJlcikgJiYgIWlzRmluaXRlKCtyYXcpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gK3JhdztcbiAgfVxuXG4gIGhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKSB7XG4gICAgY29uc3Qge2JlZ2luQXRaZXJvfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7bWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBsZXQge21pbiwgbWF4fSA9IHRoaXM7XG5cbiAgICBjb25zdCBzZXRNaW4gPSB2ID0+IChtaW4gPSBtaW5EZWZpbmVkID8gbWluIDogdik7XG4gICAgY29uc3Qgc2V0TWF4ID0gdiA9PiAobWF4ID0gbWF4RGVmaW5lZCA/IG1heCA6IHYpO1xuXG4gICAgaWYgKGJlZ2luQXRaZXJvKSB7XG4gICAgICBjb25zdCBtaW5TaWduID0gc2lnbihtaW4pO1xuICAgICAgY29uc3QgbWF4U2lnbiA9IHNpZ24obWF4KTtcblxuICAgICAgaWYgKG1pblNpZ24gPCAwICYmIG1heFNpZ24gPCAwKSB7XG4gICAgICAgIHNldE1heCgwKTtcbiAgICAgIH0gZWxzZSBpZiAobWluU2lnbiA+IDAgJiYgbWF4U2lnbiA+IDApIHtcbiAgICAgICAgc2V0TWluKDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtaW4gPT09IG1heCkge1xuICAgICAgbGV0IG9mZnNldCA9IG1heCA9PT0gMCA/IDEgOiBNYXRoLmFicyhtYXggKiAwLjA1KTtcblxuICAgICAgc2V0TWF4KG1heCArIG9mZnNldCk7XG5cbiAgICAgIGlmICghYmVnaW5BdFplcm8pIHtcbiAgICAgICAgc2V0TWluKG1pbiAtIG9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubWluID0gbWluO1xuICAgIHRoaXMubWF4ID0gbWF4O1xuICB9XG5cbiAgZ2V0VGlja0xpbWl0KCkge1xuICAgIGNvbnN0IHRpY2tPcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICBsZXQge21heFRpY2tzTGltaXQsIHN0ZXBTaXplfSA9IHRpY2tPcHRzO1xuICAgIGxldCBtYXhUaWNrcztcblxuICAgIGlmIChzdGVwU2l6ZSkge1xuICAgICAgbWF4VGlja3MgPSBNYXRoLmNlaWwodGhpcy5tYXggLyBzdGVwU2l6ZSkgLSBNYXRoLmZsb29yKHRoaXMubWluIC8gc3RlcFNpemUpICsgMTtcbiAgICAgIGlmIChtYXhUaWNrcyA+IDEwMDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBzY2FsZXMuJHt0aGlzLmlkfS50aWNrcy5zdGVwU2l6ZTogJHtzdGVwU2l6ZX0gd291bGQgcmVzdWx0IGdlbmVyYXRpbmcgdXAgdG8gJHttYXhUaWNrc30gdGlja3MuIExpbWl0aW5nIHRvIDEwMDAuYCk7XG4gICAgICAgIG1heFRpY2tzID0gMTAwMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4VGlja3MgPSB0aGlzLmNvbXB1dGVUaWNrTGltaXQoKTtcbiAgICAgIG1heFRpY2tzTGltaXQgPSBtYXhUaWNrc0xpbWl0IHx8IDExO1xuICAgIH1cblxuICAgIGlmIChtYXhUaWNrc0xpbWl0KSB7XG4gICAgICBtYXhUaWNrcyA9IE1hdGgubWluKG1heFRpY2tzTGltaXQsIG1heFRpY2tzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWF4VGlja3M7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgY29tcHV0ZVRpY2tMaW1pdCgpIHtcbiAgICByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICB9XG5cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0cy50aWNrcztcblxuICAgIC8vIEZpZ3VyZSBvdXQgd2hhdCB0aGUgbWF4IG51bWJlciBvZiB0aWNrcyB3ZSBjYW4gc3VwcG9ydCBpdCBpcyBiYXNlZCBvbiB0aGUgc2l6ZSBvZlxuICAgIC8vIHRoZSBheGlzIGFyZWEuIEZvciBub3csIHdlIHNheSB0aGF0IHRoZSBtaW5pbXVtIHRpY2sgc3BhY2luZyBpbiBwaXhlbHMgbXVzdCBiZSA0MFxuICAgIC8vIFdlIGFsc28gbGltaXQgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpY2tzIHRvIDExIHdoaWNoIGdpdmVzIGEgbmljZSAxMCBzcXVhcmVzIG9uXG4gICAgLy8gdGhlIGdyYXBoLiBNYWtlIHN1cmUgd2UgYWx3YXlzIGhhdmUgYXQgbGVhc3QgMiB0aWNrc1xuICAgIGxldCBtYXhUaWNrcyA9IHRoaXMuZ2V0VGlja0xpbWl0KCk7XG4gICAgbWF4VGlja3MgPSBNYXRoLm1heCgyLCBtYXhUaWNrcyk7XG5cbiAgICBjb25zdCBudW1lcmljR2VuZXJhdG9yT3B0aW9ucyA9IHtcbiAgICAgIG1heFRpY2tzLFxuICAgICAgYm91bmRzOiBvcHRzLmJvdW5kcyxcbiAgICAgIG1pbjogb3B0cy5taW4sXG4gICAgICBtYXg6IG9wdHMubWF4LFxuICAgICAgcHJlY2lzaW9uOiB0aWNrT3B0cy5wcmVjaXNpb24sXG4gICAgICBzdGVwOiB0aWNrT3B0cy5zdGVwU2l6ZSxcbiAgICAgIGNvdW50OiB0aWNrT3B0cy5jb3VudCxcbiAgICAgIG1heERpZ2l0czogdGhpcy5fbWF4RGlnaXRzKCksXG4gICAgICBob3Jpem9udGFsOiB0aGlzLmlzSG9yaXpvbnRhbCgpLFxuICAgICAgbWluUm90YXRpb246IHRpY2tPcHRzLm1pblJvdGF0aW9uIHx8IDAsXG4gICAgICBpbmNsdWRlQm91bmRzOiB0aWNrT3B0cy5pbmNsdWRlQm91bmRzICE9PSBmYWxzZVxuICAgIH07XG4gICAgY29uc3QgZGF0YVJhbmdlID0gdGhpcy5fcmFuZ2UgfHwgdGhpcztcbiAgICBjb25zdCB0aWNrcyA9IGdlbmVyYXRlVGlja3MobnVtZXJpY0dlbmVyYXRvck9wdGlvbnMsIGRhdGFSYW5nZSk7XG5cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBuZWVkIHRvIHVwZGF0ZSBvdXIgbWF4IGFuZCBtaW4gZ2l2ZW4gdGhlIHRpY2sgdmFsdWVzLFxuICAgIC8vIHNpbmNlIHdlIHByb2JhYmx5IGhhdmUgZXhwYW5kZWQgdGhlIHJhbmdlIG9mIHRoZSBzY2FsZVxuICAgIGlmIChvcHRzLmJvdW5kcyA9PT0gJ3RpY2tzJykge1xuICAgICAgX3NldE1pbkFuZE1heEJ5S2V5KHRpY2tzLCB0aGlzLCAndmFsdWUnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5yZXZlcnNlKSB7XG4gICAgICB0aWNrcy5yZXZlcnNlKCk7XG5cbiAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm1heDtcbiAgICAgIHRoaXMuZW5kID0gdGhpcy5taW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm1pbjtcbiAgICAgIHRoaXMuZW5kID0gdGhpcy5tYXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgbGV0IHN0YXJ0ID0gdGhpcy5taW47XG4gICAgbGV0IGVuZCA9IHRoaXMubWF4O1xuXG4gICAgc3VwZXIuY29uZmlndXJlKCk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm9mZnNldCAmJiB0aWNrcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IChlbmQgLSBzdGFydCkgLyBNYXRoLm1heCh0aWNrcy5sZW5ndGggLSAxLCAxKSAvIDI7XG4gICAgICBzdGFydCAtPSBvZmZzZXQ7XG4gICAgICBlbmQgKz0gb2Zmc2V0O1xuICAgIH1cbiAgICB0aGlzLl9zdGFydFZhbHVlID0gc3RhcnQ7XG4gICAgdGhpcy5fZW5kVmFsdWUgPSBlbmQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IGVuZCAtIHN0YXJ0O1xuICB9XG5cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiBmb3JtYXROdW1iZXIodmFsdWUsIHRoaXMuY2hhcnQub3B0aW9ucy5sb2NhbGUsIHRoaXMub3B0aW9ucy50aWNrcy5mb3JtYXQpO1xuICB9XG59XG4iLCAiaW1wb3J0IHtpc0Zpbml0ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IExpbmVhclNjYWxlQmFzZSBmcm9tICcuL3NjYWxlLmxpbmVhcmJhc2UuanMnO1xuaW1wb3J0IFRpY2tzIGZyb20gJy4uL2NvcmUvY29yZS50aWNrcy5qcyc7XG5pbXBvcnQge3RvUmFkaWFuc30gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmVhclNjYWxlIGV4dGVuZHMgTGluZWFyU2NhbGVCYXNlIHtcblxuICBzdGF0aWMgaWQgPSAnbGluZWFyJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICB0aWNrczoge1xuICAgICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMubnVtZXJpY1xuICAgIH1cbiAgfTtcblxuXG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KHRydWUpO1xuXG4gICAgdGhpcy5taW4gPSBpc0Zpbml0ZShtaW4pID8gbWluIDogMDtcbiAgICB0aGlzLm1heCA9IGlzRmluaXRlKG1heCkgPyBtYXggOiAxO1xuXG4gICAgLy8gQ29tbW9uIGJhc2UgaW1wbGVtZW50YXRpb24gdG8gaGFuZGxlIG1pbiwgbWF4LCBiZWdpbkF0WmVyb1xuICAgIHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpY2tzIGJhc2VkIG9uIHRoZSBzY2FsZSBkaW1lbnNpb25cblx0ICogQHByb3RlY3RlZFxuIFx0ICovXG4gIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgY29uc3QgaG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgbGVuZ3RoID0gaG9yaXpvbnRhbCA/IHRoaXMud2lkdGggOiB0aGlzLmhlaWdodDtcbiAgICBjb25zdCBtaW5Sb3RhdGlvbiA9IHRvUmFkaWFucyh0aGlzLm9wdGlvbnMudGlja3MubWluUm90YXRpb24pO1xuICAgIGNvbnN0IHJhdGlvID0gKGhvcml6b250YWwgPyBNYXRoLnNpbihtaW5Sb3RhdGlvbikgOiBNYXRoLmNvcyhtaW5Sb3RhdGlvbikpIHx8IDAuMDAxO1xuICAgIGNvbnN0IHRpY2tGb250ID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucygwKTtcbiAgICByZXR1cm4gTWF0aC5jZWlsKGxlbmd0aCAvIE1hdGgubWluKDQwLCB0aWNrRm9udC5saW5lSGVpZ2h0IC8gcmF0aW8pKTtcbiAgfVxuXG4gIC8vIFV0aWxzXG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBOYU4gOiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCgodmFsdWUgLSB0aGlzLl9zdGFydFZhbHVlKSAvIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG5cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIHJldHVybiB0aGlzLl9zdGFydFZhbHVlICsgdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpICogdGhpcy5fdmFsdWVSYW5nZTtcbiAgfVxufVxuIiwgImltcG9ydCB7ZmluaXRlT3JEZWZhdWx0LCBpc0Zpbml0ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtmb3JtYXROdW1iZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5pbnRsLmpzJztcbmltcG9ydCB7X3NldE1pbkFuZE1heEJ5S2V5LCBsb2cxMH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IFNjYWxlIGZyb20gJy4uL2NvcmUvY29yZS5zY2FsZS5qcyc7XG5pbXBvcnQgTGluZWFyU2NhbGVCYXNlIGZyb20gJy4vc2NhbGUubGluZWFyYmFzZS5qcyc7XG5pbXBvcnQgVGlja3MgZnJvbSAnLi4vY29yZS9jb3JlLnRpY2tzLmpzJztcblxuY29uc3QgbG9nMTBGbG9vciA9IHYgPT4gTWF0aC5mbG9vcihsb2cxMCh2KSk7XG5jb25zdCBjaGFuZ2VFeHBvbmVudCA9ICh2LCBtKSA9PiBNYXRoLnBvdygxMCwgbG9nMTBGbG9vcih2KSArIG0pO1xuXG5mdW5jdGlvbiBpc01ham9yKHRpY2tWYWwpIHtcbiAgY29uc3QgcmVtYWluID0gdGlja1ZhbCAvIChNYXRoLnBvdygxMCwgbG9nMTBGbG9vcih0aWNrVmFsKSkpO1xuICByZXR1cm4gcmVtYWluID09PSAxO1xufVxuXG5mdW5jdGlvbiBzdGVwcyhtaW4sIG1heCwgcmFuZ2VFeHApIHtcbiAgY29uc3QgcmFuZ2VTdGVwID0gTWF0aC5wb3coMTAsIHJhbmdlRXhwKTtcbiAgY29uc3Qgc3RhcnQgPSBNYXRoLmZsb29yKG1pbiAvIHJhbmdlU3RlcCk7XG4gIGNvbnN0IGVuZCA9IE1hdGguY2VpbChtYXggLyByYW5nZVN0ZXApO1xuICByZXR1cm4gZW5kIC0gc3RhcnQ7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0RXhwKG1pbiwgbWF4KSB7XG4gIGNvbnN0IHJhbmdlID0gbWF4IC0gbWluO1xuICBsZXQgcmFuZ2VFeHAgPSBsb2cxMEZsb29yKHJhbmdlKTtcbiAgd2hpbGUgKHN0ZXBzKG1pbiwgbWF4LCByYW5nZUV4cCkgPiAxMCkge1xuICAgIHJhbmdlRXhwKys7XG4gIH1cbiAgd2hpbGUgKHN0ZXBzKG1pbiwgbWF4LCByYW5nZUV4cCkgPCAxMCkge1xuICAgIHJhbmdlRXhwLS07XG4gIH1cbiAgcmV0dXJuIE1hdGgubWluKHJhbmdlRXhwLCBsb2cxMEZsb29yKG1pbikpO1xufVxuXG5cbi8qKlxuICogR2VuZXJhdGUgYSBzZXQgb2YgbG9nYXJpdGhtaWMgdGlja3NcbiAqIEBwYXJhbSBnZW5lcmF0aW9uT3B0aW9ucyB0aGUgb3B0aW9ucyB1c2VkIHRvIGdlbmVyYXRlIHRoZSB0aWNrc1xuICogQHBhcmFtIGRhdGFSYW5nZSB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGFcbiAqIEByZXR1cm5zIHtvYmplY3RbXX0gYXJyYXkgb2YgdGljayBvYmplY3RzXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlVGlja3MoZ2VuZXJhdGlvbk9wdGlvbnMsIHttaW4sIG1heH0pIHtcbiAgbWluID0gZmluaXRlT3JEZWZhdWx0KGdlbmVyYXRpb25PcHRpb25zLm1pbiwgbWluKTtcbiAgY29uc3QgdGlja3MgPSBbXTtcbiAgY29uc3QgbWluRXhwID0gbG9nMTBGbG9vcihtaW4pO1xuICBsZXQgZXhwID0gc3RhcnRFeHAobWluLCBtYXgpO1xuICBsZXQgcHJlY2lzaW9uID0gZXhwIDwgMCA/IE1hdGgucG93KDEwLCBNYXRoLmFicyhleHApKSA6IDE7XG4gIGNvbnN0IHN0ZXBTaXplID0gTWF0aC5wb3coMTAsIGV4cCk7XG4gIGNvbnN0IGJhc2UgPSBtaW5FeHAgPiBleHAgPyBNYXRoLnBvdygxMCwgbWluRXhwKSA6IDA7XG4gIGNvbnN0IHN0YXJ0ID0gTWF0aC5yb3VuZCgobWluIC0gYmFzZSkgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuICBjb25zdCBvZmZzZXQgPSBNYXRoLmZsb29yKChtaW4gLSBiYXNlKSAvIHN0ZXBTaXplIC8gMTApICogc3RlcFNpemUgKiAxMDtcbiAgbGV0IHNpZ25pZmljYW5kID0gTWF0aC5mbG9vcigoc3RhcnQgLSBvZmZzZXQpIC8gTWF0aC5wb3coMTAsIGV4cCkpO1xuICBsZXQgdmFsdWUgPSBmaW5pdGVPckRlZmF1bHQoZ2VuZXJhdGlvbk9wdGlvbnMubWluLCBNYXRoLnJvdW5kKChiYXNlICsgb2Zmc2V0ICsgc2lnbmlmaWNhbmQgKiBNYXRoLnBvdygxMCwgZXhwKSkgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uKTtcbiAgd2hpbGUgKHZhbHVlIDwgbWF4KSB7XG4gICAgdGlja3MucHVzaCh7dmFsdWUsIG1ham9yOiBpc01ham9yKHZhbHVlKSwgc2lnbmlmaWNhbmR9KTtcbiAgICBpZiAoc2lnbmlmaWNhbmQgPj0gMTApIHtcbiAgICAgIHNpZ25pZmljYW5kID0gc2lnbmlmaWNhbmQgPCAxNSA/IDE1IDogMjA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpZ25pZmljYW5kKys7XG4gICAgfVxuICAgIGlmIChzaWduaWZpY2FuZCA+PSAyMCkge1xuICAgICAgZXhwKys7XG4gICAgICBzaWduaWZpY2FuZCA9IDI7XG4gICAgICBwcmVjaXNpb24gPSBleHAgPj0gMCA/IDEgOiBwcmVjaXNpb247XG4gICAgfVxuICAgIHZhbHVlID0gTWF0aC5yb3VuZCgoYmFzZSArIG9mZnNldCArIHNpZ25pZmljYW5kICogTWF0aC5wb3coMTAsIGV4cCkpICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcbiAgfVxuICBjb25zdCBsYXN0VGljayA9IGZpbml0ZU9yRGVmYXVsdChnZW5lcmF0aW9uT3B0aW9ucy5tYXgsIHZhbHVlKTtcbiAgdGlja3MucHVzaCh7dmFsdWU6IGxhc3RUaWNrLCBtYWpvcjogaXNNYWpvcihsYXN0VGljayksIHNpZ25pZmljYW5kfSk7XG5cbiAgcmV0dXJuIHRpY2tzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb2dhcml0aG1pY1NjYWxlIGV4dGVuZHMgU2NhbGUge1xuXG4gIHN0YXRpYyBpZCA9ICdsb2dhcml0aG1pYyc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgdGlja3M6IHtcbiAgICAgIGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLmxvZ2FyaXRobWljLFxuICAgICAgbWFqb3I6IHtcbiAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG5cbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnN0YXJ0ID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuZW5kID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IDA7XG4gIH1cblxuICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgY29uc3QgdmFsdWUgPSBMaW5lYXJTY2FsZUJhc2UucHJvdG90eXBlLnBhcnNlLmFwcGx5KHRoaXMsIFtyYXcsIGluZGV4XSk7XG4gICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICB0aGlzLl96ZXJvID0gdHJ1ZTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSkgJiYgdmFsdWUgPiAwID8gdmFsdWUgOiBudWxsO1xuICB9XG5cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcy5nZXRNaW5NYXgodHJ1ZSk7XG5cbiAgICB0aGlzLm1pbiA9IGlzRmluaXRlKG1pbikgPyBNYXRoLm1heCgwLCBtaW4pIDogbnVsbDtcbiAgICB0aGlzLm1heCA9IGlzRmluaXRlKG1heCkgPyBNYXRoLm1heCgwLCBtYXgpIDogbnVsbDtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuYmVnaW5BdFplcm8pIHtcbiAgICAgIHRoaXMuX3plcm8gPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGlmIGRhdGEgaGFzIGAwYCBpbiBpdCBvciBgYmVnaW5BdFplcm9gIGlzIHRydWUsIG1pbiAobm9uIHplcm8pIHZhbHVlIGlzIGF0IGJvdHRvbVxuICAgIC8vIG9mIHNjYWxlLCBhbmQgaXQgZG9lcyBub3QgZXF1YWwgc3VnZ2VzdGVkTWluLCBsb3dlciB0aGUgbWluIGJvdW5kIGJ5IG9uZSBleHAuXG4gICAgaWYgKHRoaXMuX3plcm8gJiYgdGhpcy5taW4gIT09IHRoaXMuX3N1Z2dlc3RlZE1pbiAmJiAhaXNGaW5pdGUodGhpcy5fdXNlck1pbikpIHtcbiAgICAgIHRoaXMubWluID0gbWluID09PSBjaGFuZ2VFeHBvbmVudCh0aGlzLm1pbiwgMCkgPyBjaGFuZ2VFeHBvbmVudCh0aGlzLm1pbiwgLTEpIDogY2hhbmdlRXhwb25lbnQodGhpcy5taW4sIDApO1xuICAgIH1cblxuICAgIHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuICB9XG5cbiAgaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpIHtcbiAgICBjb25zdCB7bWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBsZXQgbWluID0gdGhpcy5taW47XG4gICAgbGV0IG1heCA9IHRoaXMubWF4O1xuXG4gICAgY29uc3Qgc2V0TWluID0gdiA9PiAobWluID0gbWluRGVmaW5lZCA/IG1pbiA6IHYpO1xuICAgIGNvbnN0IHNldE1heCA9IHYgPT4gKG1heCA9IG1heERlZmluZWQgPyBtYXggOiB2KTtcblxuICAgIGlmIChtaW4gPT09IG1heCkge1xuICAgICAgaWYgKG1pbiA8PSAwKSB7IC8vIGluY2x1ZGVzIG51bGxcbiAgICAgICAgc2V0TWluKDEpO1xuICAgICAgICBzZXRNYXgoMTApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0TWluKGNoYW5nZUV4cG9uZW50KG1pbiwgLTEpKTtcbiAgICAgICAgc2V0TWF4KGNoYW5nZUV4cG9uZW50KG1heCwgKzEpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1pbiA8PSAwKSB7XG4gICAgICBzZXRNaW4oY2hhbmdlRXhwb25lbnQobWF4LCAtMSkpO1xuICAgIH1cbiAgICBpZiAobWF4IDw9IDApIHtcblxuICAgICAgc2V0TWF4KGNoYW5nZUV4cG9uZW50KG1pbiwgKzEpKTtcbiAgICB9XG5cbiAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICB0aGlzLm1heCA9IG1heDtcbiAgfVxuXG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcblxuICAgIGNvbnN0IGdlbmVyYXRpb25PcHRpb25zID0ge1xuICAgICAgbWluOiB0aGlzLl91c2VyTWluLFxuICAgICAgbWF4OiB0aGlzLl91c2VyTWF4XG4gICAgfTtcbiAgICBjb25zdCB0aWNrcyA9IGdlbmVyYXRlVGlja3MoZ2VuZXJhdGlvbk9wdGlvbnMsIHRoaXMpO1xuXG4gICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgbmVlZCB0byB1cGRhdGUgb3VyIG1heCBhbmQgbWluIGdpdmVuIHRoZSB0aWNrIHZhbHVlcyxcbiAgICAvLyBzaW5jZSB3ZSBwcm9iYWJseSBoYXZlIGV4cGFuZGVkIHRoZSByYW5nZSBvZiB0aGUgc2NhbGVcbiAgICBpZiAob3B0cy5ib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICAgIF9zZXRNaW5BbmRNYXhCeUtleSh0aWNrcywgdGhpcywgJ3ZhbHVlJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMucmV2ZXJzZSkge1xuICAgICAgdGlja3MucmV2ZXJzZSgpO1xuXG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5tYXg7XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWluO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5taW47XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWF4O1xuICAgIH1cblxuICAgIHJldHVybiB0aWNrcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICA/ICcwJ1xuICAgICAgOiBmb3JtYXROdW1iZXIodmFsdWUsIHRoaXMuY2hhcnQub3B0aW9ucy5sb2NhbGUsIHRoaXMub3B0aW9ucy50aWNrcy5mb3JtYXQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMubWluO1xuXG4gICAgc3VwZXIuY29uZmlndXJlKCk7XG5cbiAgICB0aGlzLl9zdGFydFZhbHVlID0gbG9nMTAoc3RhcnQpO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSBsb2cxMCh0aGlzLm1heCkgLSBsb2cxMChzdGFydCk7XG4gIH1cblxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IDApIHtcbiAgICAgIHZhbHVlID0gdGhpcy5taW47XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCBpc05hTih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCh2YWx1ZSA9PT0gdGhpcy5taW5cbiAgICAgID8gMFxuICAgICAgOiAobG9nMTAodmFsdWUpIC0gdGhpcy5fc3RhcnRWYWx1ZSkgLyB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuXG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBkZWNpbWFsID0gdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpO1xuICAgIHJldHVybiBNYXRoLnBvdygxMCwgdGhpcy5fc3RhcnRWYWx1ZSArIGRlY2ltYWwgKiB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxufVxuIiwgImltcG9ydCBkZWZhdWx0cyBmcm9tICcuLi9jb3JlL2NvcmUuZGVmYXVsdHMuanMnO1xuaW1wb3J0IHtfbG9uZ2VzdFRleHQsIGFkZFJvdW5kZWRSZWN0UGF0aCwgcmVuZGVyVGV4dCwgX2lzUG9pbnRJbkFyZWF9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHtIQUxGX1BJLCBUQVUsIHRvRGVncmVlcywgdG9SYWRpYW5zLCBfbm9ybWFsaXplQW5nbGUsIFBJfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQgTGluZWFyU2NhbGVCYXNlIGZyb20gJy4vc2NhbGUubGluZWFyYmFzZS5qcyc7XG5pbXBvcnQgVGlja3MgZnJvbSAnLi4vY29yZS9jb3JlLnRpY2tzLmpzJztcbmltcG9ydCB7dmFsdWVPckRlZmF1bHQsIGlzQXJyYXksIGlzRmluaXRlLCBjYWxsYmFjayBhcyBjYWxsQ2FsbGJhY2ssIGlzTnVsbE9yVW5kZWZ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7Y3JlYXRlQ29udGV4dCwgdG9Gb250LCB0b1BhZGRpbmcsIHRvVFJCTENvcm5lcnN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLmpzJztcblxuZnVuY3Rpb24gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KG9wdHMpIHtcbiAgY29uc3QgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuXG4gIGlmICh0aWNrT3B0cy5kaXNwbGF5ICYmIG9wdHMuZGlzcGxheSkge1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcodGlja09wdHMuYmFja2Ryb3BQYWRkaW5nKTtcbiAgICByZXR1cm4gdmFsdWVPckRlZmF1bHQodGlja09wdHMuZm9udCAmJiB0aWNrT3B0cy5mb250LnNpemUsIGRlZmF1bHRzLmZvbnQuc2l6ZSkgKyBwYWRkaW5nLmhlaWdodDtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gbWVhc3VyZUxhYmVsU2l6ZShjdHgsIGZvbnQsIGxhYmVsKSB7XG4gIGxhYmVsID0gaXNBcnJheShsYWJlbCkgPyBsYWJlbCA6IFtsYWJlbF07XG4gIHJldHVybiB7XG4gICAgdzogX2xvbmdlc3RUZXh0KGN0eCwgZm9udC5zdHJpbmcsIGxhYmVsKSxcbiAgICBoOiBsYWJlbC5sZW5ndGggKiBmb250LmxpbmVIZWlnaHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb3MsIHNpemUsIG1pbiwgbWF4KSB7XG4gIGlmIChhbmdsZSA9PT0gbWluIHx8IGFuZ2xlID09PSBtYXgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHBvcyAtIChzaXplIC8gMiksXG4gICAgICBlbmQ6IHBvcyArIChzaXplIC8gMilcbiAgICB9O1xuICB9IGVsc2UgaWYgKGFuZ2xlIDwgbWluIHx8IGFuZ2xlID4gbWF4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBwb3MgLSBzaXplLFxuICAgICAgZW5kOiBwb3NcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogcG9zLFxuICAgIGVuZDogcG9zICsgc2l6ZVxuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBmaXQgYSByYWRpYWwgbGluZWFyIHNjYWxlIHdpdGggcG9pbnQgbGFiZWxzXG4gKi9cbmZ1bmN0aW9uIGZpdFdpdGhQb2ludExhYmVscyhzY2FsZSkge1xuXG4gIC8vIFJpZ2h0LCB0aGlzIGlzIHJlYWxseSBjb25mdXNpbmcgYW5kIHRoZXJlIGlzIGEgbG90IG9mIG1hdGhzIGdvaW5nIG9uIGhlcmVcbiAgLy8gVGhlIGdpc3Qgb2YgdGhlIHByb2JsZW0gaXMgaGVyZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbm5uaWNrLzY5NmNjOWM1NWY0YjBiZWI4ZmU5XG4gIC8vXG4gIC8vIFJlYWN0aW9uOiBodHRwczovL2RsLmRyb3Bib3h1c2VyY29udGVudC5jb20vdS8zNDYwMTM2My90b29tdWNoc2NpZW5jZS5naWZcbiAgLy9cbiAgLy8gU29sdXRpb246XG4gIC8vXG4gIC8vIFdlIGFzc3VtZSB0aGUgcmFkaXVzIG9mIHRoZSBwb2x5Z29uIGlzIGhhbGYgdGhlIHNpemUgb2YgdGhlIGNhbnZhcyBhdCBmaXJzdFxuICAvLyBhdCBlYWNoIGluZGV4IHdlIGNoZWNrIGlmIHRoZSB0ZXh0IG92ZXJsYXBzLlxuICAvL1xuICAvLyBXaGVyZSBpdCBkb2VzLCB3ZSBzdG9yZSB0aGF0IGFuZ2xlIGFuZCB0aGF0IGluZGV4LlxuICAvL1xuICAvLyBBZnRlciBmaW5kaW5nIHRoZSBsYXJnZXN0IGluZGV4IGFuZCBhbmdsZSB3ZSBjYWxjdWxhdGUgaG93IG11Y2ggd2UgbmVlZCB0byByZW1vdmVcbiAgLy8gZnJvbSB0aGUgc2hhcGUgcmFkaXVzIHRvIG1vdmUgdGhlIHBvaW50IGlud2FyZHMgYnkgdGhhdCB4LlxuICAvL1xuICAvLyBXZSBhdmVyYWdlIHRoZSBsZWZ0IGFuZCByaWdodCBkaXN0YW5jZXMgdG8gZ2V0IHRoZSBtYXhpbXVtIHNoYXBlIHJhZGl1cyB0aGF0IGNhbiBmaXQgaW4gdGhlIGJveFxuICAvLyBhbG9uZyB3aXRoIGxhYmVscy5cbiAgLy9cbiAgLy8gT25jZSB3ZSBoYXZlIHRoYXQsIHdlIGNhbiBmaW5kIHRoZSBjZW50cmUgcG9pbnQgZm9yIHRoZSBjaGFydCwgYnkgdGFraW5nIHRoZSB4IHRleHQgcHJvdHJ1c2lvblxuICAvLyBvbiBlYWNoIHNpZGUsIHJlbW92aW5nIHRoYXQgZnJvbSB0aGUgc2l6ZSwgaGFsdmluZyBpdCBhbmQgYWRkaW5nIHRoZSBsZWZ0IHggcHJvdHJ1c2lvbiB3aWR0aC5cbiAgLy9cbiAgLy8gVGhpcyB3aWxsIG1lYW4gd2UgaGF2ZSBhIHNoYXBlIGZpdHRlZCB0byB0aGUgY2FudmFzLCBhcyBsYXJnZSBhcyBpdCBjYW4gYmUgd2l0aCB0aGUgbGFiZWxzXG4gIC8vIGFuZCBwb3NpdGlvbiBpdCBpbiB0aGUgbW9zdCBzcGFjZSBlZmZpY2llbnQgbWFubmVyXG4gIC8vXG4gIC8vIGh0dHBzOi8vZGwuZHJvcGJveHVzZXJjb250ZW50LmNvbS91LzM0NjAxMzYzL3llYWhzY2llbmNlLmdpZlxuXG4gIC8vIEdldCBtYXhpbXVtIHJhZGl1cyBvZiB0aGUgcG9seWdvbi4gRWl0aGVyIGhhbGYgdGhlIGhlaWdodCAobWludXMgdGhlIHRleHQgd2lkdGgpIG9yIGhhbGYgdGhlIHdpZHRoLlxuICAvLyBVc2UgdGhpcyB0byBjYWxjdWxhdGUgdGhlIG9mZnNldCArIGNoYW5nZS4gLSBNYWtlIHN1cmUgTC9SIHByb3RydXNpb24gaXMgYXQgbGVhc3QgMCB0byBzdG9wIGlzc3VlcyB3aXRoIGNlbnRyZSBwb2ludHNcbiAgY29uc3Qgb3JpZyA9IHtcbiAgICBsOiBzY2FsZS5sZWZ0ICsgc2NhbGUuX3BhZGRpbmcubGVmdCxcbiAgICByOiBzY2FsZS5yaWdodCAtIHNjYWxlLl9wYWRkaW5nLnJpZ2h0LFxuICAgIHQ6IHNjYWxlLnRvcCArIHNjYWxlLl9wYWRkaW5nLnRvcCxcbiAgICBiOiBzY2FsZS5ib3R0b20gLSBzY2FsZS5fcGFkZGluZy5ib3R0b21cbiAgfTtcbiAgY29uc3QgbGltaXRzID0gT2JqZWN0LmFzc2lnbih7fSwgb3JpZyk7XG4gIGNvbnN0IGxhYmVsU2l6ZXMgPSBbXTtcbiAgY29uc3QgcGFkZGluZyA9IFtdO1xuICBjb25zdCB2YWx1ZUNvdW50ID0gc2NhbGUuX3BvaW50TGFiZWxzLmxlbmd0aDtcbiAgY29uc3QgcG9pbnRMYWJlbE9wdHMgPSBzY2FsZS5vcHRpb25zLnBvaW50TGFiZWxzO1xuICBjb25zdCBhZGRpdGlvbmFsQW5nbGUgPSBwb2ludExhYmVsT3B0cy5jZW50ZXJQb2ludExhYmVscyA/IFBJIC8gdmFsdWVDb3VudCA6IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZUNvdW50OyBpKyspIHtcbiAgICBjb25zdCBvcHRzID0gcG9pbnRMYWJlbE9wdHMuc2V0Q29udGV4dChzY2FsZS5nZXRQb2ludExhYmVsQ29udGV4dChpKSk7XG4gICAgcGFkZGluZ1tpXSA9IG9wdHMucGFkZGluZztcbiAgICBjb25zdCBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCBzY2FsZS5kcmF3aW5nQXJlYSArIHBhZGRpbmdbaV0sIGFkZGl0aW9uYWxBbmdsZSk7XG4gICAgY29uc3QgcGxGb250ID0gdG9Gb250KG9wdHMuZm9udCk7XG4gICAgY29uc3QgdGV4dFNpemUgPSBtZWFzdXJlTGFiZWxTaXplKHNjYWxlLmN0eCwgcGxGb250LCBzY2FsZS5fcG9pbnRMYWJlbHNbaV0pO1xuICAgIGxhYmVsU2l6ZXNbaV0gPSB0ZXh0U2l6ZTtcblxuICAgIGNvbnN0IGFuZ2xlUmFkaWFucyA9IF9ub3JtYWxpemVBbmdsZShzY2FsZS5nZXRJbmRleEFuZ2xlKGkpICsgYWRkaXRpb25hbEFuZ2xlKTtcbiAgICBjb25zdCBhbmdsZSA9IE1hdGgucm91bmQodG9EZWdyZWVzKGFuZ2xlUmFkaWFucykpO1xuICAgIGNvbnN0IGhMaW1pdHMgPSBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvaW50UG9zaXRpb24ueCwgdGV4dFNpemUudywgMCwgMTgwKTtcbiAgICBjb25zdCB2TGltaXRzID0gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb2ludFBvc2l0aW9uLnksIHRleHRTaXplLmgsIDkwLCAyNzApO1xuICAgIHVwZGF0ZUxpbWl0cyhsaW1pdHMsIG9yaWcsIGFuZ2xlUmFkaWFucywgaExpbWl0cywgdkxpbWl0cyk7XG4gIH1cblxuICBzY2FsZS5zZXRDZW50ZXJQb2ludChcbiAgICBvcmlnLmwgLSBsaW1pdHMubCxcbiAgICBsaW1pdHMuciAtIG9yaWcucixcbiAgICBvcmlnLnQgLSBsaW1pdHMudCxcbiAgICBsaW1pdHMuYiAtIG9yaWcuYlxuICApO1xuXG4gIC8vIE5vdyB0aGF0IHRleHQgc2l6ZSBpcyBkZXRlcm1pbmVkLCBjb21wdXRlIHRoZSBmdWxsIHBvc2l0aW9uc1xuICBzY2FsZS5fcG9pbnRMYWJlbEl0ZW1zID0gYnVpbGRQb2ludExhYmVsSXRlbXMoc2NhbGUsIGxhYmVsU2l6ZXMsIHBhZGRpbmcpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVMaW1pdHMobGltaXRzLCBvcmlnLCBhbmdsZSwgaExpbWl0cywgdkxpbWl0cykge1xuICBjb25zdCBzaW4gPSBNYXRoLmFicyhNYXRoLnNpbihhbmdsZSkpO1xuICBjb25zdCBjb3MgPSBNYXRoLmFicyhNYXRoLmNvcyhhbmdsZSkpO1xuICBsZXQgeCA9IDA7XG4gIGxldCB5ID0gMDtcbiAgaWYgKGhMaW1pdHMuc3RhcnQgPCBvcmlnLmwpIHtcbiAgICB4ID0gKG9yaWcubCAtIGhMaW1pdHMuc3RhcnQpIC8gc2luO1xuICAgIGxpbWl0cy5sID0gTWF0aC5taW4obGltaXRzLmwsIG9yaWcubCAtIHgpO1xuICB9IGVsc2UgaWYgKGhMaW1pdHMuZW5kID4gb3JpZy5yKSB7XG4gICAgeCA9IChoTGltaXRzLmVuZCAtIG9yaWcucikgLyBzaW47XG4gICAgbGltaXRzLnIgPSBNYXRoLm1heChsaW1pdHMuciwgb3JpZy5yICsgeCk7XG4gIH1cbiAgaWYgKHZMaW1pdHMuc3RhcnQgPCBvcmlnLnQpIHtcbiAgICB5ID0gKG9yaWcudCAtIHZMaW1pdHMuc3RhcnQpIC8gY29zO1xuICAgIGxpbWl0cy50ID0gTWF0aC5taW4obGltaXRzLnQsIG9yaWcudCAtIHkpO1xuICB9IGVsc2UgaWYgKHZMaW1pdHMuZW5kID4gb3JpZy5iKSB7XG4gICAgeSA9ICh2TGltaXRzLmVuZCAtIG9yaWcuYikgLyBjb3M7XG4gICAgbGltaXRzLmIgPSBNYXRoLm1heChsaW1pdHMuYiwgb3JpZy5iICsgeSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlUG9pbnRMYWJlbEl0ZW0oc2NhbGUsIGluZGV4LCBpdGVtT3B0cykge1xuICBjb25zdCBvdXRlckRpc3RhbmNlID0gc2NhbGUuZHJhd2luZ0FyZWE7XG4gIGNvbnN0IHtleHRyYSwgYWRkaXRpb25hbEFuZ2xlLCBwYWRkaW5nLCBzaXplfSA9IGl0ZW1PcHRzO1xuICBjb25zdCBwb2ludExhYmVsUG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGluZGV4LCBvdXRlckRpc3RhbmNlICsgZXh0cmEgKyBwYWRkaW5nLCBhZGRpdGlvbmFsQW5nbGUpO1xuICBjb25zdCBhbmdsZSA9IE1hdGgucm91bmQodG9EZWdyZWVzKF9ub3JtYWxpemVBbmdsZShwb2ludExhYmVsUG9zaXRpb24uYW5nbGUgKyBIQUxGX1BJKSkpO1xuICBjb25zdCB5ID0geUZvckFuZ2xlKHBvaW50TGFiZWxQb3NpdGlvbi55LCBzaXplLmgsIGFuZ2xlKTtcbiAgY29uc3QgdGV4dEFsaWduID0gZ2V0VGV4dEFsaWduRm9yQW5nbGUoYW5nbGUpO1xuICBjb25zdCBsZWZ0ID0gbGVmdEZvclRleHRBbGlnbihwb2ludExhYmVsUG9zaXRpb24ueCwgc2l6ZS53LCB0ZXh0QWxpZ24pO1xuICByZXR1cm4ge1xuICAgIC8vIGlmIHRvIGRyYXcgb3Igb3ZlcmxhcHBlZFxuICAgIHZpc2libGU6IHRydWUsXG5cbiAgICAvLyBUZXh0IHBvc2l0aW9uXG4gICAgeDogcG9pbnRMYWJlbFBvc2l0aW9uLngsXG4gICAgeSxcblxuICAgIC8vIFRleHQgcmVuZGVyaW5nIGRhdGFcbiAgICB0ZXh0QWxpZ24sXG5cbiAgICAvLyBCb3VuZGluZyBib3hcbiAgICBsZWZ0LFxuICAgIHRvcDogeSxcbiAgICByaWdodDogbGVmdCArIHNpemUudyxcbiAgICBib3R0b206IHkgKyBzaXplLmhcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNOb3RPdmVybGFwcGVkKGl0ZW0sIGFyZWEpIHtcbiAgaWYgKCFhcmVhKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3Qge2xlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbX0gPSBpdGVtO1xuICBjb25zdCBhcGV4ZXNJbkFyZWEgPSBfaXNQb2ludEluQXJlYSh7eDogbGVmdCwgeTogdG9wfSwgYXJlYSkgfHwgX2lzUG9pbnRJbkFyZWEoe3g6IGxlZnQsIHk6IGJvdHRvbX0sIGFyZWEpIHx8XG4gICAgX2lzUG9pbnRJbkFyZWEoe3g6IHJpZ2h0LCB5OiB0b3B9LCBhcmVhKSB8fCBfaXNQb2ludEluQXJlYSh7eDogcmlnaHQsIHk6IGJvdHRvbX0sIGFyZWEpO1xuICByZXR1cm4gIWFwZXhlc0luQXJlYTtcbn1cblxuZnVuY3Rpb24gYnVpbGRQb2ludExhYmVsSXRlbXMoc2NhbGUsIGxhYmVsU2l6ZXMsIHBhZGRpbmcpIHtcbiAgY29uc3QgaXRlbXMgPSBbXTtcbiAgY29uc3QgdmFsdWVDb3VudCA9IHNjYWxlLl9wb2ludExhYmVscy5sZW5ndGg7XG4gIGNvbnN0IG9wdHMgPSBzY2FsZS5vcHRpb25zO1xuICBjb25zdCB7Y2VudGVyUG9pbnRMYWJlbHMsIGRpc3BsYXl9ID0gb3B0cy5wb2ludExhYmVscztcbiAgY29uc3QgaXRlbU9wdHMgPSB7XG4gICAgZXh0cmE6IGdldFRpY2tCYWNrZHJvcEhlaWdodChvcHRzKSAvIDIsXG4gICAgYWRkaXRpb25hbEFuZ2xlOiBjZW50ZXJQb2ludExhYmVscyA/IFBJIC8gdmFsdWVDb3VudCA6IDBcbiAgfTtcbiAgbGV0IGFyZWE7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZUNvdW50OyBpKyspIHtcbiAgICBpdGVtT3B0cy5wYWRkaW5nID0gcGFkZGluZ1tpXTtcbiAgICBpdGVtT3B0cy5zaXplID0gbGFiZWxTaXplc1tpXTtcblxuICAgIGNvbnN0IGl0ZW0gPSBjcmVhdGVQb2ludExhYmVsSXRlbShzY2FsZSwgaSwgaXRlbU9wdHMpO1xuICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgaWYgKGRpc3BsYXkgPT09ICdhdXRvJykge1xuICAgICAgaXRlbS52aXNpYmxlID0gaXNOb3RPdmVybGFwcGVkKGl0ZW0sIGFyZWEpO1xuICAgICAgaWYgKGl0ZW0udmlzaWJsZSkge1xuICAgICAgICBhcmVhID0gaXRlbTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGl0ZW1zO1xufVxuXG5mdW5jdGlvbiBnZXRUZXh0QWxpZ25Gb3JBbmdsZShhbmdsZSkge1xuICBpZiAoYW5nbGUgPT09IDAgfHwgYW5nbGUgPT09IDE4MCkge1xuICAgIHJldHVybiAnY2VudGVyJztcbiAgfSBlbHNlIGlmIChhbmdsZSA8IDE4MCkge1xuICAgIHJldHVybiAnbGVmdCc7XG4gIH1cblxuICByZXR1cm4gJ3JpZ2h0Jztcbn1cblxuZnVuY3Rpb24gbGVmdEZvclRleHRBbGlnbih4LCB3LCBhbGlnbikge1xuICBpZiAoYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB4IC09IHc7XG4gIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgeCAtPSAodyAvIDIpO1xuICB9XG4gIHJldHVybiB4O1xufVxuXG5mdW5jdGlvbiB5Rm9yQW5nbGUoeSwgaCwgYW5nbGUpIHtcbiAgaWYgKGFuZ2xlID09PSA5MCB8fCBhbmdsZSA9PT0gMjcwKSB7XG4gICAgeSAtPSAoaCAvIDIpO1xuICB9IGVsc2UgaWYgKGFuZ2xlID4gMjcwIHx8IGFuZ2xlIDwgOTApIHtcbiAgICB5IC09IGg7XG4gIH1cbiAgcmV0dXJuIHk7XG59XG5cbmZ1bmN0aW9uIGRyYXdQb2ludExhYmVsQm94KGN0eCwgb3B0cywgaXRlbSkge1xuICBjb25zdCB7bGVmdCwgdG9wLCByaWdodCwgYm90dG9tfSA9IGl0ZW07XG4gIGNvbnN0IHtiYWNrZHJvcENvbG9yfSA9IG9wdHM7XG5cbiAgaWYgKCFpc051bGxPclVuZGVmKGJhY2tkcm9wQ29sb3IpKSB7XG4gICAgY29uc3QgYm9yZGVyUmFkaXVzID0gdG9UUkJMQ29ybmVycyhvcHRzLmJvcmRlclJhZGl1cyk7XG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRzLmJhY2tkcm9wUGFkZGluZyk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tkcm9wQ29sb3I7XG5cbiAgICBjb25zdCBiYWNrZHJvcExlZnQgPSBsZWZ0IC0gcGFkZGluZy5sZWZ0O1xuICAgIGNvbnN0IGJhY2tkcm9wVG9wID0gdG9wIC0gcGFkZGluZy50b3A7XG4gICAgY29uc3QgYmFja2Ryb3BXaWR0aCA9IHJpZ2h0IC0gbGVmdCArIHBhZGRpbmcud2lkdGg7XG4gICAgY29uc3QgYmFja2Ryb3BIZWlnaHQgPSBib3R0b20gLSB0b3AgKyBwYWRkaW5nLmhlaWdodDtcblxuICAgIGlmIChPYmplY3QudmFsdWVzKGJvcmRlclJhZGl1cykuc29tZSh2ID0+IHYgIT09IDApKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgIHg6IGJhY2tkcm9wTGVmdCxcbiAgICAgICAgeTogYmFja2Ryb3BUb3AsXG4gICAgICAgIHc6IGJhY2tkcm9wV2lkdGgsXG4gICAgICAgIGg6IGJhY2tkcm9wSGVpZ2h0LFxuICAgICAgICByYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICAgIH0pO1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmZpbGxSZWN0KGJhY2tkcm9wTGVmdCwgYmFja2Ryb3BUb3AsIGJhY2tkcm9wV2lkdGgsIGJhY2tkcm9wSGVpZ2h0KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhd1BvaW50TGFiZWxzKHNjYWxlLCBsYWJlbENvdW50KSB7XG4gIGNvbnN0IHtjdHgsIG9wdGlvbnM6IHtwb2ludExhYmVsc319ID0gc2NhbGU7XG5cbiAgZm9yIChsZXQgaSA9IGxhYmVsQ291bnQgLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IGl0ZW0gPSBzY2FsZS5fcG9pbnRMYWJlbEl0ZW1zW2ldO1xuICAgIGlmICghaXRlbS52aXNpYmxlKSB7XG4gICAgICAvLyBvdmVybGFwcGluZ1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gcG9pbnRMYWJlbHMuc2V0Q29udGV4dChzY2FsZS5nZXRQb2ludExhYmVsQ29udGV4dChpKSk7XG4gICAgZHJhd1BvaW50TGFiZWxCb3goY3R4LCBvcHRzQXRJbmRleCwgaXRlbSk7XG4gICAgY29uc3QgcGxGb250ID0gdG9Gb250KG9wdHNBdEluZGV4LmZvbnQpO1xuICAgIGNvbnN0IHt4LCB5LCB0ZXh0QWxpZ259ID0gaXRlbTtcblxuICAgIHJlbmRlclRleHQoXG4gICAgICBjdHgsXG4gICAgICBzY2FsZS5fcG9pbnRMYWJlbHNbaV0sXG4gICAgICB4LFxuICAgICAgeSArIChwbEZvbnQubGluZUhlaWdodCAvIDIpLFxuICAgICAgcGxGb250LFxuICAgICAge1xuICAgICAgICBjb2xvcjogb3B0c0F0SW5kZXguY29sb3IsXG4gICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnXG4gICAgICB9XG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXRoUmFkaXVzTGluZShzY2FsZSwgcmFkaXVzLCBjaXJjdWxhciwgbGFiZWxDb3VudCkge1xuICBjb25zdCB7Y3R4fSA9IHNjYWxlO1xuICBpZiAoY2lyY3VsYXIpIHtcbiAgICAvLyBEcmF3IGNpcmN1bGFyIGFyY3MgYmV0d2VlbiB0aGUgcG9pbnRzXG4gICAgY3R4LmFyYyhzY2FsZS54Q2VudGVyLCBzY2FsZS55Q2VudGVyLCByYWRpdXMsIDAsIFRBVSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRHJhdyBzdHJhaWdodCBsaW5lcyBjb25uZWN0aW5nIGVhY2ggaW5kZXhcbiAgICBsZXQgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oMCwgcmFkaXVzKTtcbiAgICBjdHgubW92ZVRvKHBvaW50UG9zaXRpb24ueCwgcG9pbnRQb3NpdGlvbi55KTtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGFiZWxDb3VudDsgaSsrKSB7XG4gICAgICBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCByYWRpdXMpO1xuICAgICAgY3R4LmxpbmVUbyhwb2ludFBvc2l0aW9uLngsIHBvaW50UG9zaXRpb24ueSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdSYWRpdXNMaW5lKHNjYWxlLCBncmlkTGluZU9wdHMsIHJhZGl1cywgbGFiZWxDb3VudCwgYm9yZGVyT3B0cykge1xuICBjb25zdCBjdHggPSBzY2FsZS5jdHg7XG4gIGNvbnN0IGNpcmN1bGFyID0gZ3JpZExpbmVPcHRzLmNpcmN1bGFyO1xuXG4gIGNvbnN0IHtjb2xvciwgbGluZVdpZHRofSA9IGdyaWRMaW5lT3B0cztcblxuICBpZiAoKCFjaXJjdWxhciAmJiAhbGFiZWxDb3VudCkgfHwgIWNvbG9yIHx8ICFsaW5lV2lkdGggfHwgcmFkaXVzIDwgMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICBjdHguc2V0TGluZURhc2goYm9yZGVyT3B0cy5kYXNoKTtcbiAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gYm9yZGVyT3B0cy5kYXNoT2Zmc2V0O1xuXG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgcGF0aFJhZGl1c0xpbmUoc2NhbGUsIHJhZGl1cywgY2lyY3VsYXIsIGxhYmVsQ291bnQpO1xuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5zdHJva2UoKTtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUG9pbnRMYWJlbENvbnRleHQocGFyZW50LCBpbmRleCwgbGFiZWwpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgbGFiZWwsXG4gICAgaW5kZXgsXG4gICAgdHlwZTogJ3BvaW50TGFiZWwnXG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSYWRpYWxMaW5lYXJTY2FsZSBleHRlbmRzIExpbmVhclNjYWxlQmFzZSB7XG5cbiAgc3RhdGljIGlkID0gJ3JhZGlhbExpbmVhcic7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgZGlzcGxheTogdHJ1ZSxcblxuICAgIC8vIEJvb2xlYW4gLSBXaGV0aGVyIHRvIGFuaW1hdGUgc2NhbGluZyB0aGUgY2hhcnQgZnJvbSB0aGUgY2VudHJlXG4gICAgYW5pbWF0ZTogdHJ1ZSxcbiAgICBwb3NpdGlvbjogJ2NoYXJ0QXJlYScsXG5cbiAgICBhbmdsZUxpbmVzOiB7XG4gICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgbGluZVdpZHRoOiAxLFxuICAgICAgYm9yZGVyRGFzaDogW10sXG4gICAgICBib3JkZXJEYXNoT2Zmc2V0OiAwLjBcbiAgICB9LFxuXG4gICAgZ3JpZDoge1xuICAgICAgY2lyY3VsYXI6IGZhbHNlXG4gICAgfSxcblxuICAgIHN0YXJ0QW5nbGU6IDAsXG5cbiAgICAvLyBsYWJlbCBzZXR0aW5nc1xuICAgIHRpY2tzOiB7XG4gICAgICAvLyBCb29sZWFuIC0gU2hvdyBhIGJhY2tkcm9wIHRvIHRoZSBzY2FsZSBsYWJlbFxuICAgICAgc2hvd0xhYmVsQmFja2Ryb3A6IHRydWUsXG5cbiAgICAgIGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLm51bWVyaWNcbiAgICB9LFxuXG4gICAgcG9pbnRMYWJlbHM6IHtcbiAgICAgIGJhY2tkcm9wQ29sb3I6IHVuZGVmaW5lZCxcblxuICAgICAgLy8gTnVtYmVyIC0gVGhlIGJhY2tkcm9wIHBhZGRpbmcgYWJvdmUgJiBiZWxvdyB0aGUgbGFiZWwgaW4gcGl4ZWxzXG4gICAgICBiYWNrZHJvcFBhZGRpbmc6IDIsXG5cbiAgICAgIC8vIEJvb2xlYW4gLSBpZiB0cnVlLCBzaG93IHBvaW50IGxhYmVsc1xuICAgICAgZGlzcGxheTogdHJ1ZSxcblxuICAgICAgLy8gTnVtYmVyIC0gUG9pbnQgbGFiZWwgZm9udCBzaXplIGluIHBpeGVsc1xuICAgICAgZm9udDoge1xuICAgICAgICBzaXplOiAxMFxuICAgICAgfSxcblxuICAgICAgLy8gRnVuY3Rpb24gLSBVc2VkIHRvIGNvbnZlcnQgcG9pbnQgbGFiZWxzXG4gICAgICBjYWxsYmFjayhsYWJlbCkge1xuICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgICB9LFxuXG4gICAgICAvLyBOdW1iZXIgLSBBZGRpdGlvbmwgcGFkZGluZyBiZXR3ZWVuIHNjYWxlIGFuZCBwb2ludExhYmVsXG4gICAgICBwYWRkaW5nOiA1LFxuXG4gICAgICAvLyBCb29sZWFuIC0gaWYgdHJ1ZSwgY2VudGVyIHBvaW50IGxhYmVscyB0byBzbGljZXMgaW4gcG9sYXIgY2hhcnRcbiAgICAgIGNlbnRlclBvaW50TGFiZWxzOiBmYWxzZVxuICAgIH1cbiAgfTtcblxuICBzdGF0aWMgZGVmYXVsdFJvdXRlcyA9IHtcbiAgICAnYW5nbGVMaW5lcy5jb2xvcic6ICdib3JkZXJDb2xvcicsXG4gICAgJ3BvaW50TGFiZWxzLmNvbG9yJzogJ2NvbG9yJyxcbiAgICAndGlja3MuY29sb3InOiAnY29sb3InXG4gIH07XG5cbiAgc3RhdGljIGRlc2NyaXB0b3JzID0ge1xuICAgIGFuZ2xlTGluZXM6IHtcbiAgICAgIF9mYWxsYmFjazogJ2dyaWQnXG4gICAgfVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG5cbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnhDZW50ZXIgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy55Q2VudGVyID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuZHJhd2luZ0FyZWEgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtzdHJpbmdbXX0gKi9cbiAgICB0aGlzLl9wb2ludExhYmVscyA9IFtdO1xuICAgIHRoaXMuX3BvaW50TGFiZWxJdGVtcyA9IFtdO1xuICB9XG5cbiAgc2V0RGltZW5zaW9ucygpIHtcbiAgICAvLyBTZXQgdGhlIHVuY29uc3RyYWluZWQgZGltZW5zaW9uIGJlZm9yZSBsYWJlbCByb3RhdGlvblxuICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLl9wYWRkaW5nID0gdG9QYWRkaW5nKGdldFRpY2tCYWNrZHJvcEhlaWdodCh0aGlzLm9wdGlvbnMpIC8gMik7XG4gICAgY29uc3QgdyA9IHRoaXMud2lkdGggPSB0aGlzLm1heFdpZHRoIC0gcGFkZGluZy53aWR0aDtcbiAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQgPSB0aGlzLm1heEhlaWdodCAtIHBhZGRpbmcuaGVpZ2h0O1xuICAgIHRoaXMueENlbnRlciA9IE1hdGguZmxvb3IodGhpcy5sZWZ0ICsgdyAvIDIgKyBwYWRkaW5nLmxlZnQpO1xuICAgIHRoaXMueUNlbnRlciA9IE1hdGguZmxvb3IodGhpcy50b3AgKyBoIC8gMiArIHBhZGRpbmcudG9wKTtcbiAgICB0aGlzLmRyYXdpbmdBcmVhID0gTWF0aC5mbG9vcihNYXRoLm1pbih3LCBoKSAvIDIpO1xuICB9XG5cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcy5nZXRNaW5NYXgoZmFsc2UpO1xuXG4gICAgdGhpcy5taW4gPSBpc0Zpbml0ZShtaW4pICYmICFpc05hTihtaW4pID8gbWluIDogMDtcbiAgICB0aGlzLm1heCA9IGlzRmluaXRlKG1heCkgJiYgIWlzTmFOKG1heCkgPyBtYXggOiAwO1xuXG4gICAgLy8gQ29tbW9uIGJhc2UgaW1wbGVtZW50YXRpb24gdG8gaGFuZGxlIG1pbiwgbWF4LCBiZWdpbkF0WmVyb1xuICAgIHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpY2tzIGJhc2VkIG9uIHRoZSBzY2FsZSBkaW1lbnNpb25cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgY29tcHV0ZVRpY2tMaW1pdCgpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuZHJhd2luZ0FyZWEgLyBnZXRUaWNrQmFja2Ryb3BIZWlnaHQodGhpcy5vcHRpb25zKSk7XG4gIH1cblxuICBnZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpIHtcbiAgICBMaW5lYXJTY2FsZUJhc2UucHJvdG90eXBlLmdlbmVyYXRlVGlja0xhYmVscy5jYWxsKHRoaXMsIHRpY2tzKTtcblxuICAgIC8vIFBvaW50IGxhYmVsc1xuICAgIHRoaXMuX3BvaW50TGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKVxuICAgICAgLm1hcCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gY2FsbENhbGxiYWNrKHRoaXMub3B0aW9ucy5wb2ludExhYmVscy5jYWxsYmFjaywgW3ZhbHVlLCBpbmRleF0sIHRoaXMpO1xuICAgICAgICByZXR1cm4gbGFiZWwgfHwgbGFiZWwgPT09IDAgPyBsYWJlbCA6ICcnO1xuICAgICAgfSlcbiAgICAgIC5maWx0ZXIoKHYsIGkpID0+IHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkpO1xuICB9XG5cbiAgZml0KCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBpZiAob3B0cy5kaXNwbGF5ICYmIG9wdHMucG9pbnRMYWJlbHMuZGlzcGxheSkge1xuICAgICAgZml0V2l0aFBvaW50TGFiZWxzKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldENlbnRlclBvaW50KDAsIDAsIDAsIDApO1xuICAgIH1cbiAgfVxuXG4gIHNldENlbnRlclBvaW50KGxlZnRNb3ZlbWVudCwgcmlnaHRNb3ZlbWVudCwgdG9wTW92ZW1lbnQsIGJvdHRvbU1vdmVtZW50KSB7XG4gICAgdGhpcy54Q2VudGVyICs9IE1hdGguZmxvb3IoKGxlZnRNb3ZlbWVudCAtIHJpZ2h0TW92ZW1lbnQpIC8gMik7XG4gICAgdGhpcy55Q2VudGVyICs9IE1hdGguZmxvb3IoKHRvcE1vdmVtZW50IC0gYm90dG9tTW92ZW1lbnQpIC8gMik7XG4gICAgdGhpcy5kcmF3aW5nQXJlYSAtPSBNYXRoLm1pbih0aGlzLmRyYXdpbmdBcmVhIC8gMiwgTWF0aC5tYXgobGVmdE1vdmVtZW50LCByaWdodE1vdmVtZW50LCB0b3BNb3ZlbWVudCwgYm90dG9tTW92ZW1lbnQpKTtcbiAgfVxuXG4gIGdldEluZGV4QW5nbGUoaW5kZXgpIHtcbiAgICBjb25zdCBhbmdsZU11bHRpcGxpZXIgPSBUQVUgLyAodGhpcy5fcG9pbnRMYWJlbHMubGVuZ3RoIHx8IDEpO1xuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSB0aGlzLm9wdGlvbnMuc3RhcnRBbmdsZSB8fCAwO1xuXG4gICAgcmV0dXJuIF9ub3JtYWxpemVBbmdsZShpbmRleCAqIGFuZ2xlTXVsdGlwbGllciArIHRvUmFkaWFucyhzdGFydEFuZ2xlKSk7XG4gIH1cblxuICBnZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGlmIChpc051bGxPclVuZGVmKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG5cbiAgICAvLyBUYWtlIGludG8gYWNjb3VudCBoYWxmIGZvbnQgc2l6ZSArIHRoZSB5UGFkZGluZyBvZiB0aGUgdG9wIHZhbHVlXG4gICAgY29uc3Qgc2NhbGluZ0ZhY3RvciA9IHRoaXMuZHJhd2luZ0FyZWEgLyAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICByZXR1cm4gKHRoaXMubWF4IC0gdmFsdWUpICogc2NhbGluZ0ZhY3RvcjtcbiAgICB9XG4gICAgcmV0dXJuICh2YWx1ZSAtIHRoaXMubWluKSAqIHNjYWxpbmdGYWN0b3I7XG4gIH1cblxuICBnZXRWYWx1ZUZvckRpc3RhbmNlRnJvbUNlbnRlcihkaXN0YW5jZSkge1xuICAgIGlmIChpc051bGxPclVuZGVmKGRpc3RhbmNlKSkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG5cbiAgICBjb25zdCBzY2FsZWREaXN0YW5jZSA9IGRpc3RhbmNlIC8gKHRoaXMuZHJhd2luZ0FyZWEgLyAodGhpcy5tYXggLSB0aGlzLm1pbikpO1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMucmV2ZXJzZSA/IHRoaXMubWF4IC0gc2NhbGVkRGlzdGFuY2UgOiB0aGlzLm1pbiArIHNjYWxlZERpc3RhbmNlO1xuICB9XG5cbiAgZ2V0UG9pbnRMYWJlbENvbnRleHQoaW5kZXgpIHtcbiAgICBjb25zdCBwb2ludExhYmVscyA9IHRoaXMuX3BvaW50TGFiZWxzIHx8IFtdO1xuXG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCBwb2ludExhYmVscy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHBvaW50TGFiZWwgPSBwb2ludExhYmVsc1tpbmRleF07XG4gICAgICByZXR1cm4gY3JlYXRlUG9pbnRMYWJlbENvbnRleHQodGhpcy5nZXRDb250ZXh0KCksIGluZGV4LCBwb2ludExhYmVsKTtcbiAgICB9XG4gIH1cblxuICBnZXRQb2ludFBvc2l0aW9uKGluZGV4LCBkaXN0YW5jZUZyb21DZW50ZXIsIGFkZGl0aW9uYWxBbmdsZSA9IDApIHtcbiAgICBjb25zdCBhbmdsZSA9IHRoaXMuZ2V0SW5kZXhBbmdsZShpbmRleCkgLSBIQUxGX1BJICsgYWRkaXRpb25hbEFuZ2xlO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBNYXRoLmNvcyhhbmdsZSkgKiBkaXN0YW5jZUZyb21DZW50ZXIgKyB0aGlzLnhDZW50ZXIsXG4gICAgICB5OiBNYXRoLnNpbihhbmdsZSkgKiBkaXN0YW5jZUZyb21DZW50ZXIgKyB0aGlzLnlDZW50ZXIsXG4gICAgICBhbmdsZVxuICAgIH07XG4gIH1cblxuICBnZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaW5kZXgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnRQb3NpdGlvbihpbmRleCwgdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh2YWx1ZSkpO1xuICB9XG5cbiAgZ2V0QmFzZVBvc2l0aW9uKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGluZGV4IHx8IDAsIHRoaXMuZ2V0QmFzZVZhbHVlKCkpO1xuICB9XG5cbiAgZ2V0UG9pbnRMYWJlbFBvc2l0aW9uKGluZGV4KSB7XG4gICAgY29uc3Qge2xlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbX0gPSB0aGlzLl9wb2ludExhYmVsSXRlbXNbaW5kZXhdO1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0LFxuICAgICAgdG9wLFxuICAgICAgcmlnaHQsXG4gICAgICBib3R0b20sXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3QmFja2dyb3VuZCgpIHtcbiAgICBjb25zdCB7YmFja2dyb3VuZENvbG9yLCBncmlkOiB7Y2lyY3VsYXJ9fSA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBwYXRoUmFkaXVzTGluZSh0aGlzLCB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRoaXMuX2VuZFZhbHVlKSwgY2lyY3VsYXIsIHRoaXMuX3BvaW50TGFiZWxzLmxlbmd0aCk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdHcmlkKCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge2FuZ2xlTGluZXMsIGdyaWQsIGJvcmRlcn0gPSBvcHRzO1xuICAgIGNvbnN0IGxhYmVsQ291bnQgPSB0aGlzLl9wb2ludExhYmVscy5sZW5ndGg7XG5cbiAgICBsZXQgaSwgb2Zmc2V0LCBwb3NpdGlvbjtcblxuICAgIGlmIChvcHRzLnBvaW50TGFiZWxzLmRpc3BsYXkpIHtcbiAgICAgIGRyYXdQb2ludExhYmVscyh0aGlzLCBsYWJlbENvdW50KTtcbiAgICB9XG5cbiAgICBpZiAoZ3JpZC5kaXNwbGF5KSB7XG4gICAgICB0aGlzLnRpY2tzLmZvckVhY2goKHRpY2ssIGluZGV4KSA9PiB7XG4gICAgICAgIGlmIChpbmRleCAhPT0gMCB8fCAoaW5kZXggPT09IDAgJiYgdGhpcy5taW4gPCAwKSkge1xuICAgICAgICAgIG9mZnNldCA9IHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodGljay52YWx1ZSk7XG4gICAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0Q29udGV4dChpbmRleCk7XG4gICAgICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSBncmlkLnNldENvbnRleHQoY29udGV4dCk7XG4gICAgICAgICAgY29uc3Qgb3B0c0F0SW5kZXhCb3JkZXIgPSBib3JkZXIuc2V0Q29udGV4dChjb250ZXh0KTtcblxuICAgICAgICAgIGRyYXdSYWRpdXNMaW5lKHRoaXMsIG9wdHNBdEluZGV4LCBvZmZzZXQsIGxhYmVsQ291bnQsIG9wdHNBdEluZGV4Qm9yZGVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFuZ2xlTGluZXMuZGlzcGxheSkge1xuICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgZm9yIChpID0gbGFiZWxDb3VudCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gYW5nbGVMaW5lcy5zZXRDb250ZXh0KHRoaXMuZ2V0UG9pbnRMYWJlbENvbnRleHQoaSkpO1xuICAgICAgICBjb25zdCB7Y29sb3IsIGxpbmVXaWR0aH0gPSBvcHRzQXRJbmRleDtcblxuICAgICAgICBpZiAoIWxpbmVXaWR0aCB8fCAhY29sb3IpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuXG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaChvcHRzQXRJbmRleC5ib3JkZXJEYXNoKTtcbiAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gb3B0c0F0SW5kZXguYm9yZGVyRGFzaE9mZnNldDtcblxuICAgICAgICBvZmZzZXQgPSB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKG9wdHMudGlja3MucmV2ZXJzZSA/IHRoaXMubWluIDogdGhpcy5tYXgpO1xuICAgICAgICBwb3NpdGlvbiA9IHRoaXMuZ2V0UG9pbnRQb3NpdGlvbihpLCBvZmZzZXQpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8odGhpcy54Q2VudGVyLCB0aGlzLnlDZW50ZXIpO1xuICAgICAgICBjdHgubGluZVRvKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdCb3JkZXIoKSB7fVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3TGFiZWxzKCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuXG4gICAgaWYgKCF0aWNrT3B0cy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnRBbmdsZSA9IHRoaXMuZ2V0SW5kZXhBbmdsZSgwKTtcbiAgICBsZXQgb2Zmc2V0LCB3aWR0aDtcblxuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnRyYW5zbGF0ZSh0aGlzLnhDZW50ZXIsIHRoaXMueUNlbnRlcik7XG4gICAgY3R4LnJvdGF0ZShzdGFydEFuZ2xlKTtcbiAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXG4gICAgdGhpcy50aWNrcy5mb3JFYWNoKCh0aWNrLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKChpbmRleCA9PT0gMCAmJiB0aGlzLm1pbiA+PSAwKSAmJiAhb3B0cy5yZXZlcnNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSB0aWNrT3B0cy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpbmRleCkpO1xuICAgICAgY29uc3QgdGlja0ZvbnQgPSB0b0ZvbnQob3B0c0F0SW5kZXguZm9udCk7XG4gICAgICBvZmZzZXQgPSB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRoaXMudGlja3NbaW5kZXhdLnZhbHVlKTtcblxuICAgICAgaWYgKG9wdHNBdEluZGV4LnNob3dMYWJlbEJhY2tkcm9wKSB7XG4gICAgICAgIGN0eC5mb250ID0gdGlja0ZvbnQuc3RyaW5nO1xuICAgICAgICB3aWR0aCA9IGN0eC5tZWFzdXJlVGV4dCh0aWNrLmxhYmVsKS53aWR0aDtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdHNBdEluZGV4LmJhY2tkcm9wQ29sb3I7XG5cbiAgICAgICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRzQXRJbmRleC5iYWNrZHJvcFBhZGRpbmcpO1xuICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgLXdpZHRoIC8gMiAtIHBhZGRpbmcubGVmdCxcbiAgICAgICAgICAtb2Zmc2V0IC0gdGlja0ZvbnQuc2l6ZSAvIDIgLSBwYWRkaW5nLnRvcCxcbiAgICAgICAgICB3aWR0aCArIHBhZGRpbmcud2lkdGgsXG4gICAgICAgICAgdGlja0ZvbnQuc2l6ZSArIHBhZGRpbmcuaGVpZ2h0XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJlbmRlclRleHQoY3R4LCB0aWNrLmxhYmVsLCAwLCAtb2Zmc2V0LCB0aWNrRm9udCwge1xuICAgICAgICBjb2xvcjogb3B0c0F0SW5kZXguY29sb3IsXG4gICAgICAgIHN0cm9rZUNvbG9yOiBvcHRzQXRJbmRleC50ZXh0U3Ryb2tlQ29sb3IsXG4gICAgICAgIHN0cm9rZVdpZHRoOiBvcHRzQXRJbmRleC50ZXh0U3Ryb2tlV2lkdGgsXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd1RpdGxlKCkge31cbn1cbiIsICJpbXBvcnQgYWRhcHRlcnMgZnJvbSAnLi4vY29yZS9jb3JlLmFkYXB0ZXJzLmpzJztcbmltcG9ydCB7Y2FsbGJhY2sgYXMgY2FsbCwgaXNGaW5pdGUsIGlzTnVsbE9yVW5kZWYsIG1lcmdlSWYsIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge3RvUmFkaWFucywgaXNOdW1iZXIsIF9saW1pdFZhbHVlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQgU2NhbGUgZnJvbSAnLi4vY29yZS9jb3JlLnNjYWxlLmpzJztcbmltcG9ydCB7X2FycmF5VW5pcXVlLCBfZmlsdGVyQmV0d2VlbiwgX2xvb2t1cH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbGxlY3Rpb24uanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9jb3JlL2NvcmUuYWRhcHRlcnMuanMnKS5UaW1lVW5pdCB9IFVuaXRcbiAqIEB0eXBlZGVmIHt7Y29tbW9uOiBib29sZWFuLCBzaXplOiBudW1iZXIsIHN0ZXBzPzogbnVtYmVyfX0gSW50ZXJ2YWxcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9jb3JlL2NvcmUuYWRhcHRlcnMuanMnKS5EYXRlQWRhcHRlciB9IERhdGVBZGFwdGVyXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7T2JqZWN0PFVuaXQsIEludGVydmFsPn1cbiAqL1xuY29uc3QgSU5URVJWQUxTID0ge1xuICBtaWxsaXNlY29uZDoge2NvbW1vbjogdHJ1ZSwgc2l6ZTogMSwgc3RlcHM6IDEwMDB9LFxuICBzZWNvbmQ6IHtjb21tb246IHRydWUsIHNpemU6IDEwMDAsIHN0ZXBzOiA2MH0sXG4gIG1pbnV0ZToge2NvbW1vbjogdHJ1ZSwgc2l6ZTogNjAwMDAsIHN0ZXBzOiA2MH0sXG4gIGhvdXI6IHtjb21tb246IHRydWUsIHNpemU6IDM2MDAwMDAsIHN0ZXBzOiAyNH0sXG4gIGRheToge2NvbW1vbjogdHJ1ZSwgc2l6ZTogODY0MDAwMDAsIHN0ZXBzOiAzMH0sXG4gIHdlZWs6IHtjb21tb246IGZhbHNlLCBzaXplOiA2MDQ4MDAwMDAsIHN0ZXBzOiA0fSxcbiAgbW9udGg6IHtjb21tb246IHRydWUsIHNpemU6IDIuNjI4ZTksIHN0ZXBzOiAxMn0sXG4gIHF1YXJ0ZXI6IHtjb21tb246IGZhbHNlLCBzaXplOiA3Ljg4NGU5LCBzdGVwczogNH0sXG4gIHllYXI6IHtjb21tb246IHRydWUsIHNpemU6IDMuMTU0ZTEwfVxufTtcblxuLyoqXG4gKiBAdHlwZSB7VW5pdFtdfVxuICovXG5jb25zdCBVTklUUyA9IC8qKiBAdHlwZSBVbml0W10gKi8gLyogI19fUFVSRV9fICovIChPYmplY3Qua2V5cyhJTlRFUlZBTFMpKTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IGJcbiAqL1xuZnVuY3Rpb24gc29ydGVyKGEsIGIpIHtcbiAgcmV0dXJuIGEgLSBiO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGltZVNjYWxlfSBzY2FsZVxuICogQHBhcmFtIHsqfSBpbnB1dFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBwYXJzZShzY2FsZSwgaW5wdXQpIHtcbiAgaWYgKGlzTnVsbE9yVW5kZWYoaW5wdXQpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBhZGFwdGVyID0gc2NhbGUuX2FkYXB0ZXI7XG4gIGNvbnN0IHtwYXJzZXIsIHJvdW5kLCBpc29XZWVrZGF5fSA9IHNjYWxlLl9wYXJzZU9wdHM7XG4gIGxldCB2YWx1ZSA9IGlucHV0O1xuXG4gIGlmICh0eXBlb2YgcGFyc2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFsdWUgPSBwYXJzZXIodmFsdWUpO1xuICB9XG5cbiAgLy8gT25seSBwYXJzZSBpZiBpdCdzIG5vdCBhIHRpbWVzdGFtcCBhbHJlYWR5XG4gIGlmICghaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgdmFsdWUgPSB0eXBlb2YgcGFyc2VyID09PSAnc3RyaW5nJ1xuICAgICAgPyBhZGFwdGVyLnBhcnNlKHZhbHVlLCAvKiogQHR5cGUge1VuaXR9ICovIChwYXJzZXIpKVxuICAgICAgOiBhZGFwdGVyLnBhcnNlKHZhbHVlKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHJvdW5kKSB7XG4gICAgdmFsdWUgPSByb3VuZCA9PT0gJ3dlZWsnICYmIChpc051bWJlcihpc29XZWVrZGF5KSB8fCBpc29XZWVrZGF5ID09PSB0cnVlKVxuICAgICAgPyBhZGFwdGVyLnN0YXJ0T2YodmFsdWUsICdpc29XZWVrJywgaXNvV2Vla2RheSlcbiAgICAgIDogYWRhcHRlci5zdGFydE9mKHZhbHVlLCByb3VuZCk7XG4gIH1cblxuICByZXR1cm4gK3ZhbHVlO1xufVxuXG4vKipcbiAqIEZpZ3VyZXMgb3V0IHdoYXQgdW5pdCByZXN1bHRzIGluIGFuIGFwcHJvcHJpYXRlIG51bWJlciBvZiBhdXRvLWdlbmVyYXRlZCB0aWNrc1xuICogQHBhcmFtIHtVbml0fSBtaW5Vbml0XG4gKiBAcGFyYW0ge251bWJlcn0gbWluXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gKiBAcGFyYW0ge251bWJlcn0gY2FwYWNpdHlcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyhtaW5Vbml0LCBtaW4sIG1heCwgY2FwYWNpdHkpIHtcbiAgY29uc3QgaWxlbiA9IFVOSVRTLmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gVU5JVFMuaW5kZXhPZihtaW5Vbml0KTsgaSA8IGlsZW4gLSAxOyArK2kpIHtcbiAgICBjb25zdCBpbnRlcnZhbCA9IElOVEVSVkFMU1tVTklUU1tpXV07XG4gICAgY29uc3QgZmFjdG9yID0gaW50ZXJ2YWwuc3RlcHMgPyBpbnRlcnZhbC5zdGVwcyA6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuXG4gICAgaWYgKGludGVydmFsLmNvbW1vbiAmJiBNYXRoLmNlaWwoKG1heCAtIG1pbikgLyAoZmFjdG9yICogaW50ZXJ2YWwuc2l6ZSkpIDw9IGNhcGFjaXR5KSB7XG4gICAgICByZXR1cm4gVU5JVFNbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFVOSVRTW2lsZW4gLSAxXTtcbn1cblxuLyoqXG4gKiBGaWd1cmVzIG91dCB3aGF0IHVuaXQgdG8gZm9ybWF0IGEgc2V0IG9mIHRpY2tzIHdpdGhcbiAqIEBwYXJhbSB7VGltZVNjYWxlfSBzY2FsZVxuICogQHBhcmFtIHtudW1iZXJ9IG51bVRpY2tzXG4gKiBAcGFyYW0ge1VuaXR9IG1pblVuaXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAqIEByZXR1cm4ge1VuaXR9XG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nKHNjYWxlLCBudW1UaWNrcywgbWluVW5pdCwgbWluLCBtYXgpIHtcbiAgZm9yIChsZXQgaSA9IFVOSVRTLmxlbmd0aCAtIDE7IGkgPj0gVU5JVFMuaW5kZXhPZihtaW5Vbml0KTsgaS0tKSB7XG4gICAgY29uc3QgdW5pdCA9IFVOSVRTW2ldO1xuICAgIGlmIChJTlRFUlZBTFNbdW5pdF0uY29tbW9uICYmIHNjYWxlLl9hZGFwdGVyLmRpZmYobWF4LCBtaW4sIHVuaXQpID49IG51bVRpY2tzIC0gMSkge1xuICAgICAgcmV0dXJuIHVuaXQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFVOSVRTW21pblVuaXQgPyBVTklUUy5pbmRleE9mKG1pblVuaXQpIDogMF07XG59XG5cbi8qKlxuICogQHBhcmFtIHtVbml0fSB1bml0XG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZU1ham9yVW5pdCh1bml0KSB7XG4gIGZvciAobGV0IGkgPSBVTklUUy5pbmRleE9mKHVuaXQpICsgMSwgaWxlbiA9IFVOSVRTLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGlmIChJTlRFUlZBTFNbVU5JVFNbaV1dLmNvbW1vbikge1xuICAgICAgcmV0dXJuIFVOSVRTW2ldO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSB0aWNrc1xuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVcbiAqIEBwYXJhbSB7bnVtYmVyW119IFt0aW1lc3RhbXBzXSAtIGlmIGRlZmluZWQsIHNuYXAgdG8gdGhlc2UgdGltZXN0YW1wc1xuICovXG5mdW5jdGlvbiBhZGRUaWNrKHRpY2tzLCB0aW1lLCB0aW1lc3RhbXBzKSB7XG4gIGlmICghdGltZXN0YW1wcykge1xuICAgIHRpY2tzW3RpbWVdID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgIGNvbnN0IHtsbywgaGl9ID0gX2xvb2t1cCh0aW1lc3RhbXBzLCB0aW1lKTtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSB0aW1lc3RhbXBzW2xvXSA+PSB0aW1lID8gdGltZXN0YW1wc1tsb10gOiB0aW1lc3RhbXBzW2hpXTtcbiAgICB0aWNrc1t0aW1lc3RhbXBdID0gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VGltZVNjYWxlfSBzY2FsZVxuICogQHBhcmFtIHtvYmplY3RbXX0gdGlja3NcbiAqIEBwYXJhbSB7b2JqZWN0fSBtYXBcbiAqIEBwYXJhbSB7VW5pdH0gbWFqb3JVbml0XG4gKiBAcmV0dXJuIHtvYmplY3RbXX1cbiAqL1xuZnVuY3Rpb24gc2V0TWFqb3JUaWNrcyhzY2FsZSwgdGlja3MsIG1hcCwgbWFqb3JVbml0KSB7XG4gIGNvbnN0IGFkYXB0ZXIgPSBzY2FsZS5fYWRhcHRlcjtcbiAgY29uc3QgZmlyc3QgPSArYWRhcHRlci5zdGFydE9mKHRpY2tzWzBdLnZhbHVlLCBtYWpvclVuaXQpO1xuICBjb25zdCBsYXN0ID0gdGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWU7XG4gIGxldCBtYWpvciwgaW5kZXg7XG5cbiAgZm9yIChtYWpvciA9IGZpcnN0OyBtYWpvciA8PSBsYXN0OyBtYWpvciA9ICthZGFwdGVyLmFkZChtYWpvciwgMSwgbWFqb3JVbml0KSkge1xuICAgIGluZGV4ID0gbWFwW21ham9yXTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdGlja3NbaW5kZXhdLm1ham9yID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRpY2tzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGltZVNjYWxlfSBzY2FsZVxuICogQHBhcmFtIHtudW1iZXJbXX0gdmFsdWVzXG4gKiBAcGFyYW0ge1VuaXR8dW5kZWZpbmVkfSBbbWFqb3JVbml0XVxuICogQHJldHVybiB7b2JqZWN0W119XG4gKi9cbmZ1bmN0aW9uIHRpY2tzRnJvbVRpbWVzdGFtcHMoc2NhbGUsIHZhbHVlcywgbWFqb3JVbml0KSB7XG4gIGNvbnN0IHRpY2tzID0gW107XG4gIC8qKiBAdHlwZSB7T2JqZWN0PG51bWJlcixvYmplY3Q+fSAqL1xuICBjb25zdCBtYXAgPSB7fTtcbiAgY29uc3QgaWxlbiA9IHZhbHVlcy5sZW5ndGg7XG4gIGxldCBpLCB2YWx1ZTtcblxuICBmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgbWFwW3ZhbHVlXSA9IGk7XG5cbiAgICB0aWNrcy5wdXNoKHtcbiAgICAgIHZhbHVlLFxuICAgICAgbWFqb3I6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxuICAvLyBXZSBzZXQgdGhlIG1ham9yIHRpY2tzIHNlcGFyYXRlbHkgZnJvbSB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIGNhbGxpbmcgc3RhcnRPZiBmb3IgZXZlcnkgdGlja1xuICAvLyBpcyBleHBlbnNpdmUgd2hlbiB0aGVyZSBpcyBhIGxhcmdlIG51bWJlciBvZiB0aWNrc1xuICByZXR1cm4gKGlsZW4gPT09IDAgfHwgIW1ham9yVW5pdCkgPyB0aWNrcyA6IHNldE1ham9yVGlja3Moc2NhbGUsIHRpY2tzLCBtYXAsIG1ham9yVW5pdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbWVTY2FsZSBleHRlbmRzIFNjYWxlIHtcblxuICBzdGF0aWMgaWQgPSAndGltZSc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgLyoqXG4gICAgICogU2NhbGUgYm91bmRhcnkgc3RyYXRlZ3kgKGJ5cGFzc2VkIGJ5IG1pbi9tYXggdGltZSBvcHRpb25zKVxuICAgICAqIC0gYGRhdGFgOiBtYWtlIHN1cmUgZGF0YSBhcmUgZnVsbHkgdmlzaWJsZSwgdGlja3Mgb3V0c2lkZSBhcmUgcmVtb3ZlZFxuICAgICAqIC0gYHRpY2tzYDogbWFrZSBzdXJlIHRpY2tzIGFyZSBmdWxseSB2aXNpYmxlLCBkYXRhIG91dHNpZGUgYXJlIHRydW5jYXRlZFxuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvcHVsbC80NTU2XG4gICAgICogQHNpbmNlIDIuNy4wXG4gICAgICovXG4gICAgYm91bmRzOiAnZGF0YScsXG5cbiAgICBhZGFwdGVyczoge30sXG4gICAgdGltZToge1xuICAgICAgcGFyc2VyOiBmYWxzZSwgLy8gZmFsc2UgPT0gYSBwYXR0ZXJuIHN0cmluZyBmcm9tIG9yIGEgY3VzdG9tIGNhbGxiYWNrIHRoYXQgY29udmVydHMgaXRzIGFyZ3VtZW50IHRvIGEgdGltZXN0YW1wXG4gICAgICB1bml0OiBmYWxzZSwgLy8gZmFsc2UgPT0gYXV0b21hdGljIG9yIG92ZXJyaWRlIHdpdGggd2VlaywgbW9udGgsIHllYXIsIGV0Yy5cbiAgICAgIHJvdW5kOiBmYWxzZSwgLy8gbm9uZSwgb3Igb3ZlcnJpZGUgd2l0aCB3ZWVrLCBtb250aCwgeWVhciwgZXRjLlxuICAgICAgaXNvV2Vla2RheTogZmFsc2UsIC8vIG92ZXJyaWRlIHdlZWsgc3RhcnQgZGF5XG4gICAgICBtaW5Vbml0OiAnbWlsbGlzZWNvbmQnLFxuICAgICAgZGlzcGxheUZvcm1hdHM6IHt9XG4gICAgfSxcbiAgICB0aWNrczoge1xuICAgICAgLyoqXG4gICAgICAgKiBUaWNrcyBnZW5lcmF0aW9uIGlucHV0IHZhbHVlczpcbiAgICAgICAqIC0gJ2F1dG8nOiBnZW5lcmF0ZXMgXCJvcHRpbWFsXCIgdGlja3MgYmFzZWQgb24gc2NhbGUgc2l6ZSBhbmQgdGltZSBvcHRpb25zLlxuICAgICAgICogLSAnZGF0YSc6IGdlbmVyYXRlcyB0aWNrcyBmcm9tIGRhdGEgKGluY2x1ZGluZyBsYWJlbHMgZnJvbSBkYXRhIHt0fHh8eX0gb2JqZWN0cykuXG4gICAgICAgKiAtICdsYWJlbHMnOiBnZW5lcmF0ZXMgdGlja3MgZnJvbSB1c2VyIGdpdmVuIGBkYXRhLmxhYmVsc2AgdmFsdWVzIE9OTFkuXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDUwN1xuICAgICAgICogQHNpbmNlIDIuNy4wXG4gICAgICAgKi9cbiAgICAgIHNvdXJjZTogJ2F1dG8nLFxuXG4gICAgICBjYWxsYmFjazogZmFsc2UsXG5cbiAgICAgIG1ham9yOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcblx0ICovXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgLyoqIEB0eXBlIHt7ZGF0YTogbnVtYmVyW10sIGxhYmVsczogbnVtYmVyW10sIGFsbDogbnVtYmVyW119fSAqL1xuICAgIHRoaXMuX2NhY2hlID0ge1xuICAgICAgZGF0YTogW10sXG4gICAgICBsYWJlbHM6IFtdLFxuICAgICAgYWxsOiBbXVxuICAgIH07XG5cbiAgICAvKiogQHR5cGUge1VuaXR9ICovXG4gICAgdGhpcy5fdW5pdCA9ICdkYXknO1xuICAgIC8qKiBAdHlwZSB7VW5pdD19ICovXG4gICAgdGhpcy5fbWFqb3JVbml0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX29mZnNldHMgPSB7fTtcbiAgICB0aGlzLl9ub3JtYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5fcGFyc2VPcHRzID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaW5pdChzY2FsZU9wdHMsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHRpbWUgPSBzY2FsZU9wdHMudGltZSB8fCAoc2NhbGVPcHRzLnRpbWUgPSB7fSk7XG4gICAgLyoqIEB0eXBlIHtEYXRlQWRhcHRlcn0gKi9cbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlciA9IG5ldyBhZGFwdGVycy5fZGF0ZShzY2FsZU9wdHMuYWRhcHRlcnMuZGF0ZSk7XG5cbiAgICBhZGFwdGVyLmluaXQob3B0cyk7XG5cbiAgICAvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5OiBiZWZvcmUgaW50cm9kdWNpbmcgYWRhcHRlciwgYGRpc3BsYXlGb3JtYXRzYCB3YXNcbiAgICAvLyBzdXBwb3NlZCB0byBjb250YWluICphbGwqIHVuaXQvc3RyaW5nIHBhaXJzIGJ1dCB0aGlzIGNhbid0IGJlIHJlc29sdmVkXG4gICAgLy8gd2hlbiBsb2FkaW5nIHRoZSBzY2FsZSAoYWRhcHRlcnMgYXJlIGxvYWRlZCBhZnRlcndhcmQpLCBzbyBsZXQncyBwb3B1bGF0ZVxuICAgIC8vIG1pc3NpbmcgZm9ybWF0cyBvbiB1cGRhdGVcbiAgICBtZXJnZUlmKHRpbWUuZGlzcGxheUZvcm1hdHMsIGFkYXB0ZXIuZm9ybWF0cygpKTtcblxuICAgIHRoaXMuX3BhcnNlT3B0cyA9IHtcbiAgICAgIHBhcnNlcjogdGltZS5wYXJzZXIsXG4gICAgICByb3VuZDogdGltZS5yb3VuZCxcbiAgICAgIGlzb1dlZWtkYXk6IHRpbWUuaXNvV2Vla2RheVxuICAgIH07XG5cbiAgICBzdXBlci5pbml0KHNjYWxlT3B0cyk7XG5cbiAgICB0aGlzLl9ub3JtYWxpemVkID0gb3B0cy5ub3JtYWxpemVkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7Kn0gcmF3XG5cdCAqIEBwYXJhbSB7bnVtYmVyP30gW2luZGV4XVxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBwYXJzZShyYXcsIGluZGV4KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBpZiAocmF3ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2UodGhpcywgcmF3KTtcbiAgfVxuXG4gIGJlZm9yZUxheW91dCgpIHtcbiAgICBzdXBlci5iZWZvcmVMYXlvdXQoKTtcbiAgICB0aGlzLl9jYWNoZSA9IHtcbiAgICAgIGRhdGE6IFtdLFxuICAgICAgbGFiZWxzOiBbXSxcbiAgICAgIGFsbDogW11cbiAgICB9O1xuICB9XG5cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyO1xuICAgIGNvbnN0IHVuaXQgPSBvcHRpb25zLnRpbWUudW5pdCB8fCAnZGF5JztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgbGV0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcblxuICAgIC8qKlxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBib3VuZHNcblx0XHQgKi9cbiAgICBmdW5jdGlvbiBfYXBwbHlCb3VuZHMoYm91bmRzKSB7XG4gICAgICBpZiAoIW1pbkRlZmluZWQgJiYgIWlzTmFOKGJvdW5kcy5taW4pKSB7XG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgYm91bmRzLm1pbik7XG4gICAgICB9XG4gICAgICBpZiAoIW1heERlZmluZWQgJiYgIWlzTmFOKGJvdW5kcy5tYXgpKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgYm91bmRzLm1heCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgaGF2ZSB1c2VyIHByb3ZpZGVkIGBtaW5gIGFuZCBgbWF4YCBsYWJlbHMgLyBkYXRhIGJvdW5kcyBjYW4gYmUgaWdub3JlZFxuICAgIGlmICghbWluRGVmaW5lZCB8fCAhbWF4RGVmaW5lZCkge1xuICAgICAgLy8gTGFiZWxzIGFyZSBhbHdheXMgY29uc2lkZXJlZCwgd2hlbiB1c2VyIGRpZCBub3QgZm9yY2UgYm91bmRzXG4gICAgICBfYXBwbHlCb3VuZHModGhpcy5fZ2V0TGFiZWxCb3VuZHMoKSk7XG5cbiAgICAgIC8vIElmIGBib3VuZHNgIGlzIGAndGlja3MnYCBhbmQgYHRpY2tzLnNvdXJjZWAgaXMgYCdsYWJlbHMnYCxcbiAgICAgIC8vIGRhdGEgYm91bmRzIGFyZSBpZ25vcmVkIChhbmQgZG9uJ3QgbmVlZCB0byBiZSBkZXRlcm1pbmVkKVxuICAgICAgaWYgKG9wdGlvbnMuYm91bmRzICE9PSAndGlja3MnIHx8IG9wdGlvbnMudGlja3Muc291cmNlICE9PSAnbGFiZWxzJykge1xuICAgICAgICBfYXBwbHlCb3VuZHModGhpcy5nZXRNaW5NYXgoZmFsc2UpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtaW4gPSBpc0Zpbml0ZShtaW4pICYmICFpc05hTihtaW4pID8gbWluIDogK2FkYXB0ZXIuc3RhcnRPZihEYXRlLm5vdygpLCB1bml0KTtcbiAgICBtYXggPSBpc0Zpbml0ZShtYXgpICYmICFpc05hTihtYXgpID8gbWF4IDogK2FkYXB0ZXIuZW5kT2YoRGF0ZS5ub3coKSwgdW5pdCkgKyAxO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgbWF4IGlzIHN0cmljdGx5IGhpZ2hlciB0aGFuIG1pbiAocmVxdWlyZWQgYnkgdGhlIHRpbWVzZXJpZXMgbG9va3VwIHRhYmxlKVxuICAgIHRoaXMubWluID0gTWF0aC5taW4obWluLCBtYXggLSAxKTtcbiAgICB0aGlzLm1heCA9IE1hdGgubWF4KG1pbiArIDEsIG1heCk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRMYWJlbEJvdW5kcygpIHtcbiAgICBjb25zdCBhcnIgPSB0aGlzLmdldExhYmVsVGltZXN0YW1wcygpO1xuICAgIGxldCBtaW4gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IG1heCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcblxuICAgIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgICBtaW4gPSBhcnJbMF07XG4gICAgICBtYXggPSBhcnJbYXJyLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4ge21pbiwgbWF4fTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtvYmplY3RbXX1cblx0ICovXG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aW1lT3B0cyA9IG9wdGlvbnMudGltZTtcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdGlvbnMudGlja3M7XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IHRpY2tPcHRzLnNvdXJjZSA9PT0gJ2xhYmVscycgPyB0aGlzLmdldExhYmVsVGltZXN0YW1wcygpIDogdGhpcy5fZ2VuZXJhdGUoKTtcblxuICAgIGlmIChvcHRpb25zLmJvdW5kcyA9PT0gJ3RpY2tzJyAmJiB0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgdGhpcy5taW4gPSB0aGlzLl91c2VyTWluIHx8IHRpbWVzdGFtcHNbMF07XG4gICAgICB0aGlzLm1heCA9IHRoaXMuX3VzZXJNYXggfHwgdGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluO1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuXG4gICAgY29uc3QgdGlja3MgPSBfZmlsdGVyQmV0d2Vlbih0aW1lc3RhbXBzLCBtaW4sIG1heCk7XG5cbiAgICAvLyBQUklWQVRFXG4gICAgLy8gZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmcgcmVsaWVzIG9uIHRoZSBudW1iZXIgb2YgdGlja3Mgc28gd2UgZG9uJ3QgdXNlIGl0IHdoZW5cbiAgICAvLyBhdXRvU2tpcCBpcyBlbmFibGVkIGJlY2F1c2Ugd2UgZG9uJ3QgeWV0IGtub3cgd2hhdCB0aGUgZmluYWwgbnVtYmVyIG9mIHRpY2tzIHdpbGwgYmVcbiAgICB0aGlzLl91bml0ID0gdGltZU9wdHMudW5pdCB8fCAodGlja09wdHMuYXV0b1NraXBcbiAgICAgID8gZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyh0aW1lT3B0cy5taW5Vbml0LCB0aGlzLm1pbiwgdGhpcy5tYXgsIHRoaXMuX2dldExhYmVsQ2FwYWNpdHkobWluKSlcbiAgICAgIDogZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmcodGhpcywgdGlja3MubGVuZ3RoLCB0aW1lT3B0cy5taW5Vbml0LCB0aGlzLm1pbiwgdGhpcy5tYXgpKTtcbiAgICB0aGlzLl9tYWpvclVuaXQgPSAhdGlja09wdHMubWFqb3IuZW5hYmxlZCB8fCB0aGlzLl91bml0ID09PSAneWVhcicgPyB1bmRlZmluZWRcbiAgICAgIDogZGV0ZXJtaW5lTWFqb3JVbml0KHRoaXMuX3VuaXQpO1xuICAgIHRoaXMuaW5pdE9mZnNldHModGltZXN0YW1wcyk7XG5cbiAgICBpZiAob3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICB0aWNrcy5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRpY2tzRnJvbVRpbWVzdGFtcHModGhpcywgdGlja3MsIHRoaXMuX21ham9yVW5pdCk7XG4gIH1cblxuICBhZnRlckF1dG9Ta2lwKCkge1xuICAgIC8vIE9mZnNldHMgZm9yIGJhciBjaGFydHMgbmVlZCB0byBiZSBoYW5kbGVkIHdpdGggdGhlIGF1dG8gc2tpcHBlZFxuICAgIC8vIHRpY2tzLiBPbmNlIHRpY2tzIGhhdmUgYmVlbiBza2lwcGVkLCB3ZSByZS1jb21wdXRlIHRoZSBvZmZzZXRzLlxuICAgIGlmICh0aGlzLm9wdGlvbnMub2Zmc2V0QWZ0ZXJBdXRvc2tpcCkge1xuICAgICAgdGhpcy5pbml0T2Zmc2V0cyh0aGlzLnRpY2tzLm1hcCh0aWNrID0+ICt0aWNrLnZhbHVlKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIHN0YXJ0IGFuZCBlbmQgb2Zmc2V0cyBmcm9tIGVkZ2VzIGluIHRoZSBmb3JtIG9mIHtzdGFydCwgZW5kfVxuXHQgKiB3aGVyZSBlYWNoIHZhbHVlIGlzIGEgcmVsYXRpdmUgd2lkdGggdG8gdGhlIHNjYWxlIGFuZCByYW5nZXMgYmV0d2VlbiAwIGFuZCAxLlxuXHQgKiBUaGV5IGFkZCBleHRyYSBtYXJnaW5zIG9uIHRoZSBib3RoIHNpZGVzIGJ5IHNjYWxpbmcgZG93biB0aGUgb3JpZ2luYWwgc2NhbGUuXG5cdCAqIE9mZnNldHMgYXJlIGFkZGVkIHdoZW4gdGhlIGBvZmZzZXRgIG9wdGlvbiBpcyB0cnVlLlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSB0aW1lc3RhbXBzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGluaXRPZmZzZXRzKHRpbWVzdGFtcHMgPSBbXSkge1xuICAgIGxldCBzdGFydCA9IDA7XG4gICAgbGV0IGVuZCA9IDA7XG4gICAgbGV0IGZpcnN0LCBsYXN0O1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5vZmZzZXQgJiYgdGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIGZpcnN0ID0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1swXSk7XG4gICAgICBpZiAodGltZXN0YW1wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgc3RhcnQgPSAxIC0gZmlyc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydCA9ICh0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzWzFdKSAtIGZpcnN0KSAvIDI7XG4gICAgICB9XG4gICAgICBsYXN0ID0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdKTtcbiAgICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBlbmQgPSBsYXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gKGxhc3QgLSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMl0pKSAvIDI7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxpbWl0ID0gdGltZXN0YW1wcy5sZW5ndGggPCAzID8gMC41IDogMC4yNTtcbiAgICBzdGFydCA9IF9saW1pdFZhbHVlKHN0YXJ0LCAwLCBsaW1pdCk7XG4gICAgZW5kID0gX2xpbWl0VmFsdWUoZW5kLCAwLCBsaW1pdCk7XG5cbiAgICB0aGlzLl9vZmZzZXRzID0ge3N0YXJ0LCBlbmQsIGZhY3RvcjogMSAvIChzdGFydCArIDEgKyBlbmQpfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZW5lcmF0ZXMgYSBtYXhpbXVtIG9mIGBjYXBhY2l0eWAgdGltZXN0YW1wcyBiZXR3ZWVuIG1pbiBhbmQgbWF4LCByb3VuZGVkIHRvIHRoZVxuXHQgKiBgbWlub3JgIHVuaXQgdXNpbmcgdGhlIGdpdmVuIHNjYWxlIHRpbWUgYG9wdGlvbnNgLlxuXHQgKiBJbXBvcnRhbnQ6IHRoaXMgbWV0aG9kIGNhbiByZXR1cm4gdGlja3Mgb3V0c2lkZSB0aGUgbWluIGFuZCBtYXggcmFuZ2UsIGl0J3MgdGhlXG5cdCAqIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBjYWxsaW5nIGNvZGUgdG8gY2xhbXAgdmFsdWVzIGlmIG5lZWRlZC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgX2dlbmVyYXRlKCkge1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyO1xuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluO1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGltZU9wdHMgPSBvcHRpb25zLnRpbWU7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IG1pbm9yID0gdGltZU9wdHMudW5pdCB8fCBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKHRpbWVPcHRzLm1pblVuaXQsIG1pbiwgbWF4LCB0aGlzLl9nZXRMYWJlbENhcGFjaXR5KG1pbikpO1xuICAgIGNvbnN0IHN0ZXBTaXplID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy50aWNrcy5zdGVwU2l6ZSwgMSk7XG4gICAgY29uc3Qgd2Vla2RheSA9IG1pbm9yID09PSAnd2VlaycgPyB0aW1lT3B0cy5pc29XZWVrZGF5IDogZmFsc2U7XG4gICAgY29uc3QgaGFzV2Vla2RheSA9IGlzTnVtYmVyKHdlZWtkYXkpIHx8IHdlZWtkYXkgPT09IHRydWU7XG4gICAgY29uc3QgdGlja3MgPSB7fTtcbiAgICBsZXQgZmlyc3QgPSBtaW47XG4gICAgbGV0IHRpbWUsIGNvdW50O1xuXG4gICAgLy8gRm9yICd3ZWVrJyB1bml0LCBoYW5kbGUgdGhlIGZpcnN0IGRheSBvZiB3ZWVrIG9wdGlvblxuICAgIGlmIChoYXNXZWVrZGF5KSB7XG4gICAgICBmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YoZmlyc3QsICdpc29XZWVrJywgd2Vla2RheSk7XG4gICAgfVxuXG4gICAgLy8gQWxpZ24gZmlyc3QgdGlja3Mgb24gdW5pdFxuICAgIGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZihmaXJzdCwgaGFzV2Vla2RheSA/ICdkYXknIDogbWlub3IpO1xuXG4gICAgLy8gUHJldmVudCBicm93c2VyIGZyb20gZnJlZXppbmcgaW4gY2FzZSB1c2VyIG9wdGlvbnMgcmVxdWVzdCBtaWxsaW9ucyBvZiBtaWxsaXNlY29uZHNcbiAgICBpZiAoYWRhcHRlci5kaWZmKG1heCwgbWluLCBtaW5vcikgPiAxMDAwMDAgKiBzdGVwU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1pbiArICcgYW5kICcgKyBtYXggKyAnIGFyZSB0b28gZmFyIGFwYXJ0IHdpdGggc3RlcFNpemUgb2YgJyArIHN0ZXBTaXplICsgJyAnICsgbWlub3IpO1xuICAgIH1cblxuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSBvcHRpb25zLnRpY2tzLnNvdXJjZSA9PT0gJ2RhdGEnICYmIHRoaXMuZ2V0RGF0YVRpbWVzdGFtcHMoKTtcbiAgICBmb3IgKHRpbWUgPSBmaXJzdCwgY291bnQgPSAwOyB0aW1lIDwgbWF4OyB0aW1lID0gK2FkYXB0ZXIuYWRkKHRpbWUsIHN0ZXBTaXplLCBtaW5vciksIGNvdW50KyspIHtcbiAgICAgIGFkZFRpY2sodGlja3MsIHRpbWUsIHRpbWVzdGFtcHMpO1xuICAgIH1cblxuICAgIGlmICh0aW1lID09PSBtYXggfHwgb3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycgfHwgY291bnQgPT09IDEpIHtcbiAgICAgIGFkZFRpY2sodGlja3MsIHRpbWUsIHRpbWVzdGFtcHMpO1xuICAgIH1cblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGlja3MpLnNvcnQoc29ydGVyKS5tYXAoeCA9PiAreCk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlcjtcbiAgICBjb25zdCB0aW1lT3B0cyA9IHRoaXMub3B0aW9ucy50aW1lO1xuXG4gICAgaWYgKHRpbWVPcHRzLnRvb2x0aXBGb3JtYXQpIHtcbiAgICAgIHJldHVybiBhZGFwdGVyLmZvcm1hdCh2YWx1ZSwgdGltZU9wdHMudG9vbHRpcEZvcm1hdCk7XG4gICAgfVxuICAgIHJldHVybiBhZGFwdGVyLmZvcm1hdCh2YWx1ZSwgdGltZU9wdHMuZGlzcGxheUZvcm1hdHMuZGF0ZXRpbWUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuXHQgKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IGZvcm1hdFxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuICBmb3JtYXQodmFsdWUsIGZvcm1hdCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgZm9ybWF0cyA9IG9wdGlvbnMudGltZS5kaXNwbGF5Rm9ybWF0cztcbiAgICBjb25zdCB1bml0ID0gdGhpcy5fdW5pdDtcbiAgICBjb25zdCBmbXQgPSBmb3JtYXQgfHwgZm9ybWF0c1t1bml0XTtcbiAgICByZXR1cm4gdGhpcy5fYWRhcHRlci5mb3JtYXQodmFsdWUsIGZtdCk7XG4gIH1cblxuICAvKipcblx0ICogRnVuY3Rpb24gdG8gZm9ybWF0IGFuIGluZGl2aWR1YWwgdGljayBtYXJrXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuXHQgKiBAcGFyYW0ge29iamVjdFtdfSB0aWNrc1xuXHQgKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IFtmb3JtYXRdXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF90aWNrRm9ybWF0RnVuY3Rpb24odGltZSwgaW5kZXgsIHRpY2tzLCBmb3JtYXQpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGZvcm1hdHRlciA9IG9wdGlvbnMudGlja3MuY2FsbGJhY2s7XG5cbiAgICBpZiAoZm9ybWF0dGVyKSB7XG4gICAgICByZXR1cm4gY2FsbChmb3JtYXR0ZXIsIFt0aW1lLCBpbmRleCwgdGlja3NdLCB0aGlzKTtcbiAgICB9XG5cbiAgICBjb25zdCBmb3JtYXRzID0gb3B0aW9ucy50aW1lLmRpc3BsYXlGb3JtYXRzO1xuICAgIGNvbnN0IHVuaXQgPSB0aGlzLl91bml0O1xuICAgIGNvbnN0IG1ham9yVW5pdCA9IHRoaXMuX21ham9yVW5pdDtcbiAgICBjb25zdCBtaW5vckZvcm1hdCA9IHVuaXQgJiYgZm9ybWF0c1t1bml0XTtcbiAgICBjb25zdCBtYWpvckZvcm1hdCA9IG1ham9yVW5pdCAmJiBmb3JtYXRzW21ham9yVW5pdF07XG4gICAgY29uc3QgdGljayA9IHRpY2tzW2luZGV4XTtcbiAgICBjb25zdCBtYWpvciA9IG1ham9yVW5pdCAmJiBtYWpvckZvcm1hdCAmJiB0aWNrICYmIHRpY2subWFqb3I7XG5cbiAgICByZXR1cm4gdGhpcy5fYWRhcHRlci5mb3JtYXQodGltZSwgZm9ybWF0IHx8IChtYWpvciA/IG1ham9yRm9ybWF0IDogbWlub3JGb3JtYXQpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge29iamVjdFtdfSB0aWNrc1xuXHQgKi9cbiAgZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKSB7XG4gICAgbGV0IGksIGlsZW4sIHRpY2s7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aWNrID0gdGlja3NbaV07XG4gICAgICB0aWNrLmxhYmVsID0gdGhpcy5fdGlja0Zvcm1hdEZ1bmN0aW9uKHRpY2sudmFsdWUsIGksIHRpY2tzKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gTWlsbGlzZWNvbmRzIHNpbmNlIGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldERlY2ltYWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IE5hTiA6ICh2YWx1ZSAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBNaWxsaXNlY29uZHMgc2luY2UgZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQylcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLl9vZmZzZXRzO1xuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwoKG9mZnNldHMuc3RhcnQgKyBwb3MpICogb2Zmc2V0cy5mYWN0b3IpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuX29mZnNldHM7XG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpIC8gb2Zmc2V0cy5mYWN0b3IgLSBvZmZzZXRzLmVuZDtcbiAgICByZXR1cm4gdGhpcy5taW4gKyBwb3MgKiAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsXG5cdCAqIEByZXR1cm4ge3t3Om51bWJlciwgaDpudW1iZXJ9fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldExhYmVsU2l6ZShsYWJlbCkge1xuICAgIGNvbnN0IHRpY2tzT3B0cyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICBjb25zdCB0aWNrTGFiZWxXaWR0aCA9IHRoaXMuY3R4Lm1lYXN1cmVUZXh0KGxhYmVsKS53aWR0aDtcbiAgICBjb25zdCBhbmdsZSA9IHRvUmFkaWFucyh0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGlja3NPcHRzLm1heFJvdGF0aW9uIDogdGlja3NPcHRzLm1pblJvdGF0aW9uKTtcbiAgICBjb25zdCBjb3NSb3RhdGlvbiA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICBjb25zdCBzaW5Sb3RhdGlvbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICBjb25zdCB0aWNrRm9udFNpemUgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKDApLnNpemU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdzogKHRpY2tMYWJlbFdpZHRoICogY29zUm90YXRpb24pICsgKHRpY2tGb250U2l6ZSAqIHNpblJvdGF0aW9uKSxcbiAgICAgIGg6ICh0aWNrTGFiZWxXaWR0aCAqIHNpblJvdGF0aW9uKSArICh0aWNrRm9udFNpemUgKiBjb3NSb3RhdGlvbilcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBleGFtcGxlVGltZVxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0TGFiZWxDYXBhY2l0eShleGFtcGxlVGltZSkge1xuICAgIGNvbnN0IHRpbWVPcHRzID0gdGhpcy5vcHRpb25zLnRpbWU7XG4gICAgY29uc3QgZGlzcGxheUZvcm1hdHMgPSB0aW1lT3B0cy5kaXNwbGF5Rm9ybWF0cztcblxuICAgIC8vIHBpY2sgdGhlIGxvbmdlc3QgZm9ybWF0IChtaWxsaXNlY29uZHMpIGZvciBndWVzc3RpbWF0aW9uXG4gICAgY29uc3QgZm9ybWF0ID0gZGlzcGxheUZvcm1hdHNbdGltZU9wdHMudW5pdF0gfHwgZGlzcGxheUZvcm1hdHMubWlsbGlzZWNvbmQ7XG4gICAgY29uc3QgZXhhbXBsZUxhYmVsID0gdGhpcy5fdGlja0Zvcm1hdEZ1bmN0aW9uKGV4YW1wbGVUaW1lLCAwLCB0aWNrc0Zyb21UaW1lc3RhbXBzKHRoaXMsIFtleGFtcGxlVGltZV0sIHRoaXMuX21ham9yVW5pdCksIGZvcm1hdCk7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuX2dldExhYmVsU2l6ZShleGFtcGxlTGFiZWwpO1xuICAgIC8vIHN1YnRyYWN0IDEgLSBpZiBvZmZzZXQgdGhlbiB0aGVyZSdzIG9uZSBsZXNzIGxhYmVsIHRoYW4gdGlja1xuICAgIC8vIGlmIG5vdCBvZmZzZXQgdGhlbiBvbmUgaGFsZiBsYWJlbCBwYWRkaW5nIGlzIGFkZGVkIHRvIGVhY2ggZW5kIGxlYXZpbmcgcm9vbSBmb3Igb25lIGxlc3MgbGFiZWxcbiAgICBjb25zdCBjYXBhY2l0eSA9IE1hdGguZmxvb3IodGhpcy5pc0hvcml6b250YWwoKSA/IHRoaXMud2lkdGggLyBzaXplLncgOiB0aGlzLmhlaWdodCAvIHNpemUuaCkgLSAxO1xuICAgIHJldHVybiBjYXBhY2l0eSA+IDAgPyBjYXBhY2l0eSA6IDE7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0RGF0YVRpbWVzdGFtcHMoKSB7XG4gICAgbGV0IHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5kYXRhIHx8IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuXG4gICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICB9XG5cbiAgICBjb25zdCBtZXRhcyA9IHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKTtcblxuICAgIGlmICh0aGlzLl9ub3JtYWxpemVkICYmIG1ldGFzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuICh0aGlzLl9jYWNoZS5kYXRhID0gbWV0YXNbMF0uY29udHJvbGxlci5nZXRBbGxQYXJzZWRWYWx1ZXModGhpcykpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRpbWVzdGFtcHMgPSB0aW1lc3RhbXBzLmNvbmNhdChtZXRhc1tpXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyh0aGlzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICh0aGlzLl9jYWNoZS5kYXRhID0gdGhpcy5ub3JtYWxpemUodGltZXN0YW1wcykpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldExhYmVsVGltZXN0YW1wcygpIHtcbiAgICBjb25zdCB0aW1lc3RhbXBzID0gdGhpcy5fY2FjaGUubGFiZWxzIHx8IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuXG4gICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICB9XG5cbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBsYWJlbHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aW1lc3RhbXBzLnB1c2gocGFyc2UodGhpcywgbGFiZWxzW2ldKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICh0aGlzLl9jYWNoZS5sYWJlbHMgPSB0aGlzLl9ub3JtYWxpemVkID8gdGltZXN0YW1wcyA6IHRoaXMubm9ybWFsaXplKHRpbWVzdGFtcHMpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSB2YWx1ZXNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgbm9ybWFsaXplKHZhbHVlcykge1xuICAgIC8vIEl0IHNlZW1zIHRvIGJlIHNvbWV3aGF0IGZhc3RlciB0byBkbyBzb3J0aW5nIGZpcnN0XG4gICAgcmV0dXJuIF9hcnJheVVuaXF1ZSh2YWx1ZXMuc29ydChzb3J0ZXIpKTtcbiAgfVxufVxuIiwgImltcG9ydCBUaW1lU2NhbGUgZnJvbSAnLi9zY2FsZS50aW1lLmpzJztcbmltcG9ydCB7X2xvb2t1cEJ5S2V5fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29sbGVjdGlvbi5qcyc7XG5cbi8qKlxuICogTGluZWFybHkgaW50ZXJwb2xhdGVzIHRoZSBnaXZlbiBzb3VyY2UgYHZhbGAgdXNpbmcgdGhlIHRhYmxlLiBJZiB2YWx1ZSBpcyBvdXQgb2YgYm91bmRzLCB2YWx1ZXNcbiAqIGF0IGVkZ2VzIGFyZSB1c2VkIGZvciB0aGUgaW50ZXJwb2xhdGlvbi5cbiAqIEBwYXJhbSB7b2JqZWN0fSB0YWJsZVxuICogQHBhcmFtIHtudW1iZXJ9IHZhbFxuICogQHBhcmFtIHtib29sZWFufSBbcmV2ZXJzZV0gbG9va3VwIHRpbWUgYmFzZWQgb24gcG9zaXRpb24gaW5zdGVhZCBvZiB2aWNlIHZlcnNhXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGludGVycG9sYXRlKHRhYmxlLCB2YWwsIHJldmVyc2UpIHtcbiAgbGV0IGxvID0gMDtcbiAgbGV0IGhpID0gdGFibGUubGVuZ3RoIC0gMTtcbiAgbGV0IHByZXZTb3VyY2UsIG5leHRTb3VyY2UsIHByZXZUYXJnZXQsIG5leHRUYXJnZXQ7XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgaWYgKHZhbCA+PSB0YWJsZVtsb10ucG9zICYmIHZhbCA8PSB0YWJsZVtoaV0ucG9zKSB7XG4gICAgICAoe2xvLCBoaX0gPSBfbG9va3VwQnlLZXkodGFibGUsICdwb3MnLCB2YWwpKTtcbiAgICB9XG4gICAgKHtwb3M6IHByZXZTb3VyY2UsIHRpbWU6IHByZXZUYXJnZXR9ID0gdGFibGVbbG9dKTtcbiAgICAoe3BvczogbmV4dFNvdXJjZSwgdGltZTogbmV4dFRhcmdldH0gPSB0YWJsZVtoaV0pO1xuICB9IGVsc2Uge1xuICAgIGlmICh2YWwgPj0gdGFibGVbbG9dLnRpbWUgJiYgdmFsIDw9IHRhYmxlW2hpXS50aW1lKSB7XG4gICAgICAoe2xvLCBoaX0gPSBfbG9va3VwQnlLZXkodGFibGUsICd0aW1lJywgdmFsKSk7XG4gICAgfVxuICAgICh7dGltZTogcHJldlNvdXJjZSwgcG9zOiBwcmV2VGFyZ2V0fSA9IHRhYmxlW2xvXSk7XG4gICAgKHt0aW1lOiBuZXh0U291cmNlLCBwb3M6IG5leHRUYXJnZXR9ID0gdGFibGVbaGldKTtcbiAgfVxuXG4gIGNvbnN0IHNwYW4gPSBuZXh0U291cmNlIC0gcHJldlNvdXJjZTtcbiAgcmV0dXJuIHNwYW4gPyBwcmV2VGFyZ2V0ICsgKG5leHRUYXJnZXQgLSBwcmV2VGFyZ2V0KSAqICh2YWwgLSBwcmV2U291cmNlKSAvIHNwYW4gOiBwcmV2VGFyZ2V0O1xufVxuXG5jbGFzcyBUaW1lU2VyaWVzU2NhbGUgZXh0ZW5kcyBUaW1lU2NhbGUge1xuXG4gIHN0YXRpYyBpZCA9ICd0aW1lc2VyaWVzJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IFRpbWVTY2FsZS5kZWZhdWx0cztcblxuICAvKipcblx0ICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG5cdCAqL1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcblxuICAgIC8qKiBAdHlwZSB7b2JqZWN0W119ICovXG4gICAgdGhpcy5fdGFibGUgPSBbXTtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLl9taW5Qb3MgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fdGFibGVSYW5nZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBpbml0T2Zmc2V0cygpIHtcbiAgICBjb25zdCB0aW1lc3RhbXBzID0gdGhpcy5fZ2V0VGltZXN0YW1wc0ZvclRhYmxlKCk7XG4gICAgY29uc3QgdGFibGUgPSB0aGlzLl90YWJsZSA9IHRoaXMuYnVpbGRMb29rdXBUYWJsZSh0aW1lc3RhbXBzKTtcbiAgICB0aGlzLl9taW5Qb3MgPSBpbnRlcnBvbGF0ZSh0YWJsZSwgdGhpcy5taW4pO1xuICAgIHRoaXMuX3RhYmxlUmFuZ2UgPSBpbnRlcnBvbGF0ZSh0YWJsZSwgdGhpcy5tYXgpIC0gdGhpcy5fbWluUG9zO1xuICAgIHN1cGVyLmluaXRPZmZzZXRzKHRpbWVzdGFtcHMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgYW4gYXJyYXkgb2Yge3RpbWUsIHBvc30gb2JqZWN0cyB1c2VkIHRvIGludGVycG9sYXRlIGEgc3BlY2lmaWMgYHRpbWVgIG9yIHBvc2l0aW9uXG5cdCAqIChgcG9zYCkgb24gdGhlIHNjYWxlLCBieSBzZWFyY2hpbmcgZW50cmllcyBiZWZvcmUgYW5kIGFmdGVyIHRoZSByZXF1ZXN0ZWQgdmFsdWUuIGBwb3NgIGlzXG5cdCAqIGEgZGVjaW1hbCBiZXR3ZWVuIDAgYW5kIDE6IDAgYmVpbmcgdGhlIHN0YXJ0IG9mIHRoZSBzY2FsZSAobGVmdCBvciB0b3ApIGFuZCAxIHRoZSBvdGhlclxuXHQgKiBleHRyZW1pdHkgKGxlZnQgKyB3aWR0aCBvciB0b3AgKyBoZWlnaHQpLiBOb3RlIHRoYXQgaXQgd291bGQgYmUgbW9yZSBvcHRpbWl6ZWQgdG8gZGlyZWN0bHlcblx0ICogc3RvcmUgcHJlLWNvbXB1dGVkIHBpeGVscywgYnV0IHRoZSBzY2FsZSBkaW1lbnNpb25zIGFyZSBub3QgZ3VhcmFudGVlZCBhdCB0aGUgdGltZSB3ZSBuZWVkXG5cdCAqIHRvIGNyZWF0ZSB0aGUgbG9va3VwIHRhYmxlLiBUaGUgdGFibGUgQUxXQVlTIGNvbnRhaW5zIGF0IGxlYXN0IHR3byBpdGVtczogbWluIGFuZCBtYXguXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IHRpbWVzdGFtcHNcblx0ICogQHJldHVybiB7b2JqZWN0W119XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGJ1aWxkTG9va3VwVGFibGUodGltZXN0YW1wcykge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzO1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgY29uc3QgdGFibGUgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgcHJldiwgY3VyciwgbmV4dDtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aW1lc3RhbXBzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY3VyciA9IHRpbWVzdGFtcHNbaV07XG4gICAgICBpZiAoY3VyciA+PSBtaW4gJiYgY3VyciA8PSBtYXgpIHtcbiAgICAgICAgaXRlbXMucHVzaChjdXJyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXRlbXMubGVuZ3RoIDwgMikge1xuICAgICAgLy8gSW4gY2FzZSB0aGVyZSBpcyBsZXNzIHRoYXQgMiB0aW1lc3RhbXBzIGJldHdlZW4gbWluIGFuZCBtYXgsIHRoZSBzY2FsZSBpcyBkZWZpbmVkIGJ5IG1pbiBhbmQgbWF4XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7dGltZTogbWluLCBwb3M6IDB9LFxuICAgICAgICB7dGltZTogbWF4LCBwb3M6IDF9XG4gICAgICBdO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIG5leHQgPSBpdGVtc1tpICsgMV07XG4gICAgICBwcmV2ID0gaXRlbXNbaSAtIDFdO1xuICAgICAgY3VyciA9IGl0ZW1zW2ldO1xuXG4gICAgICAvLyBvbmx5IGFkZCBwb2ludHMgdGhhdCBicmVha3MgdGhlIHNjYWxlIGxpbmVhcml0eVxuICAgICAgaWYgKE1hdGgucm91bmQoKG5leHQgKyBwcmV2KSAvIDIpICE9PSBjdXJyKSB7XG4gICAgICAgIHRhYmxlLnB1c2goe3RpbWU6IGN1cnIsIHBvczogaSAvIChpbGVuIC0gMSl9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhYmxlO1xuICB9XG5cbiAgLyoqXG4gICAgKiBHZW5lcmF0ZXMgYWxsIHRpbWVzdGFtcHMgZGVmaW5lZCBpbiB0aGUgZGF0YS5cbiAgICAqIEltcG9ydGFudDogdGhpcyBtZXRob2QgY2FuIHJldHVybiB0aWNrcyBvdXRzaWRlIHRoZSBtaW4gYW5kIG1heCByYW5nZSwgaXQncyB0aGVcbiAgICAqIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBjYWxsaW5nIGNvZGUgdG8gY2xhbXAgdmFsdWVzIGlmIG5lZWRlZC5cbiAgICAqIEBwcm90ZWN0ZWRcbiAgICAqL1xuICBfZ2VuZXJhdGUoKSB7XG4gICAgY29uc3QgbWluID0gdGhpcy5taW47XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXg7XG4gICAgbGV0IHRpbWVzdGFtcHMgPSBzdXBlci5nZXREYXRhVGltZXN0YW1wcygpO1xuICAgIGlmICghdGltZXN0YW1wcy5pbmNsdWRlcyhtaW4pIHx8ICF0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgdGltZXN0YW1wcy5zcGxpY2UoMCwgMCwgbWluKTtcbiAgICB9XG4gICAgaWYgKCF0aW1lc3RhbXBzLmluY2x1ZGVzKG1heCkgfHwgdGltZXN0YW1wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRpbWVzdGFtcHMucHVzaChtYXgpO1xuICAgIH1cbiAgICByZXR1cm4gdGltZXN0YW1wcy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyBhbGwgdGltZXN0YW1wc1xuXHQgKiBAcmV0dXJuIHtudW1iZXJbXX1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRUaW1lc3RhbXBzRm9yVGFibGUoKSB7XG4gICAgbGV0IHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5hbGwgfHwgW107XG5cbiAgICBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdldERhdGFUaW1lc3RhbXBzKCk7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLmdldExhYmVsVGltZXN0YW1wcygpO1xuICAgIGlmIChkYXRhLmxlbmd0aCAmJiBsYWJlbC5sZW5ndGgpIHtcbiAgICAgIC8vIElmIGNvbWJpbmluZyBsYWJlbHMgYW5kIGRhdGEgKGRhdGEgbWlnaHQgbm90IGNvbnRhaW4gYWxsIGxhYmVscyksXG4gICAgICAvLyB3ZSBuZWVkIHRvIHJlY2hlY2sgdW5pcXVlbmVzcyBhbmQgc29ydFxuICAgICAgdGltZXN0YW1wcyA9IHRoaXMubm9ybWFsaXplKGRhdGEuY29uY2F0KGxhYmVsKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVzdGFtcHMgPSBkYXRhLmxlbmd0aCA/IGRhdGEgOiBsYWJlbDtcbiAgICB9XG4gICAgdGltZXN0YW1wcyA9IHRoaXMuX2NhY2hlLmFsbCA9IHRpbWVzdGFtcHM7XG5cbiAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBNaWxsaXNlY29uZHMgc2luY2UgZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQylcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0RGVjaW1hbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIChpbnRlcnBvbGF0ZSh0aGlzLl90YWJsZSwgdmFsdWUpIC0gdGhpcy5fbWluUG9zKSAvIHRoaXMuX3RhYmxlUmFuZ2U7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5fb2Zmc2V0cztcbiAgICBjb25zdCBkZWNpbWFsID0gdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpIC8gb2Zmc2V0cy5mYWN0b3IgLSBvZmZzZXRzLmVuZDtcbiAgICByZXR1cm4gaW50ZXJwb2xhdGUodGhpcy5fdGFibGUsIGRlY2ltYWwgKiB0aGlzLl90YWJsZVJhbmdlICsgdGhpcy5fbWluUG9zLCB0cnVlKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUaW1lU2VyaWVzU2NhbGU7XG4iLCAiZXhwb3J0ICogZnJvbSAnLi9jb250cm9sbGVycy9pbmRleC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2NvcmUvaW5kZXguanMnO1xuZXhwb3J0ICogZnJvbSAnLi9lbGVtZW50cy9pbmRleC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3BsYXRmb3JtL2luZGV4LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vcGx1Z2lucy9pbmRleC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3NjYWxlcy9pbmRleC5qcyc7XG5cbmltcG9ydCAqIGFzIGNvbnRyb2xsZXJzIGZyb20gJy4vY29udHJvbGxlcnMvaW5kZXguanMnO1xuaW1wb3J0ICogYXMgZWxlbWVudHMgZnJvbSAnLi9lbGVtZW50cy9pbmRleC5qcyc7XG5pbXBvcnQgKiBhcyBwbHVnaW5zIGZyb20gJy4vcGx1Z2lucy9pbmRleC5qcyc7XG5pbXBvcnQgKiBhcyBzY2FsZXMgZnJvbSAnLi9zY2FsZXMvaW5kZXguanMnO1xuXG5leHBvcnQge1xuICBjb250cm9sbGVycyxcbiAgZWxlbWVudHMsXG4gIHBsdWdpbnMsXG4gIHNjYWxlcyxcbn07XG5cbmV4cG9ydCBjb25zdCByZWdpc3RlcmFibGVzID0gW1xuICBjb250cm9sbGVycyxcbiAgZWxlbWVudHMsXG4gIHBsdWdpbnMsXG4gIHNjYWxlcyxcbl07XG4iLCAiLyohXG4gKiBAa3Vya2xlL2NvbG9yIHYwLjMuMlxuICogaHR0cHM6Ly9naXRodWIuY29tL2t1cmtsZS9jb2xvciNyZWFkbWVcbiAqIChjKSAyMDIzIEp1a2thIEt1cmtlbGFcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG5mdW5jdGlvbiByb3VuZCh2KSB7XG4gIHJldHVybiB2ICsgMC41IHwgMDtcbn1cbmNvbnN0IGxpbSA9ICh2LCBsLCBoKSA9PiBNYXRoLm1heChNYXRoLm1pbih2LCBoKSwgbCk7XG5mdW5jdGlvbiBwMmIodikge1xuICByZXR1cm4gbGltKHJvdW5kKHYgKiAyLjU1KSwgMCwgMjU1KTtcbn1cbmZ1bmN0aW9uIGIycCh2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAvIDIuNTUpLCAwLCAxMDApO1xufVxuZnVuY3Rpb24gbjJiKHYpIHtcbiAgcmV0dXJuIGxpbShyb3VuZCh2ICogMjU1KSwgMCwgMjU1KTtcbn1cbmZ1bmN0aW9uIGIybih2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAvIDIuNTUpIC8gMTAwLCAwLCAxKTtcbn1cbmZ1bmN0aW9uIG4ycCh2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAqIDEwMCksIDAsIDEwMCk7XG59XG5cbmNvbnN0IG1hcCQxID0gezA6IDAsIDE6IDEsIDI6IDIsIDM6IDMsIDQ6IDQsIDU6IDUsIDY6IDYsIDc6IDcsIDg6IDgsIDk6IDksIEE6IDEwLCBCOiAxMSwgQzogMTIsIEQ6IDEzLCBFOiAxNCwgRjogMTUsIGE6IDEwLCBiOiAxMSwgYzogMTIsIGQ6IDEzLCBlOiAxNCwgZjogMTV9O1xuY29uc3QgaGV4ID0gWy4uLicwMTIzNDU2Nzg5QUJDREVGJ107XG5jb25zdCBoMSA9IGIgPT4gaGV4W2IgJiAweEZdO1xuY29uc3QgaDIgPSBiID0+IGhleFsoYiAmIDB4RjApID4+IDRdICsgaGV4W2IgJiAweEZdO1xuY29uc3QgZXEgPSBiID0+ICgoYiAmIDB4RjApID4+IDQpID09PSAoYiAmIDB4Rik7XG5jb25zdCBpc1Nob3J0ID0gdiA9PiBlcSh2LnIpICYmIGVxKHYuZykgJiYgZXEodi5iKSAmJiBlcSh2LmEpO1xuZnVuY3Rpb24gaGV4UGFyc2Uoc3RyKSB7XG4gIHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuICB2YXIgcmV0O1xuICBpZiAoc3RyWzBdID09PSAnIycpIHtcbiAgICBpZiAobGVuID09PSA0IHx8IGxlbiA9PT0gNSkge1xuICAgICAgcmV0ID0ge1xuICAgICAgICByOiAyNTUgJiBtYXAkMVtzdHJbMV1dICogMTcsXG4gICAgICAgIGc6IDI1NSAmIG1hcCQxW3N0clsyXV0gKiAxNyxcbiAgICAgICAgYjogMjU1ICYgbWFwJDFbc3RyWzNdXSAqIDE3LFxuICAgICAgICBhOiBsZW4gPT09IDUgPyBtYXAkMVtzdHJbNF1dICogMTcgOiAyNTVcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDcgfHwgbGVuID09PSA5KSB7XG4gICAgICByZXQgPSB7XG4gICAgICAgIHI6IG1hcCQxW3N0clsxXV0gPDwgNCB8IG1hcCQxW3N0clsyXV0sXG4gICAgICAgIGc6IG1hcCQxW3N0clszXV0gPDwgNCB8IG1hcCQxW3N0cls0XV0sXG4gICAgICAgIGI6IG1hcCQxW3N0cls1XV0gPDwgNCB8IG1hcCQxW3N0cls2XV0sXG4gICAgICAgIGE6IGxlbiA9PT0gOSA/IChtYXAkMVtzdHJbN11dIDw8IDQgfCBtYXAkMVtzdHJbOF1dKSA6IDI1NVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmNvbnN0IGFscGhhID0gKGEsIGYpID0+IGEgPCAyNTUgPyBmKGEpIDogJyc7XG5mdW5jdGlvbiBoZXhTdHJpbmcodikge1xuICB2YXIgZiA9IGlzU2hvcnQodikgPyBoMSA6IGgyO1xuICByZXR1cm4gdlxuICAgID8gJyMnICsgZih2LnIpICsgZih2LmcpICsgZih2LmIpICsgYWxwaGEodi5hLCBmKVxuICAgIDogdW5kZWZpbmVkO1xufVxuXG5jb25zdCBIVUVfUkUgPSAvXihoc2xhP3xod2J8aHN2KVxcKFxccyooWy0rLmVcXGRdKykoPzpkZWcpP1tcXHMsXSsoWy0rLmVcXGRdKyklW1xccyxdKyhbLSsuZVxcZF0rKSUoPzpbXFxzLF0rKFstKy5lXFxkXSspKCUpPyk/XFxzKlxcKSQvO1xuZnVuY3Rpb24gaHNsMnJnYm4oaCwgcywgbCkge1xuICBjb25zdCBhID0gcyAqIE1hdGgubWluKGwsIDEgLSBsKTtcbiAgY29uc3QgZiA9IChuLCBrID0gKG4gKyBoIC8gMzApICUgMTIpID0+IGwgLSBhICogTWF0aC5tYXgoTWF0aC5taW4oayAtIDMsIDkgLSBrLCAxKSwgLTEpO1xuICByZXR1cm4gW2YoMCksIGYoOCksIGYoNCldO1xufVxuZnVuY3Rpb24gaHN2MnJnYm4oaCwgcywgdikge1xuICBjb25zdCBmID0gKG4sIGsgPSAobiArIGggLyA2MCkgJSA2KSA9PiB2IC0gdiAqIHMgKiBNYXRoLm1heChNYXRoLm1pbihrLCA0IC0gaywgMSksIDApO1xuICByZXR1cm4gW2YoNSksIGYoMyksIGYoMSldO1xufVxuZnVuY3Rpb24gaHdiMnJnYm4oaCwgdywgYikge1xuICBjb25zdCByZ2IgPSBoc2wycmdibihoLCAxLCAwLjUpO1xuICBsZXQgaTtcbiAgaWYgKHcgKyBiID4gMSkge1xuICAgIGkgPSAxIC8gKHcgKyBiKTtcbiAgICB3ICo9IGk7XG4gICAgYiAqPSBpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICByZ2JbaV0gKj0gMSAtIHcgLSBiO1xuICAgIHJnYltpXSArPSB3O1xuICB9XG4gIHJldHVybiByZ2I7XG59XG5mdW5jdGlvbiBodWVWYWx1ZShyLCBnLCBiLCBkLCBtYXgpIHtcbiAgaWYgKHIgPT09IG1heCkge1xuICAgIHJldHVybiAoKGcgLSBiKSAvIGQpICsgKGcgPCBiID8gNiA6IDApO1xuICB9XG4gIGlmIChnID09PSBtYXgpIHtcbiAgICByZXR1cm4gKGIgLSByKSAvIGQgKyAyO1xuICB9XG4gIHJldHVybiAociAtIGcpIC8gZCArIDQ7XG59XG5mdW5jdGlvbiByZ2IyaHNsKHYpIHtcbiAgY29uc3QgcmFuZ2UgPSAyNTU7XG4gIGNvbnN0IHIgPSB2LnIgLyByYW5nZTtcbiAgY29uc3QgZyA9IHYuZyAvIHJhbmdlO1xuICBjb25zdCBiID0gdi5iIC8gcmFuZ2U7XG4gIGNvbnN0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICBjb25zdCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgY29uc3QgbCA9IChtYXggKyBtaW4pIC8gMjtcbiAgbGV0IGgsIHMsIGQ7XG4gIGlmIChtYXggIT09IG1pbikge1xuICAgIGQgPSBtYXggLSBtaW47XG4gICAgcyA9IGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pO1xuICAgIGggPSBodWVWYWx1ZShyLCBnLCBiLCBkLCBtYXgpO1xuICAgIGggPSBoICogNjAgKyAwLjU7XG4gIH1cbiAgcmV0dXJuIFtoIHwgMCwgcyB8fCAwLCBsXTtcbn1cbmZ1bmN0aW9uIGNhbGxuKGYsIGEsIGIsIGMpIHtcbiAgcmV0dXJuIChcbiAgICBBcnJheS5pc0FycmF5KGEpXG4gICAgICA/IGYoYVswXSwgYVsxXSwgYVsyXSlcbiAgICAgIDogZihhLCBiLCBjKVxuICApLm1hcChuMmIpO1xufVxuZnVuY3Rpb24gaHNsMnJnYihoLCBzLCBsKSB7XG4gIHJldHVybiBjYWxsbihoc2wycmdibiwgaCwgcywgbCk7XG59XG5mdW5jdGlvbiBod2IycmdiKGgsIHcsIGIpIHtcbiAgcmV0dXJuIGNhbGxuKGh3YjJyZ2JuLCBoLCB3LCBiKTtcbn1cbmZ1bmN0aW9uIGhzdjJyZ2IoaCwgcywgdikge1xuICByZXR1cm4gY2FsbG4oaHN2MnJnYm4sIGgsIHMsIHYpO1xufVxuZnVuY3Rpb24gaHVlKGgpIHtcbiAgcmV0dXJuIChoICUgMzYwICsgMzYwKSAlIDM2MDtcbn1cbmZ1bmN0aW9uIGh1ZVBhcnNlKHN0cikge1xuICBjb25zdCBtID0gSFVFX1JFLmV4ZWMoc3RyKTtcbiAgbGV0IGEgPSAyNTU7XG4gIGxldCB2O1xuICBpZiAoIW0pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG1bNV0gIT09IHYpIHtcbiAgICBhID0gbVs2XSA/IHAyYigrbVs1XSkgOiBuMmIoK21bNV0pO1xuICB9XG4gIGNvbnN0IGggPSBodWUoK21bMl0pO1xuICBjb25zdCBwMSA9ICttWzNdIC8gMTAwO1xuICBjb25zdCBwMiA9ICttWzRdIC8gMTAwO1xuICBpZiAobVsxXSA9PT0gJ2h3YicpIHtcbiAgICB2ID0gaHdiMnJnYihoLCBwMSwgcDIpO1xuICB9IGVsc2UgaWYgKG1bMV0gPT09ICdoc3YnKSB7XG4gICAgdiA9IGhzdjJyZ2IoaCwgcDEsIHAyKTtcbiAgfSBlbHNlIHtcbiAgICB2ID0gaHNsMnJnYihoLCBwMSwgcDIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgcjogdlswXSxcbiAgICBnOiB2WzFdLFxuICAgIGI6IHZbMl0sXG4gICAgYTogYVxuICB9O1xufVxuZnVuY3Rpb24gcm90YXRlKHYsIGRlZykge1xuICB2YXIgaCA9IHJnYjJoc2wodik7XG4gIGhbMF0gPSBodWUoaFswXSArIGRlZyk7XG4gIGggPSBoc2wycmdiKGgpO1xuICB2LnIgPSBoWzBdO1xuICB2LmcgPSBoWzFdO1xuICB2LmIgPSBoWzJdO1xufVxuZnVuY3Rpb24gaHNsU3RyaW5nKHYpIHtcbiAgaWYgKCF2KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGEgPSByZ2IyaHNsKHYpO1xuICBjb25zdCBoID0gYVswXTtcbiAgY29uc3QgcyA9IG4ycChhWzFdKTtcbiAgY29uc3QgbCA9IG4ycChhWzJdKTtcbiAgcmV0dXJuIHYuYSA8IDI1NVxuICAgID8gYGhzbGEoJHtofSwgJHtzfSUsICR7bH0lLCAke2Iybih2LmEpfSlgXG4gICAgOiBgaHNsKCR7aH0sICR7c30lLCAke2x9JSlgO1xufVxuXG5jb25zdCBtYXAgPSB7XG4gIHg6ICdkYXJrJyxcbiAgWjogJ2xpZ2h0JyxcbiAgWTogJ3JlJyxcbiAgWDogJ2JsdScsXG4gIFc6ICdncicsXG4gIFY6ICdtZWRpdW0nLFxuICBVOiAnc2xhdGUnLFxuICBBOiAnZWUnLFxuICBUOiAnb2wnLFxuICBTOiAnb3InLFxuICBCOiAncmEnLFxuICBDOiAnbGF0ZWcnLFxuICBEOiAnaWdodHMnLFxuICBSOiAnaW4nLFxuICBROiAndHVycXVvaXMnLFxuICBFOiAnaGknLFxuICBQOiAncm8nLFxuICBPOiAnYWwnLFxuICBOOiAnbGUnLFxuICBNOiAnZGUnLFxuICBMOiAneWVsbG8nLFxuICBGOiAnZW4nLFxuICBLOiAnY2gnLFxuICBHOiAnYXJrcycsXG4gIEg6ICdlYScsXG4gIEk6ICdpZ2h0ZycsXG4gIEo6ICd3aCdcbn07XG5jb25zdCBuYW1lcyQxID0ge1xuICBPaWNlWGU6ICdmMGY4ZmYnLFxuICBhbnRpcXVld0V0ZTogJ2ZhZWJkNycsXG4gIGFxdWE6ICdmZmZmJyxcbiAgYXF1YW1hclJlOiAnN2ZmZmQ0JyxcbiAgYXp1WTogJ2YwZmZmZicsXG4gIGJlaWdlOiAnZjVmNWRjJyxcbiAgYmlzcXVlOiAnZmZlNGM0JyxcbiAgYmxhY2s6ICcwJyxcbiAgYmxhbktlZE9tb25kOiAnZmZlYmNkJyxcbiAgWGU6ICdmZicsXG4gIFhldmlUZXQ6ICc4YTJiZTInLFxuICBiUHduOiAnYTUyYTJhJyxcbiAgYnVybHl3b29kOiAnZGViODg3JyxcbiAgY2FNdFhlOiAnNWY5ZWEwJyxcbiAgS2FydFl1c2U6ICc3ZmZmMDAnLFxuICBLb2NUYXRlOiAnZDI2OTFlJyxcbiAgY1NPOiAnZmY3ZjUwJyxcbiAgY1NuZmxvd2VyWGU6ICc2NDk1ZWQnLFxuICBjU25zaWxrOiAnZmZmOGRjJyxcbiAgY3JpbXNvbjogJ2RjMTQzYycsXG4gIGN5YW46ICdmZmZmJyxcbiAgeFhlOiAnOGInLFxuICB4Y3lhbjogJzhiOGInLFxuICB4Z1RNblBkOiAnYjg4NjBiJyxcbiAgeFdheTogJ2E5YTlhOScsXG4gIHhnWUY6ICc2NDAwJyxcbiAgeGdZeTogJ2E5YTlhOScsXG4gIHhraGFraTogJ2JkYjc2YicsXG4gIHhtYWdGdGE6ICc4YjAwOGInLFxuICB4VGl2ZWdZRjogJzU1NmIyZicsXG4gIHhTYW5nZTogJ2ZmOGMwMCcsXG4gIHhTY0VkOiAnOTkzMmNjJyxcbiAgeFlkOiAnOGIwMDAwJyxcbiAgeHNPbW9uOiAnZTk5NjdhJyxcbiAgeHNIZ1lGOiAnOGZiYzhmJyxcbiAgeFVYZTogJzQ4M2Q4YicsXG4gIHhVV2F5OiAnMmY0ZjRmJyxcbiAgeFVnWXk6ICcyZjRmNGYnLFxuICB4UWU6ICdjZWQxJyxcbiAgeHZpVGV0OiAnOTQwMGQzJyxcbiAgZEFwcFJrOiAnZmYxNDkzJyxcbiAgZEFwc2t5WGU6ICdiZmZmJyxcbiAgZGltV2F5OiAnNjk2OTY5JyxcbiAgZGltZ1l5OiAnNjk2OTY5JyxcbiAgZG9kZ2VyWGU6ICcxZTkwZmYnLFxuICBmaVlicmljazogJ2IyMjIyMicsXG4gIGZsU093RXRlOiAnZmZmYWYwJyxcbiAgZm9Zc3RXQW46ICcyMjhiMjInLFxuICBmdUtzaWE6ICdmZjAwZmYnLFxuICBnYVJzYlNvOiAnZGNkY2RjJyxcbiAgZ2hvc3R3RXRlOiAnZjhmOGZmJyxcbiAgZ1RkOiAnZmZkNzAwJyxcbiAgZ1RNblBkOiAnZGFhNTIwJyxcbiAgV2F5OiAnODA4MDgwJyxcbiAgZ1lGOiAnODAwMCcsXG4gIGdZRkx3OiAnYWRmZjJmJyxcbiAgZ1l5OiAnODA4MDgwJyxcbiAgaG9uZXlNdzogJ2YwZmZmMCcsXG4gIGhvdHBSazogJ2ZmNjliNCcsXG4gIFJkaWFuWWQ6ICdjZDVjNWMnLFxuICBSZGlnbzogJzRiMDA4MicsXG4gIGl2U3k6ICdmZmZmZjAnLFxuICBraGFraTogJ2YwZTY4YycsXG4gIGxhdkZNcjogJ2U2ZTZmYScsXG4gIGxhdkZNclhzaDogJ2ZmZjBmNScsXG4gIGxhd25nWUY6ICc3Y2ZjMDAnLFxuICBObW9uY0VmZm9uOiAnZmZmYWNkJyxcbiAgWlhlOiAnYWRkOGU2JyxcbiAgWmNTTzogJ2YwODA4MCcsXG4gIFpjeWFuOiAnZTBmZmZmJyxcbiAgWmdUTW5QZEx3OiAnZmFmYWQyJyxcbiAgWldheTogJ2QzZDNkMycsXG4gIFpnWUY6ICc5MGVlOTAnLFxuICBaZ1l5OiAnZDNkM2QzJyxcbiAgWnBSazogJ2ZmYjZjMScsXG4gIFpzT21vbjogJ2ZmYTA3YScsXG4gIFpzSGdZRjogJzIwYjJhYScsXG4gIFpza3lYZTogJzg3Y2VmYScsXG4gIFpVV2F5OiAnNzc4ODk5JyxcbiAgWlVnWXk6ICc3Nzg4OTknLFxuICBac3RBbFhlOiAnYjBjNGRlJyxcbiAgWkx3OiAnZmZmZmUwJyxcbiAgbGltZTogJ2ZmMDAnLFxuICBsaW1lZ1lGOiAnMzJjZDMyJyxcbiAgbFJGOiAnZmFmMGU2JyxcbiAgbWFnRnRhOiAnZmYwMGZmJyxcbiAgbWFQb246ICc4MDAwMDAnLFxuICBWYXF1YW1hclJlOiAnNjZjZGFhJyxcbiAgVlhlOiAnY2QnLFxuICBWU2NFZDogJ2JhNTVkMycsXG4gIFZwdXJwTjogJzkzNzBkYicsXG4gIFZzSGdZRjogJzNjYjM3MScsXG4gIFZVWGU6ICc3YjY4ZWUnLFxuICBWc3ByUmdnWUY6ICdmYTlhJyxcbiAgVlFlOiAnNDhkMWNjJyxcbiAgVnZpVGV0WWQ6ICdjNzE1ODUnLFxuICBtaWRuaWdodFhlOiAnMTkxOTcwJyxcbiAgbVJ0Y1lhbTogJ2Y1ZmZmYScsXG4gIG1pc3R5UHNlOiAnZmZlNGUxJyxcbiAgbW9jY2FzUjogJ2ZmZTRiNScsXG4gIG5hdmFqb3dFdGU6ICdmZmRlYWQnLFxuICBuYXZ5OiAnODAnLFxuICBUZGxhY2U6ICdmZGY1ZTYnLFxuICBUaXZlOiAnODA4MDAwJyxcbiAgVGl2ZWRCYjogJzZiOGUyMycsXG4gIFNhbmdlOiAnZmZhNTAwJyxcbiAgU2FuZ2VZZDogJ2ZmNDUwMCcsXG4gIFNjRWQ6ICdkYTcwZDYnLFxuICBwT2VnVE1uUGQ6ICdlZWU4YWEnLFxuICBwT2VnWUY6ICc5OGZiOTgnLFxuICBwT2VRZTogJ2FmZWVlZScsXG4gIHBPZXZpVGV0WWQ6ICdkYjcwOTMnLFxuICBwYXBheWF3RXA6ICdmZmVmZDUnLFxuICBwSEtwdWZmOiAnZmZkYWI5JyxcbiAgcGVydTogJ2NkODUzZicsXG4gIHBSazogJ2ZmYzBjYicsXG4gIHBsdW06ICdkZGEwZGQnLFxuICBwb3dNclhlOiAnYjBlMGU2JyxcbiAgcHVycE46ICc4MDAwODAnLFxuICBZYmVjY2FwdXJwTjogJzY2MzM5OScsXG4gIFlkOiAnZmYwMDAwJyxcbiAgUHN5YnJvd246ICdiYzhmOGYnLFxuICBQeU9YZTogJzQxNjllMScsXG4gIHNhZGROYlB3bjogJzhiNDUxMycsXG4gIHNPbW9uOiAnZmE4MDcyJyxcbiAgc2FuZHliUHduOiAnZjRhNDYwJyxcbiAgc0hnWUY6ICcyZThiNTcnLFxuICBzSHNoZWxsOiAnZmZmNWVlJyxcbiAgc2lGbmE6ICdhMDUyMmQnLFxuICBzaWx2ZXI6ICdjMGMwYzAnLFxuICBza3lYZTogJzg3Y2VlYicsXG4gIFVYZTogJzZhNWFjZCcsXG4gIFVXYXk6ICc3MDgwOTAnLFxuICBVZ1l5OiAnNzA4MDkwJyxcbiAgc25vdzogJ2ZmZmFmYScsXG4gIHNwclJnZ1lGOiAnZmY3ZicsXG4gIHN0QWxYZTogJzQ2ODJiNCcsXG4gIHRhbjogJ2QyYjQ4YycsXG4gIHRlTzogJzgwODAnLFxuICB0RXN0TjogJ2Q4YmZkOCcsXG4gIHRvbWF0bzogJ2ZmNjM0NycsXG4gIFFlOiAnNDBlMGQwJyxcbiAgdmlUZXQ6ICdlZTgyZWUnLFxuICBKSHQ6ICdmNWRlYjMnLFxuICB3RXRlOiAnZmZmZmZmJyxcbiAgd0V0ZXNtb2tlOiAnZjVmNWY1JyxcbiAgTHc6ICdmZmZmMDAnLFxuICBMd2dZRjogJzlhY2QzMidcbn07XG5mdW5jdGlvbiB1bnBhY2soKSB7XG4gIGNvbnN0IHVucGFja2VkID0ge307XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhuYW1lcyQxKTtcbiAgY29uc3QgdGtleXMgPSBPYmplY3Qua2V5cyhtYXApO1xuICBsZXQgaSwgaiwgaywgb2ssIG5rO1xuICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIG9rID0gbmsgPSBrZXlzW2ldO1xuICAgIGZvciAoaiA9IDA7IGogPCB0a2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgayA9IHRrZXlzW2pdO1xuICAgICAgbmsgPSBuay5yZXBsYWNlKGssIG1hcFtrXSk7XG4gICAgfVxuICAgIGsgPSBwYXJzZUludChuYW1lcyQxW29rXSwgMTYpO1xuICAgIHVucGFja2VkW25rXSA9IFtrID4+IDE2ICYgMHhGRiwgayA+PiA4ICYgMHhGRiwgayAmIDB4RkZdO1xuICB9XG4gIHJldHVybiB1bnBhY2tlZDtcbn1cblxubGV0IG5hbWVzO1xuZnVuY3Rpb24gbmFtZVBhcnNlKHN0cikge1xuICBpZiAoIW5hbWVzKSB7XG4gICAgbmFtZXMgPSB1bnBhY2soKTtcbiAgICBuYW1lcy50cmFuc3BhcmVudCA9IFswLCAwLCAwLCAwXTtcbiAgfVxuICBjb25zdCBhID0gbmFtZXNbc3RyLnRvTG93ZXJDYXNlKCldO1xuICByZXR1cm4gYSAmJiB7XG4gICAgcjogYVswXSxcbiAgICBnOiBhWzFdLFxuICAgIGI6IGFbMl0sXG4gICAgYTogYS5sZW5ndGggPT09IDQgPyBhWzNdIDogMjU1XG4gIH07XG59XG5cbmNvbnN0IFJHQl9SRSA9IC9ecmdiYT9cXChcXHMqKFstKy5cXGRdKykoJSk/W1xccyxdKyhbLSsuZVxcZF0rKSglKT9bXFxzLF0rKFstKy5lXFxkXSspKCUpPyg/OltcXHMsL10rKFstKy5lXFxkXSspKCUpPyk/XFxzKlxcKSQvO1xuZnVuY3Rpb24gcmdiUGFyc2Uoc3RyKSB7XG4gIGNvbnN0IG0gPSBSR0JfUkUuZXhlYyhzdHIpO1xuICBsZXQgYSA9IDI1NTtcbiAgbGV0IHIsIGcsIGI7XG4gIGlmICghbSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobVs3XSAhPT0gcikge1xuICAgIGNvbnN0IHYgPSArbVs3XTtcbiAgICBhID0gbVs4XSA/IHAyYih2KSA6IGxpbSh2ICogMjU1LCAwLCAyNTUpO1xuICB9XG4gIHIgPSArbVsxXTtcbiAgZyA9ICttWzNdO1xuICBiID0gK21bNV07XG4gIHIgPSAyNTUgJiAobVsyXSA/IHAyYihyKSA6IGxpbShyLCAwLCAyNTUpKTtcbiAgZyA9IDI1NSAmIChtWzRdID8gcDJiKGcpIDogbGltKGcsIDAsIDI1NSkpO1xuICBiID0gMjU1ICYgKG1bNl0gPyBwMmIoYikgOiBsaW0oYiwgMCwgMjU1KSk7XG4gIHJldHVybiB7XG4gICAgcjogcixcbiAgICBnOiBnLFxuICAgIGI6IGIsXG4gICAgYTogYVxuICB9O1xufVxuZnVuY3Rpb24gcmdiU3RyaW5nKHYpIHtcbiAgcmV0dXJuIHYgJiYgKFxuICAgIHYuYSA8IDI1NVxuICAgICAgPyBgcmdiYSgke3Yucn0sICR7di5nfSwgJHt2LmJ9LCAke2Iybih2LmEpfSlgXG4gICAgICA6IGByZ2IoJHt2LnJ9LCAke3YuZ30sICR7di5ifSlgXG4gICk7XG59XG5cbmNvbnN0IHRvID0gdiA9PiB2IDw9IDAuMDAzMTMwOCA/IHYgKiAxMi45MiA6IE1hdGgucG93KHYsIDEuMCAvIDIuNCkgKiAxLjA1NSAtIDAuMDU1O1xuY29uc3QgZnJvbSA9IHYgPT4gdiA8PSAwLjA0MDQ1ID8gdiAvIDEyLjkyIDogTWF0aC5wb3coKHYgKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbmZ1bmN0aW9uIGludGVycG9sYXRlKHJnYjEsIHJnYjIsIHQpIHtcbiAgY29uc3QgciA9IGZyb20oYjJuKHJnYjEucikpO1xuICBjb25zdCBnID0gZnJvbShiMm4ocmdiMS5nKSk7XG4gIGNvbnN0IGIgPSBmcm9tKGIybihyZ2IxLmIpKTtcbiAgcmV0dXJuIHtcbiAgICByOiBuMmIodG8ociArIHQgKiAoZnJvbShiMm4ocmdiMi5yKSkgLSByKSkpLFxuICAgIGc6IG4yYih0byhnICsgdCAqIChmcm9tKGIybihyZ2IyLmcpKSAtIGcpKSksXG4gICAgYjogbjJiKHRvKGIgKyB0ICogKGZyb20oYjJuKHJnYjIuYikpIC0gYikpKSxcbiAgICBhOiByZ2IxLmEgKyB0ICogKHJnYjIuYSAtIHJnYjEuYSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gbW9kSFNMKHYsIGksIHJhdGlvKSB7XG4gIGlmICh2KSB7XG4gICAgbGV0IHRtcCA9IHJnYjJoc2wodik7XG4gICAgdG1wW2ldID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odG1wW2ldICsgdG1wW2ldICogcmF0aW8sIGkgPT09IDAgPyAzNjAgOiAxKSk7XG4gICAgdG1wID0gaHNsMnJnYih0bXApO1xuICAgIHYuciA9IHRtcFswXTtcbiAgICB2LmcgPSB0bXBbMV07XG4gICAgdi5iID0gdG1wWzJdO1xuICB9XG59XG5mdW5jdGlvbiBjbG9uZSh2LCBwcm90bykge1xuICByZXR1cm4gdiA/IE9iamVjdC5hc3NpZ24ocHJvdG8gfHwge30sIHYpIDogdjtcbn1cbmZ1bmN0aW9uIGZyb21PYmplY3QoaW5wdXQpIHtcbiAgdmFyIHYgPSB7cjogMCwgZzogMCwgYjogMCwgYTogMjU1fTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgaWYgKGlucHV0Lmxlbmd0aCA+PSAzKSB7XG4gICAgICB2ID0ge3I6IGlucHV0WzBdLCBnOiBpbnB1dFsxXSwgYjogaW5wdXRbMl0sIGE6IDI1NX07XG4gICAgICBpZiAoaW5wdXQubGVuZ3RoID4gMykge1xuICAgICAgICB2LmEgPSBuMmIoaW5wdXRbM10pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2ID0gY2xvbmUoaW5wdXQsIHtyOiAwLCBnOiAwLCBiOiAwLCBhOiAxfSk7XG4gICAgdi5hID0gbjJiKHYuYSk7XG4gIH1cbiAgcmV0dXJuIHY7XG59XG5mdW5jdGlvbiBmdW5jdGlvblBhcnNlKHN0cikge1xuICBpZiAoc3RyLmNoYXJBdCgwKSA9PT0gJ3InKSB7XG4gICAgcmV0dXJuIHJnYlBhcnNlKHN0cik7XG4gIH1cbiAgcmV0dXJuIGh1ZVBhcnNlKHN0cik7XG59XG5jbGFzcyBDb2xvciB7XG4gIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQ29sb3IpIHtcbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBpbnB1dDtcbiAgICBsZXQgdjtcbiAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHYgPSBmcm9tT2JqZWN0KGlucHV0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2ID0gaGV4UGFyc2UoaW5wdXQpIHx8IG5hbWVQYXJzZShpbnB1dCkgfHwgZnVuY3Rpb25QYXJzZShpbnB1dCk7XG4gICAgfVxuICAgIHRoaXMuX3JnYiA9IHY7XG4gICAgdGhpcy5fdmFsaWQgPSAhIXY7XG4gIH1cbiAgZ2V0IHZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZDtcbiAgfVxuICBnZXQgcmdiKCkge1xuICAgIHZhciB2ID0gY2xvbmUodGhpcy5fcmdiKTtcbiAgICBpZiAodikge1xuICAgICAgdi5hID0gYjJuKHYuYSk7XG4gICAgfVxuICAgIHJldHVybiB2O1xuICB9XG4gIHNldCByZ2Iob2JqKSB7XG4gICAgdGhpcy5fcmdiID0gZnJvbU9iamVjdChvYmopO1xuICB9XG4gIHJnYlN0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWQgPyByZ2JTdHJpbmcodGhpcy5fcmdiKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBoZXhTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkID8gaGV4U3RyaW5nKHRoaXMuX3JnYikgOiB1bmRlZmluZWQ7XG4gIH1cbiAgaHNsU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZCA/IGhzbFN0cmluZyh0aGlzLl9yZ2IpIDogdW5kZWZpbmVkO1xuICB9XG4gIG1peChjb2xvciwgd2VpZ2h0KSB7XG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICBjb25zdCBjMSA9IHRoaXMucmdiO1xuICAgICAgY29uc3QgYzIgPSBjb2xvci5yZ2I7XG4gICAgICBsZXQgdzI7XG4gICAgICBjb25zdCBwID0gd2VpZ2h0ID09PSB3MiA/IDAuNSA6IHdlaWdodDtcbiAgICAgIGNvbnN0IHcgPSAyICogcCAtIDE7XG4gICAgICBjb25zdCBhID0gYzEuYSAtIGMyLmE7XG4gICAgICBjb25zdCB3MSA9ICgodyAqIGEgPT09IC0xID8gdyA6ICh3ICsgYSkgLyAoMSArIHcgKiBhKSkgKyAxKSAvIDIuMDtcbiAgICAgIHcyID0gMSAtIHcxO1xuICAgICAgYzEuciA9IDB4RkYgJiB3MSAqIGMxLnIgKyB3MiAqIGMyLnIgKyAwLjU7XG4gICAgICBjMS5nID0gMHhGRiAmIHcxICogYzEuZyArIHcyICogYzIuZyArIDAuNTtcbiAgICAgIGMxLmIgPSAweEZGICYgdzEgKiBjMS5iICsgdzIgKiBjMi5iICsgMC41O1xuICAgICAgYzEuYSA9IHAgKiBjMS5hICsgKDEgLSBwKSAqIGMyLmE7XG4gICAgICB0aGlzLnJnYiA9IGMxO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpbnRlcnBvbGF0ZShjb2xvciwgdCkge1xuICAgIGlmIChjb2xvcikge1xuICAgICAgdGhpcy5fcmdiID0gaW50ZXJwb2xhdGUodGhpcy5fcmdiLCBjb2xvci5fcmdiLCB0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBDb2xvcih0aGlzLnJnYik7XG4gIH1cbiAgYWxwaGEoYSkge1xuICAgIHRoaXMuX3JnYi5hID0gbjJiKGEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNsZWFyZXIocmF0aW8pIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgcmdiLmEgKj0gMSAtIHJhdGlvO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdyZXlzY2FsZSgpIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgY29uc3QgdmFsID0gcm91bmQocmdiLnIgKiAwLjMgKyByZ2IuZyAqIDAuNTkgKyByZ2IuYiAqIDAuMTEpO1xuICAgIHJnYi5yID0gcmdiLmcgPSByZ2IuYiA9IHZhbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBvcGFxdWVyKHJhdGlvKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5fcmdiO1xuICAgIHJnYi5hICo9IDEgKyByYXRpbztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBuZWdhdGUoKSB7XG4gICAgY29uc3QgdiA9IHRoaXMuX3JnYjtcbiAgICB2LnIgPSAyNTUgLSB2LnI7XG4gICAgdi5nID0gMjU1IC0gdi5nO1xuICAgIHYuYiA9IDI1NSAtIHYuYjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBsaWdodGVuKHJhdGlvKSB7XG4gICAgbW9kSFNMKHRoaXMuX3JnYiwgMiwgcmF0aW8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGRhcmtlbihyYXRpbykge1xuICAgIG1vZEhTTCh0aGlzLl9yZ2IsIDIsIC1yYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2F0dXJhdGUocmF0aW8pIHtcbiAgICBtb2RIU0wodGhpcy5fcmdiLCAxLCByYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZGVzYXR1cmF0ZShyYXRpbykge1xuICAgIG1vZEhTTCh0aGlzLl9yZ2IsIDEsIC1yYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcm90YXRlKGRlZykge1xuICAgIHJvdGF0ZSh0aGlzLl9yZ2IsIGRlZyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhfZXNtKGlucHV0KSB7XG4gIHJldHVybiBuZXcgQ29sb3IoaW5wdXQpO1xufVxuXG5leHBvcnQgeyBDb2xvciwgYjJuLCBiMnAsIGluZGV4X2VzbSBhcyBkZWZhdWx0LCBoZXhQYXJzZSwgaGV4U3RyaW5nLCBoc2wycmdiLCBoc2xTdHJpbmcsIGhzdjJyZ2IsIGh1ZVBhcnNlLCBod2IycmdiLCBsaW0sIG4yYiwgbjJwLCBuYW1lUGFyc2UsIHAyYiwgcmdiMmhzbCwgcmdiUGFyc2UsIHJnYlN0cmluZywgcm90YXRlLCByb3VuZCB9O1xuIiwgIi8qKlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzXG4gKi9cblxuaW1wb3J0IHR5cGUge0FueU9iamVjdH0gZnJvbSAnLi4vdHlwZXMvYmFzaWMuanMnO1xuaW1wb3J0IHR5cGUge0FjdGl2ZURhdGFQb2ludCwgQ2hhcnRFdmVudH0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuXG4vKipcbiAqIEFuIGVtcHR5IGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQsIGZvciBleGFtcGxlLCBmb3Igb3B0aW9uYWwgY2FsbGJhY2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub29wKCkge1xuICAvKiBub29wICovXG59XG5cbi8qKlxuICogUmV0dXJucyBhIHVuaXF1ZSBpZCwgc2VxdWVudGlhbGx5IGdlbmVyYXRlZCBmcm9tIGEgZ2xvYmFsIHZhcmlhYmxlLlxuICovXG5leHBvcnQgY29uc3QgdWlkID0gKCgpID0+IHtcbiAgbGV0IGlkID0gMDtcbiAgcmV0dXJuICgpID0+IGlkKys7XG59KSgpO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIG5laXRoZXIgbnVsbCBub3IgdW5kZWZpbmVkLCBlbHNlIHJldHVybnMgZmFsc2UuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOdWxsT3JVbmRlZih2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIG51bGwgfCB1bmRlZmluZWQge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSAoaW5jbHVkaW5nIHR5cGVkIGFycmF5cyksIGVsc2UgcmV0dXJucyBmYWxzZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FycmF5PFQgPSB1bmtub3duPih2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIFRbXSB7XG4gIGlmIChBcnJheS5pc0FycmF5ICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh0eXBlLnNsaWNlKDAsIDcpID09PSAnW29iamVjdCcgJiYgdHlwZS5zbGljZSgtNikgPT09ICdBcnJheV0nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCAoZXhjbHVkaW5nIG51bGwpLCBlbHNlIHJldHVybnMgZmFsc2UuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBBbnlPYmplY3Qge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgbnVtYmVyLCBlbHNlIHJldHVybnMgZmFsc2VcbiAqIEBwYXJhbSB2YWx1ZSAgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXJGaW5pdGUodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBudW1iZXIge1xuICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpICYmIGlzRmluaXRlKCt2YWx1ZSk7XG59XG5leHBvcnQge1xuICBpc051bWJlckZpbml0ZSBhcyBpc0Zpbml0ZSxcbn07XG5cbi8qKlxuICogUmV0dXJucyBgdmFsdWVgIGlmIGZpbml0ZSwgZWxzZSByZXR1cm5zIGBkZWZhdWx0VmFsdWVgLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHJldHVybiBpZiBkZWZpbmVkLlxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSAtIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgYHZhbHVlYCBpcyBub3QgZmluaXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluaXRlT3JEZWZhdWx0KHZhbHVlOiB1bmtub3duLCBkZWZhdWx0VmFsdWU6IG51bWJlcikge1xuICByZXR1cm4gaXNOdW1iZXJGaW5pdGUodmFsdWUpID8gdmFsdWUgOiBkZWZhdWx0VmFsdWU7XG59XG5cbi8qKlxuICogUmV0dXJucyBgdmFsdWVgIGlmIGRlZmluZWQsIGVsc2UgcmV0dXJucyBgZGVmYXVsdFZhbHVlYC5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgZGVmaW5lZC5cbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgLSBUaGUgdmFsdWUgdG8gcmV0dXJuIGlmIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsdWVPckRlZmF1bHQ8VD4odmFsdWU6IFQgfCB1bmRlZmluZWQsIGRlZmF1bHRWYWx1ZTogVCkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xufVxuXG5leHBvcnQgY29uc3QgdG9QZXJjZW50YWdlID0gKHZhbHVlOiBudW1iZXIgfCBzdHJpbmcsIGRpbWVuc2lvbjogbnVtYmVyKSA9PlxuICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmVuZHNXaXRoKCclJykgP1xuICAgIHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwXG4gICAgOiArdmFsdWUgLyBkaW1lbnNpb247XG5cbmV4cG9ydCBjb25zdCB0b0RpbWVuc2lvbiA9ICh2YWx1ZTogbnVtYmVyIHwgc3RyaW5nLCBkaW1lbnNpb246IG51bWJlcikgPT5cbiAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5lbmRzV2l0aCgnJScpID9cbiAgICBwYXJzZUZsb2F0KHZhbHVlKSAvIDEwMCAqIGRpbWVuc2lvblxuICAgIDogK3ZhbHVlO1xuXG4vKipcbiAqIENhbGxzIGBmbmAgd2l0aCB0aGUgZ2l2ZW4gYGFyZ3NgIGluIHRoZSBzY29wZSBkZWZpbmVkIGJ5IGB0aGlzQXJnYCBhbmQgcmV0dXJucyB0aGVcbiAqIHZhbHVlIHJldHVybmVkIGJ5IGBmbmAuIElmIGBmbmAgaXMgbm90IGEgZnVuY3Rpb24sIHRoaXMgbWV0aG9kIHJldHVybnMgdW5kZWZpbmVkLlxuICogQHBhcmFtIGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG4gKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgd2l0aCB3aGljaCBgZm5gIHNob3VsZCBiZSBjYWxsZWQuXG4gKiBAcGFyYW0gW3RoaXNBcmddIC0gVGhlIHZhbHVlIG9mIGB0aGlzYCBwcm92aWRlZCBmb3IgdGhlIGNhbGwgdG8gYGZuYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGxiYWNrPFQgZXh0ZW5kcyAodGhpczogVEEsIC4uLnJlc3RBcmdzOiB1bmtub3duW10pID0+IFIsIFRBLCBSPihcbiAgZm46IFQgfCB1bmRlZmluZWQsXG4gIGFyZ3M6IHVua25vd25bXSxcbiAgdGhpc0FyZz86IFRBXG4pOiBSIHwgdW5kZWZpbmVkIHtcbiAgaWYgKGZuICYmIHR5cGVvZiBmbi5jYWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9XG59XG5cbi8qKlxuICogTm90ZShTQikgZm9yIHBlcmZvcm1hbmNlIHNha2UsIHRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiBsb29wYWJsZSB0eXBlXG4gKiBpcyB1bmtub3duIG9yIGluIG5vbmUgaW50ZW5zaXZlIGNvZGUgKG5vdCBjYWxsZWQgb2Z0ZW4gYW5kIHNtYWxsIGxvb3BhYmxlKS4gRWxzZVxuICogaXQncyBwcmVmZXJhYmxlIHRvIHVzZSBhIHJlZ3VsYXIgZm9yKCkgbG9vcCBhbmQgc2F2ZSBleHRyYSBmdW5jdGlvbiBjYWxscy5cbiAqIEBwYXJhbSBsb29wYWJsZSAtIFRoZSBvYmplY3Qgb3IgYXJyYXkgdG8gYmUgaXRlcmF0ZWQuXG4gKiBAcGFyYW0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpdGVtLlxuICogQHBhcmFtIFt0aGlzQXJnXSAtIFRoZSB2YWx1ZSBvZiBgdGhpc2AgcHJvdmlkZWQgZm9yIHRoZSBjYWxsIHRvIGBmbmAuXG4gKiBAcGFyYW0gW3JldmVyc2VdIC0gSWYgdHJ1ZSwgaXRlcmF0ZXMgYmFja3dhcmQgb24gdGhlIGxvb3BhYmxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZWFjaDxULCBUQT4oXG4gIGxvb3BhYmxlOiBSZWNvcmQ8c3RyaW5nLCBUPixcbiAgZm46ICh0aGlzOiBUQSwgdjogVCwgaTogc3RyaW5nKSA9PiB2b2lkLFxuICB0aGlzQXJnPzogVEEsXG4gIHJldmVyc2U/OiBib29sZWFuXG4pOiB2b2lkO1xuZXhwb3J0IGZ1bmN0aW9uIGVhY2g8VCwgVEE+KFxuICBsb29wYWJsZTogVFtdLFxuICBmbjogKHRoaXM6IFRBLCB2OiBULCBpOiBudW1iZXIpID0+IHZvaWQsXG4gIHRoaXNBcmc/OiBUQSxcbiAgcmV2ZXJzZT86IGJvb2xlYW5cbik6IHZvaWQ7XG5leHBvcnQgZnVuY3Rpb24gZWFjaDxULCBUQT4oXG4gIGxvb3BhYmxlOiBUW10gfCBSZWNvcmQ8c3RyaW5nLCBUPixcbiAgZm46ICh0aGlzOiBUQSwgdjogVCwgaTogYW55KSA9PiB2b2lkLFxuICB0aGlzQXJnPzogVEEsXG4gIHJldmVyc2U/OiBib29sZWFuXG4pIHtcbiAgbGV0IGk6IG51bWJlciwgbGVuOiBudW1iZXIsIGtleXM6IHN0cmluZ1tdO1xuICBpZiAoaXNBcnJheShsb29wYWJsZSkpIHtcbiAgICBsZW4gPSBsb29wYWJsZS5sZW5ndGg7XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVbaV0sIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtpXSwgaSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxvb3BhYmxlKSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyhsb29wYWJsZSk7XG4gICAgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2tleXNbaV1dLCBrZXlzW2ldKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGBhMGAgYW5kIGBhMWAgYXJyYXlzIGhhdmUgdGhlIHNhbWUgY29udGVudCwgZWxzZSByZXR1cm5zIGZhbHNlLlxuICogQHBhcmFtIGEwIC0gVGhlIGFycmF5IHRvIGNvbXBhcmVcbiAqIEBwYXJhbSBhMSAtIFRoZSBhcnJheSB0byBjb21wYXJlXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2VsZW1lbnRzRXF1YWwoYTA6IEFjdGl2ZURhdGFQb2ludFtdLCBhMTogQWN0aXZlRGF0YVBvaW50W10pIHtcbiAgbGV0IGk6IG51bWJlciwgaWxlbjogbnVtYmVyLCB2MDogQWN0aXZlRGF0YVBvaW50LCB2MTogQWN0aXZlRGF0YVBvaW50O1xuXG4gIGlmICghYTAgfHwgIWExIHx8IGEwLmxlbmd0aCAhPT0gYTEubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IGEwLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIHYwID0gYTBbaV07XG4gICAgdjEgPSBhMVtpXTtcblxuICAgIGlmICh2MC5kYXRhc2V0SW5kZXggIT09IHYxLmRhdGFzZXRJbmRleCB8fCB2MC5pbmRleCAhPT0gdjEuaW5kZXgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZGVlcCBjb3B5IG9mIGBzb3VyY2VgIHdpdGhvdXQga2VlcGluZyByZWZlcmVuY2VzIG9uIG9iamVjdHMgYW5kIGFycmF5cy5cbiAqIEBwYXJhbSBzb3VyY2UgLSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZTxUPihzb3VyY2U6IFQpOiBUIHtcbiAgaWYgKGlzQXJyYXkoc291cmNlKSkge1xuICAgIHJldHVybiBzb3VyY2UubWFwKGNsb25lKSBhcyB1bmtub3duIGFzIFQ7XG4gIH1cblxuICBpZiAoaXNPYmplY3Qoc291cmNlKSkge1xuICAgIGNvbnN0IHRhcmdldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgY29uc3Qga2xlbiA9IGtleXMubGVuZ3RoO1xuICAgIGxldCBrID0gMDtcblxuICAgIGZvciAoOyBrIDwga2xlbjsgKytrKSB7XG4gICAgICB0YXJnZXRba2V5c1trXV0gPSBjbG9uZShzb3VyY2Vba2V5c1trXV0pO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICByZXR1cm4gc291cmNlO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleTogc3RyaW5nKSB7XG4gIHJldHVybiBbJ19fcHJvdG9fXycsICdwcm90b3R5cGUnLCAnY29uc3RydWN0b3InXS5pbmRleE9mKGtleSkgPT09IC0xO1xufVxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IG1lcmdlciB3aGVuIENoYXJ0LmhlbHBlcnMubWVyZ2UgaXMgY2FsbGVkIHdpdGhvdXQgbWVyZ2VyIG9wdGlvbi5cbiAqIE5vdGUoU0IpOiBhbHNvIHVzZWQgYnkgbWVyZ2VDb25maWcgYW5kIG1lcmdlU2NhbGVDb25maWcgYXMgZmFsbGJhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX21lcmdlcihrZXk6IHN0cmluZywgdGFyZ2V0OiBBbnlPYmplY3QsIHNvdXJjZTogQW55T2JqZWN0LCBvcHRpb25zOiBBbnlPYmplY3QpIHtcbiAgaWYgKCFpc1ZhbGlkS2V5KGtleSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB0dmFsID0gdGFyZ2V0W2tleV07XG4gIGNvbnN0IHN2YWwgPSBzb3VyY2Vba2V5XTtcblxuICBpZiAoaXNPYmplY3QodHZhbCkgJiYgaXNPYmplY3Qoc3ZhbCkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgbWVyZ2UodHZhbCwgc3ZhbCwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0W2tleV0gPSBjbG9uZShzdmFsKTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1lcmdlT3B0aW9ucyB7XG4gIG1lcmdlcj86IChrZXk6IHN0cmluZywgdGFyZ2V0OiBBbnlPYmplY3QsIHNvdXJjZTogQW55T2JqZWN0LCBvcHRpb25zPzogQW55T2JqZWN0KSA9PiB2b2lkO1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGRlZXAgY29waWVzIGBzb3VyY2VgIHByb3BlcnRpZXMgaW50byBgdGFyZ2V0YCB3aXRoIHRoZSBnaXZlbiBgb3B0aW9uc2AuXG4gKiBJTVBPUlRBTlQ6IGB0YXJnZXRgIGlzIG5vdCBjbG9uZWQgYW5kIHdpbGwgYmUgdXBkYXRlZCB3aXRoIGBzb3VyY2VgIHByb3BlcnRpZXMuXG4gKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHRhcmdldCBvYmplY3QgaW4gd2hpY2ggYWxsIHNvdXJjZXMgYXJlIG1lcmdlZCBpbnRvLlxuICogQHBhcmFtIHNvdXJjZSAtIE9iamVjdChzKSB0byBtZXJnZSBpbnRvIGB0YXJnZXRgLlxuICogQHBhcmFtIFtvcHRpb25zXSAtIE1lcmdpbmcgb3B0aW9uczpcbiAqIEBwYXJhbSBbb3B0aW9ucy5tZXJnZXJdIC0gVGhlIG1lcmdlIG1ldGhvZCAoa2V5LCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucylcbiAqIEByZXR1cm5zIFRoZSBgdGFyZ2V0YCBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZTxUPih0YXJnZXQ6IFQsIHNvdXJjZTogW10sIG9wdGlvbnM/OiBNZXJnZU9wdGlvbnMpOiBUO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQsIFMxPih0YXJnZXQ6IFQsIHNvdXJjZTogUzEsIG9wdGlvbnM/OiBNZXJnZU9wdGlvbnMpOiBUICYgUzE7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VCwgUzE+KHRhcmdldDogVCwgc291cmNlOiBbUzFdLCBvcHRpb25zPzogTWVyZ2VPcHRpb25zKTogVCAmIFMxO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQsIFMxLCBTMj4odGFyZ2V0OiBULCBzb3VyY2U6IFtTMSwgUzJdLCBvcHRpb25zPzogTWVyZ2VPcHRpb25zKTogVCAmIFMxICYgUzI7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VCwgUzEsIFMyLCBTMz4odGFyZ2V0OiBULCBzb3VyY2U6IFtTMSwgUzIsIFMzXSwgb3B0aW9ucz86IE1lcmdlT3B0aW9ucyk6IFQgJiBTMSAmIFMyICYgUzM7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VCwgUzEsIFMyLCBTMywgUzQ+KFxuICB0YXJnZXQ6IFQsXG4gIHNvdXJjZTogW1MxLCBTMiwgUzMsIFM0XSxcbiAgb3B0aW9ucz86IE1lcmdlT3B0aW9uc1xuKTogVCAmIFMxICYgUzIgJiBTMyAmIFM0O1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQ+KHRhcmdldDogVCwgc291cmNlOiBBbnlPYmplY3RbXSwgb3B0aW9ucz86IE1lcmdlT3B0aW9ucyk6IEFueU9iamVjdDtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZTxUPih0YXJnZXQ6IFQsIHNvdXJjZTogQW55T2JqZWN0W10sIG9wdGlvbnM/OiBNZXJnZU9wdGlvbnMpOiBBbnlPYmplY3Qge1xuICBjb25zdCBzb3VyY2VzID0gaXNBcnJheShzb3VyY2UpID8gc291cmNlIDogW3NvdXJjZV07XG4gIGNvbnN0IGlsZW4gPSBzb3VyY2VzLmxlbmd0aDtcblxuICBpZiAoIWlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0IGFzIEFueU9iamVjdDtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBtZXJnZXIgPSBvcHRpb25zLm1lcmdlciB8fCBfbWVyZ2VyO1xuICBsZXQgY3VycmVudDogQW55T2JqZWN0O1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY3VycmVudCA9IHNvdXJjZXNbaV07XG4gICAgaWYgKCFpc09iamVjdChjdXJyZW50KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGN1cnJlbnQpO1xuICAgIGZvciAobGV0IGsgPSAwLCBrbGVuID0ga2V5cy5sZW5ndGg7IGsgPCBrbGVuOyArK2spIHtcbiAgICAgIG1lcmdlcihrZXlzW2tdLCB0YXJnZXQsIGN1cnJlbnQsIG9wdGlvbnMgYXMgQW55T2JqZWN0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGRlZXAgY29waWVzIGBzb3VyY2VgIHByb3BlcnRpZXMgaW50byBgdGFyZ2V0YCAqb25seSogaWYgbm90IGRlZmluZWQgaW4gdGFyZ2V0LlxuICogSU1QT1JUQU5UOiBgdGFyZ2V0YCBpcyBub3QgY2xvbmVkIGFuZCB3aWxsIGJlIHVwZGF0ZWQgd2l0aCBgc291cmNlYCBwcm9wZXJ0aWVzLlxuICogQHBhcmFtIHRhcmdldCAtIFRoZSB0YXJnZXQgb2JqZWN0IGluIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSBtZXJnZWQgaW50by5cbiAqIEBwYXJhbSBzb3VyY2UgLSBPYmplY3QocykgdG8gbWVyZ2UgaW50byBgdGFyZ2V0YC5cbiAqIEByZXR1cm5zIFRoZSBgdGFyZ2V0YCBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUlmPFQ+KHRhcmdldDogVCwgc291cmNlOiBbXSk6IFQ7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VJZjxULCBTMT4odGFyZ2V0OiBULCBzb3VyY2U6IFMxKTogVCAmIFMxO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VCwgUzE+KHRhcmdldDogVCwgc291cmNlOiBbUzFdKTogVCAmIFMxO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VCwgUzEsIFMyPih0YXJnZXQ6IFQsIHNvdXJjZTogW1MxLCBTMl0pOiBUICYgUzEgJiBTMjtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUlmPFQsIFMxLCBTMiwgUzM+KHRhcmdldDogVCwgc291cmNlOiBbUzEsIFMyLCBTM10pOiBUICYgUzEgJiBTMiAmIFMzO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VCwgUzEsIFMyLCBTMywgUzQ+KHRhcmdldDogVCwgc291cmNlOiBbUzEsIFMyLCBTMywgUzRdKTogVCAmIFMxICYgUzIgJiBTMyAmIFM0O1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VD4odGFyZ2V0OiBULCBzb3VyY2U6IEFueU9iamVjdFtdKTogQW55T2JqZWN0O1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VD4odGFyZ2V0OiBULCBzb3VyY2U6IEFueU9iamVjdFtdKTogQW55T2JqZWN0IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICByZXR1cm4gbWVyZ2U8VD4odGFyZ2V0LCBzb3VyY2UsIHttZXJnZXI6IF9tZXJnZXJJZn0pO1xufVxuXG4vKipcbiAqIE1lcmdlcyBzb3VyY2Vba2V5XSBpbiB0YXJnZXRba2V5XSBvbmx5IGlmIHRhcmdldFtrZXldIGlzIHVuZGVmaW5lZC5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfbWVyZ2VySWYoa2V5OiBzdHJpbmcsIHRhcmdldDogQW55T2JqZWN0LCBzb3VyY2U6IEFueU9iamVjdCkge1xuICBpZiAoIWlzVmFsaWRLZXkoa2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHR2YWwgPSB0YXJnZXRba2V5XTtcbiAgY29uc3Qgc3ZhbCA9IHNvdXJjZVtrZXldO1xuXG4gIGlmIChpc09iamVjdCh0dmFsKSAmJiBpc09iamVjdChzdmFsKSkge1xuICAgIG1lcmdlSWYodHZhbCwgc3ZhbCk7XG4gIH0gZWxzZSBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkpIHtcbiAgICB0YXJnZXRba2V5XSA9IGNsb25lKHN2YWwpO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9kZXByZWNhdGVkKHNjb3BlOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duLCBwcmV2aW91czogc3RyaW5nLCBjdXJyZW50OiBzdHJpbmcpIHtcbiAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zb2xlLndhcm4oc2NvcGUgKyAnOiBcIicgKyBwcmV2aW91cyArXG4gICAgICAnXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcIicgKyBjdXJyZW50ICsgJ1wiIGluc3RlYWQnKTtcbiAgfVxufVxuXG4vLyByZXNvbHZlT2JqZWN0S2V5IHJlc29sdmVyIGNhY2hlXG5jb25zdCBrZXlSZXNvbHZlcnMgPSB7XG4gIC8vIENoYXJ0LmhlbHBlcnMuY29yZSByZXNvbHZlT2JqZWN0S2V5IHNob3VsZCByZXNvbHZlIGVtcHR5IGtleSB0byByb290IG9iamVjdFxuICAnJzogdiA9PiB2LFxuICAvLyBkZWZhdWx0IHJlc29sdmVyc1xuICB4OiBvID0+IG8ueCxcbiAgeTogbyA9PiBvLnlcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9zcGxpdEtleShrZXk6IHN0cmluZykge1xuICBjb25zdCBwYXJ0cyA9IGtleS5zcGxpdCgnLicpO1xuICBjb25zdCBrZXlzOiBzdHJpbmdbXSA9IFtdO1xuICBsZXQgdG1wID0gJyc7XG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgIHRtcCArPSBwYXJ0O1xuICAgIGlmICh0bXAuZW5kc1dpdGgoJ1xcXFwnKSkge1xuICAgICAgdG1wID0gdG1wLnNsaWNlKDAsIC0xKSArICcuJztcbiAgICB9IGVsc2Uge1xuICAgICAga2V5cy5wdXNoKHRtcCk7XG4gICAgICB0bXAgPSAnJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9nZXRLZXlSZXNvbHZlcihrZXk6IHN0cmluZykge1xuICBjb25zdCBrZXlzID0gX3NwbGl0S2V5KGtleSk7XG4gIHJldHVybiBvYmogPT4ge1xuICAgIGZvciAoY29uc3QgayBvZiBrZXlzKSB7XG4gICAgICBpZiAoayA9PT0gJycpIHtcbiAgICAgICAgLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHk6XG4gICAgICAgIC8vIENoYXJ0LmhlbHBlcnMuY29yZSByZXNvbHZlT2JqZWN0S2V5IHNob3VsZCBicmVhayBhdCBlbXB0eSBrZXlcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBvYmogPSBvYmogJiYgb2JqW2tdO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZU9iamVjdEtleShvYmo6IEFueU9iamVjdCwga2V5OiBzdHJpbmcpOiBhbnkge1xuICBjb25zdCByZXNvbHZlciA9IGtleVJlc29sdmVyc1trZXldIHx8IChrZXlSZXNvbHZlcnNba2V5XSA9IF9nZXRLZXlSZXNvbHZlcihrZXkpKTtcbiAgcmV0dXJuIHJlc29sdmVyKG9iaik7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9jYXBpdGFsaXplKHN0cjogc3RyaW5nKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59XG5cblxuZXhwb3J0IGNvbnN0IGRlZmluZWQgPSAodmFsdWU6IHVua25vd24pID0+IHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCc7XG5cbmV4cG9ydCBjb25zdCBpc0Z1bmN0aW9uID0gKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkgPT4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuXG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzExMjg4NTUvY29tcGFyaW5nLWVjbWE2LXNldHMtZm9yLWVxdWFsaXR5IzMxMTI5Mzg0XG5leHBvcnQgY29uc3Qgc2V0c0VxdWFsID0gPFQ+KGE6IFNldDxUPiwgYjogU2V0PFQ+KSA9PiB7XG4gIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAoY29uc3QgaXRlbSBvZiBhKSB7XG4gICAgaWYgKCFiLmhhcyhpdGVtKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gZSAtIFRoZSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9pc0NsaWNrRXZlbnQoZTogQ2hhcnRFdmVudCkge1xuICByZXR1cm4gZS50eXBlID09PSAnbW91c2V1cCcgfHwgZS50eXBlID09PSAnY2xpY2snIHx8IGUudHlwZSA9PT0gJ2NvbnRleHRtZW51Jztcbn1cbiIsICJpbXBvcnQgdHlwZSB7UG9pbnR9IGZyb20gJy4uL3R5cGVzL2dlb21ldHJpYy5qcyc7XG5pbXBvcnQge2lzRmluaXRlIGFzIGlzRmluaXRlTnVtYmVyfSBmcm9tICcuL2hlbHBlcnMuY29yZS5qcyc7XG5cbi8qKlxuICogQGFsaWFzIENoYXJ0LmhlbHBlcnMubWF0aFxuICogQG5hbWVzcGFjZVxuICovXG5cbmV4cG9ydCBjb25zdCBQSSA9IE1hdGguUEk7XG5leHBvcnQgY29uc3QgVEFVID0gMiAqIFBJO1xuZXhwb3J0IGNvbnN0IFBJVEFVID0gVEFVICsgUEk7XG5leHBvcnQgY29uc3QgSU5GSU5JVFkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5leHBvcnQgY29uc3QgUkFEX1BFUl9ERUcgPSBQSSAvIDE4MDtcbmV4cG9ydCBjb25zdCBIQUxGX1BJID0gUEkgLyAyO1xuZXhwb3J0IGNvbnN0IFFVQVJURVJfUEkgPSBQSSAvIDQ7XG5leHBvcnQgY29uc3QgVFdPX1RISVJEU19QSSA9IFBJICogMiAvIDM7XG5cbmV4cG9ydCBjb25zdCBsb2cxMCA9IE1hdGgubG9nMTA7XG5leHBvcnQgY29uc3Qgc2lnbiA9IE1hdGguc2lnbjtcblxuZXhwb3J0IGZ1bmN0aW9uIGFsbW9zdEVxdWFscyh4OiBudW1iZXIsIHk6IG51bWJlciwgZXBzaWxvbjogbnVtYmVyKSB7XG4gIHJldHVybiBNYXRoLmFicyh4IC0geSkgPCBlcHNpbG9uO1xufVxuXG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBuaWNlIG51bWJlciBhbGdvcml0aG0gdXNlZCBpbiBkZXRlcm1pbmluZyB3aGVyZSBheGlzIGxhYmVscyB3aWxsIGdvXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBuaWNlTnVtKHJhbmdlOiBudW1iZXIpIHtcbiAgY29uc3Qgcm91bmRlZFJhbmdlID0gTWF0aC5yb3VuZChyYW5nZSk7XG4gIHJhbmdlID0gYWxtb3N0RXF1YWxzKHJhbmdlLCByb3VuZGVkUmFuZ2UsIHJhbmdlIC8gMTAwMCkgPyByb3VuZGVkUmFuZ2UgOiByYW5nZTtcbiAgY29uc3QgbmljZVJhbmdlID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAocmFuZ2UpKSk7XG4gIGNvbnN0IGZyYWN0aW9uID0gcmFuZ2UgLyBuaWNlUmFuZ2U7XG4gIGNvbnN0IG5pY2VGcmFjdGlvbiA9IGZyYWN0aW9uIDw9IDEgPyAxIDogZnJhY3Rpb24gPD0gMiA/IDIgOiBmcmFjdGlvbiA8PSA1ID8gNSA6IDEwO1xuICByZXR1cm4gbmljZUZyYWN0aW9uICogbmljZVJhbmdlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgZmFjdG9ycyBzb3J0ZWQgZnJvbSAxIHRvIHNxcnQodmFsdWUpXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2ZhY3Rvcml6ZSh2YWx1ZTogbnVtYmVyKSB7XG4gIGNvbnN0IHJlc3VsdDogbnVtYmVyW10gPSBbXTtcbiAgY29uc3Qgc3FydCA9IE1hdGguc3FydCh2YWx1ZSk7XG4gIGxldCBpOiBudW1iZXI7XG5cbiAgZm9yIChpID0gMTsgaSA8IHNxcnQ7IGkrKykge1xuICAgIGlmICh2YWx1ZSAlIGkgPT09IDApIHtcbiAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgICAgcmVzdWx0LnB1c2godmFsdWUgLyBpKTtcbiAgICB9XG4gIH1cbiAgaWYgKHNxcnQgPT09IChzcXJ0IHwgMCkpIHsgLy8gaWYgdmFsdWUgaXMgYSBzcXVhcmUgbnVtYmVyXG4gICAgcmVzdWx0LnB1c2goc3FydCk7XG4gIH1cblxuICByZXN1bHQuc29ydCgoYSwgYikgPT4gYSAtIGIpLnBvcCgpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIobjogdW5rbm93bik6IG4gaXMgbnVtYmVyIHtcbiAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG4gYXMgc3RyaW5nKSkgJiYgaXNGaW5pdGUobiBhcyBudW1iZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWxtb3N0V2hvbGUoeDogbnVtYmVyLCBlcHNpbG9uOiBudW1iZXIpIHtcbiAgY29uc3Qgcm91bmRlZCA9IE1hdGgucm91bmQoeCk7XG4gIHJldHVybiAoKHJvdW5kZWQgLSBlcHNpbG9uKSA8PSB4KSAmJiAoKHJvdW5kZWQgKyBlcHNpbG9uKSA+PSB4KTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX3NldE1pbkFuZE1heEJ5S2V5KFxuICBhcnJheTogUmVjb3JkPHN0cmluZywgbnVtYmVyPltdLFxuICB0YXJnZXQ6IHsgbWluOiBudW1iZXIsIG1heDogbnVtYmVyIH0sXG4gIHByb3BlcnR5OiBzdHJpbmdcbikge1xuICBsZXQgaTogbnVtYmVyLCBpbGVuOiBudW1iZXIsIHZhbHVlOiBudW1iZXI7XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgIHZhbHVlID0gYXJyYXlbaV1bcHJvcGVydHldO1xuICAgIGlmICghaXNOYU4odmFsdWUpKSB7XG4gICAgICB0YXJnZXQubWluID0gTWF0aC5taW4odGFyZ2V0Lm1pbiwgdmFsdWUpO1xuICAgICAgdGFyZ2V0Lm1heCA9IE1hdGgubWF4KHRhcmdldC5tYXgsIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvUmFkaWFucyhkZWdyZWVzOiBudW1iZXIpIHtcbiAgcmV0dXJuIGRlZ3JlZXMgKiAoUEkgLyAxODApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9EZWdyZWVzKHJhZGlhbnM6IG51bWJlcikge1xuICByZXR1cm4gcmFkaWFucyAqICgxODAgLyBQSSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzXG4gKiBpLmUuIHRoZSBudW1iZXIgb2YgZGlnaXRzIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBOdW1iZXIuXG4gKiBAcGFyYW0geCAtIEEgbnVtYmVyLlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcy5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZGVjaW1hbFBsYWNlcyh4OiBudW1iZXIpIHtcbiAgaWYgKCFpc0Zpbml0ZU51bWJlcih4KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgZSA9IDE7XG4gIGxldCBwID0gMDtcbiAgd2hpbGUgKE1hdGgucm91bmQoeCAqIGUpIC8gZSAhPT0geCkge1xuICAgIGUgKj0gMTA7XG4gICAgcCsrO1xuICB9XG4gIHJldHVybiBwO1xufVxuXG4vLyBHZXRzIHRoZSBhbmdsZSBmcm9tIHZlcnRpY2FsIHVwcmlnaHQgdG8gdGhlIHBvaW50IGFib3V0IGEgY2VudHJlLlxuZXhwb3J0IGZ1bmN0aW9uIGdldEFuZ2xlRnJvbVBvaW50KFxuICBjZW50cmVQb2ludDogUG9pbnQsXG4gIGFuZ2xlUG9pbnQ6IFBvaW50XG4pIHtcbiAgY29uc3QgZGlzdGFuY2VGcm9tWENlbnRlciA9IGFuZ2xlUG9pbnQueCAtIGNlbnRyZVBvaW50Lng7XG4gIGNvbnN0IGRpc3RhbmNlRnJvbVlDZW50ZXIgPSBhbmdsZVBvaW50LnkgLSBjZW50cmVQb2ludC55O1xuICBjb25zdCByYWRpYWxEaXN0YW5jZUZyb21DZW50ZXIgPSBNYXRoLnNxcnQoZGlzdGFuY2VGcm9tWENlbnRlciAqIGRpc3RhbmNlRnJvbVhDZW50ZXIgKyBkaXN0YW5jZUZyb21ZQ2VudGVyICogZGlzdGFuY2VGcm9tWUNlbnRlcik7XG5cbiAgbGV0IGFuZ2xlID0gTWF0aC5hdGFuMihkaXN0YW5jZUZyb21ZQ2VudGVyLCBkaXN0YW5jZUZyb21YQ2VudGVyKTtcblxuICBpZiAoYW5nbGUgPCAoLTAuNSAqIFBJKSkge1xuICAgIGFuZ2xlICs9IFRBVTsgLy8gbWFrZSBzdXJlIHRoZSByZXR1cm5lZCBhbmdsZSBpcyBpbiB0aGUgcmFuZ2Ugb2YgKC1QSS8yLCAzUEkvMl1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYW5nbGUsXG4gICAgZGlzdGFuY2U6IHJhZGlhbERpc3RhbmNlRnJvbUNlbnRlclxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKHB0MTogUG9pbnQsIHB0MjogUG9pbnQpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwdDIueCAtIHB0MS54LCAyKSArIE1hdGgucG93KHB0Mi55IC0gcHQxLnksIDIpKTtcbn1cblxuLyoqXG4gKiBTaG9ydGVzdCBkaXN0YW5jZSBiZXR3ZWVuIGFuZ2xlcywgaW4gZWl0aGVyIGRpcmVjdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYW5nbGVEaWZmKGE6IG51bWJlciwgYjogbnVtYmVyKSB7XG4gIHJldHVybiAoYSAtIGIgKyBQSVRBVSkgJSBUQVUgLSBQSTtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYW5nbGUgdG8gYmUgYmV0d2VlbiAwIGFuZCAyKlBJXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX25vcm1hbGl6ZUFuZ2xlKGE6IG51bWJlcikge1xuICByZXR1cm4gKGEgJSBUQVUgKyBUQVUpICUgVEFVO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYW5nbGVCZXR3ZWVuKGFuZ2xlOiBudW1iZXIsIHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyLCBzYW1lQW5nbGVJc0Z1bGxDaXJjbGU/OiBib29sZWFuKSB7XG4gIGNvbnN0IGEgPSBfbm9ybWFsaXplQW5nbGUoYW5nbGUpO1xuICBjb25zdCBzID0gX25vcm1hbGl6ZUFuZ2xlKHN0YXJ0KTtcbiAgY29uc3QgZSA9IF9ub3JtYWxpemVBbmdsZShlbmQpO1xuICBjb25zdCBhbmdsZVRvU3RhcnQgPSBfbm9ybWFsaXplQW5nbGUocyAtIGEpO1xuICBjb25zdCBhbmdsZVRvRW5kID0gX25vcm1hbGl6ZUFuZ2xlKGUgLSBhKTtcbiAgY29uc3Qgc3RhcnRUb0FuZ2xlID0gX25vcm1hbGl6ZUFuZ2xlKGEgLSBzKTtcbiAgY29uc3QgZW5kVG9BbmdsZSA9IF9ub3JtYWxpemVBbmdsZShhIC0gZSk7XG4gIHJldHVybiBhID09PSBzIHx8IGEgPT09IGUgfHwgKHNhbWVBbmdsZUlzRnVsbENpcmNsZSAmJiBzID09PSBlKVxuICAgIHx8IChhbmdsZVRvU3RhcnQgPiBhbmdsZVRvRW5kICYmIHN0YXJ0VG9BbmdsZSA8IGVuZFRvQW5nbGUpO1xufVxuXG4vKipcbiAqIExpbWl0IGB2YWx1ZWAgYmV0d2VlbiBgbWluYCBhbmQgYG1heGBcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHBhcmFtIG1pblxuICogQHBhcmFtIG1heFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9saW1pdFZhbHVlKHZhbHVlOiBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcikge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHZhbHVlKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2ludDE2UmFuZ2UodmFsdWU6IG51bWJlcikge1xuICByZXR1cm4gX2xpbWl0VmFsdWUodmFsdWUsIC0zMjc2OCwgMzI3NjcpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHBhcmFtIHN0YXJ0XG4gKiBAcGFyYW0gZW5kXG4gKiBAcGFyYW0gW2Vwc2lsb25dXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2lzQmV0d2Vlbih2YWx1ZTogbnVtYmVyLCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlciwgZXBzaWxvbiA9IDFlLTYpIHtcbiAgcmV0dXJuIHZhbHVlID49IE1hdGgubWluKHN0YXJ0LCBlbmQpIC0gZXBzaWxvbiAmJiB2YWx1ZSA8PSBNYXRoLm1heChzdGFydCwgZW5kKSArIGVwc2lsb247XG59XG4iLCAiaW1wb3J0IHtfY2FwaXRhbGl6ZX0gZnJvbSAnLi9oZWxwZXJzLmNvcmUuanMnO1xuXG4vKipcbiAqIEJpbmFyeSBzZWFyY2hcbiAqIEBwYXJhbSB0YWJsZSAtIHRoZSB0YWJsZSBzZWFyY2guIG11c3QgYmUgc29ydGVkIVxuICogQHBhcmFtIHZhbHVlIC0gdmFsdWUgdG8gZmluZFxuICogQHBhcmFtIGNtcFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9sb29rdXAoXG4gIHRhYmxlOiBudW1iZXJbXSxcbiAgdmFsdWU6IG51bWJlcixcbiAgY21wPzogKHZhbHVlOiBudW1iZXIpID0+IGJvb2xlYW5cbik6IHtsbzogbnVtYmVyLCBoaTogbnVtYmVyfTtcbmV4cG9ydCBmdW5jdGlvbiBfbG9va3VwPFQ+KFxuICB0YWJsZTogVFtdLFxuICB2YWx1ZTogbnVtYmVyLFxuICBjbXA6ICh2YWx1ZTogbnVtYmVyKSA9PiBib29sZWFuXG4pOiB7bG86IG51bWJlciwgaGk6IG51bWJlcn07XG5leHBvcnQgZnVuY3Rpb24gX2xvb2t1cChcbiAgdGFibGU6IHVua25vd25bXSxcbiAgdmFsdWU6IG51bWJlcixcbiAgY21wPzogKHZhbHVlOiBudW1iZXIpID0+IGJvb2xlYW5cbikge1xuICBjbXAgPSBjbXAgfHwgKChpbmRleCkgPT4gdGFibGVbaW5kZXhdIDwgdmFsdWUpO1xuICBsZXQgaGkgPSB0YWJsZS5sZW5ndGggLSAxO1xuICBsZXQgbG8gPSAwO1xuICBsZXQgbWlkOiBudW1iZXI7XG5cbiAgd2hpbGUgKGhpIC0gbG8gPiAxKSB7XG4gICAgbWlkID0gKGxvICsgaGkpID4+IDE7XG4gICAgaWYgKGNtcChtaWQpKSB7XG4gICAgICBsbyA9IG1pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgaGkgPSBtaWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtsbywgaGl9O1xufVxuXG4vKipcbiAqIEJpbmFyeSBzZWFyY2hcbiAqIEBwYXJhbSB0YWJsZSAtIHRoZSB0YWJsZSBzZWFyY2guIG11c3QgYmUgc29ydGVkIVxuICogQHBhcmFtIGtleSAtIHByb3BlcnR5IG5hbWUgZm9yIHRoZSB2YWx1ZSBpbiBlYWNoIGVudHJ5XG4gKiBAcGFyYW0gdmFsdWUgLSB2YWx1ZSB0byBmaW5kXG4gKiBAcGFyYW0gbGFzdCAtIGxvb2t1cCBsYXN0IGluZGV4XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgX2xvb2t1cEJ5S2V5ID0gKFxuICB0YWJsZTogUmVjb3JkPHN0cmluZywgbnVtYmVyPltdLFxuICBrZXk6IHN0cmluZyxcbiAgdmFsdWU6IG51bWJlcixcbiAgbGFzdD86IGJvb2xlYW5cbikgPT5cbiAgX2xvb2t1cCh0YWJsZSwgdmFsdWUsIGxhc3RcbiAgICA/IGluZGV4ID0+IHtcbiAgICAgIGNvbnN0IHRpID0gdGFibGVbaW5kZXhdW2tleV07XG4gICAgICByZXR1cm4gdGkgPCB2YWx1ZSB8fCB0aSA9PT0gdmFsdWUgJiYgdGFibGVbaW5kZXggKyAxXVtrZXldID09PSB2YWx1ZTtcbiAgICB9XG4gICAgOiBpbmRleCA9PiB0YWJsZVtpbmRleF1ba2V5XSA8IHZhbHVlKTtcblxuLyoqXG4gKiBSZXZlcnNlIGJpbmFyeSBzZWFyY2hcbiAqIEBwYXJhbSB0YWJsZSAtIHRoZSB0YWJsZSBzZWFyY2guIG11c3QgYmUgc29ydGVkIVxuICogQHBhcmFtIGtleSAtIHByb3BlcnR5IG5hbWUgZm9yIHRoZSB2YWx1ZSBpbiBlYWNoIGVudHJ5XG4gKiBAcGFyYW0gdmFsdWUgLSB2YWx1ZSB0byBmaW5kXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgX3Jsb29rdXBCeUtleSA9IChcbiAgdGFibGU6IFJlY29yZDxzdHJpbmcsIG51bWJlcj5bXSxcbiAga2V5OiBzdHJpbmcsXG4gIHZhbHVlOiBudW1iZXJcbikgPT5cbiAgX2xvb2t1cCh0YWJsZSwgdmFsdWUsIGluZGV4ID0+IHRhYmxlW2luZGV4XVtrZXldID49IHZhbHVlKTtcblxuLyoqXG4gKiBSZXR1cm4gc3Vic2V0IG9mIGB2YWx1ZXNgIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgIGluY2x1c2l2ZS5cbiAqIFZhbHVlcyBhcmUgYXNzdW1lZCB0byBiZSBpbiBzb3J0ZWQgb3JkZXIuXG4gKiBAcGFyYW0gdmFsdWVzIC0gc29ydGVkIGFycmF5IG9mIHZhbHVlc1xuICogQHBhcmFtIG1pbiAtIG1pbiB2YWx1ZVxuICogQHBhcmFtIG1heCAtIG1heCB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2ZpbHRlckJldHdlZW4odmFsdWVzOiBudW1iZXJbXSwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKSB7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBlbmQgPSB2YWx1ZXMubGVuZ3RoO1xuXG4gIHdoaWxlIChzdGFydCA8IGVuZCAmJiB2YWx1ZXNbc3RhcnRdIDwgbWluKSB7XG4gICAgc3RhcnQrKztcbiAgfVxuICB3aGlsZSAoZW5kID4gc3RhcnQgJiYgdmFsdWVzW2VuZCAtIDFdID4gbWF4KSB7XG4gICAgZW5kLS07XG4gIH1cblxuICByZXR1cm4gc3RhcnQgPiAwIHx8IGVuZCA8IHZhbHVlcy5sZW5ndGhcbiAgICA/IHZhbHVlcy5zbGljZShzdGFydCwgZW5kKVxuICAgIDogdmFsdWVzO1xufVxuXG5jb25zdCBhcnJheUV2ZW50cyA9IFsncHVzaCcsICdwb3AnLCAnc2hpZnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSBhcyBjb25zdDtcblxuZXhwb3J0IGludGVyZmFjZSBBcnJheUxpc3RlbmVyPFQ+IHtcbiAgX29uRGF0YVB1c2g/KC4uLml0ZW06IFRbXSk6IHZvaWQ7XG4gIF9vbkRhdGFQb3A/KCk6IHZvaWQ7XG4gIF9vbkRhdGFTaGlmdD8oKTogdm9pZDtcbiAgX29uRGF0YVNwbGljZT8oaW5kZXg6IG51bWJlciwgZGVsZXRlQ291bnQ6IG51bWJlciwgLi4uaXRlbXM6IFRbXSk6IHZvaWQ7XG4gIF9vbkRhdGFVbnNoaWZ0PyguLi5pdGVtOiBUW10pOiB2b2lkO1xufVxuXG4vKipcbiAqIEhvb2tzIHRoZSBhcnJheSBtZXRob2RzIHRoYXQgYWRkIG9yIHJlbW92ZSB2YWx1ZXMgKCdwdXNoJywgcG9wJywgJ3NoaWZ0JywgJ3NwbGljZScsXG4gKiAndW5zaGlmdCcpIGFuZCBub3RpZnkgdGhlIGxpc3RlbmVyIEFGVEVSIHRoZSBhcnJheSBoYXMgYmVlbiBhbHRlcmVkLiBMaXN0ZW5lcnMgYXJlXG4gKiBjYWxsZWQgb24gdGhlICdfb25EYXRhKicgY2FsbGJhY2tzIChlLmcuIF9vbkRhdGFQdXNoLCBldGMuKSB3aXRoIHNhbWUgYXJndW1lbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuQXJyYXlFdmVudHM8VD4oYXJyYXk6IFRbXSwgbGlzdGVuZXI6IEFycmF5TGlzdGVuZXI8VD4pOiB2b2lkO1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3RlbkFycmF5RXZlbnRzKGFycmF5LCBsaXN0ZW5lcikge1xuICBpZiAoYXJyYXkuX2NoYXJ0anMpIHtcbiAgICBhcnJheS5fY2hhcnRqcy5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCAnX2NoYXJ0anMnLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiB7XG4gICAgICBsaXN0ZW5lcnM6IFtsaXN0ZW5lcl1cbiAgICB9XG4gIH0pO1xuXG4gIGFycmF5RXZlbnRzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGNvbnN0IG1ldGhvZCA9ICdfb25EYXRhJyArIF9jYXBpdGFsaXplKGtleSk7XG4gICAgY29uc3QgYmFzZSA9IGFycmF5W2tleV07XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyYXksIGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZSguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJhc2UuYXBwbHkodGhpcywgYXJncyk7XG5cbiAgICAgICAgYXJyYXkuX2NoYXJ0anMubGlzdGVuZXJzLmZvckVhY2goKG9iamVjdCkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0W21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9iamVjdFttZXRob2RdKC4uLmFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBnaXZlbiBhcnJheSBldmVudCBsaXN0ZW5lciBhbmQgY2xlYW51cCBleHRyYSBhdHRhY2hlZCBwcm9wZXJ0aWVzIChzdWNoIGFzXG4gKiB0aGUgX2NoYXJ0anMgc3R1YiBhbmQgb3ZlcnJpZGRlbiBtZXRob2RzKSBpZiBhcnJheSBkb2Vzbid0IGhhdmUgYW55IG1vcmUgbGlzdGVuZXJzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5saXN0ZW5BcnJheUV2ZW50czxUPihhcnJheTogVFtdLCBsaXN0ZW5lcjogQXJyYXlMaXN0ZW5lcjxUPik6IHZvaWQ7XG5leHBvcnQgZnVuY3Rpb24gdW5saXN0ZW5BcnJheUV2ZW50cyhhcnJheSwgbGlzdGVuZXIpIHtcbiAgY29uc3Qgc3R1YiA9IGFycmF5Ll9jaGFydGpzO1xuICBpZiAoIXN0dWIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBsaXN0ZW5lcnMgPSBzdHViLmxpc3RlbmVycztcbiAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxuXG4gIGlmIChsaXN0ZW5lcnMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGFycmF5RXZlbnRzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGRlbGV0ZSBhcnJheVtrZXldO1xuICB9KTtcblxuICBkZWxldGUgYXJyYXkuX2NoYXJ0anM7XG59XG5cbi8qKlxuICogQHBhcmFtIGl0ZW1zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYXJyYXlVbmlxdWU8VD4oaXRlbXM6IFRbXSkge1xuICBjb25zdCBzZXQgPSBuZXcgU2V0PFQ+KGl0ZW1zKTtcblxuICBpZiAoc2V0LnNpemUgPT09IGl0ZW1zLmxlbmd0aCkge1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuXG4gIHJldHVybiBBcnJheS5mcm9tKHNldCk7XG59XG4iLCAiaW1wb3J0IHR5cGUge0NoYXJ0TWV0YSwgUG9pbnRFbGVtZW50fSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5cbmltcG9ydCB7X2xpbWl0VmFsdWV9IGZyb20gJy4vaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCB7X2xvb2t1cEJ5S2V5fSBmcm9tICcuL2hlbHBlcnMuY29sbGVjdGlvbi5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBmb250U3RyaW5nKHBpeGVsU2l6ZTogbnVtYmVyLCBmb250U3R5bGU6IHN0cmluZywgZm9udEZhbWlseTogc3RyaW5nKSB7XG4gIHJldHVybiBmb250U3R5bGUgKyAnICcgKyBwaXhlbFNpemUgKyAncHggJyArIGZvbnRGYW1pbHk7XG59XG5cbi8qKlxuKiBSZXF1ZXN0IGFuaW1hdGlvbiBwb2x5ZmlsbFxuKi9cbmV4cG9ydCBjb25zdCByZXF1ZXN0QW5pbUZyYW1lID0gKGZ1bmN0aW9uKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG59KCkpO1xuXG4vKipcbiAqIFRocm90dGxlcyBjYWxsaW5nIGBmbmAgb25jZSBwZXIgYW5pbWF0aW9uIGZyYW1lXG4gKiBMYXRlc3QgYXJndW1lbnRzIGFyZSB1c2VkIG9uIHRoZSBhY3R1YWwgY2FsbFxuICovXG5leHBvcnQgZnVuY3Rpb24gdGhyb3R0bGVkPFRBcmdzIGV4dGVuZHMgQXJyYXk8YW55Pj4oXG4gIGZuOiAoLi4uYXJnczogVEFyZ3MpID0+IHZvaWQsXG4gIHRoaXNBcmc6IGFueSxcbikge1xuICBsZXQgYXJnc1RvVXNlID0gW10gYXMgVEFyZ3M7XG4gIGxldCB0aWNraW5nID0gZmFsc2U7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3M6IFRBcmdzKSB7XG4gICAgLy8gU2F2ZSB0aGUgYXJncyBmb3IgdXNlIGxhdGVyXG4gICAgYXJnc1RvVXNlID0gYXJncztcbiAgICBpZiAoIXRpY2tpbmcpIHtcbiAgICAgIHRpY2tpbmcgPSB0cnVlO1xuICAgICAgcmVxdWVzdEFuaW1GcmFtZS5jYWxsKHdpbmRvdywgKCkgPT4ge1xuICAgICAgICB0aWNraW5nID0gZmFsc2U7XG4gICAgICAgIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3NUb1VzZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogRGVib3VuY2VzIGNhbGxpbmcgYGZuYCBmb3IgYGRlbGF5YCBtc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZGVib3VuY2U8VEFyZ3MgZXh0ZW5kcyBBcnJheTxhbnk+PihmbjogKC4uLmFyZ3M6IFRBcmdzKSA9PiB2b2lkLCBkZWxheTogbnVtYmVyKSB7XG4gIGxldCB0aW1lb3V0O1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJnczogVEFyZ3MpIHtcbiAgICBpZiAoZGVsYXkpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZuLCBkZWxheSwgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gZGVsYXk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgJ3N0YXJ0JyB0byAnbGVmdCcsICdlbmQnIHRvICdyaWdodCcgYW5kIG90aGVycyB0byAnY2VudGVyJ1xuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IF90b0xlZnRSaWdodENlbnRlciA9IChhbGlnbjogJ3N0YXJ0JyB8ICdlbmQnIHwgJ2NlbnRlcicpID0+IGFsaWduID09PSAnc3RhcnQnID8gJ2xlZnQnIDogYWxpZ24gPT09ICdlbmQnID8gJ3JpZ2h0JyA6ICdjZW50ZXInO1xuXG4vKipcbiAqIFJldHVybnMgYHN0YXJ0YCwgYGVuZGAgb3IgYChzdGFydCArIGVuZCkgLyAyYCBkZXBlbmRpbmcgb24gYGFsaWduYC4gRGVmYXVsdHMgdG8gYGNlbnRlcmBcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBfYWxpZ25TdGFydEVuZCA9IChhbGlnbjogJ3N0YXJ0JyB8ICdlbmQnIHwgJ2NlbnRlcicsIHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKSA9PiBhbGlnbiA9PT0gJ3N0YXJ0JyA/IHN0YXJ0IDogYWxpZ24gPT09ICdlbmQnID8gZW5kIDogKHN0YXJ0ICsgZW5kKSAvIDI7XG5cbi8qKlxuICogUmV0dXJucyBgbGVmdGAsIGByaWdodGAgb3IgYChsZWZ0ICsgcmlnaHQpIC8gMmAgZGVwZW5kaW5nIG9uIGBhbGlnbmAuIERlZmF1bHRzIHRvIGBsZWZ0YFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IF90ZXh0WCA9IChhbGlnbjogJ2xlZnQnIHwgJ3JpZ2h0JyB8ICdjZW50ZXInLCBsZWZ0OiBudW1iZXIsIHJpZ2h0OiBudW1iZXIsIHJ0bDogYm9vbGVhbikgPT4ge1xuICBjb25zdCBjaGVjayA9IHJ0bCA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gIHJldHVybiBhbGlnbiA9PT0gY2hlY2sgPyByaWdodCA6IGFsaWduID09PSAnY2VudGVyJyA/IChsZWZ0ICsgcmlnaHQpIC8gMiA6IGxlZnQ7XG59O1xuXG4vKipcbiAqIFJldHVybiBzdGFydCBhbmQgY291bnQgb2YgdmlzaWJsZSBwb2ludHMuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMobWV0YTogQ2hhcnRNZXRhPCdsaW5lJyB8ICdzY2F0dGVyJz4sIHBvaW50czogUG9pbnRFbGVtZW50W10sIGFuaW1hdGlvbnNEaXNhYmxlZDogYm9vbGVhbikge1xuICBjb25zdCBwb2ludENvdW50ID0gcG9pbnRzLmxlbmd0aDtcblxuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgY291bnQgPSBwb2ludENvdW50O1xuXG4gIGlmIChtZXRhLl9zb3J0ZWQpIHtcbiAgICBjb25zdCB7aVNjYWxlLCBfcGFyc2VkfSA9IG1ldGE7XG4gICAgY29uc3QgYXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSBpU2NhbGUuZ2V0VXNlckJvdW5kcygpO1xuXG4gICAgaWYgKG1pbkRlZmluZWQpIHtcbiAgICAgIHN0YXJ0ID0gX2xpbWl0VmFsdWUoTWF0aC5taW4oXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgTmVlZCB0byB0eXBlIF9wYXJzZWRcbiAgICAgICAgX2xvb2t1cEJ5S2V5KF9wYXJzZWQsIGF4aXMsIG1pbikubG8sXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgTmVlZCB0byBmaXggdHlwZXMgb24gX2xvb2t1cEJ5S2V5XG4gICAgICAgIGFuaW1hdGlvbnNEaXNhYmxlZCA/IHBvaW50Q291bnQgOiBfbG9va3VwQnlLZXkocG9pbnRzLCBheGlzLCBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShtaW4pKS5sbyksXG4gICAgICAwLCBwb2ludENvdW50IC0gMSk7XG4gICAgfVxuICAgIGlmIChtYXhEZWZpbmVkKSB7XG4gICAgICBjb3VudCA9IF9saW1pdFZhbHVlKE1hdGgubWF4KFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIE5lZWQgdG8gdHlwZSBfcGFyc2VkXG4gICAgICAgIF9sb29rdXBCeUtleShfcGFyc2VkLCBpU2NhbGUuYXhpcywgbWF4LCB0cnVlKS5oaSArIDEsXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgTmVlZCB0byBmaXggdHlwZXMgb24gX2xvb2t1cEJ5S2V5XG4gICAgICAgIGFuaW1hdGlvbnNEaXNhYmxlZCA/IDAgOiBfbG9va3VwQnlLZXkocG9pbnRzLCBheGlzLCBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShtYXgpLCB0cnVlKS5oaSArIDEpLFxuICAgICAgc3RhcnQsIHBvaW50Q291bnQpIC0gc3RhcnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gcG9pbnRDb3VudCAtIHN0YXJ0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7c3RhcnQsIGNvdW50fTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHNjYWxlIHJhbmdlcyBoYXZlIGNoYW5nZWQuXG4gKiBAcGFyYW0ge29iamVjdH0gbWV0YSAtIGRhdGFzZXQgbWV0YS5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9zY2FsZVJhbmdlc0NoYW5nZWQobWV0YSkge1xuICBjb25zdCB7eFNjYWxlLCB5U2NhbGUsIF9zY2FsZVJhbmdlc30gPSBtZXRhO1xuICBjb25zdCBuZXdSYW5nZXMgPSB7XG4gICAgeG1pbjogeFNjYWxlLm1pbixcbiAgICB4bWF4OiB4U2NhbGUubWF4LFxuICAgIHltaW46IHlTY2FsZS5taW4sXG4gICAgeW1heDogeVNjYWxlLm1heFxuICB9O1xuICBpZiAoIV9zY2FsZVJhbmdlcykge1xuICAgIG1ldGEuX3NjYWxlUmFuZ2VzID0gbmV3UmFuZ2VzO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGNoYW5nZWQgPSBfc2NhbGVSYW5nZXMueG1pbiAhPT0geFNjYWxlLm1pblxuXHRcdHx8IF9zY2FsZVJhbmdlcy54bWF4ICE9PSB4U2NhbGUubWF4XG5cdFx0fHwgX3NjYWxlUmFuZ2VzLnltaW4gIT09IHlTY2FsZS5taW5cblx0XHR8fCBfc2NhbGVSYW5nZXMueW1heCAhPT0geVNjYWxlLm1heDtcblxuICBPYmplY3QuYXNzaWduKF9zY2FsZVJhbmdlcywgbmV3UmFuZ2VzKTtcbiAgcmV0dXJuIGNoYW5nZWQ7XG59XG4iLCAiaW1wb3J0IHtQSSwgVEFVLCBIQUxGX1BJfSBmcm9tICcuL2hlbHBlcnMubWF0aC5qcyc7XG5cbmNvbnN0IGF0RWRnZSA9ICh0OiBudW1iZXIpID0+IHQgPT09IDAgfHwgdCA9PT0gMTtcbmNvbnN0IGVsYXN0aWNJbiA9ICh0OiBudW1iZXIsIHM6IG51bWJlciwgcDogbnVtYmVyKSA9PiAtKE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgLSBzKSAqIFRBVSAvIHApKTtcbmNvbnN0IGVsYXN0aWNPdXQgPSAodDogbnVtYmVyLCBzOiBudW1iZXIsIHA6IG51bWJlcikgPT4gTWF0aC5wb3coMiwgLTEwICogdCkgKiBNYXRoLnNpbigodCAtIHMpICogVEFVIC8gcCkgKyAxO1xuXG4vKipcbiAqIEVhc2luZyBmdW5jdGlvbnMgYWRhcHRlZCBmcm9tIFJvYmVydCBQZW5uZXIncyBlYXNpbmcgZXF1YXRpb25zLlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmVhc2luZy5lZmZlY3RzXG4gKiBAc2VlIGh0dHA6Ly93d3cucm9iZXJ0cGVubmVyLmNvbS9lYXNpbmcvXG4gKi9cbmNvbnN0IGVmZmVjdHMgPSB7XG4gIGxpbmVhcjogKHQ6IG51bWJlcikgPT4gdCxcblxuICBlYXNlSW5RdWFkOiAodDogbnVtYmVyKSA9PiB0ICogdCxcblxuICBlYXNlT3V0UXVhZDogKHQ6IG51bWJlcikgPT4gLXQgKiAodCAtIDIpLFxuXG4gIGVhc2VJbk91dFF1YWQ6ICh0OiBudW1iZXIpID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IDAuNSAqIHQgKiB0XG4gICAgOiAtMC41ICogKCgtLXQpICogKHQgLSAyKSAtIDEpLFxuXG4gIGVhc2VJbkN1YmljOiAodDogbnVtYmVyKSA9PiB0ICogdCAqIHQsXG5cbiAgZWFzZU91dEN1YmljOiAodDogbnVtYmVyKSA9PiAodCAtPSAxKSAqIHQgKiB0ICsgMSxcblxuICBlYXNlSW5PdXRDdWJpYzogKHQ6IG51bWJlcikgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHQgKiB0XG4gICAgOiAwLjUgKiAoKHQgLT0gMikgKiB0ICogdCArIDIpLFxuXG4gIGVhc2VJblF1YXJ0OiAodDogbnVtYmVyKSA9PiB0ICogdCAqIHQgKiB0LFxuXG4gIGVhc2VPdXRRdWFydDogKHQ6IG51bWJlcikgPT4gLSgodCAtPSAxKSAqIHQgKiB0ICogdCAtIDEpLFxuXG4gIGVhc2VJbk91dFF1YXJ0OiAodDogbnVtYmVyKSA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAwLjUgKiB0ICogdCAqIHQgKiB0XG4gICAgOiAtMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0IC0gMiksXG5cbiAgZWFzZUluUXVpbnQ6ICh0OiBudW1iZXIpID0+IHQgKiB0ICogdCAqIHQgKiB0LFxuXG4gIGVhc2VPdXRRdWludDogKHQ6IG51bWJlcikgPT4gKHQgLT0gMSkgKiB0ICogdCAqIHQgKiB0ICsgMSxcblxuICBlYXNlSW5PdXRRdWludDogKHQ6IG51bWJlcikgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHQgKiB0ICogdCAqIHRcbiAgICA6IDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAqIHQgKyAyKSxcblxuICBlYXNlSW5TaW5lOiAodDogbnVtYmVyKSA9PiAtTWF0aC5jb3ModCAqIEhBTEZfUEkpICsgMSxcblxuICBlYXNlT3V0U2luZTogKHQ6IG51bWJlcikgPT4gTWF0aC5zaW4odCAqIEhBTEZfUEkpLFxuXG4gIGVhc2VJbk91dFNpbmU6ICh0OiBudW1iZXIpID0+IC0wLjUgKiAoTWF0aC5jb3MoUEkgKiB0KSAtIDEpLFxuXG4gIGVhc2VJbkV4cG86ICh0OiBudW1iZXIpID0+ICh0ID09PSAwKSA/IDAgOiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpLFxuXG4gIGVhc2VPdXRFeHBvOiAodDogbnVtYmVyKSA9PiAodCA9PT0gMSkgPyAxIDogLU1hdGgucG93KDIsIC0xMCAqIHQpICsgMSxcblxuICBlYXNlSW5PdXRFeHBvOiAodDogbnVtYmVyKSA9PiBhdEVkZ2UodCkgPyB0IDogdCA8IDAuNVxuICAgID8gMC41ICogTWF0aC5wb3coMiwgMTAgKiAodCAqIDIgLSAxKSlcbiAgICA6IDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogKHQgKiAyIC0gMSkpICsgMiksXG5cbiAgZWFzZUluQ2lyYzogKHQ6IG51bWJlcikgPT4gKHQgPj0gMSkgPyB0IDogLShNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpLFxuXG4gIGVhc2VPdXRDaXJjOiAodDogbnVtYmVyKSA9PiBNYXRoLnNxcnQoMSAtICh0IC09IDEpICogdCksXG5cbiAgZWFzZUluT3V0Q2lyYzogKHQ6IG51bWJlcikgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gLTAuNSAqIChNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpXG4gICAgOiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAodCAtPSAyKSAqIHQpICsgMSksXG5cbiAgZWFzZUluRWxhc3RpYzogKHQ6IG51bWJlcikgPT4gYXRFZGdlKHQpID8gdCA6IGVsYXN0aWNJbih0LCAwLjA3NSwgMC4zKSxcblxuICBlYXNlT3V0RWxhc3RpYzogKHQ6IG51bWJlcikgPT4gYXRFZGdlKHQpID8gdCA6IGVsYXN0aWNPdXQodCwgMC4wNzUsIDAuMyksXG5cbiAgZWFzZUluT3V0RWxhc3RpYyh0OiBudW1iZXIpIHtcbiAgICBjb25zdCBzID0gMC4xMTI1O1xuICAgIGNvbnN0IHAgPSAwLjQ1O1xuICAgIHJldHVybiBhdEVkZ2UodCkgPyB0IDpcbiAgICAgIHQgPCAwLjVcbiAgICAgICAgPyAwLjUgKiBlbGFzdGljSW4odCAqIDIsIHMsIHApXG4gICAgICAgIDogMC41ICsgMC41ICogZWxhc3RpY091dCh0ICogMiAtIDEsIHMsIHApO1xuICB9LFxuXG4gIGVhc2VJbkJhY2sodDogbnVtYmVyKSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuIHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG4gIH0sXG5cbiAgZWFzZU91dEJhY2sodDogbnVtYmVyKSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuICh0IC09IDEpICogdCAqICgocyArIDEpICogdCArIHMpICsgMTtcbiAgfSxcblxuICBlYXNlSW5PdXRCYWNrKHQ6IG51bWJlcikge1xuICAgIGxldCBzID0gMS43MDE1ODtcbiAgICBpZiAoKHQgLz0gMC41KSA8IDEpIHtcbiAgICAgIHJldHVybiAwLjUgKiAodCAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0IC0gcykpO1xuICAgIH1cbiAgICByZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgKyBzKSArIDIpO1xuICB9LFxuXG4gIGVhc2VJbkJvdW5jZTogKHQ6IG51bWJlcikgPT4gMSAtIGVmZmVjdHMuZWFzZU91dEJvdW5jZSgxIC0gdCksXG5cbiAgZWFzZU91dEJvdW5jZSh0OiBudW1iZXIpIHtcbiAgICBjb25zdCBtID0gNy41NjI1O1xuICAgIGNvbnN0IGQgPSAyLjc1O1xuICAgIGlmICh0IDwgKDEgLyBkKSkge1xuICAgICAgcmV0dXJuIG0gKiB0ICogdDtcbiAgICB9XG4gICAgaWYgKHQgPCAoMiAvIGQpKSB7XG4gICAgICByZXR1cm4gbSAqICh0IC09ICgxLjUgLyBkKSkgKiB0ICsgMC43NTtcbiAgICB9XG4gICAgaWYgKHQgPCAoMi41IC8gZCkpIHtcbiAgICAgIHJldHVybiBtICogKHQgLT0gKDIuMjUgLyBkKSkgKiB0ICsgMC45Mzc1O1xuICAgIH1cbiAgICByZXR1cm4gbSAqICh0IC09ICgyLjYyNSAvIGQpKSAqIHQgKyAwLjk4NDM3NTtcbiAgfSxcblxuICBlYXNlSW5PdXRCb3VuY2U6ICh0OiBudW1iZXIpID0+ICh0IDwgMC41KVxuICAgID8gZWZmZWN0cy5lYXNlSW5Cb3VuY2UodCAqIDIpICogMC41XG4gICAgOiBlZmZlY3RzLmVhc2VPdXRCb3VuY2UodCAqIDIgLSAxKSAqIDAuNSArIDAuNSxcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCB0eXBlIEVhc2luZ0Z1bmN0aW9uID0ga2V5b2YgdHlwZW9mIGVmZmVjdHNcblxuZXhwb3J0IGRlZmF1bHQgZWZmZWN0cztcbiIsICJpbXBvcnQge0NvbG9yfSBmcm9tICdAa3Vya2xlL2NvbG9yJztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzUGF0dGVybk9yR3JhZGllbnQodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBDYW52YXNQYXR0ZXJuIHwgQ2FudmFzR3JhZGllbnQge1xuICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIGNvbnN0IHR5cGUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIHJldHVybiB0eXBlID09PSAnW29iamVjdCBDYW52YXNQYXR0ZXJuXScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgQ2FudmFzR3JhZGllbnRdJztcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbG9yKHZhbHVlOiBDYW52YXNHcmFkaWVudCk6IENhbnZhc0dyYWRpZW50O1xuZXhwb3J0IGZ1bmN0aW9uIGNvbG9yKHZhbHVlOiBDYW52YXNQYXR0ZXJuKTogQ2FudmFzUGF0dGVybjtcbmV4cG9ydCBmdW5jdGlvbiBjb2xvcihcbiAgdmFsdWU6XG4gIHwgc3RyaW5nXG4gIHwgeyByOiBudW1iZXI7IGc6IG51bWJlcjsgYjogbnVtYmVyOyBhOiBudW1iZXIgfVxuICB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXVxuICB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdXG4pOiBDb2xvcjtcbmV4cG9ydCBmdW5jdGlvbiBjb2xvcih2YWx1ZSkge1xuICByZXR1cm4gaXNQYXR0ZXJuT3JHcmFkaWVudCh2YWx1ZSkgPyB2YWx1ZSA6IG5ldyBDb2xvcih2YWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRIb3ZlckNvbG9yKHZhbHVlOiBDYW52YXNHcmFkaWVudCk6IENhbnZhc0dyYWRpZW50O1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhvdmVyQ29sb3IodmFsdWU6IENhbnZhc1BhdHRlcm4pOiBDYW52YXNQYXR0ZXJuO1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhvdmVyQ29sb3IodmFsdWU6IHN0cmluZyk6IHN0cmluZztcbmV4cG9ydCBmdW5jdGlvbiBnZXRIb3ZlckNvbG9yKHZhbHVlKSB7XG4gIHJldHVybiBpc1BhdHRlcm5PckdyYWRpZW50KHZhbHVlKVxuICAgID8gdmFsdWVcbiAgICA6IG5ldyBDb2xvcih2YWx1ZSkuc2F0dXJhdGUoMC41KS5kYXJrZW4oMC4xKS5oZXhTdHJpbmcoKTtcbn1cbiIsICJjb25zdCBudW1iZXJzID0gWyd4JywgJ3knLCAnYm9yZGVyV2lkdGgnLCAncmFkaXVzJywgJ3RlbnNpb24nXTtcbmNvbnN0IGNvbG9ycyA9IFsnY29sb3InLCAnYm9yZGVyQ29sb3InLCAnYmFja2dyb3VuZENvbG9yJ107XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseUFuaW1hdGlvbnNEZWZhdWx0cyhkZWZhdWx0cykge1xuICBkZWZhdWx0cy5zZXQoJ2FuaW1hdGlvbicsIHtcbiAgICBkZWxheTogdW5kZWZpbmVkLFxuICAgIGR1cmF0aW9uOiAxMDAwLFxuICAgIGVhc2luZzogJ2Vhc2VPdXRRdWFydCcsXG4gICAgZm46IHVuZGVmaW5lZCxcbiAgICBmcm9tOiB1bmRlZmluZWQsXG4gICAgbG9vcDogdW5kZWZpbmVkLFxuICAgIHRvOiB1bmRlZmluZWQsXG4gICAgdHlwZTogdW5kZWZpbmVkLFxuICB9KTtcblxuICBkZWZhdWx0cy5kZXNjcmliZSgnYW5pbWF0aW9uJywge1xuICAgIF9mYWxsYmFjazogZmFsc2UsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnb25Qcm9ncmVzcycgJiYgbmFtZSAhPT0gJ29uQ29tcGxldGUnICYmIG5hbWUgIT09ICdmbicsXG4gIH0pO1xuXG4gIGRlZmF1bHRzLnNldCgnYW5pbWF0aW9ucycsIHtcbiAgICBjb2xvcnM6IHtcbiAgICAgIHR5cGU6ICdjb2xvcicsXG4gICAgICBwcm9wZXJ0aWVzOiBjb2xvcnNcbiAgICB9LFxuICAgIG51bWJlcnM6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgcHJvcGVydGllczogbnVtYmVyc1xuICAgIH0sXG4gIH0pO1xuXG4gIGRlZmF1bHRzLmRlc2NyaWJlKCdhbmltYXRpb25zJywge1xuICAgIF9mYWxsYmFjazogJ2FuaW1hdGlvbicsXG4gIH0pO1xuXG4gIGRlZmF1bHRzLnNldCgndHJhbnNpdGlvbnMnLCB7XG4gICAgYWN0aXZlOiB7XG4gICAgICBhbmltYXRpb246IHtcbiAgICAgICAgZHVyYXRpb246IDQwMFxuICAgICAgfVxuICAgIH0sXG4gICAgcmVzaXplOiB7XG4gICAgICBhbmltYXRpb246IHtcbiAgICAgICAgZHVyYXRpb246IDBcbiAgICAgIH1cbiAgICB9LFxuICAgIHNob3c6IHtcbiAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgY29sb3JzOiB7XG4gICAgICAgICAgZnJvbTogJ3RyYW5zcGFyZW50J1xuICAgICAgICB9LFxuICAgICAgICB2aXNpYmxlOiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgIGR1cmF0aW9uOiAwIC8vIHNob3cgaW1tZWRpYXRlbHlcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICB9LFxuICAgIGhpZGU6IHtcbiAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgY29sb3JzOiB7XG4gICAgICAgICAgdG86ICd0cmFuc3BhcmVudCdcbiAgICAgICAgfSxcbiAgICAgICAgdmlzaWJsZToge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICBlYXNpbmc6ICdsaW5lYXInLFxuICAgICAgICAgIGZuOiB2ID0+IHYgfCAwIC8vIGZvciBrZWVwaW5nIHRoZSBkYXRhc2V0IHZpc2libGUgYWxsIHRoZSB3YXkgdGhyb3VnaCB0aGUgYW5pbWF0aW9uXG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gYXBwbHlMYXlvdXRzRGVmYXVsdHMoZGVmYXVsdHMpIHtcbiAgZGVmYXVsdHMuc2V0KCdsYXlvdXQnLCB7XG4gICAgYXV0b1BhZGRpbmc6IHRydWUsXG4gICAgcGFkZGluZzoge1xuICAgICAgdG9wOiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICBib3R0b206IDAsXG4gICAgICBsZWZ0OiAwXG4gICAgfVxuICB9KTtcbn1cbiIsICJcbmNvbnN0IGludGxDYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBJbnRsLk51bWJlckZvcm1hdD4oKTtcblxuZnVuY3Rpb24gZ2V0TnVtYmVyRm9ybWF0KGxvY2FsZTogc3RyaW5nLCBvcHRpb25zPzogSW50bC5OdW1iZXJGb3JtYXRPcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBjYWNoZUtleSA9IGxvY2FsZSArIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpO1xuICBsZXQgZm9ybWF0dGVyID0gaW50bENhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmICghZm9ybWF0dGVyKSB7XG4gICAgZm9ybWF0dGVyID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxvY2FsZSwgb3B0aW9ucyk7XG4gICAgaW50bENhY2hlLnNldChjYWNoZUtleSwgZm9ybWF0dGVyKTtcbiAgfVxuICByZXR1cm4gZm9ybWF0dGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0TnVtYmVyKG51bTogbnVtYmVyLCBsb2NhbGU6IHN0cmluZywgb3B0aW9ucz86IEludGwuTnVtYmVyRm9ybWF0T3B0aW9ucykge1xuICByZXR1cm4gZ2V0TnVtYmVyRm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0KG51bSk7XG59XG4iLCAiaW1wb3J0IHtpc0FycmF5fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge2Zvcm1hdE51bWJlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmludGwuanMnO1xuaW1wb3J0IHtsb2cxMH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuXG4vKipcbiAqIE5hbWVzcGFjZSB0byBob2xkIGZvcm1hdHRlcnMgZm9yIGRpZmZlcmVudCB0eXBlcyBvZiB0aWNrc1xuICogQG5hbWVzcGFjZSBDaGFydC5UaWNrcy5mb3JtYXR0ZXJzXG4gKi9cbmNvbnN0IGZvcm1hdHRlcnMgPSB7XG4gIC8qKlxuICAgKiBGb3JtYXR0ZXIgZm9yIHZhbHVlIGxhYmVsc1xuICAgKiBAbWV0aG9kIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnMudmFsdWVzXG4gICAqIEBwYXJhbSB2YWx1ZSB0aGUgdmFsdWUgdG8gZGlzcGxheVxuICAgKiBAcmV0dXJuIHtzdHJpbmd8c3RyaW5nW119IHRoZSBsYWJlbCB0byBkaXNwbGF5XG4gICAqL1xuICB2YWx1ZXModmFsdWUpIHtcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgPyAvKiogQHR5cGUge3N0cmluZ1tdfSAqLyAodmFsdWUpIDogJycgKyB2YWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogRm9ybWF0dGVyIGZvciBudW1lcmljIHRpY2tzXG4gICAqIEBtZXRob2QgQ2hhcnQuVGlja3MuZm9ybWF0dGVycy5udW1lcmljXG4gICAqIEBwYXJhbSB0aWNrVmFsdWUge251bWJlcn0gdGhlIHZhbHVlIHRvIGJlIGZvcm1hdHRlZFxuICAgKiBAcGFyYW0gaW5kZXgge251bWJlcn0gdGhlIHBvc2l0aW9uIG9mIHRoZSB0aWNrVmFsdWUgcGFyYW1ldGVyIGluIHRoZSB0aWNrcyBhcnJheVxuICAgKiBAcGFyYW0gdGlja3Mge29iamVjdFtdfSB0aGUgbGlzdCBvZiB0aWNrcyBiZWluZyBjb252ZXJ0ZWRcbiAgICogQHJldHVybiB7c3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRpY2tWYWx1ZSBwYXJhbWV0ZXJcbiAgICovXG4gIG51bWVyaWModGlja1ZhbHVlLCBpbmRleCwgdGlja3MpIHtcbiAgICBpZiAodGlja1ZhbHVlID09PSAwKSB7XG4gICAgICByZXR1cm4gJzAnOyAvLyBuZXZlciBzaG93IGRlY2ltYWwgcGxhY2VzIGZvciAwXG4gICAgfVxuXG4gICAgY29uc3QgbG9jYWxlID0gdGhpcy5jaGFydC5vcHRpb25zLmxvY2FsZTtcbiAgICBsZXQgbm90YXRpb247XG4gICAgbGV0IGRlbHRhID0gdGlja1ZhbHVlOyAvLyBUaGlzIGlzIHVzZWQgd2hlbiB0aGVyZSBhcmUgbGVzcyB0aGFuIDIgdGlja3MgYXMgdGhlIHRpY2sgaW50ZXJ2YWwuXG5cbiAgICBpZiAodGlja3MubGVuZ3RoID4gMSkge1xuICAgICAgLy8gYWxsIHRpY2tzIGFyZSBzbWFsbCBvciB0aGVyZSBodWdlIG51bWJlcnM7IHVzZSBzY2llbnRpZmljIG5vdGF0aW9uXG4gICAgICBjb25zdCBtYXhUaWNrID0gTWF0aC5tYXgoTWF0aC5hYnModGlja3NbMF0udmFsdWUpLCBNYXRoLmFicyh0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZSkpO1xuICAgICAgaWYgKG1heFRpY2sgPCAxZS00IHx8IG1heFRpY2sgPiAxZSsxNSkge1xuICAgICAgICBub3RhdGlvbiA9ICdzY2llbnRpZmljJztcbiAgICAgIH1cblxuICAgICAgZGVsdGEgPSBjYWxjdWxhdGVEZWx0YSh0aWNrVmFsdWUsIHRpY2tzKTtcbiAgICB9XG5cbiAgICBjb25zdCBsb2dEZWx0YSA9IGxvZzEwKE1hdGguYWJzKGRlbHRhKSk7XG5cbiAgICAvLyBXaGVuIGRhdGFzZXRzIGhhdmUgdmFsdWVzIGFwcHJvYWNoaW5nIE51bWJlci5NQVhfVkFMVUUsIHRoZSB0aWNrIGNhbGN1bGF0aW9ucyBtaWdodCByZXN1bHQgaW5cbiAgICAvLyBpbmZpbml0eSBhbmQgZXZlbnR1YWxseSBOYU4uIFBhc3NpbmcgTmFOIGZvciBtaW5pbXVtRnJhY3Rpb25EaWdpdHMgb3IgbWF4aW11bUZyYWN0aW9uRGlnaXRzXG4gICAgLy8gd2lsbCBtYWtlIHRoZSBudW1iZXIgZm9ybWF0dGVyIHRocm93LiBTbyBpbnN0ZWFkIHdlIGNoZWNrIGZvciBpc05hTiBhbmQgdXNlIGEgZmFsbGJhY2sgdmFsdWUuXG4gICAgLy9cbiAgICAvLyB0b0ZpeGVkIGhhcyBhIG1heCBvZiAyMCBkZWNpbWFsIHBsYWNlc1xuICAgIGNvbnN0IG51bURlY2ltYWwgPSBpc05hTihsb2dEZWx0YSkgPyAxIDogTWF0aC5tYXgoTWF0aC5taW4oLTEgKiBNYXRoLmZsb29yKGxvZ0RlbHRhKSwgMjApLCAwKTtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7bm90YXRpb24sIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogbnVtRGVjaW1hbCwgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiBudW1EZWNpbWFsfTtcbiAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHRoaXMub3B0aW9ucy50aWNrcy5mb3JtYXQpO1xuXG4gICAgcmV0dXJuIGZvcm1hdE51bWJlcih0aWNrVmFsdWUsIGxvY2FsZSwgb3B0aW9ucyk7XG4gIH0sXG5cblxuICAvKipcbiAgICogRm9ybWF0dGVyIGZvciBsb2dhcml0aG1pYyB0aWNrc1xuICAgKiBAbWV0aG9kIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnMubG9nYXJpdGhtaWNcbiAgICogQHBhcmFtIHRpY2tWYWx1ZSB7bnVtYmVyfSB0aGUgdmFsdWUgdG8gYmUgZm9ybWF0dGVkXG4gICAqIEBwYXJhbSBpbmRleCB7bnVtYmVyfSB0aGUgcG9zaXRpb24gb2YgdGhlIHRpY2tWYWx1ZSBwYXJhbWV0ZXIgaW4gdGhlIHRpY2tzIGFycmF5XG4gICAqIEBwYXJhbSB0aWNrcyB7b2JqZWN0W119IHRoZSBsaXN0IG9mIHRpY2tzIGJlaW5nIGNvbnZlcnRlZFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGlja1ZhbHVlIHBhcmFtZXRlclxuICAgKi9cbiAgbG9nYXJpdGhtaWModGlja1ZhbHVlLCBpbmRleCwgdGlja3MpIHtcbiAgICBpZiAodGlja1ZhbHVlID09PSAwKSB7XG4gICAgICByZXR1cm4gJzAnO1xuICAgIH1cbiAgICBjb25zdCByZW1haW4gPSB0aWNrc1tpbmRleF0uc2lnbmlmaWNhbmQgfHwgKHRpY2tWYWx1ZSAvIChNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMCh0aWNrVmFsdWUpKSkpKTtcbiAgICBpZiAoWzEsIDIsIDMsIDUsIDEwLCAxNV0uaW5jbHVkZXMocmVtYWluKSB8fCBpbmRleCA+IDAuOCAqIHRpY2tzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcnMubnVtZXJpYy5jYWxsKHRoaXMsIHRpY2tWYWx1ZSwgaW5kZXgsIHRpY2tzKTtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbn07XG5cblxuZnVuY3Rpb24gY2FsY3VsYXRlRGVsdGEodGlja1ZhbHVlLCB0aWNrcykge1xuICAvLyBGaWd1cmUgb3V0IGhvdyBtYW55IGRpZ2l0cyB0byBzaG93XG4gIC8vIFRoZSBzcGFjZSBiZXR3ZWVuIHRoZSBmaXJzdCB0d28gdGlja3MgbWlnaHQgYmUgc21hbGxlciB0aGFuIG5vcm1hbCBzcGFjaW5nXG4gIGxldCBkZWx0YSA9IHRpY2tzLmxlbmd0aCA+IDMgPyB0aWNrc1syXS52YWx1ZSAtIHRpY2tzWzFdLnZhbHVlIDogdGlja3NbMV0udmFsdWUgLSB0aWNrc1swXS52YWx1ZTtcblxuICAvLyBJZiB3ZSBoYXZlIGEgbnVtYmVyIGxpa2UgMi41IGFzIHRoZSBkZWx0YSwgZmlndXJlIG91dCBob3cgbWFueSBkZWNpbWFsIHBsYWNlcyB3ZSBuZWVkXG4gIGlmIChNYXRoLmFicyhkZWx0YSkgPj0gMSAmJiB0aWNrVmFsdWUgIT09IE1hdGguZmxvb3IodGlja1ZhbHVlKSkge1xuICAgIC8vIG5vdCBhbiBpbnRlZ2VyXG4gICAgZGVsdGEgPSB0aWNrVmFsdWUgLSBNYXRoLmZsb29yKHRpY2tWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGRlbHRhO1xufVxuXG4vKipcbiAqIE5hbWVzcGFjZSB0byBob2xkIHN0YXRpYyB0aWNrIGdlbmVyYXRpb24gZnVuY3Rpb25zXG4gKiBAbmFtZXNwYWNlIENoYXJ0LlRpY2tzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtmb3JtYXR0ZXJzfTtcbiIsICJpbXBvcnQgVGlja3MgZnJvbSAnLi9jb3JlLnRpY2tzLmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5U2NhbGVEZWZhdWx0cyhkZWZhdWx0cykge1xuICBkZWZhdWx0cy5zZXQoJ3NjYWxlJywge1xuICAgIGRpc3BsYXk6IHRydWUsXG4gICAgb2Zmc2V0OiBmYWxzZSxcbiAgICByZXZlcnNlOiBmYWxzZSxcbiAgICBiZWdpbkF0WmVybzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBTY2FsZSBib3VuZGFyeSBzdHJhdGVneSAoYnlwYXNzZWQgYnkgbWluL21heCB0aW1lIG9wdGlvbnMpXG4gICAgICogLSBgZGF0YWA6IG1ha2Ugc3VyZSBkYXRhIGFyZSBmdWxseSB2aXNpYmxlLCB0aWNrcyBvdXRzaWRlIGFyZSByZW1vdmVkXG4gICAgICogLSBgdGlja3NgOiBtYWtlIHN1cmUgdGlja3MgYXJlIGZ1bGx5IHZpc2libGUsIGRhdGEgb3V0c2lkZSBhcmUgdHJ1bmNhdGVkXG4gICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzQ1NTZcbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKi9cbiAgICBib3VuZHM6ICd0aWNrcycsXG5cbiAgICBjbGlwOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQWRkaXRpb24gZ3JhY2UgYWRkZWQgdG8gbWF4IGFuZCByZWR1Y2VkIGZyb20gbWluIGRhdGEgdmFsdWUuXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICovXG4gICAgZ3JhY2U6IDAsXG5cbiAgICAvLyBncmlkIGxpbmUgc2V0dGluZ3NcbiAgICBncmlkOiB7XG4gICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgbGluZVdpZHRoOiAxLFxuICAgICAgZHJhd09uQ2hhcnRBcmVhOiB0cnVlLFxuICAgICAgZHJhd1RpY2tzOiB0cnVlLFxuICAgICAgdGlja0xlbmd0aDogOCxcbiAgICAgIHRpY2tXaWR0aDogKF9jdHgsIG9wdGlvbnMpID0+IG9wdGlvbnMubGluZVdpZHRoLFxuICAgICAgdGlja0NvbG9yOiAoX2N0eCwgb3B0aW9ucykgPT4gb3B0aW9ucy5jb2xvcixcbiAgICAgIG9mZnNldDogZmFsc2UsXG4gICAgfSxcblxuICAgIGJvcmRlcjoge1xuICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgIGRhc2g6IFtdLFxuICAgICAgZGFzaE9mZnNldDogMC4wLFxuICAgICAgd2lkdGg6IDFcbiAgICB9LFxuXG4gICAgLy8gc2NhbGUgdGl0bGVcbiAgICB0aXRsZToge1xuICAgICAgLy8gZGlzcGxheSBwcm9wZXJ0eVxuICAgICAgZGlzcGxheTogZmFsc2UsXG5cbiAgICAgIC8vIGFjdHVhbCBsYWJlbFxuICAgICAgdGV4dDogJycsXG5cbiAgICAgIC8vIHRvcC9ib3R0b20gcGFkZGluZ1xuICAgICAgcGFkZGluZzoge1xuICAgICAgICB0b3A6IDQsXG4gICAgICAgIGJvdHRvbTogNFxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBsYWJlbCBzZXR0aW5nc1xuICAgIHRpY2tzOiB7XG4gICAgICBtaW5Sb3RhdGlvbjogMCxcbiAgICAgIG1heFJvdGF0aW9uOiA1MCxcbiAgICAgIG1pcnJvcjogZmFsc2UsXG4gICAgICB0ZXh0U3Ryb2tlV2lkdGg6IDAsXG4gICAgICB0ZXh0U3Ryb2tlQ29sb3I6ICcnLFxuICAgICAgcGFkZGluZzogMyxcbiAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICBhdXRvU2tpcDogdHJ1ZSxcbiAgICAgIGF1dG9Ta2lwUGFkZGluZzogMyxcbiAgICAgIGxhYmVsT2Zmc2V0OiAwLFxuICAgICAgLy8gV2UgcGFzcyB0aHJvdWdoIGFycmF5cyB0byBiZSByZW5kZXJlZCBhcyBtdWx0aWxpbmUgbGFiZWxzLCB3ZSBjb252ZXJ0IE90aGVycyB0byBzdHJpbmdzIGhlcmUuXG4gICAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy52YWx1ZXMsXG4gICAgICBtaW5vcjoge30sXG4gICAgICBtYWpvcjoge30sXG4gICAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgICBjcm9zc0FsaWduOiAnbmVhcicsXG5cbiAgICAgIHNob3dMYWJlbEJhY2tkcm9wOiBmYWxzZSxcbiAgICAgIGJhY2tkcm9wQ29sb3I6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNzUpJyxcbiAgICAgIGJhY2tkcm9wUGFkZGluZzogMixcbiAgICB9XG4gIH0pO1xuXG4gIGRlZmF1bHRzLnJvdXRlKCdzY2FsZS50aWNrcycsICdjb2xvcicsICcnLCAnY29sb3InKTtcbiAgZGVmYXVsdHMucm91dGUoJ3NjYWxlLmdyaWQnLCAnY29sb3InLCAnJywgJ2JvcmRlckNvbG9yJyk7XG4gIGRlZmF1bHRzLnJvdXRlKCdzY2FsZS5ib3JkZXInLCAnY29sb3InLCAnJywgJ2JvcmRlckNvbG9yJyk7XG4gIGRlZmF1bHRzLnJvdXRlKCdzY2FsZS50aXRsZScsICdjb2xvcicsICcnLCAnY29sb3InKTtcblxuICBkZWZhdWx0cy5kZXNjcmliZSgnc2NhbGUnLCB7XG4gICAgX2ZhbGxiYWNrOiBmYWxzZSxcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFuYW1lLnN0YXJ0c1dpdGgoJ2JlZm9yZScpICYmICFuYW1lLnN0YXJ0c1dpdGgoJ2FmdGVyJykgJiYgbmFtZSAhPT0gJ2NhbGxiYWNrJyAmJiBuYW1lICE9PSAncGFyc2VyJyxcbiAgICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JvcmRlckRhc2gnICYmIG5hbWUgIT09ICd0aWNrQm9yZGVyRGFzaCcgJiYgbmFtZSAhPT0gJ2Rhc2gnLFxuICB9KTtcblxuICBkZWZhdWx0cy5kZXNjcmliZSgnc2NhbGVzJywge1xuICAgIF9mYWxsYmFjazogJ3NjYWxlJyxcbiAgfSk7XG5cbiAgZGVmYXVsdHMuZGVzY3JpYmUoJ3NjYWxlLnRpY2tzJywge1xuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JhY2tkcm9wUGFkZGluZycgJiYgbmFtZSAhPT0gJ2NhbGxiYWNrJyxcbiAgICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JhY2tkcm9wUGFkZGluZycsXG4gIH0pO1xufVxuIiwgImltcG9ydCB7Z2V0SG92ZXJDb2xvcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbG9yLmpzJztcbmltcG9ydCB7aXNPYmplY3QsIG1lcmdlLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHthcHBseUFuaW1hdGlvbnNEZWZhdWx0c30gZnJvbSAnLi9jb3JlLmFuaW1hdGlvbnMuZGVmYXVsdHMuanMnO1xuaW1wb3J0IHthcHBseUxheW91dHNEZWZhdWx0c30gZnJvbSAnLi9jb3JlLmxheW91dHMuZGVmYXVsdHMuanMnO1xuaW1wb3J0IHthcHBseVNjYWxlRGVmYXVsdHN9IGZyb20gJy4vY29yZS5zY2FsZS5kZWZhdWx0cy5qcyc7XG5cbmV4cG9ydCBjb25zdCBvdmVycmlkZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZXhwb3J0IGNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRTY29wZShub2RlLCBrZXkpIHtcbiAgaWYgKCFrZXkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBjb25zdCBrZXlzID0ga2V5LnNwbGl0KCcuJyk7XG4gIGZvciAobGV0IGkgPSAwLCBuID0ga2V5cy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBjb25zdCBrID0ga2V5c1tpXTtcbiAgICBub2RlID0gbm9kZVtrXSB8fCAobm9kZVtrXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBzZXQocm9vdCwgc2NvcGUsIHZhbHVlcykge1xuICBpZiAodHlwZW9mIHNjb3BlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBtZXJnZShnZXRTY29wZShyb290LCBzY29wZSksIHZhbHVlcyk7XG4gIH1cbiAgcmV0dXJuIG1lcmdlKGdldFNjb3BlKHJvb3QsICcnKSwgc2NvcGUpO1xufVxuXG4vKipcbiAqIFBsZWFzZSB1c2UgdGhlIG1vZHVsZSdzIGRlZmF1bHQgZXhwb3J0IHdoaWNoIHByb3ZpZGVzIGEgc2luZ2xldG9uIGluc3RhbmNlXG4gKiBOb3RlOiBjbGFzcyBpcyBleHBvcnRlZCBmb3IgdHlwZWRvY1xuICovXG5leHBvcnQgY2xhc3MgRGVmYXVsdHMge1xuICBjb25zdHJ1Y3RvcihfZGVzY3JpcHRvcnMsIF9hcHBsaWVycykge1xuICAgIHRoaXMuYW5pbWF0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoMCwwLDAsMC4xKSc7XG4gICAgdGhpcy5ib3JkZXJDb2xvciA9ICdyZ2JhKDAsMCwwLDAuMSknO1xuICAgIHRoaXMuY29sb3IgPSAnIzY2Nic7XG4gICAgdGhpcy5kYXRhc2V0cyA9IHt9O1xuICAgIHRoaXMuZGV2aWNlUGl4ZWxSYXRpbyA9IChjb250ZXh0KSA9PiBjb250ZXh0LmNoYXJ0LnBsYXRmb3JtLmdldERldmljZVBpeGVsUmF0aW8oKTtcbiAgICB0aGlzLmVsZW1lbnRzID0ge307XG4gICAgdGhpcy5ldmVudHMgPSBbXG4gICAgICAnbW91c2Vtb3ZlJyxcbiAgICAgICdtb3VzZW91dCcsXG4gICAgICAnY2xpY2snLFxuICAgICAgJ3RvdWNoc3RhcnQnLFxuICAgICAgJ3RvdWNobW92ZSdcbiAgICBdO1xuICAgIHRoaXMuZm9udCA9IHtcbiAgICAgIGZhbWlseTogXCInSGVsdmV0aWNhIE5ldWUnLCAnSGVsdmV0aWNhJywgJ0FyaWFsJywgc2Fucy1zZXJpZlwiLFxuICAgICAgc2l6ZTogMTIsXG4gICAgICBzdHlsZTogJ25vcm1hbCcsXG4gICAgICBsaW5lSGVpZ2h0OiAxLjIsXG4gICAgICB3ZWlnaHQ6IG51bGxcbiAgICB9O1xuICAgIHRoaXMuaG92ZXIgPSB7fTtcbiAgICB0aGlzLmhvdmVyQmFja2dyb3VuZENvbG9yID0gKGN0eCwgb3B0aW9ucykgPT4gZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJhY2tncm91bmRDb2xvcik7XG4gICAgdGhpcy5ob3ZlckJvcmRlckNvbG9yID0gKGN0eCwgb3B0aW9ucykgPT4gZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJvcmRlckNvbG9yKTtcbiAgICB0aGlzLmhvdmVyQ29sb3IgPSAoY3R4LCBvcHRpb25zKSA9PiBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuY29sb3IpO1xuICAgIHRoaXMuaW5kZXhBeGlzID0gJ3gnO1xuICAgIHRoaXMuaW50ZXJhY3Rpb24gPSB7XG4gICAgICBtb2RlOiAnbmVhcmVzdCcsXG4gICAgICBpbnRlcnNlY3Q6IHRydWUsXG4gICAgICBpbmNsdWRlSW52aXNpYmxlOiBmYWxzZVxuICAgIH07XG4gICAgdGhpcy5tYWludGFpbkFzcGVjdFJhdGlvID0gdHJ1ZTtcbiAgICB0aGlzLm9uSG92ZXIgPSBudWxsO1xuICAgIHRoaXMub25DbGljayA9IG51bGw7XG4gICAgdGhpcy5wYXJzaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnBsdWdpbnMgPSB7fTtcbiAgICB0aGlzLnJlc3BvbnNpdmUgPSB0cnVlO1xuICAgIHRoaXMuc2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zY2FsZXMgPSB7fTtcbiAgICB0aGlzLnNob3dMaW5lID0gdHJ1ZTtcbiAgICB0aGlzLmRyYXdBY3RpdmVFbGVtZW50c09uVG9wID0gdHJ1ZTtcblxuICAgIHRoaXMuZGVzY3JpYmUoX2Rlc2NyaXB0b3JzKTtcbiAgICB0aGlzLmFwcGx5KF9hcHBsaWVycyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBzY29wZVxuXHQgKiBAcGFyYW0ge29iamVjdH0gW3ZhbHVlc11cblx0ICovXG4gIHNldChzY29wZSwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHNldCh0aGlzLCBzY29wZSwgdmFsdWVzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc2NvcGVcblx0ICovXG4gIGdldChzY29wZSkge1xuICAgIHJldHVybiBnZXRTY29wZSh0aGlzLCBzY29wZSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBzY29wZVxuXHQgKiBAcGFyYW0ge29iamVjdH0gW3ZhbHVlc11cblx0ICovXG4gIGRlc2NyaWJlKHNjb3BlLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gc2V0KGRlc2NyaXB0b3JzLCBzY29wZSwgdmFsdWVzKTtcbiAgfVxuXG4gIG92ZXJyaWRlKHNjb3BlLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gc2V0KG92ZXJyaWRlcywgc2NvcGUsIHZhbHVlcyk7XG4gIH1cblxuICAvKipcblx0ICogUm91dGVzIHRoZSBuYW1lZCBkZWZhdWx0cyB0byBmYWxsYmFjayB0byBhbm90aGVyIHNjb3BlL25hbWUuXG5cdCAqIFRoaXMgcm91dGluZyBpcyB1c2VmdWwgd2hlbiB0aG9zZSB0YXJnZXQgdmFsdWVzLCBsaWtlIGRlZmF1bHRzLmNvbG9yLCBhcmUgY2hhbmdlZCBydW50aW1lLlxuXHQgKiBJZiB0aGUgdmFsdWVzIHdvdWxkIGJlIGNvcGllZCwgdGhlIHJ1bnRpbWUgY2hhbmdlIHdvdWxkIG5vdCB0YWtlIGVmZmVjdC4gQnkgcm91dGluZywgdGhlXG5cdCAqIGZhbGxiYWNrIGlzIGV2YWx1YXRlZCBhdCBlYWNoIGFjY2Vzcywgc28gaXRzIGFsd2F5cyB1cCB0byBkYXRlLlxuXHQgKlxuXHQgKiBFeGFtcGxlOlxuXHQgKlxuXHQgKiBcdGRlZmF1bHRzLnJvdXRlKCdlbGVtZW50cy5hcmMnLCAnYmFja2dyb3VuZENvbG9yJywgJycsICdjb2xvcicpXG5cdCAqICAgLSByZWFkcyB0aGUgYmFja2dyb3VuZENvbG9yIGZyb20gZGVmYXVsdHMuY29sb3Igd2hlbiB1bmRlZmluZWQgbG9jYWxseVxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc2NvcGUgU2NvcGUgdGhpcyByb3V0ZSBhcHBsaWVzIHRvLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBQcm9wZXJ0eSBuYW1lIHRoYXQgc2hvdWxkIGJlIHJvdXRlZCB0byBkaWZmZXJlbnQgbmFtZXNwYWNlIHdoZW4gbm90IGRlZmluZWQgaGVyZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldFNjb3BlIFRoZSBuYW1lc3BhY2Ugd2hlcmUgdGhvc2UgcHJvcGVydGllcyBzaG91bGQgYmUgcm91dGVkIHRvLlxuXHQgKiBFbXB0eSBzdHJpbmcgKCcnKSBpcyB0aGUgcm9vdCBvZiBkZWZhdWx0cy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldE5hbWUgVGhlIHRhcmdldCBuYW1lIGluIHRoZSB0YXJnZXQgc2NvcGUgdGhlIHByb3BlcnR5IHNob3VsZCBiZSByb3V0ZWQgdG8uXG5cdCAqL1xuICByb3V0ZShzY29wZSwgbmFtZSwgdGFyZ2V0U2NvcGUsIHRhcmdldE5hbWUpIHtcbiAgICBjb25zdCBzY29wZU9iamVjdCA9IGdldFNjb3BlKHRoaXMsIHNjb3BlKTtcbiAgICBjb25zdCB0YXJnZXRTY29wZU9iamVjdCA9IGdldFNjb3BlKHRoaXMsIHRhcmdldFNjb3BlKTtcbiAgICBjb25zdCBwcml2YXRlTmFtZSA9ICdfJyArIG5hbWU7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzY29wZU9iamVjdCwge1xuICAgICAgLy8gQSBwcml2YXRlIHByb3BlcnR5IGlzIGRlZmluZWQgdG8gaG9sZCB0aGUgYWN0dWFsIHZhbHVlLCB3aGVuIHRoaXMgcHJvcGVydHkgaXMgc2V0IGluIGl0cyBzY29wZSAoc2V0IGluIHRoZSBzZXR0ZXIpXG4gICAgICBbcHJpdmF0ZU5hbWVdOiB7XG4gICAgICAgIHZhbHVlOiBzY29wZU9iamVjdFtuYW1lXSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0sXG4gICAgICAvLyBUaGUgYWN0dWFsIHByb3BlcnR5IGlzIGRlZmluZWQgYXMgZ2V0dGVyL3NldHRlciBzbyB3ZSBjYW4gZG8gdGhlIHJvdXRpbmcgd2hlbiB2YWx1ZSBpcyBub3QgbG9jYWxseSBzZXQuXG4gICAgICBbbmFtZV06IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIGNvbnN0IGxvY2FsID0gdGhpc1twcml2YXRlTmFtZV07XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0U2NvcGVPYmplY3RbdGFyZ2V0TmFtZV07XG4gICAgICAgICAgaWYgKGlzT2JqZWN0KGxvY2FsKSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRhcmdldCwgbG9jYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWVPckRlZmF1bHQobG9jYWwsIHRhcmdldCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgIHRoaXNbcHJpdmF0ZU5hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGFwcGx5KGFwcGxpZXJzKSB7XG4gICAgYXBwbGllcnMuZm9yRWFjaCgoYXBwbHkpID0+IGFwcGx5KHRoaXMpKTtcbiAgfVxufVxuXG4vLyBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBkZWZhdWx0IC8qICNfX1BVUkVfXyAqLyBuZXcgRGVmYXVsdHMoe1xuICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFuYW1lLnN0YXJ0c1dpdGgoJ29uJyksXG4gIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnZXZlbnRzJyxcbiAgaG92ZXI6IHtcbiAgICBfZmFsbGJhY2s6ICdpbnRlcmFjdGlvbidcbiAgfSxcbiAgaW50ZXJhY3Rpb246IHtcbiAgICBfc2NyaXB0YWJsZTogZmFsc2UsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gIH1cbn0sIFthcHBseUFuaW1hdGlvbnNEZWZhdWx0cywgYXBwbHlMYXlvdXRzRGVmYXVsdHMsIGFwcGx5U2NhbGVEZWZhdWx0c10pO1xuIiwgImltcG9ydCB0eXBlIHtcbiAgQ2hhcnQsXG4gIFBvaW50LFxuICBGb250U3BlYyxcbiAgQ2FudmFzRm9udFNwZWMsXG4gIFBvaW50U3R5bGUsXG4gIFJlbmRlclRleHRPcHRzLFxuICBCYWNrZHJvcE9wdGlvbnNcbn0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuaW1wb3J0IHR5cGUge1xuICBUUkJMLFxuICBTcGxpbmVQb2ludCxcbiAgUm91bmRlZFJlY3QsXG4gIFRSQkxDb3JuZXJzXG59IGZyb20gJy4uL3R5cGVzL2dlb21ldHJpYy5qcyc7XG5pbXBvcnQge2lzQXJyYXksIGlzTnVsbE9yVW5kZWZ9IGZyb20gJy4vaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7UEksIFRBVSwgSEFMRl9QSSwgUVVBUlRFUl9QSSwgVFdPX1RISVJEU19QSSwgUkFEX1BFUl9ERUd9IGZyb20gJy4vaGVscGVycy5tYXRoLmpzJztcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gZm9udCBvYmplY3QgaW50byBhIENTUyBmb250IHN0cmluZy5cbiAqIEBwYXJhbSBmb250IC0gQSBmb250IG9iamVjdC5cbiAqIEByZXR1cm4gVGhlIENTUyBmb250IHN0cmluZy4gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9mb250XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Gb250U3RyaW5nKGZvbnQ6IEZvbnRTcGVjKSB7XG4gIGlmICghZm9udCB8fCBpc051bGxPclVuZGVmKGZvbnQuc2l6ZSkgfHwgaXNOdWxsT3JVbmRlZihmb250LmZhbWlseSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiAoZm9udC5zdHlsZSA/IGZvbnQuc3R5bGUgKyAnICcgOiAnJylcblx0XHQrIChmb250LndlaWdodCA/IGZvbnQud2VpZ2h0ICsgJyAnIDogJycpXG5cdFx0KyBmb250LnNpemUgKyAncHggJ1xuXHRcdCsgZm9udC5mYW1pbHk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9tZWFzdXJlVGV4dChcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIGRhdGE6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4sXG4gIGdjOiBzdHJpbmdbXSxcbiAgbG9uZ2VzdDogbnVtYmVyLFxuICBzdHJpbmc6IHN0cmluZ1xuKSB7XG4gIGxldCB0ZXh0V2lkdGggPSBkYXRhW3N0cmluZ107XG4gIGlmICghdGV4dFdpZHRoKSB7XG4gICAgdGV4dFdpZHRoID0gZGF0YVtzdHJpbmddID0gY3R4Lm1lYXN1cmVUZXh0KHN0cmluZykud2lkdGg7XG4gICAgZ2MucHVzaChzdHJpbmcpO1xuICB9XG4gIGlmICh0ZXh0V2lkdGggPiBsb25nZXN0KSB7XG4gICAgbG9uZ2VzdCA9IHRleHRXaWR0aDtcbiAgfVxuICByZXR1cm4gbG9uZ2VzdDtcbn1cblxudHlwZSBUaGluZyA9IHN0cmluZyB8IHVuZGVmaW5lZCB8IG51bGxcbnR5cGUgVGhpbmdzID0gKFRoaW5nIHwgVGhpbmdbXSlbXVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5leHBvcnQgZnVuY3Rpb24gX2xvbmdlc3RUZXh0KFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgZm9udDogc3RyaW5nLFxuICBhcnJheU9mVGhpbmdzOiBUaGluZ3MsXG4gIGNhY2hlPzoge2RhdGE/OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+LCBnYXJiYWdlQ29sbGVjdD86IHN0cmluZ1tdLCBmb250Pzogc3RyaW5nfVxuKSB7XG4gIGNhY2hlID0gY2FjaGUgfHwge307XG4gIGxldCBkYXRhID0gY2FjaGUuZGF0YSA9IGNhY2hlLmRhdGEgfHwge307XG4gIGxldCBnYyA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0ID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgfHwgW107XG5cbiAgaWYgKGNhY2hlLmZvbnQgIT09IGZvbnQpIHtcbiAgICBkYXRhID0gY2FjaGUuZGF0YSA9IHt9O1xuICAgIGdjID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgPSBbXTtcbiAgICBjYWNoZS5mb250ID0gZm9udDtcbiAgfVxuXG4gIGN0eC5zYXZlKCk7XG5cbiAgY3R4LmZvbnQgPSBmb250O1xuICBsZXQgbG9uZ2VzdCA9IDA7XG4gIGNvbnN0IGlsZW4gPSBhcnJheU9mVGhpbmdzLmxlbmd0aDtcbiAgbGV0IGk6IG51bWJlciwgajogbnVtYmVyLCBqbGVuOiBudW1iZXIsIHRoaW5nOiBUaGluZyB8IFRoaW5nW10sIG5lc3RlZFRoaW5nOiBUaGluZyB8IFRoaW5nW107XG4gIGZvciAoaSA9IDA7IGkgPCBpbGVuOyBpKyspIHtcbiAgICB0aGluZyA9IGFycmF5T2ZUaGluZ3NbaV07XG5cbiAgICAvLyBVbmRlZmluZWQgc3RyaW5ncyBhbmQgYXJyYXlzIHNob3VsZCBub3QgYmUgbWVhc3VyZWRcbiAgICBpZiAodGhpbmcgIT09IHVuZGVmaW5lZCAmJiB0aGluZyAhPT0gbnVsbCAmJiAhaXNBcnJheSh0aGluZykpIHtcbiAgICAgIGxvbmdlc3QgPSBfbWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgdGhpbmcpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh0aGluZykpIHtcbiAgICAgIC8vIGlmIGl0IGlzIGFuIGFycmF5IGxldHMgbWVhc3VyZSBlYWNoIGVsZW1lbnRcbiAgICAgIC8vIHRvIGRvIG1heWJlIHNpbXBsaWZ5IHRoaXMgZnVuY3Rpb24gYSBiaXQgc28gd2UgY2FuIGRvIHRoaXMgbW9yZSByZWN1cnNpdmVseT9cbiAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSB0aGluZy5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgICAgbmVzdGVkVGhpbmcgPSB0aGluZ1tqXTtcbiAgICAgICAgLy8gVW5kZWZpbmVkIHN0cmluZ3MgYW5kIGFycmF5cyBzaG91bGQgbm90IGJlIG1lYXN1cmVkXG4gICAgICAgIGlmIChuZXN0ZWRUaGluZyAhPT0gdW5kZWZpbmVkICYmIG5lc3RlZFRoaW5nICE9PSBudWxsICYmICFpc0FycmF5KG5lc3RlZFRoaW5nKSkge1xuICAgICAgICAgIGxvbmdlc3QgPSBfbWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgbmVzdGVkVGhpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY3R4LnJlc3RvcmUoKTtcblxuICBjb25zdCBnY0xlbiA9IGdjLmxlbmd0aCAvIDI7XG4gIGlmIChnY0xlbiA+IGFycmF5T2ZUaGluZ3MubGVuZ3RoKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGdjTGVuOyBpKyspIHtcbiAgICAgIGRlbGV0ZSBkYXRhW2djW2ldXTtcbiAgICB9XG4gICAgZ2Muc3BsaWNlKDAsIGdjTGVuKTtcbiAgfVxuICByZXR1cm4gbG9uZ2VzdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBhbGlnbmVkIHBpeGVsIHZhbHVlIHRvIGF2b2lkIGFudGktYWxpYXNpbmcgYmx1clxuICogQHBhcmFtIGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlLlxuICogQHBhcmFtIHBpeGVsIC0gQSBwaXhlbCB2YWx1ZS5cbiAqIEBwYXJhbSB3aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgZWxlbWVudC5cbiAqIEByZXR1cm5zIFRoZSBhbGlnbmVkIHBpeGVsIHZhbHVlLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9hbGlnblBpeGVsKGNoYXJ0OiBDaGFydCwgcGl4ZWw6IG51bWJlciwgd2lkdGg6IG51bWJlcikge1xuICBjb25zdCBkZXZpY2VQaXhlbFJhdGlvID0gY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW87XG4gIGNvbnN0IGhhbGZXaWR0aCA9IHdpZHRoICE9PSAwID8gTWF0aC5tYXgod2lkdGggLyAyLCAwLjUpIDogMDtcbiAgcmV0dXJuIE1hdGgucm91bmQoKHBpeGVsIC0gaGFsZldpZHRoKSAqIGRldmljZVBpeGVsUmF0aW8pIC8gZGV2aWNlUGl4ZWxSYXRpbyArIGhhbGZXaWR0aDtcbn1cblxuLyoqXG4gKiBDbGVhcnMgdGhlIGVudGlyZSBjYW52YXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhckNhbnZhcyhjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCBjdHg/OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcbiAgY3R4ID0gY3R4IHx8IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gIGN0eC5zYXZlKCk7XG4gIC8vIGNhbnZhcy53aWR0aCBhbmQgY2FudmFzLmhlaWdodCBkbyBub3QgY29uc2lkZXIgdGhlIGNhbnZhcyB0cmFuc2Zvcm0sXG4gIC8vIHdoaWxlIGNsZWFyUmVjdCBkb2VzXG4gIGN0eC5yZXNldFRyYW5zZm9ybSgpO1xuICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRHJhd1BvaW50T3B0aW9ucyB7XG4gIHBvaW50U3R5bGU6IFBvaW50U3R5bGU7XG4gIHJvdGF0aW9uPzogbnVtYmVyO1xuICByYWRpdXM6IG51bWJlcjtcbiAgYm9yZGVyV2lkdGg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRyYXdQb2ludChcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIG9wdGlvbnM6IERyYXdQb2ludE9wdGlvbnMsXG4gIHg6IG51bWJlcixcbiAgeTogbnVtYmVyXG4pIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICBkcmF3UG9pbnRMZWdlbmQoY3R4LCBvcHRpb25zLCB4LCB5LCBudWxsKTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmV4cG9ydCBmdW5jdGlvbiBkcmF3UG9pbnRMZWdlbmQoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBvcHRpb25zOiBEcmF3UG9pbnRPcHRpb25zLFxuICB4OiBudW1iZXIsXG4gIHk6IG51bWJlcixcbiAgdzogbnVtYmVyXG4pIHtcbiAgbGV0IHR5cGU6IHN0cmluZywgeE9mZnNldDogbnVtYmVyLCB5T2Zmc2V0OiBudW1iZXIsIHNpemU6IG51bWJlciwgY29ybmVyUmFkaXVzOiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIHhPZmZzZXRXOiBudW1iZXIsIHlPZmZzZXRXOiBudW1iZXI7XG4gIGNvbnN0IHN0eWxlID0gb3B0aW9ucy5wb2ludFN0eWxlO1xuICBjb25zdCByb3RhdGlvbiA9IG9wdGlvbnMucm90YXRpb247XG4gIGNvbnN0IHJhZGl1cyA9IG9wdGlvbnMucmFkaXVzO1xuICBsZXQgcmFkID0gKHJvdGF0aW9uIHx8IDApICogUkFEX1BFUl9ERUc7XG5cbiAgaWYgKHN0eWxlICYmIHR5cGVvZiBzdHlsZSA9PT0gJ29iamVjdCcpIHtcbiAgICB0eXBlID0gc3R5bGUudG9TdHJpbmcoKTtcbiAgICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgSFRNTEltYWdlRWxlbWVudF0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IEhUTUxDYW52YXNFbGVtZW50XScpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgY3R4LnJvdGF0ZShyYWQpO1xuICAgICAgY3R4LmRyYXdJbWFnZShzdHlsZSwgLXN0eWxlLndpZHRoIC8gMiwgLXN0eWxlLmhlaWdodCAvIDIsIHN0eWxlLndpZHRoLCBzdHlsZS5oZWlnaHQpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNOYU4ocmFkaXVzKSB8fCByYWRpdXMgPD0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGN0eC5iZWdpblBhdGgoKTtcblxuICBzd2l0Y2ggKHN0eWxlKSB7XG4gIC8vIERlZmF1bHQgaW5jbHVkZXMgY2lyY2xlXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICh3KSB7XG4gICAgICAgIGN0eC5lbGxpcHNlKHgsIHksIHcgLyAyLCByYWRpdXMsIDAsIDAsIFRBVSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHguYXJjKHgsIHksIHJhZGl1cywgMCwgVEFVKTtcbiAgICAgIH1cbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RyaWFuZ2xlJzpcbiAgICAgIHdpZHRoID0gdyA/IHcgLyAyIDogcmFkaXVzO1xuICAgICAgY3R4Lm1vdmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHdpZHRoLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG4gICAgICByYWQgKz0gVFdPX1RISVJEU19QSTtcbiAgICAgIGN0eC5saW5lVG8oeCArIE1hdGguc2luKHJhZCkgKiB3aWR0aCwgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuICAgICAgcmFkICs9IFRXT19USElSRFNfUEk7XG4gICAgICBjdHgubGluZVRvKHggKyBNYXRoLnNpbihyYWQpICogd2lkdGgsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3JlY3RSb3VuZGVkJzpcbiAgICAvLyBOT1RFOiB0aGUgcm91bmRlZCByZWN0IGltcGxlbWVudGF0aW9uIGNoYW5nZWQgdG8gdXNlIGBhcmNgIGluc3RlYWQgb2ZcbiAgICAvLyBgcXVhZHJhdGljQ3VydmVUb2Agc2luY2UgaXQgZ2VuZXJhdGVzIGJldHRlciByZXN1bHRzIHdoZW4gcmVjdCBpc1xuICAgIC8vIGFsbW9zdCBhIGNpcmNsZS4gMC41MTYgKGluc3RlYWQgb2YgMC41KSBwcm9kdWNlcyByZXN1bHRzIHdpdGggdmlzdWFsbHlcbiAgICAvLyBjbG9zZXIgcHJvcG9ydGlvbiB0byB0aGUgcHJldmlvdXMgaW1wbCBhbmQgaXQgaXMgaW5zY3JpYmVkIGluIHRoZVxuICAgIC8vIGNpcmNsZSB3aXRoIGByYWRpdXNgLiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUgdGhlIGZvbGxvd2luZyBQUnM6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzU1OTdcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTg1OFxuICAgICAgY29ybmVyUmFkaXVzID0gcmFkaXVzICogMC41MTY7XG4gICAgICBzaXplID0gcmFkaXVzIC0gY29ybmVyUmFkaXVzO1xuICAgICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCArIFFVQVJURVJfUEkpICogc2l6ZTtcbiAgICAgIHhPZmZzZXRXID0gTWF0aC5jb3MocmFkICsgUVVBUlRFUl9QSSkgKiAodyA/IHcgLyAyIC0gY29ybmVyUmFkaXVzIDogc2l6ZSk7XG4gICAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkICsgUVVBUlRFUl9QSSkgKiBzaXplO1xuICAgICAgeU9mZnNldFcgPSBNYXRoLnNpbihyYWQgKyBRVUFSVEVSX1BJKSAqICh3ID8gdyAvIDIgLSBjb3JuZXJSYWRpdXMgOiBzaXplKTtcbiAgICAgIGN0eC5hcmMoeCAtIHhPZmZzZXRXLCB5IC0geU9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgLSBQSSwgcmFkIC0gSEFMRl9QSSk7XG4gICAgICBjdHguYXJjKHggKyB5T2Zmc2V0VywgeSAtIHhPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkIC0gSEFMRl9QSSwgcmFkKTtcbiAgICAgIGN0eC5hcmMoeCArIHhPZmZzZXRXLCB5ICsgeU9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQsIHJhZCArIEhBTEZfUEkpO1xuICAgICAgY3R4LmFyYyh4IC0geU9mZnNldFcsIHkgKyB4T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCArIEhBTEZfUEksIHJhZCArIFBJKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3JlY3QnOlxuICAgICAgaWYgKCFyb3RhdGlvbikge1xuICAgICAgICBzaXplID0gTWF0aC5TUVJUMV8yICogcmFkaXVzO1xuICAgICAgICB3aWR0aCA9IHcgPyB3IC8gMiA6IHNpemU7XG4gICAgICAgIGN0eC5yZWN0KHggLSB3aWR0aCwgeSAtIHNpemUsIDIgKiB3aWR0aCwgMiAqIHNpemUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJhZCArPSBRVUFSVEVSX1BJO1xuICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlICdyZWN0Um90JzpcbiAgICAgIHhPZmZzZXRXID0gTWF0aC5jb3MocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXRXID0gTWF0aC5zaW4ocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldFcsIHkgLSB5T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHlPZmZzZXRXLCB5IC0geE9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0VywgeSArIHlPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldFcsIHkgKyB4T2Zmc2V0KTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Nyb3NzUm90JzpcbiAgICAgIHJhZCArPSBRVUFSVEVSX1BJO1xuICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlICdjcm9zcyc6XG4gICAgICB4T2Zmc2V0VyA9IE1hdGguY29zKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0VyA9IE1hdGguc2luKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXRXLCB5IC0geU9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0VywgeSArIHlPZmZzZXQpO1xuICAgICAgY3R4Lm1vdmVUbyh4ICsgeU9mZnNldFcsIHkgLSB4T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXRXLCB5ICsgeE9mZnNldCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzdGFyJzpcbiAgICAgIHhPZmZzZXRXID0gTWF0aC5jb3MocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXRXID0gTWF0aC5zaW4ocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldFcsIHkgLSB5T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXRXLCB5ICsgeU9mZnNldCk7XG4gICAgICBjdHgubW92ZVRvKHggKyB5T2Zmc2V0VywgeSAtIHhPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldFcsIHkgKyB4T2Zmc2V0KTtcbiAgICAgIHJhZCArPSBRVUFSVEVSX1BJO1xuICAgICAgeE9mZnNldFcgPSBNYXRoLmNvcyhyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyk7XG4gICAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldFcgPSBNYXRoLnNpbihyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyk7XG4gICAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0VywgeSAtIHlPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldFcsIHkgKyB5T2Zmc2V0KTtcbiAgICAgIGN0eC5tb3ZlVG8oeCArIHlPZmZzZXRXLCB5IC0geE9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0VywgeSArIHhPZmZzZXQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbGluZSc6XG4gICAgICB4T2Zmc2V0ID0gdyA/IHcgLyAyIDogTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGFzaCc6XG4gICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgTWF0aC5jb3MocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpLCB5ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGZhbHNlOlxuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBjdHguZmlsbCgpO1xuICBpZiAob3B0aW9ucy5ib3JkZXJXaWR0aCA+IDApIHtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBvaW50IGlzIGluc2lkZSB0aGUgcmVjdGFuZ2xlXG4gKiBAcGFyYW0gcG9pbnQgLSBUaGUgcG9pbnQgdG8gdGVzdFxuICogQHBhcmFtIGFyZWEgLSBUaGUgcmVjdGFuZ2xlXG4gKiBAcGFyYW0gbWFyZ2luIC0gYWxsb3dlZCBtYXJnaW5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfaXNQb2ludEluQXJlYShcbiAgcG9pbnQ6IFBvaW50LFxuICBhcmVhOiBUUkJMLFxuICBtYXJnaW4/OiBudW1iZXJcbikge1xuICBtYXJnaW4gPSBtYXJnaW4gfHwgMC41OyAvLyBtYXJnaW4gLSBkZWZhdWx0IGlzIHRvIG1hdGNoIHJvdW5kZWQgZGVjaW1hbHNcblxuICByZXR1cm4gIWFyZWEgfHwgKHBvaW50ICYmIHBvaW50LnggPiBhcmVhLmxlZnQgLSBtYXJnaW4gJiYgcG9pbnQueCA8IGFyZWEucmlnaHQgKyBtYXJnaW4gJiZcblx0XHRwb2ludC55ID4gYXJlYS50b3AgLSBtYXJnaW4gJiYgcG9pbnQueSA8IGFyZWEuYm90dG9tICsgbWFyZ2luKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsaXBBcmVhKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBhcmVhOiBUUkJMKSB7XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LnJlY3QoYXJlYS5sZWZ0LCBhcmVhLnRvcCwgYXJlYS5yaWdodCAtIGFyZWEubGVmdCwgYXJlYS5ib3R0b20gLSBhcmVhLnRvcCk7XG4gIGN0eC5jbGlwKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bmNsaXBBcmVhKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9zdGVwcGVkTGluZVRvKFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgcHJldmlvdXM6IFBvaW50LFxuICB0YXJnZXQ6IFBvaW50LFxuICBmbGlwPzogYm9vbGVhbixcbiAgbW9kZT86IHN0cmluZ1xuKSB7XG4gIGlmICghcHJldmlvdXMpIHtcbiAgICByZXR1cm4gY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xuICB9XG4gIGlmIChtb2RlID09PSAnbWlkZGxlJykge1xuICAgIGNvbnN0IG1pZHBvaW50ID0gKHByZXZpb3VzLnggKyB0YXJnZXQueCkgLyAyLjA7XG4gICAgY3R4LmxpbmVUbyhtaWRwb2ludCwgcHJldmlvdXMueSk7XG4gICAgY3R4LmxpbmVUbyhtaWRwb2ludCwgdGFyZ2V0LnkpO1xuICB9IGVsc2UgaWYgKG1vZGUgPT09ICdhZnRlcicgIT09ICEhZmxpcCkge1xuICAgIGN0eC5saW5lVG8ocHJldmlvdXMueCwgdGFyZ2V0LnkpO1xuICB9IGVsc2Uge1xuICAgIGN0eC5saW5lVG8odGFyZ2V0LngsIHByZXZpb3VzLnkpO1xuICB9XG4gIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2JlemllckN1cnZlVG8oXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBwcmV2aW91czogU3BsaW5lUG9pbnQsXG4gIHRhcmdldDogU3BsaW5lUG9pbnQsXG4gIGZsaXA/OiBib29sZWFuXG4pIHtcbiAgaWYgKCFwcmV2aW91cykge1xuICAgIHJldHVybiBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG4gIH1cbiAgY3R4LmJlemllckN1cnZlVG8oXG4gICAgZmxpcCA/IHByZXZpb3VzLmNwMXggOiBwcmV2aW91cy5jcDJ4LFxuICAgIGZsaXAgPyBwcmV2aW91cy5jcDF5IDogcHJldmlvdXMuY3AyeSxcbiAgICBmbGlwID8gdGFyZ2V0LmNwMnggOiB0YXJnZXQuY3AxeCxcbiAgICBmbGlwID8gdGFyZ2V0LmNwMnkgOiB0YXJnZXQuY3AxeSxcbiAgICB0YXJnZXQueCxcbiAgICB0YXJnZXQueSk7XG59XG5cbmZ1bmN0aW9uIHNldFJlbmRlck9wdHMoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIG9wdHM6IFJlbmRlclRleHRPcHRzKSB7XG4gIGlmIChvcHRzLnRyYW5zbGF0aW9uKSB7XG4gICAgY3R4LnRyYW5zbGF0ZShvcHRzLnRyYW5zbGF0aW9uWzBdLCBvcHRzLnRyYW5zbGF0aW9uWzFdKTtcbiAgfVxuXG4gIGlmICghaXNOdWxsT3JVbmRlZihvcHRzLnJvdGF0aW9uKSkge1xuICAgIGN0eC5yb3RhdGUob3B0cy5yb3RhdGlvbik7XG4gIH1cblxuICBpZiAob3B0cy5jb2xvcikge1xuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRzLmNvbG9yO1xuICB9XG5cbiAgaWYgKG9wdHMudGV4dEFsaWduKSB7XG4gICAgY3R4LnRleHRBbGlnbiA9IG9wdHMudGV4dEFsaWduO1xuICB9XG5cbiAgaWYgKG9wdHMudGV4dEJhc2VsaW5lKSB7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9IG9wdHMudGV4dEJhc2VsaW5lO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlY29yYXRlVGV4dChcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIHg6IG51bWJlcixcbiAgeTogbnVtYmVyLFxuICBsaW5lOiBzdHJpbmcsXG4gIG9wdHM6IFJlbmRlclRleHRPcHRzXG4pIHtcbiAgaWYgKG9wdHMuc3RyaWtldGhyb3VnaCB8fCBvcHRzLnVuZGVybGluZSkge1xuICAgIC8qKlxuICAgICAqIE5vdyB0aGF0IElFMTEgc3VwcG9ydCBoYXMgYmVlbiBkcm9wcGVkLCB3ZSBjYW4gdXNlIG1vcmVcbiAgICAgKiBvZiB0aGUgVGV4dE1ldHJpY3Mgb2JqZWN0LiBUaGUgYWN0dWFsIGJvdW5kaW5nIGJveGVzXG4gICAgICogYXJlIHVuZmxhZ2dlZCBpbiBDaHJvbWUsIEZpcmVmb3gsIEVkZ2UsIGFuZCBTYWZhcmkgc28gdGhleVxuICAgICAqIGNhbiBiZSBzYWZlbHkgdXNlZC5cbiAgICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RleHRNZXRyaWNzI0Jyb3dzZXJfY29tcGF0aWJpbGl0eVxuICAgICAqL1xuICAgIGNvbnN0IG1ldHJpY3MgPSBjdHgubWVhc3VyZVRleHQobGluZSk7XG4gICAgY29uc3QgbGVmdCA9IHggLSBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94TGVmdDtcbiAgICBjb25zdCByaWdodCA9IHggKyBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94UmlnaHQ7XG4gICAgY29uc3QgdG9wID0geSAtIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQ7XG4gICAgY29uc3QgYm90dG9tID0geSArIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50O1xuICAgIGNvbnN0IHlEZWNvcmF0aW9uID0gb3B0cy5zdHJpa2V0aHJvdWdoID8gKHRvcCArIGJvdHRvbSkgLyAyIDogYm90dG9tO1xuXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmxpbmVXaWR0aCA9IG9wdHMuZGVjb3JhdGlvbldpZHRoIHx8IDI7XG4gICAgY3R4Lm1vdmVUbyhsZWZ0LCB5RGVjb3JhdGlvbik7XG4gICAgY3R4LmxpbmVUbyhyaWdodCwgeURlY29yYXRpb24pO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3QmFja2Ryb3AoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIG9wdHM6IEJhY2tkcm9wT3B0aW9ucykge1xuICBjb25zdCBvbGRDb2xvciA9IGN0eC5maWxsU3R5bGU7XG5cbiAgY3R4LmZpbGxTdHlsZSA9IG9wdHMuY29sb3IgYXMgc3RyaW5nO1xuICBjdHguZmlsbFJlY3Qob3B0cy5sZWZ0LCBvcHRzLnRvcCwgb3B0cy53aWR0aCwgb3B0cy5oZWlnaHQpO1xuICBjdHguZmlsbFN0eWxlID0gb2xkQ29sb3I7XG59XG5cbi8qKlxuICogUmVuZGVyIHRleHQgb250byB0aGUgY2FudmFzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJUZXh0KFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgdGV4dDogc3RyaW5nIHwgc3RyaW5nW10sXG4gIHg6IG51bWJlcixcbiAgeTogbnVtYmVyLFxuICBmb250OiBDYW52YXNGb250U3BlYyxcbiAgb3B0czogUmVuZGVyVGV4dE9wdHMgPSB7fVxuKSB7XG4gIGNvbnN0IGxpbmVzID0gaXNBcnJheSh0ZXh0KSA/IHRleHQgOiBbdGV4dF07XG4gIGNvbnN0IHN0cm9rZSA9IG9wdHMuc3Ryb2tlV2lkdGggPiAwICYmIG9wdHMuc3Ryb2tlQ29sb3IgIT09ICcnO1xuICBsZXQgaTogbnVtYmVyLCBsaW5lOiBzdHJpbmc7XG5cbiAgY3R4LnNhdmUoKTtcbiAgY3R4LmZvbnQgPSBmb250LnN0cmluZztcbiAgc2V0UmVuZGVyT3B0cyhjdHgsIG9wdHMpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xuICAgIGxpbmUgPSBsaW5lc1tpXTtcblxuICAgIGlmIChvcHRzLmJhY2tkcm9wKSB7XG4gICAgICBkcmF3QmFja2Ryb3AoY3R4LCBvcHRzLmJhY2tkcm9wKTtcbiAgICB9XG5cbiAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICBpZiAob3B0cy5zdHJva2VDb2xvcikge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRzLnN0cm9rZUNvbG9yO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTnVsbE9yVW5kZWYob3B0cy5zdHJva2VXaWR0aCkpIHtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IG9wdHMuc3Ryb2tlV2lkdGg7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zdHJva2VUZXh0KGxpbmUsIHgsIHksIG9wdHMubWF4V2lkdGgpO1xuICAgIH1cblxuICAgIGN0eC5maWxsVGV4dChsaW5lLCB4LCB5LCBvcHRzLm1heFdpZHRoKTtcbiAgICBkZWNvcmF0ZVRleHQoY3R4LCB4LCB5LCBsaW5lLCBvcHRzKTtcblxuICAgIHkgKz0gTnVtYmVyKGZvbnQubGluZUhlaWdodCk7XG4gIH1cblxuICBjdHgucmVzdG9yZSgpO1xufVxuXG4vKipcbiAqIEFkZCBhIHBhdGggb2YgYSByZWN0YW5nbGUgd2l0aCByb3VuZGVkIGNvcm5lcnMgdG8gdGhlIGN1cnJlbnQgc3ViLXBhdGhcbiAqIEBwYXJhbSBjdHggLSBDb250ZXh0XG4gKiBAcGFyYW0gcmVjdCAtIEJvdW5kaW5nIHJlY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFJvdW5kZWRSZWN0UGF0aChcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIHJlY3Q6IFJvdW5kZWRSZWN0ICYgeyByYWRpdXM6IFRSQkxDb3JuZXJzIH1cbikge1xuICBjb25zdCB7eCwgeSwgdywgaCwgcmFkaXVzfSA9IHJlY3Q7XG5cbiAgLy8gdG9wIGxlZnQgYXJjXG4gIGN0eC5hcmMoeCArIHJhZGl1cy50b3BMZWZ0LCB5ICsgcmFkaXVzLnRvcExlZnQsIHJhZGl1cy50b3BMZWZ0LCAxLjUgKiBQSSwgUEksIHRydWUpO1xuXG4gIC8vIGxpbmUgZnJvbSB0b3AgbGVmdCB0byBib3R0b20gbGVmdFxuICBjdHgubGluZVRvKHgsIHkgKyBoIC0gcmFkaXVzLmJvdHRvbUxlZnQpO1xuXG4gIC8vIGJvdHRvbSBsZWZ0IGFyY1xuICBjdHguYXJjKHggKyByYWRpdXMuYm90dG9tTGVmdCwgeSArIGggLSByYWRpdXMuYm90dG9tTGVmdCwgcmFkaXVzLmJvdHRvbUxlZnQsIFBJLCBIQUxGX1BJLCB0cnVlKTtcblxuICAvLyBsaW5lIGZyb20gYm90dG9tIGxlZnQgdG8gYm90dG9tIHJpZ2h0XG4gIGN0eC5saW5lVG8oeCArIHcgLSByYWRpdXMuYm90dG9tUmlnaHQsIHkgKyBoKTtcblxuICAvLyBib3R0b20gcmlnaHQgYXJjXG4gIGN0eC5hcmMoeCArIHcgLSByYWRpdXMuYm90dG9tUmlnaHQsIHkgKyBoIC0gcmFkaXVzLmJvdHRvbVJpZ2h0LCByYWRpdXMuYm90dG9tUmlnaHQsIEhBTEZfUEksIDAsIHRydWUpO1xuXG4gIC8vIGxpbmUgZnJvbSBib3R0b20gcmlnaHQgdG8gdG9wIHJpZ2h0XG4gIGN0eC5saW5lVG8oeCArIHcsIHkgKyByYWRpdXMudG9wUmlnaHQpO1xuXG4gIC8vIHRvcCByaWdodCBhcmNcbiAgY3R4LmFyYyh4ICsgdyAtIHJhZGl1cy50b3BSaWdodCwgeSArIHJhZGl1cy50b3BSaWdodCwgcmFkaXVzLnRvcFJpZ2h0LCAwLCAtSEFMRl9QSSwgdHJ1ZSk7XG5cbiAgLy8gbGluZSBmcm9tIHRvcCByaWdodCB0byB0b3AgbGVmdFxuICBjdHgubGluZVRvKHggKyByYWRpdXMudG9wTGVmdCwgeSk7XG59XG4iLCAiaW1wb3J0IGRlZmF1bHRzIGZyb20gJy4uL2NvcmUvY29yZS5kZWZhdWx0cy5qcyc7XG5pbXBvcnQge2lzQXJyYXksIGlzT2JqZWN0LCB0b0RpbWVuc2lvbiwgdmFsdWVPckRlZmF1bHR9IGZyb20gJy4vaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7dG9Gb250U3RyaW5nfSBmcm9tICcuL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB0eXBlIHtDaGFydEFyZWEsIEZvbnRTcGVjLCBQb2ludH0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuaW1wb3J0IHR5cGUge1RSQkwsIFRSQkxDb3JuZXJzfSBmcm9tICcuLi90eXBlcy9nZW9tZXRyaWMuanMnO1xuXG5jb25zdCBMSU5FX0hFSUdIVCA9IC9eKG5vcm1hbHwoXFxkKyg/OlxcLlxcZCspPykocHh8ZW18JSk/KSQvO1xuY29uc3QgRk9OVF9TVFlMRSA9IC9eKG5vcm1hbHxpdGFsaWN8aW5pdGlhbHxpbmhlcml0fHVuc2V0fChvYmxpcXVlKCAtP1swLTldP1swLTldZGVnKT8pKSQvO1xuXG4vKipcbiAqIEBhbGlhcyBDaGFydC5oZWxwZXJzLm9wdGlvbnNcbiAqIEBuYW1lc3BhY2VcbiAqL1xuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gbGluZSBoZWlnaHQgYHZhbHVlYCBpbiBwaXhlbHMgZm9yIGEgc3BlY2lmaWMgZm9udCBgc2l6ZWAuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbGluZUhlaWdodCB0byBwYXJzZSAoZWcuIDEuNiwgJzE0cHgnLCAnNzUlJywgJzEuNmVtJykuXG4gKiBAcGFyYW0gc2l6ZSAtIFRoZSBmb250IHNpemUgKGluIHBpeGVscykgdXNlZCB0byByZXNvbHZlIHJlbGF0aXZlIGB2YWx1ZWAuXG4gKiBAcmV0dXJucyBUaGUgZWZmZWN0aXZlIGxpbmUgaGVpZ2h0IGluIHBpeGVscyAoc2l6ZSAqIDEuMiBpZiB2YWx1ZSBpcyBpbnZhbGlkKS5cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2xpbmUtaGVpZ2h0XG4gKiBAc2luY2UgMi43LjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvTGluZUhlaWdodCh2YWx1ZTogbnVtYmVyIHwgc3RyaW5nLCBzaXplOiBudW1iZXIpOiBudW1iZXIge1xuICBjb25zdCBtYXRjaGVzID0gKCcnICsgdmFsdWUpLm1hdGNoKExJTkVfSEVJR0hUKTtcbiAgaWYgKCFtYXRjaGVzIHx8IG1hdGNoZXNbMV0gPT09ICdub3JtYWwnKSB7XG4gICAgcmV0dXJuIHNpemUgKiAxLjI7XG4gIH1cblxuICB2YWx1ZSA9ICttYXRjaGVzWzJdO1xuXG4gIHN3aXRjaCAobWF0Y2hlc1szXSkge1xuICAgIGNhc2UgJ3B4JzpcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBjYXNlICclJzpcbiAgICAgIHZhbHVlIC89IDEwMDtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBzaXplICogdmFsdWU7XG59XG5cbmNvbnN0IG51bWJlck9yWmVybyA9ICh2OiB1bmtub3duKSA9PiArdiB8fCAwO1xuXG4vKipcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHBhcmFtIHByb3BzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfcmVhZFZhbHVlVG9Qcm9wczxLIGV4dGVuZHMgc3RyaW5nPih2YWx1ZTogbnVtYmVyIHwgUmVjb3JkPEssIG51bWJlcj4sIHByb3BzOiBLW10pOiBSZWNvcmQ8SywgbnVtYmVyPjtcbmV4cG9ydCBmdW5jdGlvbiBfcmVhZFZhbHVlVG9Qcm9wczxLIGV4dGVuZHMgc3RyaW5nLCBUIGV4dGVuZHMgc3RyaW5nPih2YWx1ZTogbnVtYmVyIHwgUmVjb3JkPEsgJiBULCBudW1iZXI+LCBwcm9wczogUmVjb3JkPFQsIEs+KTogUmVjb3JkPFQsIG51bWJlcj47XG5leHBvcnQgZnVuY3Rpb24gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWU6IG51bWJlciB8IFJlY29yZDxzdHJpbmcsIG51bWJlcj4sIHByb3BzOiBzdHJpbmdbXSB8IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGNvbnN0IG9ialByb3BzID0gaXNPYmplY3QocHJvcHMpO1xuICBjb25zdCBrZXlzID0gb2JqUHJvcHMgPyBPYmplY3Qua2V5cyhwcm9wcykgOiBwcm9wcztcbiAgY29uc3QgcmVhZCA9IGlzT2JqZWN0KHZhbHVlKVxuICAgID8gb2JqUHJvcHNcbiAgICAgID8gcHJvcCA9PiB2YWx1ZU9yRGVmYXVsdCh2YWx1ZVtwcm9wXSwgdmFsdWVbcHJvcHNbcHJvcF1dKVxuICAgICAgOiBwcm9wID0+IHZhbHVlW3Byb3BdXG4gICAgOiAoKSA9PiB2YWx1ZTtcblxuICBmb3IgKGNvbnN0IHByb3Agb2Yga2V5cykge1xuICAgIHJldFtwcm9wXSA9IG51bWJlck9yWmVybyhyZWFkKHByb3ApKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiB2YWx1ZSBpbnRvIGEgVFJCTCBvYmplY3QuXG4gKiBAcGFyYW0gdmFsdWUgLSBJZiBhIG51bWJlciwgc2V0IHRoZSB2YWx1ZSB0byBhbGwgVFJCTCBjb21wb25lbnQsXG4gKiAgZWxzZSwgaWYgYW4gb2JqZWN0LCB1c2UgZGVmaW5lZCBwcm9wZXJ0aWVzIGFuZCBzZXRzIHVuZGVmaW5lZCBvbmVzIHRvIDAuXG4gKiAgeCAvIHkgYXJlIHNob3J0aGFuZHMgZm9yIHNhbWUgdmFsdWUgZm9yIGxlZnQvcmlnaHQgYW5kIHRvcC9ib3R0b20uXG4gKiBAcmV0dXJucyBUaGUgcGFkZGluZyB2YWx1ZXMgKHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdClcbiAqIEBzaW5jZSAzLjAuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9UUkJMKHZhbHVlOiBudW1iZXIgfCBUUkJMIHwgUG9pbnQpIHtcbiAgcmV0dXJuIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlLCB7dG9wOiAneScsIHJpZ2h0OiAneCcsIGJvdHRvbTogJ3knLCBsZWZ0OiAneCd9KTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gdmFsdWUgaW50byBhIFRSQkwgY29ybmVycyBvYmplY3QgKHNpbWlsYXIgd2l0aCBjc3MgYm9yZGVyLXJhZGl1cykuXG4gKiBAcGFyYW0gdmFsdWUgLSBJZiBhIG51bWJlciwgc2V0IHRoZSB2YWx1ZSB0byBhbGwgVFJCTCBjb3JuZXIgY29tcG9uZW50cyxcbiAqICBlbHNlLCBpZiBhbiBvYmplY3QsIHVzZSBkZWZpbmVkIHByb3BlcnRpZXMgYW5kIHNldHMgdW5kZWZpbmVkIG9uZXMgdG8gMC5cbiAqIEByZXR1cm5zIFRoZSBUUkJMIGNvcm5lciB2YWx1ZXMgKHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodClcbiAqIEBzaW5jZSAzLjAuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9UUkJMQ29ybmVycyh2YWx1ZTogbnVtYmVyIHwgVFJCTENvcm5lcnMpIHtcbiAgcmV0dXJuIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlLCBbJ3RvcExlZnQnLCAndG9wUmlnaHQnLCAnYm90dG9tTGVmdCcsICdib3R0b21SaWdodCddKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gdmFsdWUgaW50byBhIHBhZGRpbmcgb2JqZWN0IHdpdGggcHJlLWNvbXB1dGVkIHdpZHRoL2hlaWdodC5cbiAqIEBwYXJhbSB2YWx1ZSAtIElmIGEgbnVtYmVyLCBzZXQgdGhlIHZhbHVlIHRvIGFsbCBUUkJMIGNvbXBvbmVudCxcbiAqICBlbHNlLCBpZiBhbiBvYmplY3QsIHVzZSBkZWZpbmVkIHByb3BlcnRpZXMgYW5kIHNldHMgdW5kZWZpbmVkIG9uZXMgdG8gMC5cbiAqICB4IC8geSBhcmUgc2hvcnRoYW5kcyBmb3Igc2FtZSB2YWx1ZSBmb3IgbGVmdC9yaWdodCBhbmQgdG9wL2JvdHRvbS5cbiAqIEByZXR1cm5zIFRoZSBwYWRkaW5nIHZhbHVlcyAodG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0KVxuICogQHNpbmNlIDIuNy4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1BhZGRpbmcodmFsdWU/OiBudW1iZXIgfCBUUkJMKTogQ2hhcnRBcmVhIHtcbiAgY29uc3Qgb2JqID0gdG9UUkJMKHZhbHVlKSBhcyBDaGFydEFyZWE7XG5cbiAgb2JqLndpZHRoID0gb2JqLmxlZnQgKyBvYmoucmlnaHQ7XG4gIG9iai5oZWlnaHQgPSBvYmoudG9wICsgb2JqLmJvdHRvbTtcblxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIFBhcnNlcyBmb250IG9wdGlvbnMgYW5kIHJldHVybnMgdGhlIGZvbnQgb2JqZWN0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBBIG9iamVjdCB0aGF0IGNvbnRhaW5zIGZvbnQgb3B0aW9ucyB0byBiZSBwYXJzZWQuXG4gKiBAcGFyYW0gZmFsbGJhY2sgLSBBIG9iamVjdCB0aGF0IGNvbnRhaW5zIGZhbGxiYWNrIGZvbnQgb3B0aW9ucy5cbiAqIEByZXR1cm4gVGhlIGZvbnQgb2JqZWN0LlxuICogQHByaXZhdGVcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdG9Gb250KG9wdGlvbnM6IFBhcnRpYWw8Rm9udFNwZWM+LCBmYWxsYmFjaz86IFBhcnRpYWw8Rm9udFNwZWM+KSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBmYWxsYmFjayA9IGZhbGxiYWNrIHx8IGRlZmF1bHRzLmZvbnQgYXMgRm9udFNwZWM7XG5cbiAgbGV0IHNpemUgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnNpemUsIGZhbGxiYWNrLnNpemUpO1xuXG4gIGlmICh0eXBlb2Ygc2l6ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBzaXplID0gcGFyc2VJbnQoc2l6ZSwgMTApO1xuICB9XG4gIGxldCBzdHlsZSA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuc3R5bGUsIGZhbGxiYWNrLnN0eWxlKTtcbiAgaWYgKHN0eWxlICYmICEoJycgKyBzdHlsZSkubWF0Y2goRk9OVF9TVFlMRSkpIHtcbiAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgZm9udCBzdHlsZSBzcGVjaWZpZWQ6IFwiJyArIHN0eWxlICsgJ1wiJyk7XG4gICAgc3R5bGUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBmb250ID0ge1xuICAgIGZhbWlseTogdmFsdWVPckRlZmF1bHQob3B0aW9ucy5mYW1pbHksIGZhbGxiYWNrLmZhbWlseSksXG4gICAgbGluZUhlaWdodDogdG9MaW5lSGVpZ2h0KHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMubGluZUhlaWdodCwgZmFsbGJhY2subGluZUhlaWdodCksIHNpemUpLFxuICAgIHNpemUsXG4gICAgc3R5bGUsXG4gICAgd2VpZ2h0OiB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLndlaWdodCwgZmFsbGJhY2sud2VpZ2h0KSxcbiAgICBzdHJpbmc6ICcnXG4gIH07XG5cbiAgZm9udC5zdHJpbmcgPSB0b0ZvbnRTdHJpbmcoZm9udCk7XG4gIHJldHVybiBmb250O1xufVxuXG4vKipcbiAqIEV2YWx1YXRlcyB0aGUgZ2l2ZW4gYGlucHV0c2Agc2VxdWVudGlhbGx5IGFuZCByZXR1cm5zIHRoZSBmaXJzdCBkZWZpbmVkIHZhbHVlLlxuICogQHBhcmFtIGlucHV0cyAtIEFuIGFycmF5IG9mIHZhbHVlcywgZmFsbGluZyBiYWNrIHRvIHRoZSBsYXN0IHZhbHVlLlxuICogQHBhcmFtIGNvbnRleHQgLSBJZiBkZWZpbmVkIGFuZCB0aGUgY3VycmVudCB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCB0aGUgdmFsdWVcbiAqIGlzIGNhbGxlZCB3aXRoIGBjb250ZXh0YCBhcyBmaXJzdCBhcmd1bWVudCBhbmQgdGhlIHJlc3VsdCBiZWNvbWVzIHRoZSBuZXcgaW5wdXQuXG4gKiBAcGFyYW0gaW5kZXggLSBJZiBkZWZpbmVkIGFuZCB0aGUgY3VycmVudCB2YWx1ZSBpcyBhbiBhcnJheSwgdGhlIHZhbHVlXG4gKiBhdCBgaW5kZXhgIGJlY29tZSB0aGUgbmV3IGlucHV0LlxuICogQHBhcmFtIGluZm8gLSBvYmplY3QgdG8gcmV0dXJuIGluZm9ybWF0aW9uIGFib3V0IHJlc29sdXRpb24gaW5cbiAqIEBwYXJhbSBpbmZvLmNhY2hlYWJsZSAtIFdpbGwgYmUgc2V0IHRvIGBmYWxzZWAgaWYgb3B0aW9uIGlzIG5vdCBjYWNoZWFibGUuXG4gKiBAc2luY2UgMi43LjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmUoaW5wdXRzOiBBcnJheTx1bmtub3duPiwgY29udGV4dD86IG9iamVjdCwgaW5kZXg/OiBudW1iZXIsIGluZm8/OiB7IGNhY2hlYWJsZTogYm9vbGVhbiB9KSB7XG4gIGxldCBjYWNoZWFibGUgPSB0cnVlO1xuICBsZXQgaTogbnVtYmVyLCBpbGVuOiBudW1iZXIsIHZhbHVlOiB1bmtub3duO1xuXG4gIGZvciAoaSA9IDAsIGlsZW4gPSBpbnB1dHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgdmFsdWUgPSBpbnB1dHNbaV07XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoY29udGV4dCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZShjb250ZXh0KTtcbiAgICAgIGNhY2hlYWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCAmJiBpc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZVtpbmRleCAlIHZhbHVlLmxlbmd0aF07XG4gICAgICBjYWNoZWFibGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChpbmZvICYmICFjYWNoZWFibGUpIHtcbiAgICAgICAgaW5mby5jYWNoZWFibGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0gbWlubWF4XG4gKiBAcGFyYW0gZ3JhY2VcbiAqIEBwYXJhbSBiZWdpbkF0WmVyb1xuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9hZGRHcmFjZShtaW5tYXg6IHsgbWluOiBudW1iZXI7IG1heDogbnVtYmVyOyB9LCBncmFjZTogbnVtYmVyIHwgc3RyaW5nLCBiZWdpbkF0WmVybzogYm9vbGVhbikge1xuICBjb25zdCB7bWluLCBtYXh9ID0gbWlubWF4O1xuICBjb25zdCBjaGFuZ2UgPSB0b0RpbWVuc2lvbihncmFjZSwgKG1heCAtIG1pbikgLyAyKTtcbiAgY29uc3Qga2VlcFplcm8gPSAodmFsdWU6IG51bWJlciwgYWRkOiBudW1iZXIpID0+IGJlZ2luQXRaZXJvICYmIHZhbHVlID09PSAwID8gMCA6IHZhbHVlICsgYWRkO1xuICByZXR1cm4ge1xuICAgIG1pbjoga2VlcFplcm8obWluLCAtTWF0aC5hYnMoY2hhbmdlKSksXG4gICAgbWF4OiBrZWVwWmVybyhtYXgsIGNoYW5nZSlcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjb250ZXh0IGluaGVyaXRpbmcgcGFyZW50Q29udGV4dFxuICogQHBhcmFtIHBhcmVudENvbnRleHRcbiAqIEBwYXJhbSBjb250ZXh0XG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29udGV4dDxUIGV4dGVuZHMgb2JqZWN0PihwYXJlbnRDb250ZXh0OiBudWxsLCBjb250ZXh0OiBUKTogVDtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb250ZXh0PFQgZXh0ZW5kcyBvYmplY3QsIFAgZXh0ZW5kcyBUPihwYXJlbnRDb250ZXh0OiBQLCBjb250ZXh0OiBUKTogUCAmIFQ7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29udGV4dChwYXJlbnRDb250ZXh0OiBvYmplY3QsIGNvbnRleHQ6IG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKHBhcmVudENvbnRleHQpLCBjb250ZXh0KTtcbn1cbiIsICIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmUgKi9cbmltcG9ydCB0eXBlIHtBbnlPYmplY3R9IGZyb20gJy4uL3R5cGVzL2Jhc2ljLmpzJztcbmltcG9ydCB0eXBlIHtDaGFydE1ldGF9IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcbmltcG9ydCB0eXBlIHtcbiAgUmVzb2x2ZXJPYmplY3RLZXksXG4gIFJlc29sdmVyQ2FjaGUsXG4gIFJlc29sdmVyUHJveHksXG4gIERlc2NyaXB0b3JEZWZhdWx0cyxcbiAgRGVzY3JpcHRvcixcbiAgQ29udGV4dENhY2hlLFxuICBDb250ZXh0UHJveHlcbn0gZnJvbSAnLi9oZWxwZXJzLmNvbmZpZy50eXBlcy5qcyc7XG5pbXBvcnQge2lzQXJyYXksIGlzRnVuY3Rpb24sIGlzT2JqZWN0LCByZXNvbHZlT2JqZWN0S2V5LCBfY2FwaXRhbGl6ZX0gZnJvbSAnLi9oZWxwZXJzLmNvcmUuanMnO1xuXG5leHBvcnQgKiBmcm9tICcuL2hlbHBlcnMuY29uZmlnLnR5cGVzLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgUHJveHkgZm9yIHJlc29sdmluZyByYXcgdmFsdWVzIGZvciBvcHRpb25zLlxuICogQHBhcmFtIHNjb3BlcyAtIFRoZSBvcHRpb24gc2NvcGVzIHRvIGxvb2sgZm9yIHZhbHVlcywgaW4gcmVzb2x1dGlvbiBvcmRlclxuICogQHBhcmFtIHByZWZpeGVzIC0gVGhlIHByZWZpeGVzIGZvciB2YWx1ZXMsIGluIHJlc29sdXRpb24gb3JkZXIuXG4gKiBAcGFyYW0gcm9vdFNjb3BlcyAtIFRoZSByb290IG9wdGlvbiBzY29wZXNcbiAqIEBwYXJhbSBmYWxsYmFjayAtIFBhcmVudCBzY29wZXMgZmFsbGJhY2tcbiAqIEBwYXJhbSBnZXRUYXJnZXQgLSBjYWxsYmFjayBmb3IgZ2V0dGluZyB0aGUgdGFyZ2V0IGZvciBjaGFuZ2VkIHZhbHVlc1xuICogQHJldHVybnMgUHJveHlcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfY3JlYXRlUmVzb2x2ZXI8XG4gIFQgZXh0ZW5kcyBBbnlPYmplY3RbXSA9IEFueU9iamVjdFtdLFxuICBSIGV4dGVuZHMgQW55T2JqZWN0W10gPSBUXG4+KFxuICBzY29wZXM6IFQsXG4gIHByZWZpeGVzID0gWycnXSxcbiAgcm9vdFNjb3Blcz86IFIsXG4gIGZhbGxiYWNrPzogUmVzb2x2ZXJPYmplY3RLZXksXG4gIGdldFRhcmdldCA9ICgpID0+IHNjb3Blc1swXVxuKSB7XG4gIGNvbnN0IGZpbmFsUm9vdFNjb3BlcyA9IHJvb3RTY29wZXMgfHwgc2NvcGVzO1xuICBpZiAodHlwZW9mIGZhbGxiYWNrID09PSAndW5kZWZpbmVkJykge1xuICAgIGZhbGxiYWNrID0gX3Jlc29sdmUoJ19mYWxsYmFjaycsIHNjb3Blcyk7XG4gIH1cbiAgY29uc3QgY2FjaGU6IFJlc29sdmVyQ2FjaGU8VCwgUj4gPSB7XG4gICAgW1N5bWJvbC50b1N0cmluZ1RhZ106ICdPYmplY3QnLFxuICAgIF9jYWNoZWFibGU6IHRydWUsXG4gICAgX3Njb3Blczogc2NvcGVzLFxuICAgIF9yb290U2NvcGVzOiBmaW5hbFJvb3RTY29wZXMsXG4gICAgX2ZhbGxiYWNrOiBmYWxsYmFjayxcbiAgICBfZ2V0VGFyZ2V0OiBnZXRUYXJnZXQsXG4gICAgb3ZlcnJpZGU6IChzY29wZTogQW55T2JqZWN0KSA9PiBfY3JlYXRlUmVzb2x2ZXIoW3Njb3BlLCAuLi5zY29wZXNdLCBwcmVmaXhlcywgZmluYWxSb290U2NvcGVzLCBmYWxsYmFjayksXG4gIH07XG4gIHJldHVybiBuZXcgUHJveHkoY2FjaGUsIHtcbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIHRoZSBkZWxldGUgb3BlcmF0b3IuXG4gICAgICovXG4gICAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wOiBzdHJpbmcpIHtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbcHJvcF07IC8vIHJlbW92ZSBmcm9tIGNhY2hlXG4gICAgICBkZWxldGUgdGFyZ2V0Ll9rZXlzOyAvLyByZW1vdmUgY2FjaGVkIGtleXNcbiAgICAgIGRlbGV0ZSBzY29wZXNbMF1bcHJvcF07IC8vIHJlbW92ZSBmcm9tIHRvcCBsZXZlbCBzY29wZVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgZ2V0dGluZyBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICovXG4gICAgZ2V0KHRhcmdldCwgcHJvcDogc3RyaW5nKSB7XG4gICAgICByZXR1cm4gX2NhY2hlZCh0YXJnZXQsIHByb3AsXG4gICAgICAgICgpID0+IF9yZXNvbHZlV2l0aFByZWZpeGVzKHByb3AsIHByZWZpeGVzLCBzY29wZXMsIHRhcmdldCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuXG4gICAgICogQWxzbyB1c2VkIGJ5IE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0Ll9zY29wZXNbMF0sIHByb3ApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZi5cbiAgICAgKi9cbiAgICBnZXRQcm90b3R5cGVPZigpIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHNjb3Blc1swXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgdGhlIGluIG9wZXJhdG9yLlxuICAgICAqL1xuICAgIGhhcyh0YXJnZXQsIHByb3A6IHN0cmluZykge1xuICAgICAgcmV0dXJuIGdldEtleXNGcm9tQWxsU2NvcGVzKHRhcmdldCkuaW5jbHVkZXMocHJvcCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgYW5kIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMuXG4gICAgICovXG4gICAgb3duS2V5cyh0YXJnZXQpIHtcbiAgICAgIHJldHVybiBnZXRLZXlzRnJvbUFsbFNjb3Blcyh0YXJnZXQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIHNldHRpbmcgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqL1xuICAgIHNldCh0YXJnZXQsIHByb3A6IHN0cmluZywgdmFsdWUpIHtcbiAgICAgIGNvbnN0IHN0b3JhZ2UgPSB0YXJnZXQuX3N0b3JhZ2UgfHwgKHRhcmdldC5fc3RvcmFnZSA9IGdldFRhcmdldCgpKTtcbiAgICAgIHRhcmdldFtwcm9wXSA9IHN0b3JhZ2VbcHJvcF0gPSB2YWx1ZTsgLy8gc2V0IHRvIHRvcCBsZXZlbCBzY29wZSArIGNhY2hlXG4gICAgICBkZWxldGUgdGFyZ2V0Ll9rZXlzOyAvLyByZW1vdmUgY2FjaGVkIGtleXNcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSkgYXMgUmVzb2x2ZXJQcm94eTxULCBSPjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIFByb3h5IGZvciByZXNvbHZpbmcgb3B0aW9uIHZhbHVlcyB3aXRoIGNvbnRleHQuXG4gKiBAcGFyYW0gcHJveHkgLSBUaGUgUHJveHkgcmV0dXJuZWQgYnkgYF9jcmVhdGVSZXNvbHZlcmBcbiAqIEBwYXJhbSBjb250ZXh0IC0gQ29udGV4dCBvYmplY3QgZm9yIHNjcmlwdGFibGUvaW5kZXhhYmxlIG9wdGlvbnNcbiAqIEBwYXJhbSBzdWJQcm94eSAtIFRoZSBwcm94eSBwcm92aWRlZCBmb3Igc2NyaXB0YWJsZSBvcHRpb25zXG4gKiBAcGFyYW0gZGVzY3JpcHRvckRlZmF1bHRzIC0gRGVmYXVsdHMgZm9yIGRlc2NyaXB0b3JzXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2F0dGFjaENvbnRleHQ8XG4gIFQgZXh0ZW5kcyBBbnlPYmplY3RbXSA9IEFueU9iamVjdFtdLFxuICBSIGV4dGVuZHMgQW55T2JqZWN0W10gPSBUXG4+KFxuICBwcm94eTogUmVzb2x2ZXJQcm94eTxULCBSPixcbiAgY29udGV4dDogQW55T2JqZWN0LFxuICBzdWJQcm94eT86IFJlc29sdmVyUHJveHk8VCwgUj4sXG4gIGRlc2NyaXB0b3JEZWZhdWx0cz86IERlc2NyaXB0b3JEZWZhdWx0c1xuKSB7XG4gIGNvbnN0IGNhY2hlOiBDb250ZXh0Q2FjaGU8VCwgUj4gPSB7XG4gICAgX2NhY2hlYWJsZTogZmFsc2UsXG4gICAgX3Byb3h5OiBwcm94eSxcbiAgICBfY29udGV4dDogY29udGV4dCxcbiAgICBfc3ViUHJveHk6IHN1YlByb3h5LFxuICAgIF9zdGFjazogbmV3IFNldCgpLFxuICAgIF9kZXNjcmlwdG9yczogX2Rlc2NyaXB0b3JzKHByb3h5LCBkZXNjcmlwdG9yRGVmYXVsdHMpLFxuICAgIHNldENvbnRleHQ6IChjdHg6IEFueU9iamVjdCkgPT4gX2F0dGFjaENvbnRleHQocHJveHksIGN0eCwgc3ViUHJveHksIGRlc2NyaXB0b3JEZWZhdWx0cyksXG4gICAgb3ZlcnJpZGU6IChzY29wZTogQW55T2JqZWN0KSA9PiBfYXR0YWNoQ29udGV4dChwcm94eS5vdmVycmlkZShzY29wZSksIGNvbnRleHQsIHN1YlByb3h5LCBkZXNjcmlwdG9yRGVmYXVsdHMpXG4gIH07XG4gIHJldHVybiBuZXcgUHJveHkoY2FjaGUsIHtcbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIHRoZSBkZWxldGUgb3BlcmF0b3IuXG4gICAgICovXG4gICAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wKSB7XG4gICAgICBkZWxldGUgdGFyZ2V0W3Byb3BdOyAvLyByZW1vdmUgZnJvbSBjYWNoZVxuICAgICAgZGVsZXRlIHByb3h5W3Byb3BdOyAvLyByZW1vdmUgZnJvbSBwcm94eVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgZ2V0dGluZyBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICovXG4gICAgZ2V0KHRhcmdldCwgcHJvcDogc3RyaW5nLCByZWNlaXZlcikge1xuICAgICAgcmV0dXJuIF9jYWNoZWQodGFyZ2V0LCBwcm9wLFxuICAgICAgICAoKSA9PiBfcmVzb2x2ZVdpdGhDb250ZXh0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLlxuICAgICAqIEFsc28gdXNlZCBieSBPYmplY3QuaGFzT3duUHJvcGVydHkuXG4gICAgICovXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcCkge1xuICAgICAgcmV0dXJuIHRhcmdldC5fZGVzY3JpcHRvcnMuYWxsS2V5c1xuICAgICAgICA/IFJlZmxlY3QuaGFzKHByb3h5LCBwcm9wKSA/IHtlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9IDogdW5kZWZpbmVkXG4gICAgICAgIDogUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJveHksIHByb3ApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZi5cbiAgICAgKi9cbiAgICBnZXRQcm90b3R5cGVPZigpIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHByb3h5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciB0aGUgaW4gb3BlcmF0b3IuXG4gICAgICovXG4gICAgaGFzKHRhcmdldCwgcHJvcCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHByb3h5LCBwcm9wKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyBhbmQgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scy5cbiAgICAgKi9cbiAgICBvd25LZXlzKCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyhwcm94eSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3Igc2V0dGluZyBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICovXG4gICAgc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgIHByb3h5W3Byb3BdID0gdmFsdWU7IC8vIHNldCB0byBwcm94eVxuICAgICAgZGVsZXRlIHRhcmdldFtwcm9wXTsgLy8gcmVtb3ZlIGZyb20gY2FjaGVcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSkgYXMgQ29udGV4dFByb3h5PFQsIFI+O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZGVzY3JpcHRvcnMoXG4gIHByb3h5OiBSZXNvbHZlckNhY2hlLFxuICBkZWZhdWx0czogRGVzY3JpcHRvckRlZmF1bHRzID0ge3NjcmlwdGFibGU6IHRydWUsIGluZGV4YWJsZTogdHJ1ZX1cbik6IERlc2NyaXB0b3Ige1xuICBjb25zdCB7X3NjcmlwdGFibGUgPSBkZWZhdWx0cy5zY3JpcHRhYmxlLCBfaW5kZXhhYmxlID0gZGVmYXVsdHMuaW5kZXhhYmxlLCBfYWxsS2V5cyA9IGRlZmF1bHRzLmFsbEtleXN9ID0gcHJveHk7XG4gIHJldHVybiB7XG4gICAgYWxsS2V5czogX2FsbEtleXMsXG4gICAgc2NyaXB0YWJsZTogX3NjcmlwdGFibGUsXG4gICAgaW5kZXhhYmxlOiBfaW5kZXhhYmxlLFxuICAgIGlzU2NyaXB0YWJsZTogaXNGdW5jdGlvbihfc2NyaXB0YWJsZSkgPyBfc2NyaXB0YWJsZSA6ICgpID0+IF9zY3JpcHRhYmxlLFxuICAgIGlzSW5kZXhhYmxlOiBpc0Z1bmN0aW9uKF9pbmRleGFibGUpID8gX2luZGV4YWJsZSA6ICgpID0+IF9pbmRleGFibGVcbiAgfTtcbn1cblxuY29uc3QgcmVhZEtleSA9IChwcmVmaXg6IHN0cmluZywgbmFtZTogc3RyaW5nKSA9PiBwcmVmaXggPyBwcmVmaXggKyBfY2FwaXRhbGl6ZShuYW1lKSA6IG5hbWU7XG5jb25zdCBuZWVkc1N1YlJlc29sdmVyID0gKHByb3A6IHN0cmluZywgdmFsdWU6IHVua25vd24pID0+IGlzT2JqZWN0KHZhbHVlKSAmJiBwcm9wICE9PSAnYWRhcHRlcnMnICYmXG4gIChPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBudWxsIHx8IHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3QpO1xuXG5mdW5jdGlvbiBfY2FjaGVkKFxuICB0YXJnZXQ6IEFueU9iamVjdCxcbiAgcHJvcDogc3RyaW5nLFxuICByZXNvbHZlOiAoKSA9PiB1bmtub3duXG4pIHtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIHByb3ApKSB7XG4gICAgcmV0dXJuIHRhcmdldFtwcm9wXTtcbiAgfVxuXG4gIGNvbnN0IHZhbHVlID0gcmVzb2x2ZSgpO1xuICAvLyBjYWNoZSB0aGUgcmVzb2x2ZWQgdmFsdWVcbiAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gX3Jlc29sdmVXaXRoQ29udGV4dChcbiAgdGFyZ2V0OiBDb250ZXh0Q2FjaGUsXG4gIHByb3A6IHN0cmluZyxcbiAgcmVjZWl2ZXI6IEFueU9iamVjdFxuKSB7XG4gIGNvbnN0IHtfcHJveHksIF9jb250ZXh0LCBfc3ViUHJveHksIF9kZXNjcmlwdG9yczogZGVzY3JpcHRvcnN9ID0gdGFyZ2V0O1xuICBsZXQgdmFsdWUgPSBfcHJveHlbcHJvcF07IC8vIHJlc29sdmUgZnJvbSBwcm94eVxuXG4gIC8vIHJlc29sdmUgd2l0aCBjb250ZXh0XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSAmJiBkZXNjcmlwdG9ycy5pc1NjcmlwdGFibGUocHJvcCkpIHtcbiAgICB2YWx1ZSA9IF9yZXNvbHZlU2NyaXB0YWJsZShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCByZWNlaXZlcik7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCkge1xuICAgIHZhbHVlID0gX3Jlc29sdmVBcnJheShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCBkZXNjcmlwdG9ycy5pc0luZGV4YWJsZSk7XG4gIH1cbiAgaWYgKG5lZWRzU3ViUmVzb2x2ZXIocHJvcCwgdmFsdWUpKSB7XG4gICAgLy8gaWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzIGFuIG9iamVjdCwgY3JlYXRlIGEgc3ViIHJlc29sdmVyIGZvciBpdFxuICAgIHZhbHVlID0gX2F0dGFjaENvbnRleHQodmFsdWUsIF9jb250ZXh0LCBfc3ViUHJveHkgJiYgX3N1YlByb3h5W3Byb3BdLCBkZXNjcmlwdG9ycyk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBfcmVzb2x2ZVNjcmlwdGFibGUoXG4gIHByb3A6IHN0cmluZyxcbiAgZ2V0VmFsdWU6IChjdHg6IEFueU9iamVjdCwgc3ViOiBBbnlPYmplY3QpID0+IHVua25vd24sXG4gIHRhcmdldDogQ29udGV4dENhY2hlLFxuICByZWNlaXZlcjogQW55T2JqZWN0XG4pIHtcbiAgY29uc3Qge19wcm94eSwgX2NvbnRleHQsIF9zdWJQcm94eSwgX3N0YWNrfSA9IHRhcmdldDtcbiAgaWYgKF9zdGFjay5oYXMocHJvcCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlY3Vyc2lvbiBkZXRlY3RlZDogJyArIEFycmF5LmZyb20oX3N0YWNrKS5qb2luKCctPicpICsgJy0+JyArIHByb3ApO1xuICB9XG4gIF9zdGFjay5hZGQocHJvcCk7XG4gIGxldCB2YWx1ZSA9IGdldFZhbHVlKF9jb250ZXh0LCBfc3ViUHJveHkgfHwgcmVjZWl2ZXIpO1xuICBfc3RhY2suZGVsZXRlKHByb3ApO1xuICBpZiAobmVlZHNTdWJSZXNvbHZlcihwcm9wLCB2YWx1ZSkpIHtcbiAgICAvLyBXaGVuIHNjcmlwdGFibGUgb3B0aW9uIHJldHVybnMgYW4gb2JqZWN0LCBjcmVhdGUgYSByZXNvbHZlciBvbiB0aGF0LlxuICAgIHZhbHVlID0gY3JlYXRlU3ViUmVzb2x2ZXIoX3Byb3h5Ll9zY29wZXMsIF9wcm94eSwgcHJvcCwgdmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gX3Jlc29sdmVBcnJheShcbiAgcHJvcDogc3RyaW5nLFxuICB2YWx1ZTogdW5rbm93bltdLFxuICB0YXJnZXQ6IENvbnRleHRDYWNoZSxcbiAgaXNJbmRleGFibGU6IChrZXk6IHN0cmluZykgPT4gYm9vbGVhblxuKSB7XG4gIGNvbnN0IHtfcHJveHksIF9jb250ZXh0LCBfc3ViUHJveHksIF9kZXNjcmlwdG9yczogZGVzY3JpcHRvcnN9ID0gdGFyZ2V0O1xuXG4gIGlmICh0eXBlb2YgX2NvbnRleHQuaW5kZXggIT09ICd1bmRlZmluZWQnICYmIGlzSW5kZXhhYmxlKHByb3ApKSB7XG4gICAgcmV0dXJuIHZhbHVlW19jb250ZXh0LmluZGV4ICUgdmFsdWUubGVuZ3RoXTtcbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZVswXSkpIHtcbiAgICAvLyBBcnJheSBvZiBvYmplY3RzLCByZXR1cm4gYXJyYXkgb3IgcmVzb2x2ZXJzXG4gICAgY29uc3QgYXJyID0gdmFsdWU7XG4gICAgY29uc3Qgc2NvcGVzID0gX3Byb3h5Ll9zY29wZXMuZmlsdGVyKHMgPT4gcyAhPT0gYXJyKTtcbiAgICB2YWx1ZSA9IFtdO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIHtcbiAgICAgIGNvbnN0IHJlc29sdmVyID0gY3JlYXRlU3ViUmVzb2x2ZXIoc2NvcGVzLCBfcHJveHksIHByb3AsIGl0ZW0pO1xuICAgICAgdmFsdWUucHVzaChfYXR0YWNoQ29udGV4dChyZXNvbHZlciwgX2NvbnRleHQsIF9zdWJQcm94eSAmJiBfc3ViUHJveHlbcHJvcF0sIGRlc2NyaXB0b3JzKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUZhbGxiYWNrKFxuICBmYWxsYmFjazogUmVzb2x2ZXJPYmplY3RLZXkgfCAoKHByb3A6IFJlc29sdmVyT2JqZWN0S2V5LCB2YWx1ZTogdW5rbm93bikgPT4gUmVzb2x2ZXJPYmplY3RLZXkpLFxuICBwcm9wOiBSZXNvbHZlck9iamVjdEtleSxcbiAgdmFsdWU6IHVua25vd25cbikge1xuICByZXR1cm4gaXNGdW5jdGlvbihmYWxsYmFjaykgPyBmYWxsYmFjayhwcm9wLCB2YWx1ZSkgOiBmYWxsYmFjaztcbn1cblxuY29uc3QgZ2V0U2NvcGUgPSAoa2V5OiBSZXNvbHZlck9iamVjdEtleSwgcGFyZW50OiBBbnlPYmplY3QpID0+IGtleSA9PT0gdHJ1ZSA/IHBhcmVudFxuICA6IHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnID8gcmVzb2x2ZU9iamVjdEtleShwYXJlbnQsIGtleSkgOiB1bmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGFkZFNjb3BlcyhcbiAgc2V0OiBTZXQ8QW55T2JqZWN0PixcbiAgcGFyZW50U2NvcGVzOiBBbnlPYmplY3RbXSxcbiAga2V5OiBSZXNvbHZlck9iamVjdEtleSxcbiAgcGFyZW50RmFsbGJhY2s6IFJlc29sdmVyT2JqZWN0S2V5LFxuICB2YWx1ZTogdW5rbm93blxuKSB7XG4gIGZvciAoY29uc3QgcGFyZW50IG9mIHBhcmVudFNjb3Blcykge1xuICAgIGNvbnN0IHNjb3BlID0gZ2V0U2NvcGUoa2V5LCBwYXJlbnQpO1xuICAgIGlmIChzY29wZSkge1xuICAgICAgc2V0LmFkZChzY29wZSk7XG4gICAgICBjb25zdCBmYWxsYmFjayA9IHJlc29sdmVGYWxsYmFjayhzY29wZS5fZmFsbGJhY2ssIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKHR5cGVvZiBmYWxsYmFjayAhPT0gJ3VuZGVmaW5lZCcgJiYgZmFsbGJhY2sgIT09IGtleSAmJiBmYWxsYmFjayAhPT0gcGFyZW50RmFsbGJhY2spIHtcbiAgICAgICAgLy8gV2hlbiB3ZSByZWFjaCB0aGUgZGVzY3JpcHRvciB0aGF0IGRlZmluZXMgYSBuZXcgX2ZhbGxiYWNrLCByZXR1cm4gdGhhdC5cbiAgICAgICAgLy8gVGhlIGZhbGxiYWNrIHdpbGwgcmVzdW1lIHRvIHRoYXQgbmV3IHNjb3BlLlxuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzY29wZSA9PT0gZmFsc2UgJiYgdHlwZW9mIHBhcmVudEZhbGxiYWNrICE9PSAndW5kZWZpbmVkJyAmJiBrZXkgIT09IHBhcmVudEZhbGxiYWNrKSB7XG4gICAgICAvLyBGYWxsYmFjayB0byBgZmFsc2VgIHJlc3VsdHMgdG8gYGZhbHNlYCwgd2hlbiBmYWxsaW5nIGJhY2sgdG8gZGlmZmVyZW50IGtleS5cbiAgICAgIC8vIEZvciBleGFtcGxlIGBpbnRlcmFjdGlvbmAgZnJvbSBgaG92ZXJgIG9yIGBwbHVnaW5zLnRvb2x0aXBgIGFuZCBgYW5pbWF0aW9uYCBmcm9tIGBhbmltYXRpb25zYFxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU3ViUmVzb2x2ZXIoXG4gIHBhcmVudFNjb3BlczogQW55T2JqZWN0W10sXG4gIHJlc29sdmVyOiBSZXNvbHZlckNhY2hlLFxuICBwcm9wOiBSZXNvbHZlck9iamVjdEtleSxcbiAgdmFsdWU6IHVua25vd25cbikge1xuICBjb25zdCByb290U2NvcGVzID0gcmVzb2x2ZXIuX3Jvb3RTY29wZXM7XG4gIGNvbnN0IGZhbGxiYWNrID0gcmVzb2x2ZUZhbGxiYWNrKHJlc29sdmVyLl9mYWxsYmFjaywgcHJvcCwgdmFsdWUpO1xuICBjb25zdCBhbGxTY29wZXMgPSBbLi4ucGFyZW50U2NvcGVzLCAuLi5yb290U2NvcGVzXTtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldDxBbnlPYmplY3Q+KCk7XG4gIHNldC5hZGQodmFsdWUpO1xuICBsZXQga2V5ID0gYWRkU2NvcGVzRnJvbUtleShzZXQsIGFsbFNjb3BlcywgcHJvcCwgZmFsbGJhY2sgfHwgcHJvcCwgdmFsdWUpO1xuICBpZiAoa2V5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgZmFsbGJhY2sgIT09ICd1bmRlZmluZWQnICYmIGZhbGxiYWNrICE9PSBwcm9wKSB7XG4gICAga2V5ID0gYWRkU2NvcGVzRnJvbUtleShzZXQsIGFsbFNjb3BlcywgZmFsbGJhY2ssIGtleSwgdmFsdWUpO1xuICAgIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVSZXNvbHZlcihBcnJheS5mcm9tKHNldCksIFsnJ10sIHJvb3RTY29wZXMsIGZhbGxiYWNrLFxuICAgICgpID0+IHN1YkdldFRhcmdldChyZXNvbHZlciwgcHJvcCBhcyBzdHJpbmcsIHZhbHVlKSk7XG59XG5cbmZ1bmN0aW9uIGFkZFNjb3Blc0Zyb21LZXkoXG4gIHNldDogU2V0PEFueU9iamVjdD4sXG4gIGFsbFNjb3BlczogQW55T2JqZWN0W10sXG4gIGtleTogUmVzb2x2ZXJPYmplY3RLZXksXG4gIGZhbGxiYWNrOiBSZXNvbHZlck9iamVjdEtleSxcbiAgaXRlbTogdW5rbm93blxuKSB7XG4gIHdoaWxlIChrZXkpIHtcbiAgICBrZXkgPSBhZGRTY29wZXMoc2V0LCBhbGxTY29wZXMsIGtleSwgZmFsbGJhY2ssIGl0ZW0pO1xuICB9XG4gIHJldHVybiBrZXk7XG59XG5cbmZ1bmN0aW9uIHN1YkdldFRhcmdldChcbiAgcmVzb2x2ZXI6IFJlc29sdmVyQ2FjaGUsXG4gIHByb3A6IHN0cmluZyxcbiAgdmFsdWU6IHVua25vd25cbikge1xuICBjb25zdCBwYXJlbnQgPSByZXNvbHZlci5fZ2V0VGFyZ2V0KCk7XG4gIGlmICghKHByb3AgaW4gcGFyZW50KSkge1xuICAgIHBhcmVudFtwcm9wXSA9IHt9O1xuICB9XG4gIGNvbnN0IHRhcmdldCA9IHBhcmVudFtwcm9wXTtcbiAgaWYgKGlzQXJyYXkodGFyZ2V0KSAmJiBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAvLyBGb3IgYXJyYXkgb2Ygb2JqZWN0cywgdGhlIG9iamVjdCBpcyB1c2VkIHRvIHN0b3JlIHVwZGF0ZWQgdmFsdWVzXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiB0YXJnZXQgfHwge307XG59XG5cbmZ1bmN0aW9uIF9yZXNvbHZlV2l0aFByZWZpeGVzKFxuICBwcm9wOiBzdHJpbmcsXG4gIHByZWZpeGVzOiBzdHJpbmdbXSxcbiAgc2NvcGVzOiBBbnlPYmplY3RbXSxcbiAgcHJveHk6IFJlc29sdmVyUHJveHlcbikge1xuICBsZXQgdmFsdWU6IHVua25vd247XG4gIGZvciAoY29uc3QgcHJlZml4IG9mIHByZWZpeGVzKSB7XG4gICAgdmFsdWUgPSBfcmVzb2x2ZShyZWFkS2V5KHByZWZpeCwgcHJvcCksIHNjb3Blcyk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZWVkc1N1YlJlc29sdmVyKHByb3AsIHZhbHVlKVxuICAgICAgICA/IGNyZWF0ZVN1YlJlc29sdmVyKHNjb3BlcywgcHJveHksIHByb3AsIHZhbHVlKVxuICAgICAgICA6IHZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBfcmVzb2x2ZShrZXk6IHN0cmluZywgc2NvcGVzOiBBbnlPYmplY3RbXSkge1xuICBmb3IgKGNvbnN0IHNjb3BlIG9mIHNjb3Blcykge1xuICAgIGlmICghc2NvcGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHNjb3BlW2tleV07XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0S2V5c0Zyb21BbGxTY29wZXModGFyZ2V0OiBSZXNvbHZlckNhY2hlKSB7XG4gIGxldCBrZXlzID0gdGFyZ2V0Ll9rZXlzO1xuICBpZiAoIWtleXMpIHtcbiAgICBrZXlzID0gdGFyZ2V0Ll9rZXlzID0gcmVzb2x2ZUtleXNGcm9tQWxsU2NvcGVzKHRhcmdldC5fc2NvcGVzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUtleXNGcm9tQWxsU2NvcGVzKHNjb3BlczogQW55T2JqZWN0W10pIHtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIGZvciAoY29uc3Qgc2NvcGUgb2Ygc2NvcGVzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NvcGUpLmZpbHRlcihrID0+ICFrLnN0YXJ0c1dpdGgoJ18nKSkpIHtcbiAgICAgIHNldC5hZGQoa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20oc2V0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZShcbiAgbWV0YTogQ2hhcnRNZXRhPCdsaW5lJyB8ICdzY2F0dGVyJz4sXG4gIGRhdGE6IEFueU9iamVjdFtdLFxuICBzdGFydDogbnVtYmVyLFxuICBjb3VudDogbnVtYmVyXG4pIHtcbiAgY29uc3Qge2lTY2FsZX0gPSBtZXRhO1xuICBjb25zdCB7a2V5ID0gJ3InfSA9IHRoaXMuX3BhcnNpbmc7XG4gIGNvbnN0IHBhcnNlZCA9IG5ldyBBcnJheTx7cjogdW5rbm93bn0+KGNvdW50KTtcbiAgbGV0IGk6IG51bWJlciwgaWxlbjogbnVtYmVyLCBpbmRleDogbnVtYmVyLCBpdGVtOiBBbnlPYmplY3Q7XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgaW5kZXggPSBpICsgc3RhcnQ7XG4gICAgaXRlbSA9IGRhdGFbaW5kZXhdO1xuICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgIHI6IGlTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KGl0ZW0sIGtleSksIGluZGV4KVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn1cbiIsICJpbXBvcnQge2FsbW9zdEVxdWFscywgZGlzdGFuY2VCZXR3ZWVuUG9pbnRzLCBzaWdufSBmcm9tICcuL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge19pc1BvaW50SW5BcmVhfSBmcm9tICcuL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB0eXBlIHtDaGFydEFyZWF9IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcbmltcG9ydCB0eXBlIHtTcGxpbmVQb2ludH0gZnJvbSAnLi4vdHlwZXMvZ2VvbWV0cmljLmpzJztcblxuY29uc3QgRVBTSUxPTiA9IE51bWJlci5FUFNJTE9OIHx8IDFlLTE0O1xuXG50eXBlIE9wdGlvbmFsU3BsaW5lUG9pbnQgPSBTcGxpbmVQb2ludCB8IGZhbHNlXG5jb25zdCBnZXRQb2ludCA9IChwb2ludHM6IFNwbGluZVBvaW50W10sIGk6IG51bWJlcik6IE9wdGlvbmFsU3BsaW5lUG9pbnQgPT4gaSA8IHBvaW50cy5sZW5ndGggJiYgIXBvaW50c1tpXS5za2lwICYmIHBvaW50c1tpXTtcbmNvbnN0IGdldFZhbHVlQXhpcyA9IChpbmRleEF4aXM6ICd4JyB8ICd5JykgPT4gaW5kZXhBeGlzID09PSAneCcgPyAneScgOiAneCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzcGxpbmVDdXJ2ZShcbiAgZmlyc3RQb2ludDogU3BsaW5lUG9pbnQsXG4gIG1pZGRsZVBvaW50OiBTcGxpbmVQb2ludCxcbiAgYWZ0ZXJQb2ludDogU3BsaW5lUG9pbnQsXG4gIHQ6IG51bWJlclxuKToge1xuICAgIHByZXZpb3VzOiBTcGxpbmVQb2ludFxuICAgIG5leHQ6IFNwbGluZVBvaW50XG4gIH0ge1xuICAvLyBQcm9wcyB0byBSb2IgU3BlbmNlciBhdCBzY2FsZWQgaW5ub3ZhdGlvbiBmb3IgaGlzIHBvc3Qgb24gc3BsaW5pbmcgYmV0d2VlbiBwb2ludHNcbiAgLy8gaHR0cDovL3NjYWxlZGlubm92YXRpb24uY29tL2FuYWx5dGljcy9zcGxpbmVzL2Fib3V0U3BsaW5lcy5odG1sXG5cbiAgLy8gVGhpcyBmdW5jdGlvbiBtdXN0IGFsc28gcmVzcGVjdCBcInNraXBwZWRcIiBwb2ludHNcblxuICBjb25zdCBwcmV2aW91cyA9IGZpcnN0UG9pbnQuc2tpcCA/IG1pZGRsZVBvaW50IDogZmlyc3RQb2ludDtcbiAgY29uc3QgY3VycmVudCA9IG1pZGRsZVBvaW50O1xuICBjb25zdCBuZXh0ID0gYWZ0ZXJQb2ludC5za2lwID8gbWlkZGxlUG9pbnQgOiBhZnRlclBvaW50O1xuICBjb25zdCBkMDEgPSBkaXN0YW5jZUJldHdlZW5Qb2ludHMoY3VycmVudCwgcHJldmlvdXMpO1xuICBjb25zdCBkMTIgPSBkaXN0YW5jZUJldHdlZW5Qb2ludHMobmV4dCwgY3VycmVudCk7XG5cbiAgbGV0IHMwMSA9IGQwMSAvIChkMDEgKyBkMTIpO1xuICBsZXQgczEyID0gZDEyIC8gKGQwMSArIGQxMik7XG5cbiAgLy8gSWYgYWxsIHBvaW50cyBhcmUgdGhlIHNhbWUsIHMwMSAmIHMwMiB3aWxsIGJlIGluZlxuICBzMDEgPSBpc05hTihzMDEpID8gMCA6IHMwMTtcbiAgczEyID0gaXNOYU4oczEyKSA/IDAgOiBzMTI7XG5cbiAgY29uc3QgZmEgPSB0ICogczAxOyAvLyBzY2FsaW5nIGZhY3RvciBmb3IgdHJpYW5nbGUgVGFcbiAgY29uc3QgZmIgPSB0ICogczEyO1xuXG4gIHJldHVybiB7XG4gICAgcHJldmlvdXM6IHtcbiAgICAgIHg6IGN1cnJlbnQueCAtIGZhICogKG5leHQueCAtIHByZXZpb3VzLngpLFxuICAgICAgeTogY3VycmVudC55IC0gZmEgKiAobmV4dC55IC0gcHJldmlvdXMueSlcbiAgICB9LFxuICAgIG5leHQ6IHtcbiAgICAgIHg6IGN1cnJlbnQueCArIGZiICogKG5leHQueCAtIHByZXZpb3VzLngpLFxuICAgICAgeTogY3VycmVudC55ICsgZmIgKiAobmV4dC55IC0gcHJldmlvdXMueSlcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQWRqdXN0IHRhbmdlbnRzIHRvIGVuc3VyZSBtb25vdG9uaWMgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtb25vdG9uZUFkanVzdChwb2ludHM6IFNwbGluZVBvaW50W10sIGRlbHRhSzogbnVtYmVyW10sIG1LOiBudW1iZXJbXSkge1xuICBjb25zdCBwb2ludHNMZW4gPSBwb2ludHMubGVuZ3RoO1xuXG4gIGxldCBhbHBoYUs6IG51bWJlciwgYmV0YUs6IG51bWJlciwgdGF1SzogbnVtYmVyLCBzcXVhcmVkTWFnbml0dWRlOiBudW1iZXIsIHBvaW50Q3VycmVudDogT3B0aW9uYWxTcGxpbmVQb2ludDtcbiAgbGV0IHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIDApO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50c0xlbiAtIDE7ICsraSkge1xuICAgIHBvaW50Q3VycmVudCA9IHBvaW50QWZ0ZXI7XG4gICAgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgaSArIDEpO1xuICAgIGlmICghcG9pbnRDdXJyZW50IHx8ICFwb2ludEFmdGVyKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoYWxtb3N0RXF1YWxzKGRlbHRhS1tpXSwgMCwgRVBTSUxPTikpIHtcbiAgICAgIG1LW2ldID0gbUtbaSArIDFdID0gMDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGFscGhhSyA9IG1LW2ldIC8gZGVsdGFLW2ldO1xuICAgIGJldGFLID0gbUtbaSArIDFdIC8gZGVsdGFLW2ldO1xuICAgIHNxdWFyZWRNYWduaXR1ZGUgPSBNYXRoLnBvdyhhbHBoYUssIDIpICsgTWF0aC5wb3coYmV0YUssIDIpO1xuICAgIGlmIChzcXVhcmVkTWFnbml0dWRlIDw9IDkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHRhdUsgPSAzIC8gTWF0aC5zcXJ0KHNxdWFyZWRNYWduaXR1ZGUpO1xuICAgIG1LW2ldID0gYWxwaGFLICogdGF1SyAqIGRlbHRhS1tpXTtcbiAgICBtS1tpICsgMV0gPSBiZXRhSyAqIHRhdUsgKiBkZWx0YUtbaV07XG4gIH1cbn1cblxuZnVuY3Rpb24gbW9ub3RvbmVDb21wdXRlKHBvaW50czogU3BsaW5lUG9pbnRbXSwgbUs6IG51bWJlcltdLCBpbmRleEF4aXM6ICd4JyB8ICd5JyA9ICd4Jykge1xuICBjb25zdCB2YWx1ZUF4aXMgPSBnZXRWYWx1ZUF4aXMoaW5kZXhBeGlzKTtcbiAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgbGV0IGRlbHRhOiBudW1iZXIsIHBvaW50QmVmb3JlOiBPcHRpb25hbFNwbGluZVBvaW50LCBwb2ludEN1cnJlbnQ6IE9wdGlvbmFsU3BsaW5lUG9pbnQ7XG4gIGxldCBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCAwKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50c0xlbjsgKytpKSB7XG4gICAgcG9pbnRCZWZvcmUgPSBwb2ludEN1cnJlbnQ7XG4gICAgcG9pbnRDdXJyZW50ID0gcG9pbnRBZnRlcjtcbiAgICBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCBpICsgMSk7XG4gICAgaWYgKCFwb2ludEN1cnJlbnQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGlQaXhlbCA9IHBvaW50Q3VycmVudFtpbmRleEF4aXNdO1xuICAgIGNvbnN0IHZQaXhlbCA9IHBvaW50Q3VycmVudFt2YWx1ZUF4aXNdO1xuICAgIGlmIChwb2ludEJlZm9yZSkge1xuICAgICAgZGVsdGEgPSAoaVBpeGVsIC0gcG9pbnRCZWZvcmVbaW5kZXhBeGlzXSkgLyAzO1xuICAgICAgcG9pbnRDdXJyZW50W2BjcDEke2luZGV4QXhpc31gXSA9IGlQaXhlbCAtIGRlbHRhO1xuICAgICAgcG9pbnRDdXJyZW50W2BjcDEke3ZhbHVlQXhpc31gXSA9IHZQaXhlbCAtIGRlbHRhICogbUtbaV07XG4gICAgfVxuICAgIGlmIChwb2ludEFmdGVyKSB7XG4gICAgICBkZWx0YSA9IChwb2ludEFmdGVyW2luZGV4QXhpc10gLSBpUGl4ZWwpIC8gMztcbiAgICAgIHBvaW50Q3VycmVudFtgY3AyJHtpbmRleEF4aXN9YF0gPSBpUGl4ZWwgKyBkZWx0YTtcbiAgICAgIHBvaW50Q3VycmVudFtgY3AyJHt2YWx1ZUF4aXN9YF0gPSB2UGl4ZWwgKyBkZWx0YSAqIG1LW2ldO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyBCw6l6aWVyIGNvbnRyb2wgcG9pbnRzIGluIGEgc2ltaWxhciB3YXkgdGhhbiB8c3BsaW5lQ3VydmV8LFxuICogYnV0IHByZXNlcnZlcyBtb25vdG9uaWNpdHkgb2YgdGhlIHByb3ZpZGVkIGRhdGEgYW5kIGVuc3VyZXMgbm8gbG9jYWwgZXh0cmVtdW1zIGFyZSBhZGRlZFxuICogYmV0d2VlbiB0aGUgZGF0YXNldCBkaXNjcmV0ZSBwb2ludHMgZHVlIHRvIHRoZSBpbnRlcnBvbGF0aW9uLlxuICogU2VlIDogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9ub3RvbmVfY3ViaWNfaW50ZXJwb2xhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gc3BsaW5lQ3VydmVNb25vdG9uZShwb2ludHM6IFNwbGluZVBvaW50W10sIGluZGV4QXhpczogJ3gnIHwgJ3knID0gJ3gnKSB7XG4gIGNvbnN0IHZhbHVlQXhpcyA9IGdldFZhbHVlQXhpcyhpbmRleEF4aXMpO1xuICBjb25zdCBwb2ludHNMZW4gPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCBkZWx0YUs6IG51bWJlcltdID0gQXJyYXkocG9pbnRzTGVuKS5maWxsKDApO1xuICBjb25zdCBtSzogbnVtYmVyW10gPSBBcnJheShwb2ludHNMZW4pO1xuXG4gIC8vIENhbGN1bGF0ZSBzbG9wZXMgKGRlbHRhSykgYW5kIGluaXRpYWxpemUgdGFuZ2VudHMgKG1LKVxuICBsZXQgaSwgcG9pbnRCZWZvcmU6IE9wdGlvbmFsU3BsaW5lUG9pbnQsIHBvaW50Q3VycmVudDogT3B0aW9uYWxTcGxpbmVQb2ludDtcbiAgbGV0IHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIDApO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBwb2ludHNMZW47ICsraSkge1xuICAgIHBvaW50QmVmb3JlID0gcG9pbnRDdXJyZW50O1xuICAgIHBvaW50Q3VycmVudCA9IHBvaW50QWZ0ZXI7XG4gICAgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgaSArIDEpO1xuICAgIGlmICghcG9pbnRDdXJyZW50KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAocG9pbnRBZnRlcikge1xuICAgICAgY29uc3Qgc2xvcGVEZWx0YSA9IHBvaW50QWZ0ZXJbaW5kZXhBeGlzXSAtIHBvaW50Q3VycmVudFtpbmRleEF4aXNdO1xuXG4gICAgICAvLyBJbiB0aGUgY2FzZSBvZiB0d28gcG9pbnRzIHRoYXQgYXBwZWFyIGF0IHRoZSBzYW1lIHggcGl4ZWwsIHNsb3BlRGVsdGFYIGlzIDBcbiAgICAgIGRlbHRhS1tpXSA9IHNsb3BlRGVsdGEgIT09IDAgPyAocG9pbnRBZnRlclt2YWx1ZUF4aXNdIC0gcG9pbnRDdXJyZW50W3ZhbHVlQXhpc10pIC8gc2xvcGVEZWx0YSA6IDA7XG4gICAgfVxuICAgIG1LW2ldID0gIXBvaW50QmVmb3JlID8gZGVsdGFLW2ldXG4gICAgICA6ICFwb2ludEFmdGVyID8gZGVsdGFLW2kgLSAxXVxuICAgICAgICA6IChzaWduKGRlbHRhS1tpIC0gMV0pICE9PSBzaWduKGRlbHRhS1tpXSkpID8gMFxuICAgICAgICAgIDogKGRlbHRhS1tpIC0gMV0gKyBkZWx0YUtbaV0pIC8gMjtcbiAgfVxuXG4gIG1vbm90b25lQWRqdXN0KHBvaW50cywgZGVsdGFLLCBtSyk7XG5cbiAgbW9ub3RvbmVDb21wdXRlKHBvaW50cywgbUssIGluZGV4QXhpcyk7XG59XG5cbmZ1bmN0aW9uIGNhcENvbnRyb2xQb2ludChwdDogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIpIHtcbiAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHB0LCBtYXgpLCBtaW4pO1xufVxuXG5mdW5jdGlvbiBjYXBCZXppZXJQb2ludHMocG9pbnRzOiBTcGxpbmVQb2ludFtdLCBhcmVhOiBDaGFydEFyZWEpIHtcbiAgbGV0IGksIGlsZW4sIHBvaW50LCBpbkFyZWEsIGluQXJlYVByZXY7XG4gIGxldCBpbkFyZWFOZXh0ID0gX2lzUG9pbnRJbkFyZWEocG9pbnRzWzBdLCBhcmVhKTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBpbkFyZWFQcmV2ID0gaW5BcmVhO1xuICAgIGluQXJlYSA9IGluQXJlYU5leHQ7XG4gICAgaW5BcmVhTmV4dCA9IGkgPCBpbGVuIC0gMSAmJiBfaXNQb2ludEluQXJlYShwb2ludHNbaSArIDFdLCBhcmVhKTtcbiAgICBpZiAoIWluQXJlYSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgIGlmIChpbkFyZWFQcmV2KSB7XG4gICAgICBwb2ludC5jcDF4ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMXgsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG4gICAgICBwb2ludC5jcDF5ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMXksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG4gICAgfVxuICAgIGlmIChpbkFyZWFOZXh0KSB7XG4gICAgICBwb2ludC5jcDJ4ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMngsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG4gICAgICBwb2ludC5jcDJ5ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMnksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzKFxuICBwb2ludHM6IFNwbGluZVBvaW50W10sXG4gIG9wdGlvbnMsXG4gIGFyZWE6IENoYXJ0QXJlYSxcbiAgbG9vcDogYm9vbGVhbixcbiAgaW5kZXhBeGlzOiAneCcgfCAneSdcbikge1xuICBsZXQgaTogbnVtYmVyLCBpbGVuOiBudW1iZXIsIHBvaW50OiBTcGxpbmVQb2ludCwgY29udHJvbFBvaW50czogUmV0dXJuVHlwZTx0eXBlb2Ygc3BsaW5lQ3VydmU+O1xuXG4gIC8vIE9ubHkgY29uc2lkZXIgcG9pbnRzIHRoYXQgYXJlIGRyYXduIGluIGNhc2UgdGhlIHNwYW5HYXBzIG9wdGlvbiBpcyB1c2VkXG4gIGlmIChvcHRpb25zLnNwYW5HYXBzKSB7XG4gICAgcG9pbnRzID0gcG9pbnRzLmZpbHRlcigocHQpID0+ICFwdC5za2lwKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcbiAgICBzcGxpbmVDdXJ2ZU1vbm90b25lKHBvaW50cywgaW5kZXhBeGlzKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgcHJldiA9IGxvb3AgPyBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdIDogcG9pbnRzWzBdO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnRyb2xQb2ludHMgPSBzcGxpbmVDdXJ2ZShcbiAgICAgICAgcHJldixcbiAgICAgICAgcG9pbnQsXG4gICAgICAgIHBvaW50c1tNYXRoLm1pbihpICsgMSwgaWxlbiAtIChsb29wID8gMCA6IDEpKSAlIGlsZW5dLFxuICAgICAgICBvcHRpb25zLnRlbnNpb25cbiAgICAgICk7XG4gICAgICBwb2ludC5jcDF4ID0gY29udHJvbFBvaW50cy5wcmV2aW91cy54O1xuICAgICAgcG9pbnQuY3AxeSA9IGNvbnRyb2xQb2ludHMucHJldmlvdXMueTtcbiAgICAgIHBvaW50LmNwMnggPSBjb250cm9sUG9pbnRzLm5leHQueDtcbiAgICAgIHBvaW50LmNwMnkgPSBjb250cm9sUG9pbnRzLm5leHQueTtcbiAgICAgIHByZXYgPSBwb2ludDtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0aW9ucy5jYXBCZXppZXJQb2ludHMpIHtcbiAgICBjYXBCZXppZXJQb2ludHMocG9pbnRzLCBhcmVhKTtcbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHtDaGFydEFyZWEsIFNjYWxlfSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5pbXBvcnQgdHlwZSBDaGFydCBmcm9tICcuLi9jb3JlL2NvcmUuY29udHJvbGxlci5qcyc7XG5pbXBvcnQgdHlwZSB7Q2hhcnRFdmVudH0gZnJvbSAnLi4vdHlwZXMuanMnO1xuaW1wb3J0IHtJTkZJTklUWX0gZnJvbSAnLi9oZWxwZXJzLm1hdGguanMnO1xuXG4vKipcbiAqIE5vdGU6IHR5cGVkZWZzIGFyZSBhdXRvLWV4cG9ydGVkLCBzbyB1c2UgYSBtYWRlLXVwIGBkb21gIG5hbWVzcGFjZSB3aGVyZVxuICogbmVjZXNzYXJ5IHRvIGF2b2lkIGR1cGxpY2F0ZXMgd2l0aCBgZXhwb3J0ICogZnJvbSAnLi9oZWxwZXJzYDsgc2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzQ2MDExXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vY29yZS9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gZG9tLkNoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vdHlwZXMnKS5DaGFydEV2ZW50IH0gQ2hhcnRFdmVudFxuICovXG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9pc0RvbVN1cHBvcnRlZCgpOiBib29sZWFuIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9nZXRQYXJlbnROb2RlKGRvbU5vZGU6IEhUTUxDYW52YXNFbGVtZW50KTogSFRNTENhbnZhc0VsZW1lbnQge1xuICBsZXQgcGFyZW50ID0gZG9tTm9kZS5wYXJlbnROb2RlO1xuICBpZiAocGFyZW50ICYmIHBhcmVudC50b1N0cmluZygpID09PSAnW29iamVjdCBTaGFkb3dSb290XScpIHtcbiAgICBwYXJlbnQgPSAocGFyZW50IGFzIFNoYWRvd1Jvb3QpLmhvc3Q7XG4gIH1cbiAgcmV0dXJuIHBhcmVudCBhcyBIVE1MQ2FudmFzRWxlbWVudDtcbn1cblxuLyoqXG4gKiBjb252ZXJ0IG1heC13aWR0aC9tYXgtaGVpZ2h0IHZhbHVlcyB0aGF0IG1heSBiZSBwZXJjZW50YWdlcyBpbnRvIGEgbnVtYmVyXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlTWF4U3R5bGUoc3R5bGVWYWx1ZTogc3RyaW5nIHwgbnVtYmVyLCBub2RlOiBIVE1MRWxlbWVudCwgcGFyZW50UHJvcGVydHk6IHN0cmluZykge1xuICBsZXQgdmFsdWVJblBpeGVsczogbnVtYmVyO1xuICBpZiAodHlwZW9mIHN0eWxlVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWVJblBpeGVscyA9IHBhcnNlSW50KHN0eWxlVmFsdWUsIDEwKTtcblxuICAgIGlmIChzdHlsZVZhbHVlLmluZGV4T2YoJyUnKSAhPT0gLTEpIHtcbiAgICAgIC8vIHBlcmNlbnRhZ2UgKiBzaXplIGluIGRpbWVuc2lvblxuICAgICAgdmFsdWVJblBpeGVscyA9ICh2YWx1ZUluUGl4ZWxzIC8gMTAwKSAqIG5vZGUucGFyZW50Tm9kZVtwYXJlbnRQcm9wZXJ0eV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbHVlSW5QaXhlbHMgPSBzdHlsZVZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlSW5QaXhlbHM7XG59XG5cbmNvbnN0IGdldENvbXB1dGVkU3R5bGUgPSAoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBDU1NTdHlsZURlY2xhcmF0aW9uID0+XG4gIGVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3R5bGUoZWw6IEhUTUxFbGVtZW50LCBwcm9wZXJ0eTogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWwpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpO1xufVxuXG5jb25zdCBwb3NpdGlvbnMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xuZnVuY3Rpb24gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlczogQ1NTU3R5bGVEZWNsYXJhdGlvbiwgc3R5bGU6IHN0cmluZywgc3VmZml4Pzogc3RyaW5nKTogQ2hhcnRBcmVhIHtcbiAgY29uc3QgcmVzdWx0ID0ge30gYXMgQ2hhcnRBcmVhO1xuICBzdWZmaXggPSBzdWZmaXggPyAnLScgKyBzdWZmaXggOiAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBjb25zdCBwb3MgPSBwb3NpdGlvbnNbaV07XG4gICAgcmVzdWx0W3Bvc10gPSBwYXJzZUZsb2F0KHN0eWxlc1tzdHlsZSArICctJyArIHBvcyArIHN1ZmZpeF0pIHx8IDA7XG4gIH1cbiAgcmVzdWx0LndpZHRoID0gcmVzdWx0LmxlZnQgKyByZXN1bHQucmlnaHQ7XG4gIHJlc3VsdC5oZWlnaHQgPSByZXN1bHQudG9wICsgcmVzdWx0LmJvdHRvbTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuY29uc3QgdXNlT2Zmc2V0UG9zID0gKHg6IG51bWJlciwgeTogbnVtYmVyLCB0YXJnZXQ6IEhUTUxFbGVtZW50IHwgRXZlbnRUYXJnZXQpID0+XG4gICh4ID4gMCB8fCB5ID4gMCkgJiYgKCF0YXJnZXQgfHwgISh0YXJnZXQgYXMgSFRNTEVsZW1lbnQpLnNoYWRvd1Jvb3QpO1xuXG4vKipcbiAqIEBwYXJhbSBlXG4gKiBAcGFyYW0gY2FudmFzXG4gKiBAcmV0dXJucyBDYW52YXMgcG9zaXRpb25cbiAqL1xuZnVuY3Rpb24gZ2V0Q2FudmFzUG9zaXRpb24oXG4gIGU6IEV2ZW50IHwgVG91Y2hFdmVudCB8IE1vdXNlRXZlbnQsXG4gIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnRcbik6IHtcbiAgICB4OiBudW1iZXI7XG4gICAgeTogbnVtYmVyO1xuICAgIGJveDogYm9vbGVhbjtcbiAgfSB7XG4gIGNvbnN0IHRvdWNoZXMgPSAoZSBhcyBUb3VjaEV2ZW50KS50b3VjaGVzO1xuICBjb25zdCBzb3VyY2UgPSAodG91Y2hlcyAmJiB0b3VjaGVzLmxlbmd0aCA/IHRvdWNoZXNbMF0gOiBlKSBhcyBNb3VzZUV2ZW50O1xuICBjb25zdCB7b2Zmc2V0WCwgb2Zmc2V0WX0gPSBzb3VyY2UgYXMgTW91c2VFdmVudDtcbiAgbGV0IGJveCA9IGZhbHNlO1xuICBsZXQgeCwgeTtcbiAgaWYgKHVzZU9mZnNldFBvcyhvZmZzZXRYLCBvZmZzZXRZLCBlLnRhcmdldCkpIHtcbiAgICB4ID0gb2Zmc2V0WDtcbiAgICB5ID0gb2Zmc2V0WTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHggPSBzb3VyY2UuY2xpZW50WCAtIHJlY3QubGVmdDtcbiAgICB5ID0gc291cmNlLmNsaWVudFkgLSByZWN0LnRvcDtcbiAgICBib3ggPSB0cnVlO1xuICB9XG4gIHJldHVybiB7eCwgeSwgYm94fTtcbn1cblxuLyoqXG4gKiBHZXRzIGFuIGV2ZW50J3MgeCwgeSBjb29yZGluYXRlcywgcmVsYXRpdmUgdG8gdGhlIGNoYXJ0IGFyZWFcbiAqIEBwYXJhbSBldmVudFxuICogQHBhcmFtIGNoYXJ0XG4gKiBAcmV0dXJucyB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBldmVudFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZWxhdGl2ZVBvc2l0aW9uKFxuICBldmVudDogRXZlbnQgfCBDaGFydEV2ZW50IHwgVG91Y2hFdmVudCB8IE1vdXNlRXZlbnQsXG4gIGNoYXJ0OiBDaGFydFxuKTogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9IHtcbiAgaWYgKCduYXRpdmUnIGluIGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG5cbiAgY29uc3Qge2NhbnZhcywgY3VycmVudERldmljZVBpeGVsUmF0aW99ID0gY2hhcnQ7XG4gIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjYW52YXMpO1xuICBjb25zdCBib3JkZXJCb3ggPSBzdHlsZS5ib3hTaXppbmcgPT09ICdib3JkZXItYm94JztcbiAgY29uc3QgcGFkZGluZ3MgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdwYWRkaW5nJyk7XG4gIGNvbnN0IGJvcmRlcnMgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdib3JkZXInLCAnd2lkdGgnKTtcbiAgY29uc3Qge3gsIHksIGJveH0gPSBnZXRDYW52YXNQb3NpdGlvbihldmVudCwgY2FudmFzKTtcbiAgY29uc3QgeE9mZnNldCA9IHBhZGRpbmdzLmxlZnQgKyAoYm94ICYmIGJvcmRlcnMubGVmdCk7XG4gIGNvbnN0IHlPZmZzZXQgPSBwYWRkaW5ncy50b3AgKyAoYm94ICYmIGJvcmRlcnMudG9wKTtcblxuICBsZXQge3dpZHRoLCBoZWlnaHR9ID0gY2hhcnQ7XG4gIGlmIChib3JkZXJCb3gpIHtcbiAgICB3aWR0aCAtPSBwYWRkaW5ncy53aWR0aCArIGJvcmRlcnMud2lkdGg7XG4gICAgaGVpZ2h0IC09IHBhZGRpbmdzLmhlaWdodCArIGJvcmRlcnMuaGVpZ2h0O1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogTWF0aC5yb3VuZCgoeCAtIHhPZmZzZXQpIC8gd2lkdGggKiBjYW52YXMud2lkdGggLyBjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyksXG4gICAgeTogTWF0aC5yb3VuZCgoeSAtIHlPZmZzZXQpIC8gaGVpZ2h0ICogY2FudmFzLmhlaWdodCAvIGN1cnJlbnREZXZpY2VQaXhlbFJhdGlvKVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDb250YWluZXJTaXplKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogUGFydGlhbDxTY2FsZT4ge1xuICBsZXQgbWF4V2lkdGg6IG51bWJlciwgbWF4SGVpZ2h0OiBudW1iZXI7XG5cbiAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQgfHwgaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBfZ2V0UGFyZW50Tm9kZShjYW52YXMpO1xuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICB3aWR0aCA9IGNhbnZhcy5jbGllbnRXaWR0aDtcbiAgICAgIGhlaWdodCA9IGNhbnZhcy5jbGllbnRIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIHRoaXMgaXMgdGhlIGJvcmRlciBib3ggb2YgdGhlIGNvbnRhaW5lclxuICAgICAgY29uc3QgY29udGFpbmVyU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcik7XG4gICAgICBjb25zdCBjb250YWluZXJCb3JkZXIgPSBnZXRQb3NpdGlvbmVkU3R5bGUoY29udGFpbmVyU3R5bGUsICdib3JkZXInLCAnd2lkdGgnKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lclBhZGRpbmcgPSBnZXRQb3NpdGlvbmVkU3R5bGUoY29udGFpbmVyU3R5bGUsICdwYWRkaW5nJyk7XG4gICAgICB3aWR0aCA9IHJlY3Qud2lkdGggLSBjb250YWluZXJQYWRkaW5nLndpZHRoIC0gY29udGFpbmVyQm9yZGVyLndpZHRoO1xuICAgICAgaGVpZ2h0ID0gcmVjdC5oZWlnaHQgLSBjb250YWluZXJQYWRkaW5nLmhlaWdodCAtIGNvbnRhaW5lckJvcmRlci5oZWlnaHQ7XG4gICAgICBtYXhXaWR0aCA9IHBhcnNlTWF4U3R5bGUoY29udGFpbmVyU3R5bGUubWF4V2lkdGgsIGNvbnRhaW5lciwgJ2NsaWVudFdpZHRoJyk7XG4gICAgICBtYXhIZWlnaHQgPSBwYXJzZU1heFN0eWxlKGNvbnRhaW5lclN0eWxlLm1heEhlaWdodCwgY29udGFpbmVyLCAnY2xpZW50SGVpZ2h0Jyk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIG1heFdpZHRoOiBtYXhXaWR0aCB8fCBJTkZJTklUWSxcbiAgICBtYXhIZWlnaHQ6IG1heEhlaWdodCB8fCBJTkZJTklUWVxuICB9O1xufVxuXG5jb25zdCByb3VuZDEgPSAodjogbnVtYmVyKSA9PiBNYXRoLnJvdW5kKHYgKiAxMCkgLyAxMDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXhpbXVtU2l6ZShcbiAgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCxcbiAgYmJXaWR0aD86IG51bWJlcixcbiAgYmJIZWlnaHQ/OiBudW1iZXIsXG4gIGFzcGVjdFJhdGlvPzogbnVtYmVyXG4pOiB7IHdpZHRoOiBudW1iZXI7IGhlaWdodDogbnVtYmVyIH0ge1xuICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY2FudmFzKTtcbiAgY29uc3QgbWFyZ2lucyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ21hcmdpbicpO1xuICBjb25zdCBtYXhXaWR0aCA9IHBhcnNlTWF4U3R5bGUoc3R5bGUubWF4V2lkdGgsIGNhbnZhcywgJ2NsaWVudFdpZHRoJykgfHwgSU5GSU5JVFk7XG4gIGNvbnN0IG1heEhlaWdodCA9IHBhcnNlTWF4U3R5bGUoc3R5bGUubWF4SGVpZ2h0LCBjYW52YXMsICdjbGllbnRIZWlnaHQnKSB8fCBJTkZJTklUWTtcbiAgY29uc3QgY29udGFpbmVyU2l6ZSA9IGdldENvbnRhaW5lclNpemUoY2FudmFzLCBiYldpZHRoLCBiYkhlaWdodCk7XG4gIGxldCB7d2lkdGgsIGhlaWdodH0gPSBjb250YWluZXJTaXplO1xuXG4gIGlmIChzdHlsZS5ib3hTaXppbmcgPT09ICdjb250ZW50LWJveCcpIHtcbiAgICBjb25zdCBib3JkZXJzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAnYm9yZGVyJywgJ3dpZHRoJyk7XG4gICAgY29uc3QgcGFkZGluZ3MgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdwYWRkaW5nJyk7XG4gICAgd2lkdGggLT0gcGFkZGluZ3Mud2lkdGggKyBib3JkZXJzLndpZHRoO1xuICAgIGhlaWdodCAtPSBwYWRkaW5ncy5oZWlnaHQgKyBib3JkZXJzLmhlaWdodDtcbiAgfVxuICB3aWR0aCA9IE1hdGgubWF4KDAsIHdpZHRoIC0gbWFyZ2lucy53aWR0aCk7XG4gIGhlaWdodCA9IE1hdGgubWF4KDAsIGFzcGVjdFJhdGlvID8gd2lkdGggLyBhc3BlY3RSYXRpbyA6IGhlaWdodCAtIG1hcmdpbnMuaGVpZ2h0KTtcbiAgd2lkdGggPSByb3VuZDEoTWF0aC5taW4od2lkdGgsIG1heFdpZHRoLCBjb250YWluZXJTaXplLm1heFdpZHRoKSk7XG4gIGhlaWdodCA9IHJvdW5kMShNYXRoLm1pbihoZWlnaHQsIG1heEhlaWdodCwgY29udGFpbmVyU2l6ZS5tYXhIZWlnaHQpKTtcbiAgaWYgKHdpZHRoICYmICFoZWlnaHQpIHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDY1OVxuICAgIC8vIElmIHRoZSBjYW52YXMgaGFzIHdpZHRoLCBidXQgbm8gaGVpZ2h0LCBkZWZhdWx0IHRvIGFzcGVjdFJhdGlvIG9mIDIgKGNhbnZhcyBkZWZhdWx0KVxuICAgIGhlaWdodCA9IHJvdW5kMSh3aWR0aCAvIDIpO1xuICB9XG5cbiAgY29uc3QgbWFpbnRhaW5IZWlnaHQgPSBiYldpZHRoICE9PSB1bmRlZmluZWQgfHwgYmJIZWlnaHQgIT09IHVuZGVmaW5lZDtcblxuICBpZiAobWFpbnRhaW5IZWlnaHQgJiYgYXNwZWN0UmF0aW8gJiYgY29udGFpbmVyU2l6ZS5oZWlnaHQgJiYgaGVpZ2h0ID4gY29udGFpbmVyU2l6ZS5oZWlnaHQpIHtcbiAgICBoZWlnaHQgPSBjb250YWluZXJTaXplLmhlaWdodDtcbiAgICB3aWR0aCA9IHJvdW5kMShNYXRoLmZsb29yKGhlaWdodCAqIGFzcGVjdFJhdGlvKSk7XG4gIH1cblxuICByZXR1cm4ge3dpZHRoLCBoZWlnaHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSBjaGFydFxuICogQHBhcmFtIGZvcmNlUmF0aW9cbiAqIEBwYXJhbSBmb3JjZVN0eWxlXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBjYW52YXMgY29udGV4dCBzaXplIG9yIHRyYW5zZm9ybWF0aW9uIGhhcyBjaGFuZ2VkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmV0aW5hU2NhbGUoXG4gIGNoYXJ0OiBDaGFydCxcbiAgZm9yY2VSYXRpbzogbnVtYmVyLFxuICBmb3JjZVN0eWxlPzogYm9vbGVhblxuKTogYm9vbGVhbiB8IHZvaWQge1xuICBjb25zdCBwaXhlbFJhdGlvID0gZm9yY2VSYXRpbyB8fCAxO1xuICBjb25zdCBkZXZpY2VIZWlnaHQgPSBNYXRoLmZsb29yKGNoYXJ0LmhlaWdodCAqIHBpeGVsUmF0aW8pO1xuICBjb25zdCBkZXZpY2VXaWR0aCA9IE1hdGguZmxvb3IoY2hhcnQud2lkdGggKiBwaXhlbFJhdGlvKTtcblxuICBjaGFydC5oZWlnaHQgPSBNYXRoLmZsb29yKGNoYXJ0LmhlaWdodCk7XG4gIGNoYXJ0LndpZHRoID0gTWF0aC5mbG9vcihjaGFydC53aWR0aCk7XG5cbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuXG4gIC8vIElmIG5vIHN0eWxlIGhhcyBiZWVuIHNldCBvbiB0aGUgY2FudmFzLCB0aGUgcmVuZGVyIHNpemUgaXMgdXNlZCBhcyBkaXNwbGF5IHNpemUsXG4gIC8vIG1ha2luZyB0aGUgY2hhcnQgdmlzdWFsbHkgYmlnZ2VyLCBzbyBsZXQncyBlbmZvcmNlIGl0IHRvIHRoZSBcImNvcnJlY3RcIiB2YWx1ZXMuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMzU3NVxuICBpZiAoY2FudmFzLnN0eWxlICYmIChmb3JjZVN0eWxlIHx8ICghY2FudmFzLnN0eWxlLmhlaWdodCAmJiAhY2FudmFzLnN0eWxlLndpZHRoKSkpIHtcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gYCR7Y2hhcnQuaGVpZ2h0fXB4YDtcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSBgJHtjaGFydC53aWR0aH1weGA7XG4gIH1cblxuICBpZiAoY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8gIT09IHBpeGVsUmF0aW9cbiAgICAgIHx8IGNhbnZhcy5oZWlnaHQgIT09IGRldmljZUhlaWdodFxuICAgICAgfHwgY2FudmFzLndpZHRoICE9PSBkZXZpY2VXaWR0aCkge1xuICAgIGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcbiAgICBjYW52YXMuaGVpZ2h0ID0gZGV2aWNlSGVpZ2h0O1xuICAgIGNhbnZhcy53aWR0aCA9IGRldmljZVdpZHRoO1xuICAgIGNoYXJ0LmN0eC5zZXRUcmFuc2Zvcm0ocGl4ZWxSYXRpbywgMCwgMCwgcGl4ZWxSYXRpbywgMCwgMCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIERldGVjdHMgc3VwcG9ydCBmb3Igb3B0aW9ucyBvYmplY3QgYXJndW1lbnQgaW4gYWRkRXZlbnRMaXN0ZW5lci5cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9hZGRFdmVudExpc3RlbmVyI1NhZmVseV9kZXRlY3Rpbmdfb3B0aW9uX3N1cHBvcnRcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zID0gKGZ1bmN0aW9uKCkge1xuICBsZXQgcGFzc2l2ZVN1cHBvcnRlZCA9IGZhbHNlO1xuICB0cnkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBnZXQgcGFzc2l2ZSgpIHsgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBicm93c2VyIGF0dGVtcHRzIHRvIGFjY2VzcyB0aGUgcGFzc2l2ZSBwcm9wZXJ0eS5cbiAgICAgICAgcGFzc2l2ZVN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGFzIEV2ZW50TGlzdGVuZXJPcHRpb25zO1xuXG4gICAgaWYgKF9pc0RvbVN1cHBvcnRlZCgpKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdGlvbnMpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRpb25zKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBjb250aW51ZSByZWdhcmRsZXNzIG9mIGVycm9yXG4gIH1cbiAgcmV0dXJuIHBhc3NpdmVTdXBwb3J0ZWQ7XG59KCkpO1xuXG4vKipcbiAqIFRoZSBcInVzZWRcIiBzaXplIGlzIHRoZSBmaW5hbCB2YWx1ZSBvZiBhIGRpbWVuc2lvbiBwcm9wZXJ0eSBhZnRlciBhbGwgY2FsY3VsYXRpb25zIGhhdmVcbiAqIGJlZW4gcGVyZm9ybWVkLiBUaGlzIG1ldGhvZCB1c2VzIHRoZSBjb21wdXRlZCBzdHlsZSBvZiBgZWxlbWVudGAgYnV0IHJldHVybnMgdW5kZWZpbmVkXG4gKiBpZiB0aGUgY29tcHV0ZWQgc3R5bGUgaXMgbm90IGV4cHJlc3NlZCBpbiBwaXhlbHMuIFRoYXQgY2FuIGhhcHBlbiBpbiBzb21lIGNhc2VzIHdoZXJlXG4gKiBgZWxlbWVudGAgaGFzIGEgc2l6ZSByZWxhdGl2ZSB0byBpdHMgcGFyZW50IGFuZCB0aGlzIGxhc3Qgb25lIGlzIG5vdCB5ZXQgZGlzcGxheWVkLFxuICogZm9yIGV4YW1wbGUgYmVjYXVzZSBvZiBgZGlzcGxheTogbm9uZWAgb24gYSBwYXJlbnQgbm9kZS5cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3VzZWRfdmFsdWVcbiAqIEByZXR1cm5zIFNpemUgaW4gcGl4ZWxzIG9yIHVuZGVmaW5lZCBpZiB1bmtub3duLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByZWFkVXNlZFNpemUoXG4gIGVsZW1lbnQ6IEhUTUxFbGVtZW50LFxuICBwcm9wZXJ0eTogJ3dpZHRoJyB8ICdoZWlnaHQnXG4pOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICBjb25zdCB2YWx1ZSA9IGdldFN0eWxlKGVsZW1lbnQsIHByb3BlcnR5KTtcbiAgY29uc3QgbWF0Y2hlcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKC9eKFxcZCspKFxcLlxcZCspP3B4JC8pO1xuICByZXR1cm4gbWF0Y2hlcyA/ICttYXRjaGVzWzFdIDogdW5kZWZpbmVkO1xufVxuIiwgImltcG9ydCB0eXBlIHtQb2ludCwgU3BsaW5lUG9pbnR9IGZyb20gJy4uL3R5cGVzL2dlb21ldHJpYy5qcyc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9wb2ludEluTGluZShwMTogUG9pbnQsIHAyOiBQb2ludCwgdDogbnVtYmVyLCBtb2RlPykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICByZXR1cm4ge1xuICAgIHg6IHAxLnggKyB0ICogKHAyLnggLSBwMS54KSxcbiAgICB5OiBwMS55ICsgdCAqIChwMi55IC0gcDEueSlcbiAgfTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX3N0ZXBwZWRJbnRlcnBvbGF0aW9uKFxuICBwMTogUG9pbnQsXG4gIHAyOiBQb2ludCxcbiAgdDogbnVtYmVyLCBtb2RlOiAnbWlkZGxlJyB8ICdhZnRlcicgfCB1bmtub3duXG4pIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBwMS54ICsgdCAqIChwMi54IC0gcDEueCksXG4gICAgeTogbW9kZSA9PT0gJ21pZGRsZScgPyB0IDwgMC41ID8gcDEueSA6IHAyLnlcbiAgICAgIDogbW9kZSA9PT0gJ2FmdGVyJyA/IHQgPCAxID8gcDEueSA6IHAyLnlcbiAgICAgICAgOiB0ID4gMCA/IHAyLnkgOiBwMS55XG4gIH07XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9iZXppZXJJbnRlcnBvbGF0aW9uKHAxOiBTcGxpbmVQb2ludCwgcDI6IFNwbGluZVBvaW50LCB0OiBudW1iZXIsIG1vZGU/KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIGNvbnN0IGNwMSA9IHt4OiBwMS5jcDJ4LCB5OiBwMS5jcDJ5fTtcbiAgY29uc3QgY3AyID0ge3g6IHAyLmNwMXgsIHk6IHAyLmNwMXl9O1xuICBjb25zdCBhID0gX3BvaW50SW5MaW5lKHAxLCBjcDEsIHQpO1xuICBjb25zdCBiID0gX3BvaW50SW5MaW5lKGNwMSwgY3AyLCB0KTtcbiAgY29uc3QgYyA9IF9wb2ludEluTGluZShjcDIsIHAyLCB0KTtcbiAgY29uc3QgZCA9IF9wb2ludEluTGluZShhLCBiLCB0KTtcbiAgY29uc3QgZSA9IF9wb2ludEluTGluZShiLCBjLCB0KTtcbiAgcmV0dXJuIF9wb2ludEluTGluZShkLCBlLCB0KTtcbn1cbiIsICJleHBvcnQgaW50ZXJmYWNlIFJUTEFkYXB0ZXIge1xuICB4KHg6IG51bWJlcik6IG51bWJlcjtcbiAgc2V0V2lkdGgodzogbnVtYmVyKTogdm9pZDtcbiAgdGV4dEFsaWduKGFsaWduOiAnY2VudGVyJyB8ICdsZWZ0JyB8ICdyaWdodCcpOiAnY2VudGVyJyB8ICdsZWZ0JyB8ICdyaWdodCc7XG4gIHhQbHVzKHg6IG51bWJlciwgdmFsdWU6IG51bWJlcik6IG51bWJlcjtcbiAgbGVmdEZvckx0cih4OiBudW1iZXIsIGl0ZW1XaWR0aDogbnVtYmVyKTogbnVtYmVyO1xufVxuXG5jb25zdCBnZXRSaWdodFRvTGVmdEFkYXB0ZXIgPSBmdW5jdGlvbihyZWN0WDogbnVtYmVyLCB3aWR0aDogbnVtYmVyKTogUlRMQWRhcHRlciB7XG4gIHJldHVybiB7XG4gICAgeCh4KSB7XG4gICAgICByZXR1cm4gcmVjdFggKyByZWN0WCArIHdpZHRoIC0geDtcbiAgICB9LFxuICAgIHNldFdpZHRoKHcpIHtcbiAgICAgIHdpZHRoID0gdztcbiAgICB9LFxuICAgIHRleHRBbGlnbihhbGlnbikge1xuICAgICAgaWYgKGFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICByZXR1cm4gYWxpZ247XG4gICAgICB9XG4gICAgICByZXR1cm4gYWxpZ24gPT09ICdyaWdodCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgIH0sXG4gICAgeFBsdXMoeCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB4IC0gdmFsdWU7XG4gICAgfSxcbiAgICBsZWZ0Rm9yTHRyKHgsIGl0ZW1XaWR0aCkge1xuICAgICAgcmV0dXJuIHggLSBpdGVtV2lkdGg7XG4gICAgfSxcbiAgfTtcbn07XG5cbmNvbnN0IGdldExlZnRUb1JpZ2h0QWRhcHRlciA9IGZ1bmN0aW9uKCk6IFJUTEFkYXB0ZXIge1xuICByZXR1cm4ge1xuICAgIHgoeCkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfSxcbiAgICBzZXRXaWR0aCh3KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB9LFxuICAgIHRleHRBbGlnbihhbGlnbikge1xuICAgICAgcmV0dXJuIGFsaWduO1xuICAgIH0sXG4gICAgeFBsdXMoeCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB4ICsgdmFsdWU7XG4gICAgfSxcbiAgICBsZWZ0Rm9yTHRyKHgsIF9pdGVtV2lkdGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiB4O1xuICAgIH0sXG4gIH07XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UnRsQWRhcHRlcihydGw6IGJvb2xlYW4sIHJlY3RYOiBudW1iZXIsIHdpZHRoOiBudW1iZXIpIHtcbiAgcmV0dXJuIHJ0bCA/IGdldFJpZ2h0VG9MZWZ0QWRhcHRlcihyZWN0WCwgd2lkdGgpIDogZ2V0TGVmdFRvUmlnaHRBZGFwdGVyKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvdmVycmlkZVRleHREaXJlY3Rpb24oY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGRpcmVjdGlvbjogJ2x0cicgfCAncnRsJykge1xuICBsZXQgc3R5bGU6IENTU1N0eWxlRGVjbGFyYXRpb24sIG9yaWdpbmFsOiBbc3RyaW5nLCBzdHJpbmddO1xuICBpZiAoZGlyZWN0aW9uID09PSAnbHRyJyB8fCBkaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgc3R5bGUgPSBjdHguY2FudmFzLnN0eWxlO1xuICAgIG9yaWdpbmFsID0gW1xuICAgICAgc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnZGlyZWN0aW9uJyksXG4gICAgICBzdHlsZS5nZXRQcm9wZXJ0eVByaW9yaXR5KCdkaXJlY3Rpb24nKSxcbiAgICBdO1xuXG4gICAgc3R5bGUuc2V0UHJvcGVydHkoJ2RpcmVjdGlvbicsIGRpcmVjdGlvbiwgJ2ltcG9ydGFudCcpO1xuICAgIChjdHggYXMgeyBwcmV2VGV4dERpcmVjdGlvbj86IFtzdHJpbmcsIHN0cmluZ10gfSkucHJldlRleHREaXJlY3Rpb24gPSBvcmlnaW5hbDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzdG9yZVRleHREaXJlY3Rpb24oY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIG9yaWdpbmFsPzogW3N0cmluZywgc3RyaW5nXSkge1xuICBpZiAob3JpZ2luYWwgIT09IHVuZGVmaW5lZCkge1xuICAgIGRlbGV0ZSAoY3R4IGFzIHsgcHJldlRleHREaXJlY3Rpb24/OiBbc3RyaW5nLCBzdHJpbmddIH0pLnByZXZUZXh0RGlyZWN0aW9uO1xuICAgIGN0eC5jYW52YXMuc3R5bGUuc2V0UHJvcGVydHkoJ2RpcmVjdGlvbicsIG9yaWdpbmFsWzBdLCBvcmlnaW5hbFsxXSk7XG4gIH1cbn1cbiIsICJpbXBvcnQge19hbmdsZUJldHdlZW4sIF9hbmdsZURpZmYsIF9pc0JldHdlZW4sIF9ub3JtYWxpemVBbmdsZX0gZnJvbSAnLi9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtjcmVhdGVDb250ZXh0fSBmcm9tICcuL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5pbXBvcnQge2lzUGF0dGVybk9yR3JhZGllbnR9IGZyb20gJy4vaGVscGVycy5jb2xvci5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL2VsZW1lbnRzL2VsZW1lbnQubGluZS5qcycpLmRlZmF1bHQgfSBMaW5lRWxlbWVudFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL2VsZW1lbnRzL2VsZW1lbnQucG9pbnQuanMnKS5kZWZhdWx0IH0gUG9pbnRFbGVtZW50XG4gKiBAdHlwZWRlZiB7e3N0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyLCBsb29wOiBib29sZWFuLCBzdHlsZT86IGFueX19IFNlZ21lbnRcbiAqL1xuXG5mdW5jdGlvbiBwcm9wZXJ0eUZuKHByb3BlcnR5KSB7XG4gIGlmIChwcm9wZXJ0eSA9PT0gJ2FuZ2xlJykge1xuICAgIHJldHVybiB7XG4gICAgICBiZXR3ZWVuOiBfYW5nbGVCZXR3ZWVuLFxuICAgICAgY29tcGFyZTogX2FuZ2xlRGlmZixcbiAgICAgIG5vcm1hbGl6ZTogX25vcm1hbGl6ZUFuZ2xlLFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBiZXR3ZWVuOiBfaXNCZXR3ZWVuLFxuICAgIGNvbXBhcmU6IChhLCBiKSA9PiBhIC0gYixcbiAgICBub3JtYWxpemU6IHggPT4geFxuICB9O1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTZWdtZW50KHtzdGFydCwgZW5kLCBjb3VudCwgbG9vcCwgc3R5bGV9KSB7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0ICUgY291bnQsXG4gICAgZW5kOiBlbmQgJSBjb3VudCxcbiAgICBsb29wOiBsb29wICYmIChlbmQgLSBzdGFydCArIDEpICUgY291bnQgPT09IDAsXG4gICAgc3R5bGVcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0U2VnbWVudChzZWdtZW50LCBwb2ludHMsIGJvdW5kcykge1xuICBjb25zdCB7cHJvcGVydHksIHN0YXJ0OiBzdGFydEJvdW5kLCBlbmQ6IGVuZEJvdW5kfSA9IGJvdW5kcztcbiAgY29uc3Qge2JldHdlZW4sIG5vcm1hbGl6ZX0gPSBwcm9wZXJ0eUZuKHByb3BlcnR5KTtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gIGxldCB7c3RhcnQsIGVuZCwgbG9vcH0gPSBzZWdtZW50O1xuICBsZXQgaSwgaWxlbjtcblxuICBpZiAobG9vcCkge1xuICAgIHN0YXJ0ICs9IGNvdW50O1xuICAgIGVuZCArPSBjb3VudDtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGlmICghYmV0d2Vlbihub3JtYWxpemUocG9pbnRzW3N0YXJ0ICUgY291bnRdW3Byb3BlcnR5XSksIHN0YXJ0Qm91bmQsIGVuZEJvdW5kKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXJ0LS07XG4gICAgICBlbmQtLTtcbiAgICB9XG4gICAgc3RhcnQgJT0gY291bnQ7XG4gICAgZW5kICU9IGNvdW50O1xuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgZW5kICs9IGNvdW50O1xuICB9XG4gIHJldHVybiB7c3RhcnQsIGVuZCwgbG9vcCwgc3R5bGU6IHNlZ21lbnQuc3R5bGV9O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHN1Yi1zZWdtZW50KHMpIG9mIGEgbGluZSBzZWdtZW50IHRoYXQgZmFsbCBpbiB0aGUgZ2l2ZW4gYm91bmRzXG4gKiBAcGFyYW0ge29iamVjdH0gc2VnbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnQuc3RhcnQgLSBzdGFydCBpbmRleCBvZiB0aGUgc2VnbWVudCwgcmVmZXJyaW5nIHRoZSBwb2ludHMgYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LmVuZCAtIGVuZCBpbmRleCBvZiB0aGUgc2VnbWVudCwgcmVmZXJyaW5nIHRoZSBwb2ludHMgYXJyYXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VnbWVudC5sb29wIC0gaW5kaWNhdGVzIHRoYXQgdGhlIHNlZ21lbnQgaXMgYSBsb29wXG4gKiBAcGFyYW0ge29iamVjdH0gW3NlZ21lbnQuc3R5bGVdIC0gc2VnbWVudCBzdHlsZVxuICogQHBhcmFtIHtQb2ludEVsZW1lbnRbXX0gcG9pbnRzIC0gdGhlIHBvaW50cyB0aGF0IHRoaXMgc2VnbWVudCByZWZlcnMgdG9cbiAqIEBwYXJhbSB7b2JqZWN0fSBbYm91bmRzXVxuICogQHBhcmFtIHtzdHJpbmd9IGJvdW5kcy5wcm9wZXJ0eSAtIHRoZSBwcm9wZXJ0eSBvZiBhIGBQb2ludEVsZW1lbnRgIHdlIGFyZSBib3VuZGluZy4gYHhgLCBgeWAgb3IgYGFuZ2xlYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3VuZHMuc3RhcnQgLSBzdGFydCB2YWx1ZSBvZiB0aGUgcHJvcGVydHlcbiAqIEBwYXJhbSB7bnVtYmVyfSBib3VuZHMuZW5kIC0gZW5kIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuICogQHByaXZhdGVcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBfYm91bmRTZWdtZW50KHNlZ21lbnQsIHBvaW50cywgYm91bmRzKSB7XG4gIGlmICghYm91bmRzKSB7XG4gICAgcmV0dXJuIFtzZWdtZW50XTtcbiAgfVxuXG4gIGNvbnN0IHtwcm9wZXJ0eSwgc3RhcnQ6IHN0YXJ0Qm91bmQsIGVuZDogZW5kQm91bmR9ID0gYm91bmRzO1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IHtjb21wYXJlLCBiZXR3ZWVuLCBub3JtYWxpemV9ID0gcHJvcGVydHlGbihwcm9wZXJ0eSk7XG4gIGNvbnN0IHtzdGFydCwgZW5kLCBsb29wLCBzdHlsZX0gPSBnZXRTZWdtZW50KHNlZ21lbnQsIHBvaW50cywgYm91bmRzKTtcblxuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGluc2lkZSA9IGZhbHNlO1xuICBsZXQgc3ViU3RhcnQgPSBudWxsO1xuICBsZXQgdmFsdWUsIHBvaW50LCBwcmV2VmFsdWU7XG5cbiAgY29uc3Qgc3RhcnRJc0JlZm9yZSA9ICgpID0+IGJldHdlZW4oc3RhcnRCb3VuZCwgcHJldlZhbHVlLCB2YWx1ZSkgJiYgY29tcGFyZShzdGFydEJvdW5kLCBwcmV2VmFsdWUpICE9PSAwO1xuICBjb25zdCBlbmRJc0JlZm9yZSA9ICgpID0+IGNvbXBhcmUoZW5kQm91bmQsIHZhbHVlKSA9PT0gMCB8fCBiZXR3ZWVuKGVuZEJvdW5kLCBwcmV2VmFsdWUsIHZhbHVlKTtcbiAgY29uc3Qgc2hvdWxkU3RhcnQgPSAoKSA9PiBpbnNpZGUgfHwgc3RhcnRJc0JlZm9yZSgpO1xuICBjb25zdCBzaG91bGRTdG9wID0gKCkgPT4gIWluc2lkZSB8fCBlbmRJc0JlZm9yZSgpO1xuXG4gIGZvciAobGV0IGkgPSBzdGFydCwgcHJldiA9IHN0YXJ0OyBpIDw9IGVuZDsgKytpKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbaSAlIGNvdW50XTtcblxuICAgIGlmIChwb2ludC5za2lwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YWx1ZSA9IG5vcm1hbGl6ZShwb2ludFtwcm9wZXJ0eV0pO1xuXG4gICAgaWYgKHZhbHVlID09PSBwcmV2VmFsdWUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGluc2lkZSA9IGJldHdlZW4odmFsdWUsIHN0YXJ0Qm91bmQsIGVuZEJvdW5kKTtcblxuICAgIGlmIChzdWJTdGFydCA9PT0gbnVsbCAmJiBzaG91bGRTdGFydCgpKSB7XG4gICAgICBzdWJTdGFydCA9IGNvbXBhcmUodmFsdWUsIHN0YXJ0Qm91bmQpID09PSAwID8gaSA6IHByZXY7XG4gICAgfVxuXG4gICAgaWYgKHN1YlN0YXJ0ICE9PSBudWxsICYmIHNob3VsZFN0b3AoKSkge1xuICAgICAgcmVzdWx0LnB1c2gobm9ybWFsaXplU2VnbWVudCh7c3RhcnQ6IHN1YlN0YXJ0LCBlbmQ6IGksIGxvb3AsIGNvdW50LCBzdHlsZX0pKTtcbiAgICAgIHN1YlN0YXJ0ID0gbnVsbDtcbiAgICB9XG4gICAgcHJldiA9IGk7XG4gICAgcHJldlZhbHVlID0gdmFsdWU7XG4gIH1cblxuICBpZiAoc3ViU3RhcnQgIT09IG51bGwpIHtcbiAgICByZXN1bHQucHVzaChub3JtYWxpemVTZWdtZW50KHtzdGFydDogc3ViU3RhcnQsIGVuZCwgbG9vcCwgY291bnQsIHN0eWxlfSkpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNlZ21lbnRzIG9mIHRoZSBsaW5lIHRoYXQgYXJlIGluc2lkZSBnaXZlbiBib3VuZHNcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmVcbiAqIEBwYXJhbSB7b2JqZWN0fSBbYm91bmRzXVxuICogQHBhcmFtIHtzdHJpbmd9IGJvdW5kcy5wcm9wZXJ0eSAtIHRoZSBwcm9wZXJ0eSB3ZSBhcmUgYm91bmRpbmcgd2l0aC4gYHhgLCBgeWAgb3IgYGFuZ2xlYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3VuZHMuc3RhcnQgLSBzdGFydCB2YWx1ZSBvZiB0aGUgYHByb3BlcnR5YFxuICogQHBhcmFtIHtudW1iZXJ9IGJvdW5kcy5lbmQgLSBlbmQgdmFsdWUgb2YgdGhlIGBwcm9wZXJ0eWBcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYm91bmRTZWdtZW50cyhsaW5lLCBib3VuZHMpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc3ViID0gX2JvdW5kU2VnbWVudChzZWdtZW50c1tpXSwgbGluZS5wb2ludHMsIGJvdW5kcyk7XG4gICAgaWYgKHN1Yi5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdC5wdXNoKC4uLnN1Yik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRmluZCBzdGFydCBhbmQgZW5kIGluZGV4IG9mIGEgbGluZS5cbiAqL1xuZnVuY3Rpb24gZmluZFN0YXJ0QW5kRW5kKHBvaW50cywgY291bnQsIGxvb3AsIHNwYW5HYXBzKSB7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBlbmQgPSBjb3VudCAtIDE7XG5cbiAgaWYgKGxvb3AgJiYgIXNwYW5HYXBzKSB7XG4gICAgLy8gbG9vcCBhbmQgbm90IHNwYW5uaW5nIGdhcHMsIGZpcnN0IGZpbmQgYSBnYXAgdG8gc3RhcnQgZnJvbVxuICAgIHdoaWxlIChzdGFydCA8IGNvdW50ICYmICFwb2ludHNbc3RhcnRdLnNraXApIHtcbiAgICAgIHN0YXJ0Kys7XG4gICAgfVxuICB9XG5cbiAgLy8gZmluZCBmaXJzdCBub24gc2tpcHBlZCBwb2ludCAoYWZ0ZXIgdGhlIGZpcnN0IGdhcCBwb3NzaWJseSlcbiAgd2hpbGUgKHN0YXJ0IDwgY291bnQgJiYgcG9pbnRzW3N0YXJ0XS5za2lwKSB7XG4gICAgc3RhcnQrKztcbiAgfVxuXG4gIC8vIGlmIHdlIGxvb3BlZCB0byBjb3VudCwgc3RhcnQgbmVlZHMgdG8gYmUgMFxuICBzdGFydCAlPSBjb3VudDtcblxuICBpZiAobG9vcCkge1xuICAgIC8vIGxvb3Agd2lsbCBnbyBwYXN0IGNvdW50LCBpZiBzdGFydCA+IDBcbiAgICBlbmQgKz0gc3RhcnQ7XG4gIH1cblxuICB3aGlsZSAoZW5kID4gc3RhcnQgJiYgcG9pbnRzW2VuZCAlIGNvdW50XS5za2lwKSB7XG4gICAgZW5kLS07XG4gIH1cblxuICAvLyBlbmQgY291bGQgYmUgbW9yZSB0aGFuIGNvdW50LCBub3JtYWxpemVcbiAgZW5kICU9IGNvdW50O1xuXG4gIHJldHVybiB7c3RhcnQsIGVuZH07XG59XG5cbi8qKlxuICogQ29tcHV0ZSBzb2xpZCBzZWdtZW50cyBmcm9tIFBvaW50cywgd2hlbiBzcGFuR2FwcyA9PT0gZmFsc2VcbiAqIEBwYXJhbSB7UG9pbnRFbGVtZW50W119IHBvaW50cyAtIHRoZSBwb2ludHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIHN0YXJ0IGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IC0gbWF4IGluZGV4IChjYW4gZ28gcGFzdCBjb3VudCBvbiBhIGxvb3ApXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxvb3AgLSBib29sZWFuIGluZGljYXRpbmcgdGhhdCB0aGlzIHdvdWxkIGJlIGEgbG9vcCBpZiBubyBnYXBzIGFyZSBmb3VuZFxuICovXG5mdW5jdGlvbiBzb2xpZFNlZ21lbnRzKHBvaW50cywgc3RhcnQsIG1heCwgbG9vcCkge1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgbGFzdCA9IHN0YXJ0O1xuICBsZXQgcHJldiA9IHBvaW50c1tzdGFydF07XG4gIGxldCBlbmQ7XG5cbiAgZm9yIChlbmQgPSBzdGFydCArIDE7IGVuZCA8PSBtYXg7ICsrZW5kKSB7XG4gICAgY29uc3QgY3VyID0gcG9pbnRzW2VuZCAlIGNvdW50XTtcbiAgICBpZiAoY3VyLnNraXAgfHwgY3VyLnN0b3ApIHtcbiAgICAgIGlmICghcHJldi5za2lwKSB7XG4gICAgICAgIGxvb3AgPSBmYWxzZTtcbiAgICAgICAgcmVzdWx0LnB1c2goe3N0YXJ0OiBzdGFydCAlIGNvdW50LCBlbmQ6IChlbmQgLSAxKSAlIGNvdW50LCBsb29wfSk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgc3RhcnQgPSBsYXN0ID0gY3VyLnN0b3AgPyBlbmQgOiBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0ID0gZW5kO1xuICAgICAgaWYgKHByZXYuc2tpcCkge1xuICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcHJldiA9IGN1cjtcbiAgfVxuXG4gIGlmIChsYXN0ICE9PSBudWxsKSB7XG4gICAgcmVzdWx0LnB1c2goe3N0YXJ0OiBzdGFydCAlIGNvdW50LCBlbmQ6IGxhc3QgJSBjb3VudCwgbG9vcH0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb21wdXRlIHRoZSBjb250aW51b3VzIHNlZ21lbnRzIHRoYXQgZGVmaW5lIHRoZSB3aG9sZSBsaW5lXG4gKiBUaGVyZSBjYW4gYmUgc2tpcHBlZCBwb2ludHMgd2l0aGluIGEgc2VnbWVudCwgaWYgc3BhbkdhcHMgaXMgdHJ1ZS5cbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmVcbiAqIEBwYXJhbSB7b2JqZWN0fSBbc2VnbWVudE9wdGlvbnNdXG4gKiBAcmV0dXJuIHtTZWdtZW50W119XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2NvbXB1dGVTZWdtZW50cyhsaW5lLCBzZWdtZW50T3B0aW9ucykge1xuICBjb25zdCBwb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3Qgc3BhbkdhcHMgPSBsaW5lLm9wdGlvbnMuc3BhbkdhcHM7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcblxuICBpZiAoIWNvdW50KSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3QgbG9vcCA9ICEhbGluZS5fbG9vcDtcbiAgY29uc3Qge3N0YXJ0LCBlbmR9ID0gZmluZFN0YXJ0QW5kRW5kKHBvaW50cywgY291bnQsIGxvb3AsIHNwYW5HYXBzKTtcblxuICBpZiAoc3BhbkdhcHMgPT09IHRydWUpIHtcbiAgICByZXR1cm4gc3BsaXRCeVN0eWxlcyhsaW5lLCBbe3N0YXJ0LCBlbmQsIGxvb3B9XSwgcG9pbnRzLCBzZWdtZW50T3B0aW9ucyk7XG4gIH1cblxuICBjb25zdCBtYXggPSBlbmQgPCBzdGFydCA/IGVuZCArIGNvdW50IDogZW5kO1xuICBjb25zdCBjb21wbGV0ZUxvb3AgPSAhIWxpbmUuX2Z1bGxMb29wICYmIHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gY291bnQgLSAxO1xuICByZXR1cm4gc3BsaXRCeVN0eWxlcyhsaW5lLCBzb2xpZFNlZ21lbnRzKHBvaW50cywgc3RhcnQsIG1heCwgY29tcGxldGVMb29wKSwgcG9pbnRzLCBzZWdtZW50T3B0aW9ucyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTZWdtZW50W119IHNlZ21lbnRzXG4gKiBAcGFyYW0ge1BvaW50RWxlbWVudFtdfSBwb2ludHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBbc2VnbWVudE9wdGlvbnNdXG4gKiBAcmV0dXJuIHtTZWdtZW50W119XG4gKi9cbmZ1bmN0aW9uIHNwbGl0QnlTdHlsZXMobGluZSwgc2VnbWVudHMsIHBvaW50cywgc2VnbWVudE9wdGlvbnMpIHtcbiAgaWYgKCFzZWdtZW50T3B0aW9ucyB8fCAhc2VnbWVudE9wdGlvbnMuc2V0Q29udGV4dCB8fCAhcG9pbnRzKSB7XG4gICAgcmV0dXJuIHNlZ21lbnRzO1xuICB9XG4gIHJldHVybiBkb1NwbGl0QnlTdHlsZXMobGluZSwgc2VnbWVudHMsIHBvaW50cywgc2VnbWVudE9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmVcbiAqIEBwYXJhbSB7U2VnbWVudFtdfSBzZWdtZW50c1xuICogQHBhcmFtIHtQb2ludEVsZW1lbnRbXX0gcG9pbnRzXG4gKiBAcGFyYW0ge29iamVjdH0gW3NlZ21lbnRPcHRpb25zXVxuICogQHJldHVybiB7U2VnbWVudFtdfVxuICovXG5mdW5jdGlvbiBkb1NwbGl0QnlTdHlsZXMobGluZSwgc2VnbWVudHMsIHBvaW50cywgc2VnbWVudE9wdGlvbnMpIHtcbiAgY29uc3QgY2hhcnRDb250ZXh0ID0gbGluZS5fY2hhcnQuZ2V0Q29udGV4dCgpO1xuICBjb25zdCBiYXNlU3R5bGUgPSByZWFkU3R5bGUobGluZS5vcHRpb25zKTtcbiAgY29uc3Qge19kYXRhc2V0SW5kZXg6IGRhdGFzZXRJbmRleCwgb3B0aW9uczoge3NwYW5HYXBzfX0gPSBsaW5lO1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgcHJldlN0eWxlID0gYmFzZVN0eWxlO1xuICBsZXQgc3RhcnQgPSBzZWdtZW50c1swXS5zdGFydDtcbiAgbGV0IGkgPSBzdGFydDtcblxuICBmdW5jdGlvbiBhZGRTdHlsZShzLCBlLCBsLCBzdCkge1xuICAgIGNvbnN0IGRpciA9IHNwYW5HYXBzID8gLTEgOiAxO1xuICAgIGlmIChzID09PSBlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFN0eWxlIGNhbiBub3Qgc3RhcnQvZW5kIG9uIGEgc2tpcHBlZCBwb2ludCwgYWRqdXN0IGluZGljZXMgYWNjb3JkaW5nbHlcbiAgICBzICs9IGNvdW50O1xuICAgIHdoaWxlIChwb2ludHNbcyAlIGNvdW50XS5za2lwKSB7XG4gICAgICBzIC09IGRpcjtcbiAgICB9XG4gICAgd2hpbGUgKHBvaW50c1tlICUgY291bnRdLnNraXApIHtcbiAgICAgIGUgKz0gZGlyO1xuICAgIH1cbiAgICBpZiAocyAlIGNvdW50ICE9PSBlICUgY291bnQpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHtzdGFydDogcyAlIGNvdW50LCBlbmQ6IGUgJSBjb3VudCwgbG9vcDogbCwgc3R5bGU6IHN0fSk7XG4gICAgICBwcmV2U3R5bGUgPSBzdDtcbiAgICAgIHN0YXJ0ID0gZSAlIGNvdW50O1xuICAgIH1cbiAgfVxuXG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgIHN0YXJ0ID0gc3BhbkdhcHMgPyBzdGFydCA6IHNlZ21lbnQuc3RhcnQ7XG4gICAgbGV0IHByZXYgPSBwb2ludHNbc3RhcnQgJSBjb3VudF07XG4gICAgbGV0IHN0eWxlO1xuICAgIGZvciAoaSA9IHN0YXJ0ICsgMTsgaSA8PSBzZWdtZW50LmVuZDsgaSsrKSB7XG4gICAgICBjb25zdCBwdCA9IHBvaW50c1tpICUgY291bnRdO1xuICAgICAgc3R5bGUgPSByZWFkU3R5bGUoc2VnbWVudE9wdGlvbnMuc2V0Q29udGV4dChjcmVhdGVDb250ZXh0KGNoYXJ0Q29udGV4dCwge1xuICAgICAgICB0eXBlOiAnc2VnbWVudCcsXG4gICAgICAgIHAwOiBwcmV2LFxuICAgICAgICBwMTogcHQsXG4gICAgICAgIHAwRGF0YUluZGV4OiAoaSAtIDEpICUgY291bnQsXG4gICAgICAgIHAxRGF0YUluZGV4OiBpICUgY291bnQsXG4gICAgICAgIGRhdGFzZXRJbmRleFxuICAgICAgfSkpKTtcbiAgICAgIGlmIChzdHlsZUNoYW5nZWQoc3R5bGUsIHByZXZTdHlsZSkpIHtcbiAgICAgICAgYWRkU3R5bGUoc3RhcnQsIGkgLSAxLCBzZWdtZW50Lmxvb3AsIHByZXZTdHlsZSk7XG4gICAgICB9XG4gICAgICBwcmV2ID0gcHQ7XG4gICAgICBwcmV2U3R5bGUgPSBzdHlsZTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0IDwgaSAtIDEpIHtcbiAgICAgIGFkZFN0eWxlKHN0YXJ0LCBpIC0gMSwgc2VnbWVudC5sb29wLCBwcmV2U3R5bGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHJlYWRTdHlsZShvcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcbiAgICBib3JkZXJDYXBTdHlsZTogb3B0aW9ucy5ib3JkZXJDYXBTdHlsZSxcbiAgICBib3JkZXJEYXNoOiBvcHRpb25zLmJvcmRlckRhc2gsXG4gICAgYm9yZGVyRGFzaE9mZnNldDogb3B0aW9ucy5ib3JkZXJEYXNoT2Zmc2V0LFxuICAgIGJvcmRlckpvaW5TdHlsZTogb3B0aW9ucy5ib3JkZXJKb2luU3R5bGUsXG4gICAgYm9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG4gICAgYm9yZGVyQ29sb3I6IG9wdGlvbnMuYm9yZGVyQ29sb3JcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVDaGFuZ2VkKHN0eWxlLCBwcmV2U3R5bGUpIHtcbiAgaWYgKCFwcmV2U3R5bGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgY2FjaGUgPSBbXTtcbiAgY29uc3QgcmVwbGFjZXIgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgaWYgKCFpc1BhdHRlcm5PckdyYWRpZW50KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoIWNhY2hlLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgICAgY2FjaGUucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZS5pbmRleE9mKHZhbHVlKTtcbiAgfTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0eWxlLCByZXBsYWNlcikgIT09IEpTT04uc3RyaW5naWZ5KHByZXZTdHlsZSwgcmVwbGFjZXIpO1xufVxuIiwgImltcG9ydCB7cmVxdWVzdEFuaW1GcmFtZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmV4dHJhcy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vY29yZS5hbmltYXRpb24uanMnKS5kZWZhdWx0IH0gQW5pbWF0aW9uXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqL1xuXG4vKipcbiAqIFBsZWFzZSB1c2UgdGhlIG1vZHVsZSdzIGRlZmF1bHQgZXhwb3J0IHdoaWNoIHByb3ZpZGVzIGEgc2luZ2xldG9uIGluc3RhbmNlXG4gKiBOb3RlOiBjbGFzcyBpcyBleHBvcnQgZm9yIHR5cGVkb2NcbiAqL1xuZXhwb3J0IGNsYXNzIEFuaW1hdG9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fcmVxdWVzdCA9IG51bGw7XG4gICAgdGhpcy5fY2hhcnRzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9sYXN0RGF0ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX25vdGlmeShjaGFydCwgYW5pbXMsIGRhdGUsIHR5cGUpIHtcbiAgICBjb25zdCBjYWxsYmFja3MgPSBhbmltcy5saXN0ZW5lcnNbdHlwZV07XG4gICAgY29uc3QgbnVtU3RlcHMgPSBhbmltcy5kdXJhdGlvbjtcblxuICAgIGNhbGxiYWNrcy5mb3JFYWNoKGZuID0+IGZuKHtcbiAgICAgIGNoYXJ0LFxuICAgICAgaW5pdGlhbDogYW5pbXMuaW5pdGlhbCxcbiAgICAgIG51bVN0ZXBzLFxuICAgICAgY3VycmVudFN0ZXA6IE1hdGgubWluKGRhdGUgLSBhbmltcy5zdGFydCwgbnVtU3RlcHMpXG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVmcmVzaCgpIHtcbiAgICBpZiAodGhpcy5fcmVxdWVzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcblxuICAgIHRoaXMuX3JlcXVlc3QgPSByZXF1ZXN0QW5pbUZyYW1lLmNhbGwod2luZG93LCAoKSA9PiB7XG4gICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgIHRoaXMuX3JlcXVlc3QgPSBudWxsO1xuXG4gICAgICBpZiAodGhpcy5fcnVubmluZykge1xuICAgICAgICB0aGlzLl9yZWZyZXNoKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGUoZGF0ZSA9IERhdGUubm93KCkpIHtcbiAgICBsZXQgcmVtYWluaW5nID0gMDtcblxuICAgIHRoaXMuX2NoYXJ0cy5mb3JFYWNoKChhbmltcywgY2hhcnQpID0+IHtcbiAgICAgIGlmICghYW5pbXMucnVubmluZyB8fCAhYW5pbXMuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGl0ZW1zID0gYW5pbXMuaXRlbXM7XG4gICAgICBsZXQgaSA9IGl0ZW1zLmxlbmd0aCAtIDE7XG4gICAgICBsZXQgZHJhdyA9IGZhbHNlO1xuICAgICAgbGV0IGl0ZW07XG5cbiAgICAgIGZvciAoOyBpID49IDA7IC0taSkge1xuICAgICAgICBpdGVtID0gaXRlbXNbaV07XG5cbiAgICAgICAgaWYgKGl0ZW0uX2FjdGl2ZSkge1xuICAgICAgICAgIGlmIChpdGVtLl90b3RhbCA+IGFuaW1zLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgYW5pbWF0aW9uIGhhcyBiZWVuIHVwZGF0ZWQgYW5kIGl0cyBkdXJhdGlvbiBwcm9sb25nZWQsXG4gICAgICAgICAgICAvLyB1cGRhdGUgdG8gdG90YWwgZHVyYXRpb24gb2YgY3VycmVudCBhbmltYXRpb25zIHJ1biAoZm9yIHByb2dyZXNzIGV2ZW50KVxuICAgICAgICAgICAgYW5pbXMuZHVyYXRpb24gPSBpdGVtLl90b3RhbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXRlbS50aWNrKGRhdGUpO1xuICAgICAgICAgIGRyYXcgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlbW92ZSB0aGUgaXRlbSBieSByZXBsYWNpbmcgaXQgd2l0aCBsYXN0IGl0ZW0gYW5kIHJlbW92aW5nIHRoZSBsYXN0XG4gICAgICAgICAgLy8gQSBsb3QgZmFzdGVyIHRoYW4gc3BsaWNlLlxuICAgICAgICAgIGl0ZW1zW2ldID0gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaXRlbXMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGRyYXcpIHtcbiAgICAgICAgY2hhcnQuZHJhdygpO1xuICAgICAgICB0aGlzLl9ub3RpZnkoY2hhcnQsIGFuaW1zLCBkYXRlLCAncHJvZ3Jlc3MnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgYW5pbXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9ub3RpZnkoY2hhcnQsIGFuaW1zLCBkYXRlLCAnY29tcGxldGUnKTtcbiAgICAgICAgYW5pbXMuaW5pdGlhbCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZW1haW5pbmcgKz0gaXRlbXMubGVuZ3RoO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fbGFzdERhdGUgPSBkYXRlO1xuXG4gICAgaWYgKHJlbWFpbmluZyA9PT0gMCkge1xuICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldEFuaW1zKGNoYXJ0KSB7XG4gICAgY29uc3QgY2hhcnRzID0gdGhpcy5fY2hhcnRzO1xuICAgIGxldCBhbmltcyA9IGNoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMpIHtcbiAgICAgIGFuaW1zID0ge1xuICAgICAgICBydW5uaW5nOiBmYWxzZSxcbiAgICAgICAgaW5pdGlhbDogdHJ1ZSxcbiAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICAgICBjb21wbGV0ZTogW10sXG4gICAgICAgICAgcHJvZ3Jlc3M6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjaGFydHMuc2V0KGNoYXJ0LCBhbmltcyk7XG4gICAgfVxuICAgIHJldHVybiBhbmltcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgLSBldmVudCBuYW1lXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gY2FsbGJhY2tcblx0ICovXG4gIGxpc3RlbihjaGFydCwgZXZlbnQsIGNiKSB7XG4gICAgdGhpcy5fZ2V0QW5pbXMoY2hhcnQpLmxpc3RlbmVyc1tldmVudF0ucHVzaChjYik7XG4gIH1cblxuICAvKipcblx0ICogQWRkIGFuaW1hdGlvbnNcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICogQHBhcmFtIHtBbmltYXRpb25bXX0gaXRlbXMgLSBhbmltYXRpb25zXG5cdCAqL1xuICBhZGQoY2hhcnQsIGl0ZW1zKSB7XG4gICAgaWYgKCFpdGVtcyB8fCAhaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2dldEFuaW1zKGNoYXJ0KS5pdGVtcy5wdXNoKC4uLml0ZW1zKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBDb3VudHMgbnVtYmVyIG9mIGFjdGl2ZSBhbmltYXRpb25zIGZvciB0aGUgY2hhcnRcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICovXG4gIGhhcyhjaGFydCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRBbmltcyhjaGFydCkuaXRlbXMubGVuZ3RoID4gMDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBTdGFydCBhbmltYXRpbmcgKGFsbCBjaGFydHMpXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqL1xuICBzdGFydChjaGFydCkge1xuICAgIGNvbnN0IGFuaW1zID0gdGhpcy5fY2hhcnRzLmdldChjaGFydCk7XG4gICAgaWYgKCFhbmltcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhbmltcy5ydW5uaW5nID0gdHJ1ZTtcbiAgICBhbmltcy5zdGFydCA9IERhdGUubm93KCk7XG4gICAgYW5pbXMuZHVyYXRpb24gPSBhbmltcy5pdGVtcy5yZWR1Y2UoKGFjYywgY3VyKSA9PiBNYXRoLm1heChhY2MsIGN1ci5fZHVyYXRpb24pLCAwKTtcbiAgICB0aGlzLl9yZWZyZXNoKCk7XG4gIH1cblxuICBydW5uaW5nKGNoYXJ0KSB7XG4gICAgaWYgKCF0aGlzLl9ydW5uaW5nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGFuaW1zID0gdGhpcy5fY2hhcnRzLmdldChjaGFydCk7XG4gICAgaWYgKCFhbmltcyB8fCAhYW5pbXMucnVubmluZyB8fCAhYW5pbXMuaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG5cdCAqIFN0b3AgYWxsIGFuaW1hdGlvbnMgZm9yIHRoZSBjaGFydFxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKi9cbiAgc3RvcChjaGFydCkge1xuICAgIGNvbnN0IGFuaW1zID0gdGhpcy5fY2hhcnRzLmdldChjaGFydCk7XG4gICAgaWYgKCFhbmltcyB8fCAhYW5pbXMuaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGl0ZW1zID0gYW5pbXMuaXRlbXM7XG4gICAgbGV0IGkgPSBpdGVtcy5sZW5ndGggLSAxO1xuXG4gICAgZm9yICg7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBpdGVtc1tpXS5jYW5jZWwoKTtcbiAgICB9XG4gICAgYW5pbXMuaXRlbXMgPSBbXTtcbiAgICB0aGlzLl9ub3RpZnkoY2hhcnQsIGFuaW1zLCBEYXRlLm5vdygpLCAnY29tcGxldGUnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZW1vdmUgY2hhcnQgZnJvbSBBbmltYXRvclxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKi9cbiAgcmVtb3ZlKGNoYXJ0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYXJ0cy5kZWxldGUoY2hhcnQpO1xuICB9XG59XG5cbi8vIHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGRlZmF1bHQgLyogI19fUFVSRV9fICovIG5ldyBBbmltYXRvcigpO1xuIiwgImltcG9ydCBlZmZlY3RzIGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5lYXNpbmcuanMnO1xuaW1wb3J0IHtyZXNvbHZlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5pbXBvcnQge2NvbG9yIGFzIGhlbHBlcnNDb2xvcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbG9yLmpzJztcblxuY29uc3QgdHJhbnNwYXJlbnQgPSAndHJhbnNwYXJlbnQnO1xuY29uc3QgaW50ZXJwb2xhdG9ycyA9IHtcbiAgYm9vbGVhbihmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgcmV0dXJuIGZhY3RvciA+IDAuNSA/IHRvIDogZnJvbTtcbiAgfSxcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b1xuICAgKiBAcGFyYW0ge251bWJlcn0gZmFjdG9yXG4gICAqL1xuICBjb2xvcihmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgY29uc3QgYzAgPSBoZWxwZXJzQ29sb3IoZnJvbSB8fCB0cmFuc3BhcmVudCk7XG4gICAgY29uc3QgYzEgPSBjMC52YWxpZCAmJiBoZWxwZXJzQ29sb3IodG8gfHwgdHJhbnNwYXJlbnQpO1xuICAgIHJldHVybiBjMSAmJiBjMS52YWxpZFxuICAgICAgPyBjMS5taXgoYzAsIGZhY3RvcikuaGV4U3RyaW5nKClcbiAgICAgIDogdG87XG4gIH0sXG4gIG51bWJlcihmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgcmV0dXJuIGZyb20gKyAodG8gLSBmcm9tKSAqIGZhY3RvcjtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbWF0aW9uIHtcbiAgY29uc3RydWN0b3IoY2ZnLCB0YXJnZXQsIHByb3AsIHRvKSB7XG4gICAgY29uc3QgY3VycmVudFZhbHVlID0gdGFyZ2V0W3Byb3BdO1xuXG4gICAgdG8gPSByZXNvbHZlKFtjZmcudG8sIHRvLCBjdXJyZW50VmFsdWUsIGNmZy5mcm9tXSk7XG4gICAgY29uc3QgZnJvbSA9IHJlc29sdmUoW2NmZy5mcm9tLCBjdXJyZW50VmFsdWUsIHRvXSk7XG5cbiAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuX2ZuID0gY2ZnLmZuIHx8IGludGVycG9sYXRvcnNbY2ZnLnR5cGUgfHwgdHlwZW9mIGZyb21dO1xuICAgIHRoaXMuX2Vhc2luZyA9IGVmZmVjdHNbY2ZnLmVhc2luZ10gfHwgZWZmZWN0cy5saW5lYXI7XG4gICAgdGhpcy5fc3RhcnQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgKyAoY2ZnLmRlbGF5IHx8IDApKTtcbiAgICB0aGlzLl9kdXJhdGlvbiA9IHRoaXMuX3RvdGFsID0gTWF0aC5mbG9vcihjZmcuZHVyYXRpb24pO1xuICAgIHRoaXMuX2xvb3AgPSAhIWNmZy5sb29wO1xuICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLl9wcm9wID0gcHJvcDtcbiAgICB0aGlzLl9mcm9tID0gZnJvbTtcbiAgICB0aGlzLl90byA9IHRvO1xuICAgIHRoaXMuX3Byb21pc2VzID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gIH1cblxuICB1cGRhdGUoY2ZnLCB0bywgZGF0ZSkge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMuX25vdGlmeShmYWxzZSk7XG5cbiAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRoaXMuX3RhcmdldFt0aGlzLl9wcm9wXTtcbiAgICAgIGNvbnN0IGVsYXBzZWQgPSBkYXRlIC0gdGhpcy5fc3RhcnQ7XG4gICAgICBjb25zdCByZW1haW4gPSB0aGlzLl9kdXJhdGlvbiAtIGVsYXBzZWQ7XG4gICAgICB0aGlzLl9zdGFydCA9IGRhdGU7XG4gICAgICB0aGlzLl9kdXJhdGlvbiA9IE1hdGguZmxvb3IoTWF0aC5tYXgocmVtYWluLCBjZmcuZHVyYXRpb24pKTtcbiAgICAgIHRoaXMuX3RvdGFsICs9IGVsYXBzZWQ7XG4gICAgICB0aGlzLl9sb29wID0gISFjZmcubG9vcDtcbiAgICAgIHRoaXMuX3RvID0gcmVzb2x2ZShbY2ZnLnRvLCB0bywgY3VycmVudFZhbHVlLCBjZmcuZnJvbV0pO1xuICAgICAgdGhpcy5fZnJvbSA9IHJlc29sdmUoW2NmZy5mcm9tLCBjdXJyZW50VmFsdWUsIHRvXSk7XG4gICAgfVxuICB9XG5cbiAgY2FuY2VsKCkge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIC8vIHVwZGF0ZSBjdXJyZW50IGV2YWx1YXRlZCB2YWx1ZSwgZm9yIHNtb290aGVyIGFuaW1hdGlvbnNcbiAgICAgIHRoaXMudGljayhEYXRlLm5vdygpKTtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5fbm90aWZ5KGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICB0aWNrKGRhdGUpIHtcbiAgICBjb25zdCBlbGFwc2VkID0gZGF0ZSAtIHRoaXMuX3N0YXJ0O1xuICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb247XG4gICAgY29uc3QgcHJvcCA9IHRoaXMuX3Byb3A7XG4gICAgY29uc3QgZnJvbSA9IHRoaXMuX2Zyb207XG4gICAgY29uc3QgbG9vcCA9IHRoaXMuX2xvb3A7XG4gICAgY29uc3QgdG8gPSB0aGlzLl90bztcbiAgICBsZXQgZmFjdG9yO1xuXG4gICAgdGhpcy5fYWN0aXZlID0gZnJvbSAhPT0gdG8gJiYgKGxvb3AgfHwgKGVsYXBzZWQgPCBkdXJhdGlvbikpO1xuXG4gICAgaWYgKCF0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMuX3RhcmdldFtwcm9wXSA9IHRvO1xuICAgICAgdGhpcy5fbm90aWZ5KHRydWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlbGFwc2VkIDwgMCkge1xuICAgICAgdGhpcy5fdGFyZ2V0W3Byb3BdID0gZnJvbTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmYWN0b3IgPSAoZWxhcHNlZCAvIGR1cmF0aW9uKSAlIDI7XG4gICAgZmFjdG9yID0gbG9vcCAmJiBmYWN0b3IgPiAxID8gMiAtIGZhY3RvciA6IGZhY3RvcjtcbiAgICBmYWN0b3IgPSB0aGlzLl9lYXNpbmcoTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgZmFjdG9yKSkpO1xuXG4gICAgdGhpcy5fdGFyZ2V0W3Byb3BdID0gdGhpcy5fZm4oZnJvbSwgdG8sIGZhY3Rvcik7XG4gIH1cblxuICB3YWl0KCkge1xuICAgIGNvbnN0IHByb21pc2VzID0gdGhpcy5fcHJvbWlzZXMgfHwgKHRoaXMuX3Byb21pc2VzID0gW10pO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgIHByb21pc2VzLnB1c2goe3JlcywgcmVqfSk7XG4gICAgfSk7XG4gIH1cblxuICBfbm90aWZ5KHJlc29sdmVkKSB7XG4gICAgY29uc3QgbWV0aG9kID0gcmVzb2x2ZWQgPyAncmVzJyA6ICdyZWonO1xuICAgIGNvbnN0IHByb21pc2VzID0gdGhpcy5fcHJvbWlzZXMgfHwgW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9taXNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgcHJvbWlzZXNbaV1bbWV0aG9kXSgpO1xuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCBhbmltYXRvciBmcm9tICcuL2NvcmUuYW5pbWF0b3IuanMnO1xuaW1wb3J0IEFuaW1hdGlvbiBmcm9tICcuL2NvcmUuYW5pbWF0aW9uLmpzJztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICcuL2NvcmUuZGVmYXVsdHMuanMnO1xuaW1wb3J0IHtpc0FycmF5LCBpc09iamVjdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmltYXRpb25zIHtcbiAgY29uc3RydWN0b3IoY2hhcnQsIGNvbmZpZykge1xuICAgIHRoaXMuX2NoYXJ0ID0gY2hhcnQ7XG4gICAgdGhpcy5fcHJvcGVydGllcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmNvbmZpZ3VyZShjb25maWcpO1xuICB9XG5cbiAgY29uZmlndXJlKGNvbmZpZykge1xuICAgIGlmICghaXNPYmplY3QoY29uZmlnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBPYmplY3Qua2V5cyhkZWZhdWx0cy5hbmltYXRpb24pO1xuICAgIGNvbnN0IGFuaW1hdGVkUHJvcHMgPSB0aGlzLl9wcm9wZXJ0aWVzO1xuXG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY29uZmlnKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBjZmcgPSBjb25maWdba2V5XTtcbiAgICAgIGlmICghaXNPYmplY3QoY2ZnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByZXNvbHZlZCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgYW5pbWF0aW9uT3B0aW9ucykge1xuICAgICAgICByZXNvbHZlZFtvcHRpb25dID0gY2ZnW29wdGlvbl07XG4gICAgICB9XG5cbiAgICAgIChpc0FycmF5KGNmZy5wcm9wZXJ0aWVzKSAmJiBjZmcucHJvcGVydGllcyB8fCBba2V5XSkuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICBpZiAocHJvcCA9PT0ga2V5IHx8ICFhbmltYXRlZFByb3BzLmhhcyhwcm9wKSkge1xuICAgICAgICAgIGFuaW1hdGVkUHJvcHMuc2V0KHByb3AsIHJlc29sdmVkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcblx0ICogVXRpbGl0eSB0byBoYW5kbGUgYW5pbWF0aW9uIG9mIGBvcHRpb25zYC5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9hbmltYXRlT3B0aW9ucyh0YXJnZXQsIHZhbHVlcykge1xuICAgIGNvbnN0IG5ld09wdGlvbnMgPSB2YWx1ZXMub3B0aW9ucztcbiAgICBjb25zdCBvcHRpb25zID0gcmVzb2x2ZVRhcmdldE9wdGlvbnModGFyZ2V0LCBuZXdPcHRpb25zKTtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBhbmltYXRpb25zID0gdGhpcy5fY3JlYXRlQW5pbWF0aW9ucyhvcHRpb25zLCBuZXdPcHRpb25zKTtcbiAgICBpZiAobmV3T3B0aW9ucy4kc2hhcmVkKSB7XG4gICAgICAvLyBHb2luZyB0byBzaGFyZWQgb3B0aW9uczpcbiAgICAgIC8vIEFmdGVyIGFsbCBhbmltYXRpb25zIGFyZSBkb25lLCBhc3NpZ24gdGhlIHNoYXJlZCBvcHRpb25zIG9iamVjdCB0byB0aGUgZWxlbWVudFxuICAgICAgLy8gU28gYW55IG5ldyB1cGRhdGVzIHRvIHRoZSBzaGFyZWQgb3B0aW9ucyBhcmUgb2JzZXJ2ZWRcbiAgICAgIGF3YWl0QWxsKHRhcmdldC5vcHRpb25zLiRhbmltYXRpb25zLCBuZXdPcHRpb25zKS50aGVuKCgpID0+IHtcbiAgICAgICAgdGFyZ2V0Lm9wdGlvbnMgPSBuZXdPcHRpb25zO1xuICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAvLyByZWplY3RlZCwgbm9vcFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jcmVhdGVBbmltYXRpb25zKHRhcmdldCwgdmFsdWVzKSB7XG4gICAgY29uc3QgYW5pbWF0ZWRQcm9wcyA9IHRoaXMuX3Byb3BlcnRpZXM7XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IFtdO1xuICAgIGNvbnN0IHJ1bm5pbmcgPSB0YXJnZXQuJGFuaW1hdGlvbnMgfHwgKHRhcmdldC4kYW5pbWF0aW9ucyA9IHt9KTtcbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5rZXlzKHZhbHVlcyk7XG4gICAgY29uc3QgZGF0ZSA9IERhdGUubm93KCk7XG4gICAgbGV0IGk7XG5cbiAgICBmb3IgKGkgPSBwcm9wcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3QgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHByb3AuY2hhckF0KDApID09PSAnJCcpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wID09PSAnb3B0aW9ucycpIHtcbiAgICAgICAgYW5pbWF0aW9ucy5wdXNoKC4uLnRoaXMuX2FuaW1hdGVPcHRpb25zKHRhcmdldCwgdmFsdWVzKSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbcHJvcF07XG4gICAgICBsZXQgYW5pbWF0aW9uID0gcnVubmluZ1twcm9wXTtcbiAgICAgIGNvbnN0IGNmZyA9IGFuaW1hdGVkUHJvcHMuZ2V0KHByb3ApO1xuXG4gICAgICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICAgIGlmIChjZmcgJiYgYW5pbWF0aW9uLmFjdGl2ZSgpKSB7XG4gICAgICAgICAgLy8gVGhlcmUgaXMgYW4gZXhpc3RpbmcgYWN0aXZlIGFuaW1hdGlvbiwgbGV0J3MgdXBkYXRlIHRoYXRcbiAgICAgICAgICBhbmltYXRpb24udXBkYXRlKGNmZywgdmFsdWUsIGRhdGUpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFuaW1hdGlvbi5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFjZmcgfHwgIWNmZy5kdXJhdGlvbikge1xuICAgICAgICAvLyBub3QgYW5pbWF0ZWQsIHNldCBkaXJlY3RseSB0byBuZXcgdmFsdWVcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBydW5uaW5nW3Byb3BdID0gYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbihjZmcsIHRhcmdldCwgcHJvcCwgdmFsdWUpO1xuICAgICAgYW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBhbmltYXRpb25zO1xuICB9XG5cblxuICAvKipcblx0ICogVXBkYXRlIGB0YXJnZXRgIHByb3BlcnRpZXMgdG8gbmV3IHZhbHVlcywgdXNpbmcgY29uZmlndXJlZCBhbmltYXRpb25zXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgLSBvYmplY3QgdG8gdXBkYXRlXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgLSBuZXcgdGFyZ2V0IHByb3BlcnRpZXNcblx0ICogQHJldHVybnMge2Jvb2xlYW58dW5kZWZpbmVkfSAtIGB0cnVlYCBpZiBhbmltYXRpb25zIHdlcmUgc3RhcnRlZFxuXHQgKiovXG4gIHVwZGF0ZSh0YXJnZXQsIHZhbHVlcykge1xuICAgIGlmICh0aGlzLl9wcm9wZXJ0aWVzLnNpemUgPT09IDApIHtcbiAgICAgIC8vIE5vdGhpbmcgaXMgYW5pbWF0ZWQsIGp1c3QgYXBwbHkgdGhlIG5ldyB2YWx1ZXMuXG4gICAgICBPYmplY3QuYXNzaWduKHRhcmdldCwgdmFsdWVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhbmltYXRpb25zID0gdGhpcy5fY3JlYXRlQW5pbWF0aW9ucyh0YXJnZXQsIHZhbHVlcyk7XG5cbiAgICBpZiAoYW5pbWF0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGFuaW1hdG9yLmFkZCh0aGlzLl9jaGFydCwgYW5pbWF0aW9ucyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXdhaXRBbGwoYW5pbWF0aW9ucywgcHJvcGVydGllcykge1xuICBjb25zdCBydW5uaW5nID0gW107XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYW5pbSA9IGFuaW1hdGlvbnNba2V5c1tpXV07XG4gICAgaWYgKGFuaW0gJiYgYW5pbS5hY3RpdmUoKSkge1xuICAgICAgcnVubmluZy5wdXNoKGFuaW0ud2FpdCgpKTtcbiAgICB9XG4gIH1cbiAgLy8gQHRzLWlnbm9yZVxuICByZXR1cm4gUHJvbWlzZS5hbGwocnVubmluZyk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVUYXJnZXRPcHRpb25zKHRhcmdldCwgbmV3T3B0aW9ucykge1xuICBpZiAoIW5ld09wdGlvbnMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IG9wdGlvbnMgPSB0YXJnZXQub3B0aW9ucztcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgdGFyZ2V0Lm9wdGlvbnMgPSBuZXdPcHRpb25zO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAob3B0aW9ucy4kc2hhcmVkKSB7XG4gICAgLy8gR29pbmcgZnJvbSBzaGFyZWQgb3B0aW9ucyB0byBkaXN0aW5jdCBvbmU6XG4gICAgLy8gQ3JlYXRlIG5ldyBvcHRpb25zIG9iamVjdCBjb250YWluaW5nIHRoZSBvbGQgc2hhcmVkIHZhbHVlcyBhbmQgc3RhcnQgdXBkYXRpbmcgdGhhdC5cbiAgICB0YXJnZXQub3B0aW9ucyA9IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7JHNoYXJlZDogZmFsc2UsICRhbmltYXRpb25zOiB7fX0pO1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuIiwgImltcG9ydCBBbmltYXRpb25zIGZyb20gJy4vY29yZS5hbmltYXRpb25zLmpzJztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICcuL2NvcmUuZGVmYXVsdHMuanMnO1xuaW1wb3J0IHtpc0FycmF5LCBpc0Zpbml0ZSwgaXNPYmplY3QsIHZhbHVlT3JEZWZhdWx0LCByZXNvbHZlT2JqZWN0S2V5LCBkZWZpbmVkfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge2xpc3RlbkFycmF5RXZlbnRzLCB1bmxpc3RlbkFycmF5RXZlbnRzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29sbGVjdGlvbi5qcyc7XG5pbXBvcnQge2NyZWF0ZUNvbnRleHQsIHNpZ259IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vY29yZS5zY2FsZS5qcycpLmRlZmF1bHQgfSBTY2FsZVxuICovXG5cbmZ1bmN0aW9uIHNjYWxlQ2xpcChzY2FsZSwgYWxsb3dlZE92ZXJmbG93KSB7XG4gIGNvbnN0IG9wdHMgPSBzY2FsZSAmJiBzY2FsZS5vcHRpb25zIHx8IHt9O1xuICBjb25zdCByZXZlcnNlID0gb3B0cy5yZXZlcnNlO1xuICBjb25zdCBtaW4gPSBvcHRzLm1pbiA9PT0gdW5kZWZpbmVkID8gYWxsb3dlZE92ZXJmbG93IDogMDtcbiAgY29uc3QgbWF4ID0gb3B0cy5tYXggPT09IHVuZGVmaW5lZCA/IGFsbG93ZWRPdmVyZmxvdyA6IDA7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHJldmVyc2UgPyBtYXggOiBtaW4sXG4gICAgZW5kOiByZXZlcnNlID8gbWluIDogbWF4XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDbGlwKHhTY2FsZSwgeVNjYWxlLCBhbGxvd2VkT3ZlcmZsb3cpIHtcbiAgaWYgKGFsbG93ZWRPdmVyZmxvdyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgeCA9IHNjYWxlQ2xpcCh4U2NhbGUsIGFsbG93ZWRPdmVyZmxvdyk7XG4gIGNvbnN0IHkgPSBzY2FsZUNsaXAoeVNjYWxlLCBhbGxvd2VkT3ZlcmZsb3cpO1xuXG4gIHJldHVybiB7XG4gICAgdG9wOiB5LmVuZCxcbiAgICByaWdodDogeC5lbmQsXG4gICAgYm90dG9tOiB5LnN0YXJ0LFxuICAgIGxlZnQ6IHguc3RhcnRcbiAgfTtcbn1cblxuZnVuY3Rpb24gdG9DbGlwKHZhbHVlKSB7XG4gIGxldCB0LCByLCBiLCBsO1xuXG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB0ID0gdmFsdWUudG9wO1xuICAgIHIgPSB2YWx1ZS5yaWdodDtcbiAgICBiID0gdmFsdWUuYm90dG9tO1xuICAgIGwgPSB2YWx1ZS5sZWZ0O1xuICB9IGVsc2Uge1xuICAgIHQgPSByID0gYiA9IGwgPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9wOiB0LFxuICAgIHJpZ2h0OiByLFxuICAgIGJvdHRvbTogYixcbiAgICBsZWZ0OiBsLFxuICAgIGRpc2FibGVkOiB2YWx1ZSA9PT0gZmFsc2VcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0U29ydGVkRGF0YXNldEluZGljZXMoY2hhcnQsIGZpbHRlclZpc2libGUpIHtcbiAgY29uc3Qga2V5cyA9IFtdO1xuICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0Ll9nZXRTb3J0ZWREYXRhc2V0TWV0YXMoZmlsdGVyVmlzaWJsZSk7XG4gIGxldCBpLCBpbGVuO1xuXG4gIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBrZXlzLnB1c2gobWV0YXNldHNbaV0uaW5kZXgpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBhcHBseVN0YWNrKHN0YWNrLCB2YWx1ZSwgZHNJbmRleCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGtleXMgPSBzdGFjay5rZXlzO1xuICBjb25zdCBzaW5nbGVNb2RlID0gb3B0aW9ucy5tb2RlID09PSAnc2luZ2xlJztcbiAgbGV0IGksIGlsZW4sIGRhdGFzZXRJbmRleCwgb3RoZXJWYWx1ZTtcblxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBkYXRhc2V0SW5kZXggPSAra2V5c1tpXTtcbiAgICBpZiAoZGF0YXNldEluZGV4ID09PSBkc0luZGV4KSB7XG4gICAgICBpZiAob3B0aW9ucy5hbGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb3RoZXJWYWx1ZSA9IHN0YWNrLnZhbHVlc1tkYXRhc2V0SW5kZXhdO1xuICAgIGlmIChpc0Zpbml0ZShvdGhlclZhbHVlKSAmJiAoc2luZ2xlTW9kZSB8fCAodmFsdWUgPT09IDAgfHwgc2lnbih2YWx1ZSkgPT09IHNpZ24ob3RoZXJWYWx1ZSkpKSkge1xuICAgICAgdmFsdWUgKz0gb3RoZXJWYWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0T2JqZWN0RGF0YVRvQXJyYXkoZGF0YSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIGNvbnN0IGFkYXRhID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgbGV0IGksIGlsZW4sIGtleTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICBhZGF0YVtpXSA9IHtcbiAgICAgIHg6IGtleSxcbiAgICAgIHk6IGRhdGFba2V5XVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGFkYXRhO1xufVxuXG5mdW5jdGlvbiBpc1N0YWNrZWQoc2NhbGUsIG1ldGEpIHtcbiAgY29uc3Qgc3RhY2tlZCA9IHNjYWxlICYmIHNjYWxlLm9wdGlvbnMuc3RhY2tlZDtcbiAgcmV0dXJuIHN0YWNrZWQgfHwgKHN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBtZXRhLnN0YWNrICE9PSB1bmRlZmluZWQpO1xufVxuXG5mdW5jdGlvbiBnZXRTdGFja0tleShpbmRleFNjYWxlLCB2YWx1ZVNjYWxlLCBtZXRhKSB7XG4gIHJldHVybiBgJHtpbmRleFNjYWxlLmlkfS4ke3ZhbHVlU2NhbGUuaWR9LiR7bWV0YS5zdGFjayB8fCBtZXRhLnR5cGV9YDtcbn1cblxuZnVuY3Rpb24gZ2V0VXNlckJvdW5kcyhzY2FsZSkge1xuICBjb25zdCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gc2NhbGUuZ2V0VXNlckJvdW5kcygpO1xuICByZXR1cm4ge1xuICAgIG1pbjogbWluRGVmaW5lZCA/IG1pbiA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcbiAgICBtYXg6IG1heERlZmluZWQgPyBtYXggOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0T3JDcmVhdGVTdGFjayhzdGFja3MsIHN0YWNrS2V5LCBpbmRleFZhbHVlKSB7XG4gIGNvbnN0IHN1YlN0YWNrID0gc3RhY2tzW3N0YWNrS2V5XSB8fCAoc3RhY2tzW3N0YWNrS2V5XSA9IHt9KTtcbiAgcmV0dXJuIHN1YlN0YWNrW2luZGV4VmFsdWVdIHx8IChzdWJTdGFja1tpbmRleFZhbHVlXSA9IHt9KTtcbn1cblxuZnVuY3Rpb24gZ2V0TGFzdEluZGV4SW5TdGFjayhzdGFjaywgdlNjYWxlLCBwb3NpdGl2ZSwgdHlwZSkge1xuICBmb3IgKGNvbnN0IG1ldGEgb2YgdlNjYWxlLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHR5cGUpLnJldmVyc2UoKSkge1xuICAgIGNvbnN0IHZhbHVlID0gc3RhY2tbbWV0YS5pbmRleF07XG4gICAgaWYgKChwb3NpdGl2ZSAmJiB2YWx1ZSA+IDApIHx8ICghcG9zaXRpdmUgJiYgdmFsdWUgPCAwKSkge1xuICAgICAgcmV0dXJuIG1ldGEuaW5kZXg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0YWNrcyhjb250cm9sbGVyLCBwYXJzZWQpIHtcbiAgY29uc3Qge2NoYXJ0LCBfY2FjaGVkTWV0YTogbWV0YX0gPSBjb250cm9sbGVyO1xuICBjb25zdCBzdGFja3MgPSBjaGFydC5fc3RhY2tzIHx8IChjaGFydC5fc3RhY2tzID0ge30pOyAvLyBtYXAgc3RydWN0dXJlIGlzIHtzdGFja0tleToge2RhdGFzZXRJbmRleDogdmFsdWV9fVxuICBjb25zdCB7aVNjYWxlLCB2U2NhbGUsIGluZGV4OiBkYXRhc2V0SW5kZXh9ID0gbWV0YTtcbiAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgY29uc3Qga2V5ID0gZ2V0U3RhY2tLZXkoaVNjYWxlLCB2U2NhbGUsIG1ldGEpO1xuICBjb25zdCBpbGVuID0gcGFyc2VkLmxlbmd0aDtcbiAgbGV0IHN0YWNrO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY29uc3QgaXRlbSA9IHBhcnNlZFtpXTtcbiAgICBjb25zdCB7W2lBeGlzXTogaW5kZXgsIFt2QXhpc106IHZhbHVlfSA9IGl0ZW07XG4gICAgY29uc3QgaXRlbVN0YWNrcyA9IGl0ZW0uX3N0YWNrcyB8fCAoaXRlbS5fc3RhY2tzID0ge30pO1xuICAgIHN0YWNrID0gaXRlbVN0YWNrc1t2QXhpc10gPSBnZXRPckNyZWF0ZVN0YWNrKHN0YWNrcywga2V5LCBpbmRleCk7XG4gICAgc3RhY2tbZGF0YXNldEluZGV4XSA9IHZhbHVlO1xuXG4gICAgc3RhY2suX3RvcCA9IGdldExhc3RJbmRleEluU3RhY2soc3RhY2ssIHZTY2FsZSwgdHJ1ZSwgbWV0YS50eXBlKTtcbiAgICBzdGFjay5fYm90dG9tID0gZ2V0TGFzdEluZGV4SW5TdGFjayhzdGFjaywgdlNjYWxlLCBmYWxzZSwgbWV0YS50eXBlKTtcblxuICAgIGNvbnN0IHZpc3VhbFZhbHVlcyA9IHN0YWNrLl92aXN1YWxWYWx1ZXMgfHwgKHN0YWNrLl92aXN1YWxWYWx1ZXMgPSB7fSk7XG4gICAgdmlzdWFsVmFsdWVzW2RhdGFzZXRJbmRleF0gPSB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsIGF4aXMpIHtcbiAgY29uc3Qgc2NhbGVzID0gY2hhcnQuc2NhbGVzO1xuICByZXR1cm4gT2JqZWN0LmtleXMoc2NhbGVzKS5maWx0ZXIoa2V5ID0+IHNjYWxlc1trZXldLmF4aXMgPT09IGF4aXMpLnNoaWZ0KCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURhdGFzZXRDb250ZXh0KHBhcmVudCwgaW5kZXgpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LFxuICAgIHtcbiAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICBkYXRhc2V0OiB1bmRlZmluZWQsXG4gICAgICBkYXRhc2V0SW5kZXg6IGluZGV4LFxuICAgICAgaW5kZXgsXG4gICAgICBtb2RlOiAnZGVmYXVsdCcsXG4gICAgICB0eXBlOiAnZGF0YXNldCdcbiAgICB9XG4gICk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURhdGFDb250ZXh0KHBhcmVudCwgaW5kZXgsIGVsZW1lbnQpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgYWN0aXZlOiBmYWxzZSxcbiAgICBkYXRhSW5kZXg6IGluZGV4LFxuICAgIHBhcnNlZDogdW5kZWZpbmVkLFxuICAgIHJhdzogdW5kZWZpbmVkLFxuICAgIGVsZW1lbnQsXG4gICAgaW5kZXgsXG4gICAgbW9kZTogJ2RlZmF1bHQnLFxuICAgIHR5cGU6ICdkYXRhJ1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY2xlYXJTdGFja3MobWV0YSwgaXRlbXMpIHtcbiAgLy8gTm90IHVzaW5nIG1ldGEuaW5kZXggaGVyZSwgYmVjYXVzZSBpdCBtaWdodCBiZSBhbHJlYWR5IHVwZGF0ZWQgaWYgdGhlIGRhdGFzZXQgY2hhbmdlZCBsb2NhdGlvblxuICBjb25zdCBkYXRhc2V0SW5kZXggPSBtZXRhLmNvbnRyb2xsZXIuaW5kZXg7XG4gIGNvbnN0IGF4aXMgPSBtZXRhLnZTY2FsZSAmJiBtZXRhLnZTY2FsZS5heGlzO1xuICBpZiAoIWF4aXMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpdGVtcyA9IGl0ZW1zIHx8IG1ldGEuX3BhcnNlZDtcbiAgZm9yIChjb25zdCBwYXJzZWQgb2YgaXRlbXMpIHtcbiAgICBjb25zdCBzdGFja3MgPSBwYXJzZWQuX3N0YWNrcztcbiAgICBpZiAoIXN0YWNrcyB8fCBzdGFja3NbYXhpc10gPT09IHVuZGVmaW5lZCB8fCBzdGFja3NbYXhpc11bZGF0YXNldEluZGV4XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlbGV0ZSBzdGFja3NbYXhpc11bZGF0YXNldEluZGV4XTtcbiAgICBpZiAoc3RhY2tzW2F4aXNdLl92aXN1YWxWYWx1ZXMgIT09IHVuZGVmaW5lZCAmJiBzdGFja3NbYXhpc10uX3Zpc3VhbFZhbHVlc1tkYXRhc2V0SW5kZXhdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlbGV0ZSBzdGFja3NbYXhpc10uX3Zpc3VhbFZhbHVlc1tkYXRhc2V0SW5kZXhdO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBpc0RpcmVjdFVwZGF0ZU1vZGUgPSAobW9kZSkgPT4gbW9kZSA9PT0gJ3Jlc2V0JyB8fCBtb2RlID09PSAnbm9uZSc7XG5jb25zdCBjbG9uZUlmTm90U2hhcmVkID0gKGNhY2hlZCwgc2hhcmVkKSA9PiBzaGFyZWQgPyBjYWNoZWQgOiBPYmplY3QuYXNzaWduKHt9LCBjYWNoZWQpO1xuY29uc3QgY3JlYXRlU3RhY2sgPSAoY2FuU3RhY2ssIG1ldGEsIGNoYXJ0KSA9PiBjYW5TdGFjayAmJiAhbWV0YS5oaWRkZW4gJiYgbWV0YS5fc3RhY2tlZFxuICAmJiB7a2V5czogZ2V0U29ydGVkRGF0YXNldEluZGljZXMoY2hhcnQsIHRydWUpLCB2YWx1ZXM6IG51bGx9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7fTtcblxuICAvKipcbiAgICogRWxlbWVudCB0eXBlIHVzZWQgdG8gZ2VuZXJhdGUgYSBtZXRhIGRhdGFzZXQgKGUuZy4gQ2hhcnQuZWxlbWVudC5MaW5lRWxlbWVudCkuXG4gICAqL1xuICBzdGF0aWMgZGF0YXNldEVsZW1lbnRUeXBlID0gbnVsbDtcblxuICAvKipcbiAgICogRWxlbWVudCB0eXBlIHVzZWQgdG8gZ2VuZXJhdGUgYSBtZXRhIGRhdGEgKGUuZy4gQ2hhcnQuZWxlbWVudC5Qb2ludEVsZW1lbnQpLlxuICAgKi9cbiAgc3RhdGljIGRhdGFFbGVtZW50VHlwZSA9IG51bGw7XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhc2V0SW5kZXhcblx0ICovXG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcbiAgICB0aGlzLmNoYXJ0ID0gY2hhcnQ7XG4gICAgdGhpcy5fY3R4ID0gY2hhcnQuY3R4O1xuICAgIHRoaXMuaW5kZXggPSBkYXRhc2V0SW5kZXg7XG4gICAgdGhpcy5fY2FjaGVkRGF0YU9wdHMgPSB7fTtcbiAgICB0aGlzLl9jYWNoZWRNZXRhID0gdGhpcy5nZXRNZXRhKCk7XG4gICAgdGhpcy5fdHlwZSA9IHRoaXMuX2NhY2hlZE1ldGEudHlwZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtib29sZWFuIHwgb2JqZWN0fSAqL1xuICAgIHRoaXMuX3BhcnNpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9kYXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX29iamVjdERhdGEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc2hhcmVkT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kcmF3U3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZHJhd0NvdW50ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IGZhbHNlO1xuICAgIHRoaXMuc3VwcG9ydHNEZWNpbWF0aW9uID0gZmFsc2U7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zeW5jTGlzdCA9IFtdO1xuICAgIHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlID0gbmV3LnRhcmdldC5kYXRhc2V0RWxlbWVudFR5cGU7XG4gICAgdGhpcy5kYXRhRWxlbWVudFR5cGUgPSBuZXcudGFyZ2V0LmRhdGFFbGVtZW50VHlwZTtcblxuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICB9XG5cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLmNvbmZpZ3VyZSgpO1xuICAgIHRoaXMubGlua1NjYWxlcygpO1xuICAgIG1ldGEuX3N0YWNrZWQgPSBpc1N0YWNrZWQobWV0YS52U2NhbGUsIG1ldGEpO1xuICAgIHRoaXMuYWRkRWxlbWVudHMoKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZmlsbCAmJiAhdGhpcy5jaGFydC5pc1BsdWdpbkVuYWJsZWQoJ2ZpbGxlcicpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJUcmllZCB0byB1c2UgdGhlICdmaWxsJyBvcHRpb24gd2l0aG91dCB0aGUgJ0ZpbGxlcicgcGx1Z2luIGVuYWJsZWQuIFBsZWFzZSBpbXBvcnQgYW5kIHJlZ2lzdGVyIHRoZSAnRmlsbGVyJyBwbHVnaW4gYW5kIG1ha2Ugc3VyZSBpdCBpcyBub3QgZGlzYWJsZWQgaW4gdGhlIG9wdGlvbnNcIik7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlSW5kZXgoZGF0YXNldEluZGV4KSB7XG4gICAgaWYgKHRoaXMuaW5kZXggIT09IGRhdGFzZXRJbmRleCkge1xuICAgICAgY2xlYXJTdGFja3ModGhpcy5fY2FjaGVkTWV0YSk7XG4gICAgfVxuICAgIHRoaXMuaW5kZXggPSBkYXRhc2V0SW5kZXg7XG4gIH1cblxuICBsaW5rU2NhbGVzKCkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG5cbiAgICBjb25zdCBjaG9vc2VJZCA9IChheGlzLCB4LCB5LCByKSA9PiBheGlzID09PSAneCcgPyB4IDogYXhpcyA9PT0gJ3InID8gciA6IHk7XG5cbiAgICBjb25zdCB4aWQgPSBtZXRhLnhBeGlzSUQgPSB2YWx1ZU9yRGVmYXVsdChkYXRhc2V0LnhBeGlzSUQsIGdldEZpcnN0U2NhbGVJZChjaGFydCwgJ3gnKSk7XG4gICAgY29uc3QgeWlkID0gbWV0YS55QXhpc0lEID0gdmFsdWVPckRlZmF1bHQoZGF0YXNldC55QXhpc0lELCBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsICd5JykpO1xuICAgIGNvbnN0IHJpZCA9IG1ldGEuckF4aXNJRCA9IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQuckF4aXNJRCwgZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCAncicpKTtcbiAgICBjb25zdCBpbmRleEF4aXMgPSBtZXRhLmluZGV4QXhpcztcbiAgICBjb25zdCBpaWQgPSBtZXRhLmlBeGlzSUQgPSBjaG9vc2VJZChpbmRleEF4aXMsIHhpZCwgeWlkLCByaWQpO1xuICAgIGNvbnN0IHZpZCA9IG1ldGEudkF4aXNJRCA9IGNob29zZUlkKGluZGV4QXhpcywgeWlkLCB4aWQsIHJpZCk7XG4gICAgbWV0YS54U2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQoeGlkKTtcbiAgICBtZXRhLnlTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZCh5aWQpO1xuICAgIG1ldGEuclNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKHJpZCk7XG4gICAgbWV0YS5pU2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQoaWlkKTtcbiAgICBtZXRhLnZTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZCh2aWQpO1xuICB9XG5cbiAgZ2V0RGF0YXNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW3RoaXMuaW5kZXhdO1xuICB9XG5cbiAgZ2V0TWV0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YSh0aGlzLmluZGV4KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc2NhbGVJRFxuXHQgKiBAcmV0dXJuIHtTY2FsZX1cblx0ICovXG4gIGdldFNjYWxlRm9ySWQoc2NhbGVJRCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LnNjYWxlc1tzY2FsZUlEXTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldE90aGVyU2NhbGUoc2NhbGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICByZXR1cm4gc2NhbGUgPT09IG1ldGEuaVNjYWxlXG4gICAgICA/IG1ldGEudlNjYWxlXG4gICAgICA6IG1ldGEuaVNjYWxlO1xuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5fdXBkYXRlKCdyZXNldCcpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZGVzdHJveSgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBpZiAodGhpcy5fZGF0YSkge1xuICAgICAgdW5saXN0ZW5BcnJheUV2ZW50cyh0aGlzLl9kYXRhLCB0aGlzKTtcbiAgICB9XG4gICAgaWYgKG1ldGEuX3N0YWNrZWQpIHtcbiAgICAgIGNsZWFyU3RhY2tzKG1ldGEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2RhdGFDaGVjaygpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgY29uc3QgZGF0YSA9IGRhdGFzZXQuZGF0YSB8fCAoZGF0YXNldC5kYXRhID0gW10pO1xuICAgIGNvbnN0IF9kYXRhID0gdGhpcy5fZGF0YTtcblxuICAgIC8vIEluIG9yZGVyIHRvIGNvcnJlY3RseSBoYW5kbGUgZGF0YSBhZGRpdGlvbi9kZWxldGlvbiBhbmltYXRpb24gKGFuZCB0aHVzIHNpbXVsYXRlXG4gICAgLy8gcmVhbC10aW1lIGNoYXJ0cyksIHdlIG5lZWQgdG8gbW9uaXRvciB0aGVzZSBkYXRhIG1vZGlmaWNhdGlvbnMgYW5kIHN5bmNocm9uaXplXG4gICAgLy8gdGhlIGludGVybmFsIG1ldGFkYXRhIGFjY29yZGluZ2x5LlxuXG4gICAgaWYgKGlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICB0aGlzLl9kYXRhID0gY29udmVydE9iamVjdERhdGFUb0FycmF5KGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoX2RhdGEgIT09IGRhdGEpIHtcbiAgICAgIGlmIChfZGF0YSkge1xuICAgICAgICAvLyBUaGlzIGNhc2UgaGFwcGVucyB3aGVuIHRoZSB1c2VyIHJlcGxhY2VkIHRoZSBkYXRhIGFycmF5IGluc3RhbmNlLlxuICAgICAgICB1bmxpc3RlbkFycmF5RXZlbnRzKF9kYXRhLCB0aGlzKTtcbiAgICAgICAgLy8gRGlzY2FyZCBvbGQgcGFyc2VkIGRhdGEgYW5kIHN0YWNrc1xuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgICAgY2xlYXJTdGFja3MobWV0YSk7XG4gICAgICAgIG1ldGEuX3BhcnNlZCA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShkYXRhKSkge1xuICAgICAgICBsaXN0ZW5BcnJheUV2ZW50cyhkYXRhLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XG4gICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICB9XG4gIH1cblxuICBhZGRFbGVtZW50cygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcblxuICAgIHRoaXMuX2RhdGFDaGVjaygpO1xuXG4gICAgaWYgKHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlKSB7XG4gICAgICBtZXRhLmRhdGFzZXQgPSBuZXcgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUoKTtcbiAgICB9XG4gIH1cblxuICBidWlsZE9yVXBkYXRlRWxlbWVudHMocmVzZXROZXdFbGVtZW50cykge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcbiAgICBsZXQgc3RhY2tDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICB0aGlzLl9kYXRhQ2hlY2soKTtcblxuICAgIC8vIG1ha2Ugc3VyZSBjYWNoZWQgX3N0YWNrZWQgc3RhdHVzIGlzIGN1cnJlbnRcbiAgICBjb25zdCBvbGRTdGFja2VkID0gbWV0YS5fc3RhY2tlZDtcbiAgICBtZXRhLl9zdGFja2VkID0gaXNTdGFja2VkKG1ldGEudlNjYWxlLCBtZXRhKTtcblxuICAgIC8vIGRldGVjdCBjaGFuZ2UgaW4gc3RhY2sgb3B0aW9uXG4gICAgaWYgKG1ldGEuc3RhY2sgIT09IGRhdGFzZXQuc3RhY2spIHtcbiAgICAgIHN0YWNrQ2hhbmdlZCA9IHRydWU7XG4gICAgICAvLyByZW1vdmUgdmFsdWVzIGZyb20gb2xkIHN0YWNrXG4gICAgICBjbGVhclN0YWNrcyhtZXRhKTtcbiAgICAgIG1ldGEuc3RhY2sgPSBkYXRhc2V0LnN0YWNrO1xuICAgIH1cblxuICAgIC8vIFJlLXN5bmMgbWV0YSBkYXRhIGluIGNhc2UgdGhlIHVzZXIgcmVwbGFjZWQgdGhlIGRhdGEgYXJyYXkgb3IgaWYgd2UgbWlzc2VkXG4gICAgLy8gYW55IHVwZGF0ZXMgYW5kIHNvIG1ha2Ugc3VyZSB0aGF0IHdlIGhhbmRsZSBudW1iZXIgb2YgZGF0YXBvaW50cyBjaGFuZ2luZy5cbiAgICB0aGlzLl9yZXN5bmNFbGVtZW50cyhyZXNldE5ld0VsZW1lbnRzKTtcblxuICAgIC8vIGlmIHN0YWNrIGNoYW5nZWQsIHVwZGF0ZSBzdGFjayB2YWx1ZXMgZm9yIHRoZSB3aG9sZSBkYXRhc2V0XG4gICAgaWYgKHN0YWNrQ2hhbmdlZCB8fCBvbGRTdGFja2VkICE9PSBtZXRhLl9zdGFja2VkKSB7XG4gICAgICB1cGRhdGVTdGFja3ModGhpcywgbWV0YS5fcGFyc2VkKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogTWVyZ2VzIHVzZXItc3VwcGxpZWQgYW5kIGRlZmF1bHQgZGF0YXNldC1sZXZlbCBvcHRpb25zXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBjb25maWd1cmUoKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jaGFydC5jb25maWc7XG4gICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRTY29wZUtleXModGhpcy5fdHlwZSk7XG4gICAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3Blcyh0aGlzLmdldERhdGFzZXQoKSwgc2NvcGVLZXlzLCB0cnVlKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgdGhpcy5fcGFyc2luZyA9IHRoaXMub3B0aW9ucy5wYXJzaW5nO1xuICAgIHRoaXMuX2NhY2hlZERhdGFPcHRzID0ge307XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuXHQgKi9cbiAgcGFyc2Uoc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge19jYWNoZWRNZXRhOiBtZXRhLCBfZGF0YTogZGF0YX0gPSB0aGlzO1xuICAgIGNvbnN0IHtpU2NhbGUsIF9zdGFja2VkfSA9IG1ldGE7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcblxuICAgIGxldCBzb3J0ZWQgPSBzdGFydCA9PT0gMCAmJiBjb3VudCA9PT0gZGF0YS5sZW5ndGggPyB0cnVlIDogbWV0YS5fc29ydGVkO1xuICAgIGxldCBwcmV2ID0gc3RhcnQgPiAwICYmIG1ldGEuX3BhcnNlZFtzdGFydCAtIDFdO1xuICAgIGxldCBpLCBjdXIsIHBhcnNlZDtcblxuICAgIGlmICh0aGlzLl9wYXJzaW5nID09PSBmYWxzZSkge1xuICAgICAgbWV0YS5fcGFyc2VkID0gZGF0YTtcbiAgICAgIG1ldGEuX3NvcnRlZCA9IHRydWU7XG4gICAgICBwYXJzZWQgPSBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNBcnJheShkYXRhW3N0YXJ0XSkpIHtcbiAgICAgICAgcGFyc2VkID0gdGhpcy5wYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChkYXRhW3N0YXJ0XSkpIHtcbiAgICAgICAgcGFyc2VkID0gdGhpcy5wYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZCA9IHRoaXMucGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlzTm90SW5PcmRlckNvbXBhcmVkVG9QcmV2ID0gKCkgPT4gY3VyW2lBeGlzXSA9PT0gbnVsbCB8fCAocHJldiAmJiBjdXJbaUF4aXNdIDwgcHJldltpQXhpc10pO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgbWV0YS5fcGFyc2VkW2kgKyBzdGFydF0gPSBjdXIgPSBwYXJzZWRbaV07XG4gICAgICAgIGlmIChzb3J0ZWQpIHtcbiAgICAgICAgICBpZiAoaXNOb3RJbk9yZGVyQ29tcGFyZWRUb1ByZXYoKSkge1xuICAgICAgICAgICAgc29ydGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByZXYgPSBjdXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1ldGEuX3NvcnRlZCA9IHNvcnRlZDtcbiAgICB9XG5cbiAgICBpZiAoX3N0YWNrZWQpIHtcbiAgICAgIHVwZGF0ZVN0YWNrcyh0aGlzLCBwYXJzZWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBQYXJzZSBhcnJheSBvZiBwcmltaXRpdmUgdmFsdWVzXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBtZXRhIC0gZGF0YXNldCBtZXRhXG5cdCAqIEBwYXJhbSB7YXJyYXl9IGRhdGEgLSBkYXRhIGFycmF5LiBFeGFtcGxlIFsxLDMsNF1cblx0ICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gc3RhcnQgaW5kZXhcblx0ICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IC0gbnVtYmVyIG9mIGl0ZW1zIHRvIHBhcnNlXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IHBhcnNlZCBpdGVtIC0gaXRlbSBjb250YWluaW5nIGluZGV4IGFuZCBhIHBhcnNlZCB2YWx1ZVxuXHQgKiBmb3IgZWFjaCBzY2FsZSBpZC5cblx0ICogRXhhbXBsZToge3hTY2FsZTA6IDAsIHlTY2FsZTA6IDF9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgY29uc3QgbGFiZWxzID0gaVNjYWxlLmdldExhYmVscygpO1xuICAgIGNvbnN0IHNpbmdsZVNjYWxlID0gaVNjYWxlID09PSB2U2NhbGU7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXg7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgICAgcGFyc2VkW2ldID0ge1xuICAgICAgICBbaUF4aXNdOiBzaW5nbGVTY2FsZSB8fCBpU2NhbGUucGFyc2UobGFiZWxzW2luZGV4XSwgaW5kZXgpLFxuICAgICAgICBbdkF4aXNdOiB2U2NhbGUucGFyc2UoZGF0YVtpbmRleF0sIGluZGV4KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBQYXJzZSBhcnJheSBvZiBhcnJheXNcblx0ICogQHBhcmFtIHtvYmplY3R9IG1ldGEgLSBkYXRhc2V0IG1ldGFcblx0ICogQHBhcmFtIHthcnJheX0gZGF0YSAtIGRhdGEgYXJyYXkuIEV4YW1wbGUgW1sxLDJdLFszLDRdXVxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBzdGFydCBpbmRleFxuXHQgKiBAcGFyYW0ge251bWJlcn0gY291bnQgLSBudW1iZXIgb2YgaXRlbXMgdG8gcGFyc2Vcblx0ICogQHJldHVybnMge29iamVjdH0gcGFyc2VkIGl0ZW0gLSBpdGVtIGNvbnRhaW5pbmcgaW5kZXggYW5kIGEgcGFyc2VkIHZhbHVlXG5cdCAqIGZvciBlYWNoIHNjYWxlIGlkLlxuXHQgKiBFeGFtcGxlOiB7eDogMCwgeTogMX1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXgsIGl0ZW07XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgICAgaXRlbSA9IGRhdGFbaW5kZXhdO1xuICAgICAgcGFyc2VkW2ldID0ge1xuICAgICAgICB4OiB4U2NhbGUucGFyc2UoaXRlbVswXSwgaW5kZXgpLFxuICAgICAgICB5OiB5U2NhbGUucGFyc2UoaXRlbVsxXSwgaW5kZXgpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIFBhcnNlIGFycmF5IG9mIG9iamVjdHNcblx0ICogQHBhcmFtIHtvYmplY3R9IG1ldGEgLSBkYXRhc2V0IG1ldGFcblx0ICogQHBhcmFtIHthcnJheX0gZGF0YSAtIGRhdGEgYXJyYXkuIEV4YW1wbGUgW3t4OjEsIHk6NX0sIHt4OjIsIHk6MTB9XVxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBzdGFydCBpbmRleFxuXHQgKiBAcGFyYW0ge251bWJlcn0gY291bnQgLSBudW1iZXIgb2YgaXRlbXMgdG8gcGFyc2Vcblx0ICogQHJldHVybnMge29iamVjdH0gcGFyc2VkIGl0ZW0gLSBpdGVtIGNvbnRhaW5pbmcgaW5kZXggYW5kIGEgcGFyc2VkIHZhbHVlXG5cdCAqIGZvciBlYWNoIHNjYWxlIGlkLiBfY3VzdG9tIGlzIG9wdGlvbmFsXG5cdCAqIEV4YW1wbGU6IHt4U2NhbGUwOiAwLCB5U2NhbGUwOiAxLCBfY3VzdG9tOiB7cjogMTAsIGZvbzogJ2Jhcid9fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3Qge3hBeGlzS2V5ID0gJ3gnLCB5QXhpc0tleSA9ICd5J30gPSB0aGlzLl9wYXJzaW5nO1xuICAgIGNvbnN0IHBhcnNlZCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgbGV0IGksIGlsZW4sIGluZGV4LCBpdGVtO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpbmRleCA9IGkgKyBzdGFydDtcbiAgICAgIGl0ZW0gPSBkYXRhW2luZGV4XTtcbiAgICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgICAgeDogeFNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkoaXRlbSwgeEF4aXNLZXkpLCBpbmRleCksXG4gICAgICAgIHk6IHlTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KGl0ZW0sIHlBeGlzS2V5KSwgaW5kZXgpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldFBhcnNlZChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWRNZXRhLl9wYXJzZWRbaW5kZXhdO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldERhdGFFbGVtZW50KGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZE1ldGEuZGF0YVtpbmRleF07XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgYXBwbHlTdGFjayhzY2FsZSwgcGFyc2VkLCBtb2RlKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHZhbHVlID0gcGFyc2VkW3NjYWxlLmF4aXNdO1xuICAgIGNvbnN0IHN0YWNrID0ge1xuICAgICAga2V5czogZ2V0U29ydGVkRGF0YXNldEluZGljZXMoY2hhcnQsIHRydWUpLFxuICAgICAgdmFsdWVzOiBwYXJzZWQuX3N0YWNrc1tzY2FsZS5heGlzXS5fdmlzdWFsVmFsdWVzXG4gICAgfTtcbiAgICByZXR1cm4gYXBwbHlTdGFjayhzdGFjaywgdmFsdWUsIG1ldGEuaW5kZXgsIHttb2RlfSk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgdXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjaykge1xuICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gcGFyc2VkW3NjYWxlLmF4aXNdO1xuICAgIGxldCB2YWx1ZSA9IHBhcnNlZFZhbHVlID09PSBudWxsID8gTmFOIDogcGFyc2VkVmFsdWU7XG4gICAgY29uc3QgdmFsdWVzID0gc3RhY2sgJiYgcGFyc2VkLl9zdGFja3Nbc2NhbGUuYXhpc107XG4gICAgaWYgKHN0YWNrICYmIHZhbHVlcykge1xuICAgICAgc3RhY2sudmFsdWVzID0gdmFsdWVzO1xuICAgICAgdmFsdWUgPSBhcHBseVN0YWNrKHN0YWNrLCBwYXJzZWRWYWx1ZSwgdGhpcy5fY2FjaGVkTWV0YS5pbmRleCk7XG4gICAgfVxuICAgIHJhbmdlLm1pbiA9IE1hdGgubWluKHJhbmdlLm1pbiwgdmFsdWUpO1xuICAgIHJhbmdlLm1heCA9IE1hdGgubWF4KHJhbmdlLm1heCwgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldE1pbk1heChzY2FsZSwgY2FuU3RhY2spIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBfcGFyc2VkID0gbWV0YS5fcGFyc2VkO1xuICAgIGNvbnN0IHNvcnRlZCA9IG1ldGEuX3NvcnRlZCAmJiBzY2FsZSA9PT0gbWV0YS5pU2NhbGU7XG4gICAgY29uc3QgaWxlbiA9IF9wYXJzZWQubGVuZ3RoO1xuICAgIGNvbnN0IG90aGVyU2NhbGUgPSB0aGlzLl9nZXRPdGhlclNjYWxlKHNjYWxlKTtcbiAgICBjb25zdCBzdGFjayA9IGNyZWF0ZVN0YWNrKGNhblN0YWNrLCBtZXRhLCB0aGlzLmNoYXJ0KTtcbiAgICBjb25zdCByYW5nZSA9IHttaW46IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgbWF4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFl9O1xuICAgIGNvbnN0IHttaW46IG90aGVyTWluLCBtYXg6IG90aGVyTWF4fSA9IGdldFVzZXJCb3VuZHMob3RoZXJTY2FsZSk7XG4gICAgbGV0IGksIHBhcnNlZDtcblxuICAgIGZ1bmN0aW9uIF9za2lwKCkge1xuICAgICAgcGFyc2VkID0gX3BhcnNlZFtpXTtcbiAgICAgIGNvbnN0IG90aGVyVmFsdWUgPSBwYXJzZWRbb3RoZXJTY2FsZS5heGlzXTtcbiAgICAgIHJldHVybiAhaXNGaW5pdGUocGFyc2VkW3NjYWxlLmF4aXNdKSB8fCBvdGhlck1pbiA+IG90aGVyVmFsdWUgfHwgb3RoZXJNYXggPCBvdGhlclZhbHVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGlmIChfc2tpcCgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKTtcbiAgICAgIGlmIChzb3J0ZWQpIHtcbiAgICAgICAgLy8gaWYgdGhlIGRhdGEgaXMgc29ydGVkLCB3ZSBkb24ndCBuZWVkIHRvIGNoZWNrIGZ1cnRoZXIgZnJvbSB0aGlzIGVuZCBvZiBhcnJheVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNvcnRlZCkge1xuICAgICAgLy8gaW4gdGhlIHNvcnRlZCBjYXNlLCBmaW5kIGZpcnN0IG5vbi1za2lwcGVkIHZhbHVlIGZyb20gb3RoZXIgZW5kIG9mIGFycmF5XG4gICAgICBmb3IgKGkgPSBpbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaWYgKF9za2lwKCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9XG5cbiAgZ2V0QWxsUGFyc2VkVmFsdWVzKHNjYWxlKSB7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5fY2FjaGVkTWV0YS5fcGFyc2VkO1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCB2YWx1ZTtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBwYXJzZWQubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB2YWx1ZSA9IHBhcnNlZFtpXVtzY2FsZS5heGlzXTtcbiAgICAgIGlmIChpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge251bWJlcnxib29sZWFufVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGlTY2FsZSA9IG1ldGEuaVNjYWxlO1xuICAgIGNvbnN0IHZTY2FsZSA9IG1ldGEudlNjYWxlO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGlTY2FsZSA/ICcnICsgaVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW2lTY2FsZS5heGlzXSkgOiAnJyxcbiAgICAgIHZhbHVlOiB2U2NhbGUgPyAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pIDogJydcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLnVwZGF0ZShtb2RlIHx8ICdkZWZhdWx0Jyk7XG4gICAgbWV0YS5fY2xpcCA9IHRvQ2xpcCh2YWx1ZU9yRGVmYXVsdCh0aGlzLm9wdGlvbnMuY2xpcCwgZGVmYXVsdENsaXAobWV0YS54U2NhbGUsIG1ldGEueVNjYWxlLCB0aGlzLmdldE1heE92ZXJmbG93KCkpKSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IG1vZGVcblx0ICovXG4gIHVwZGF0ZShtb2RlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgZHJhdygpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLl9jdHg7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgIGNvbnN0IGFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgY29uc3QgYWN0aXZlID0gW107XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9kcmF3U3RhcnQgfHwgMDtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMuX2RyYXdDb3VudCB8fCAoZWxlbWVudHMubGVuZ3RoIC0gc3RhcnQpO1xuICAgIGNvbnN0IGRyYXdBY3RpdmVFbGVtZW50c09uVG9wID0gdGhpcy5vcHRpb25zLmRyYXdBY3RpdmVFbGVtZW50c09uVG9wO1xuICAgIGxldCBpO1xuXG4gICAgaWYgKG1ldGEuZGF0YXNldCkge1xuICAgICAgbWV0YS5kYXRhc2V0LmRyYXcoY3R4LCBhcmVhLCBzdGFydCwgY291bnQpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICBpZiAoZWxlbWVudC5oaWRkZW4pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudC5hY3RpdmUgJiYgZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3ApIHtcbiAgICAgICAgYWN0aXZlLnB1c2goZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LmRyYXcoY3R4LCBhcmVhKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgYWN0aXZlLmxlbmd0aDsgKytpKSB7XG4gICAgICBhY3RpdmVbaV0uZHJhdyhjdHgsIGFyZWEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIGEgc2V0IG9mIHByZWRlZmluZWQgc3R5bGUgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlcHJlc2VudCB0aGUgZGF0YXNldFxuXHQgKiBvciB0aGUgZGF0YSBpZiB0aGUgaW5kZXggaXMgc3BlY2lmaWVkXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIGRhdGEgaW5kZXhcblx0ICogQHBhcmFtIHtib29sZWFufSBbYWN0aXZlXSAtIHRydWUgaWYgaG92ZXJcblx0ICogQHJldHVybiB7b2JqZWN0fSBzdHlsZSBvYmplY3Rcblx0ICovXG4gIGdldFN0eWxlKGluZGV4LCBhY3RpdmUpIHtcbiAgICBjb25zdCBtb2RlID0gYWN0aXZlID8gJ2FjdGl2ZScgOiAnZGVmYXVsdCc7XG4gICAgcmV0dXJuIGluZGV4ID09PSB1bmRlZmluZWQgJiYgdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0XG4gICAgICA/IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKVxuICAgICAgOiB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXggfHwgMCwgbW9kZSk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0Q29udGV4dChpbmRleCwgYWN0aXZlLCBtb2RlKSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuICAgIGxldCBjb250ZXh0O1xuICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fY2FjaGVkTWV0YS5kYXRhLmxlbmd0aCkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YVtpbmRleF07XG4gICAgICBjb250ZXh0ID0gZWxlbWVudC4kY29udGV4dCB8fFxuICAgICAgICAoZWxlbWVudC4kY29udGV4dCA9IGNyZWF0ZURhdGFDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpLCBpbmRleCwgZWxlbWVudCkpO1xuICAgICAgY29udGV4dC5wYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgICBjb250ZXh0LnJhdyA9IGRhdGFzZXQuZGF0YVtpbmRleF07XG4gICAgICBjb250ZXh0LmluZGV4ID0gY29udGV4dC5kYXRhSW5kZXggPSBpbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dCA9IHRoaXMuJGNvbnRleHQgfHxcbiAgICAgICAgKHRoaXMuJGNvbnRleHQgPSBjcmVhdGVEYXRhc2V0Q29udGV4dCh0aGlzLmNoYXJ0LmdldENvbnRleHQoKSwgdGhpcy5pbmRleCkpO1xuICAgICAgY29udGV4dC5kYXRhc2V0ID0gZGF0YXNldDtcbiAgICAgIGNvbnRleHQuaW5kZXggPSBjb250ZXh0LmRhdGFzZXRJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgfVxuXG4gICAgY29udGV4dC5hY3RpdmUgPSAhIWFjdGl2ZTtcbiAgICBjb250ZXh0Lm1vZGUgPSBtb2RlO1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbbW9kZV1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVFbGVtZW50T3B0aW9ucyh0aGlzLmRhdGFzZXRFbGVtZW50VHlwZS5pZCwgbW9kZSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbbW9kZV1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlRWxlbWVudE9wdGlvbnModGhpcy5kYXRhRWxlbWVudFR5cGUuaWQsIG1vZGUsIGluZGV4KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3Jlc29sdmVFbGVtZW50T3B0aW9ucyhlbGVtZW50VHlwZSwgbW9kZSA9ICdkZWZhdWx0JywgaW5kZXgpIHtcbiAgICBjb25zdCBhY3RpdmUgPSBtb2RlID09PSAnYWN0aXZlJztcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2NhY2hlZERhdGFPcHRzO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gZWxlbWVudFR5cGUgKyAnLScgKyBtb2RlO1xuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICBjb25zdCBzaGFyaW5nID0gdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nICYmIGRlZmluZWQoaW5kZXgpO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjbG9uZUlmTm90U2hhcmVkKGNhY2hlZCwgc2hhcmluZyk7XG4gICAgfVxuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY2hhcnQuY29uZmlnO1xuICAgIGNvbnN0IHNjb3BlS2V5cyA9IGNvbmZpZy5kYXRhc2V0RWxlbWVudFNjb3BlS2V5cyh0aGlzLl90eXBlLCBlbGVtZW50VHlwZSk7XG4gICAgY29uc3QgcHJlZml4ZXMgPSBhY3RpdmUgPyBbYCR7ZWxlbWVudFR5cGV9SG92ZXJgLCAnaG92ZXInLCBlbGVtZW50VHlwZSwgJyddIDogW2VsZW1lbnRUeXBlLCAnJ107XG4gICAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3Blcyh0aGlzLmdldERhdGFzZXQoKSwgc2NvcGVLZXlzKTtcbiAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKGRlZmF1bHRzLmVsZW1lbnRzW2VsZW1lbnRUeXBlXSk7XG4gICAgLy8gY29udGV4dCBpcyBwcm92aWRlZCBhcyBhIGZ1bmN0aW9uLCBhbmQgaXMgY2FsbGVkIG9ubHkgaWYgbmVlZGVkLFxuICAgIC8vIHNvIHdlIGRvbid0IGNyZWF0ZSBhIGNvbnRleHQgZm9yIGVhY2ggZWxlbWVudCBpZiBub3QgbmVlZGVkLlxuICAgIGNvbnN0IGNvbnRleHQgPSAoKSA9PiB0aGlzLmdldENvbnRleHQoaW5kZXgsIGFjdGl2ZSwgbW9kZSk7XG4gICAgY29uc3QgdmFsdWVzID0gY29uZmlnLnJlc29sdmVOYW1lZE9wdGlvbnMoc2NvcGVzLCBuYW1lcywgY29udGV4dCwgcHJlZml4ZXMpO1xuXG4gICAgaWYgKHZhbHVlcy4kc2hhcmVkKSB7XG4gICAgICAvLyBgJHNoYXJlZGAgaW5kaWNhdGVzIHRoaXMgc2V0IG9mIG9wdGlvbnMgY2FuIGJlIHNoYXJlZCBiZXR3ZWVuIG11bHRpcGxlIGVsZW1lbnRzLlxuICAgICAgLy8gU2hhcmluZyBpcyB1c2VkIHRvIHJlZHVjZSBudW1iZXIgb2YgcHJvcGVydGllcyB0byBjaGFuZ2UgZHVyaW5nIGFuaW1hdGlvbi5cbiAgICAgIHZhbHVlcy4kc2hhcmVkID0gc2hhcmluZztcblxuICAgICAgLy8gV2UgY2FjaGUgb3B0aW9ucyBieSBgbW9kZWAsIHdoaWNoIGNhbiBiZSAnYWN0aXZlJyBmb3IgZXhhbXBsZS4gVGhpcyBlbmFibGVzIHVzXG4gICAgICAvLyB0byBoYXZlIHRoZSAnYWN0aXZlJyBlbGVtZW50IG9wdGlvbnMgYW5kICdkZWZhdWx0JyBvcHRpb25zIHRvIHN3aXRjaCBiZXR3ZWVuXG4gICAgICAvLyB3aGVuIGludGVyYWN0aW5nLlxuICAgICAgY2FjaGVbY2FjaGVLZXldID0gT2JqZWN0LmZyZWV6ZShjbG9uZUlmTm90U2hhcmVkKHZhbHVlcywgc2hhcmluZykpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cblxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCB0cmFuc2l0aW9uLCBhY3RpdmUpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLl9jYWNoZWREYXRhT3B0cztcbiAgICBjb25zdCBjYWNoZUtleSA9IGBhbmltYXRpb24tJHt0cmFuc2l0aW9ufWA7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGVbY2FjaGVLZXldO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuICAgIGxldCBvcHRpb25zO1xuICAgIGlmIChjaGFydC5vcHRpb25zLmFuaW1hdGlvbiAhPT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY2hhcnQuY29uZmlnO1xuICAgICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRBbmltYXRpb25TY29wZUtleXModGhpcy5fdHlwZSwgdHJhbnNpdGlvbik7XG4gICAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBzY29wZUtleXMpO1xuICAgICAgb3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIHRoaXMuZ2V0Q29udGV4dChpbmRleCwgYWN0aXZlLCB0cmFuc2l0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBuZXcgQW5pbWF0aW9ucyhjaGFydCwgb3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGlvbnMpO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2NhY2hlYWJsZSkge1xuICAgICAgY2FjaGVbY2FjaGVLZXldID0gT2JqZWN0LmZyZWV6ZShhbmltYXRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cblxuICAvKipcblx0ICogVXRpbGl0eSBmb3IgZ2V0dGluZyB0aGUgb3B0aW9ucyBvYmplY3Qgc2hhcmVkIGJldHdlZW4gZWxlbWVudHNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0U2hhcmVkT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLiRzaGFyZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NoYXJlZE9wdGlvbnMgfHwgKHRoaXMuX3NoYXJlZE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSk7XG4gIH1cblxuICAvKipcblx0ICogVXRpbGl0eSBmb3IgZGV0ZXJtaW5pbmcgaWYgYG9wdGlvbnNgIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgdXBkYXRlZCBwcm9wZXJ0aWVzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGluY2x1ZGVPcHRpb25zKG1vZGUsIHNoYXJlZE9wdGlvbnMpIHtcbiAgICByZXR1cm4gIXNoYXJlZE9wdGlvbnMgfHwgaXNEaXJlY3RVcGRhdGVNb2RlKG1vZGUpIHx8IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdG9kbyB2NCwgcmVuYW1lIHRvIGdldFNoYXJlZE9wdGlvbnMgYW5kIHJlbW92ZSBleGNlc3MgZnVuY3Rpb25zXG4gICAqL1xuICBfZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSkge1xuICAgIGNvbnN0IGZpcnN0T3B0cyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3QgcHJldmlvdXNseVNoYXJlZE9wdGlvbnMgPSB0aGlzLl9zaGFyZWRPcHRpb25zO1xuICAgIGNvbnN0IHNoYXJlZE9wdGlvbnMgPSB0aGlzLmdldFNoYXJlZE9wdGlvbnMoZmlyc3RPcHRzKTtcbiAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IHRoaXMuaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucykgfHwgKHNoYXJlZE9wdGlvbnMgIT09IHByZXZpb3VzbHlTaGFyZWRPcHRpb25zKTtcbiAgICB0aGlzLnVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgZmlyc3RPcHRzKTtcbiAgICByZXR1cm4ge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVdGlsaXR5IGZvciB1cGRhdGluZyBhbiBlbGVtZW50IHdpdGggbmV3IHByb3BlcnRpZXMsIHVzaW5nIGFuaW1hdGlvbnMgd2hlbiBhcHByb3ByaWF0ZS5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgdXBkYXRlRWxlbWVudChlbGVtZW50LCBpbmRleCwgcHJvcGVydGllcywgbW9kZSkge1xuICAgIGlmIChpc0RpcmVjdFVwZGF0ZU1vZGUobW9kZSkpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudCwgcHJvcGVydGllcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCBtb2RlKS51cGRhdGUoZWxlbWVudCwgcHJvcGVydGllcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIFV0aWxpdHkgdG8gYW5pbWF0ZSB0aGUgc2hhcmVkIG9wdGlvbnMsIHRoYXQgYXJlIHBvdGVudGlhbGx5IGFmZmVjdGluZyBtdWx0aXBsZSBlbGVtZW50cy5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgdXBkYXRlU2hhcmVkT3B0aW9ucyhzaGFyZWRPcHRpb25zLCBtb2RlLCBuZXdPcHRpb25zKSB7XG4gICAgaWYgKHNoYXJlZE9wdGlvbnMgJiYgIWlzRGlyZWN0VXBkYXRlTW9kZShtb2RlKSkge1xuICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnModW5kZWZpbmVkLCBtb2RlKS51cGRhdGUoc2hhcmVkT3B0aW9ucywgbmV3T3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfc2V0U3R5bGUoZWxlbWVudCwgaW5kZXgsIG1vZGUsIGFjdGl2ZSkge1xuICAgIGVsZW1lbnQuYWN0aXZlID0gYWN0aXZlO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmdldFN0eWxlKGluZGV4LCBhY3RpdmUpO1xuICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCBtb2RlLCBhY3RpdmUpLnVwZGF0ZShlbGVtZW50LCB7XG4gICAgICAvLyBXaGVuIGdvaW5nIGZyb20gYWN0aXZlIHRvIGluYWN0aXZlLCB3ZSBuZWVkIHRvIHVwZGF0ZSB0byB0aGUgc2hhcmVkIG9wdGlvbnMuXG4gICAgICAvLyBUaGlzIHdheSB0aGUgb25jZSBob3ZlcmVkIGVsZW1lbnQgd2lsbCBlbmQgdXAgd2l0aCB0aGUgc2FtZSBvcmlnaW5hbCBzaGFyZWQgb3B0aW9ucyBpbnN0YW5jZSwgYWZ0ZXIgYW5pbWF0aW9uLlxuICAgICAgb3B0aW9uczogKCFhY3RpdmUgJiYgdGhpcy5nZXRTaGFyZWRPcHRpb25zKG9wdGlvbnMpKSB8fCBvcHRpb25zXG4gICAgfSk7XG4gIH1cblxuICByZW1vdmVIb3ZlclN0eWxlKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICB0aGlzLl9zZXRTdHlsZShlbGVtZW50LCBpbmRleCwgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgfVxuXG4gIHNldEhvdmVyU3R5bGUoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIGluZGV4LCAnYWN0aXZlJywgdHJ1ZSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9yZW1vdmVEYXRhc2V0SG92ZXJTdHlsZSgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0O1xuXG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIHVuZGVmaW5lZCwgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9zZXREYXRhc2V0SG92ZXJTdHlsZSgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0O1xuXG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIHVuZGVmaW5lZCwgJ2FjdGl2ZScsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3Jlc3luY0VsZW1lbnRzKHJlc2V0TmV3RWxlbWVudHMpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcblxuICAgIC8vIEFwcGx5IGNoYW5nZXMgZGV0ZWN0ZWQgdGhyb3VnaCBhcnJheSBsaXN0ZW5lcnNcbiAgICBmb3IgKGNvbnN0IFttZXRob2QsIGFyZzEsIGFyZzJdIG9mIHRoaXMuX3N5bmNMaXN0KSB7XG4gICAgICB0aGlzW21ldGhvZF0oYXJnMSwgYXJnMik7XG4gICAgfVxuICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XG5cbiAgICBjb25zdCBudW1NZXRhID0gZWxlbWVudHMubGVuZ3RoO1xuICAgIGNvbnN0IG51bURhdGEgPSBkYXRhLmxlbmd0aDtcbiAgICBjb25zdCBjb3VudCA9IE1hdGgubWluKG51bURhdGEsIG51bU1ldGEpO1xuXG4gICAgaWYgKGNvdW50KSB7XG4gICAgICAvLyBUT0RPOiBJdCBpcyBub3Qgb3B0aW1hbCB0byBhbHdheXMgcGFyc2UgdGhlIG9sZCBkYXRhXG4gICAgICAvLyBUaGlzIGlzIGRvbmUgYmVjYXVzZSB3ZSBhcmUgbm90IGRldGVjdGluZyBkaXJlY3QgYXNzaWdubWVudHM6XG4gICAgICAvLyBjaGFydC5kYXRhLmRhdGFzZXRzWzBdLmRhdGFbNV0gPSAxMDtcbiAgICAgIC8vIGNoYXJ0LmRhdGEuZGF0YXNldHNbMF0uZGF0YVs1XS55ID0gMTA7XG4gICAgICB0aGlzLnBhcnNlKDAsIGNvdW50KTtcbiAgICB9XG5cbiAgICBpZiAobnVtRGF0YSA+IG51bU1ldGEpIHtcbiAgICAgIHRoaXMuX2luc2VydEVsZW1lbnRzKG51bU1ldGEsIG51bURhdGEgLSBudW1NZXRhLCByZXNldE5ld0VsZW1lbnRzKTtcbiAgICB9IGVsc2UgaWYgKG51bURhdGEgPCBudW1NZXRhKSB7XG4gICAgICB0aGlzLl9yZW1vdmVFbGVtZW50cyhudW1EYXRhLCBudW1NZXRhIC0gbnVtRGF0YSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfaW5zZXJ0RWxlbWVudHMoc3RhcnQsIGNvdW50LCByZXNldE5ld0VsZW1lbnRzID0gdHJ1ZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGEgPSBtZXRhLmRhdGE7XG4gICAgY29uc3QgZW5kID0gc3RhcnQgKyBjb3VudDtcbiAgICBsZXQgaTtcblxuICAgIGNvbnN0IG1vdmUgPSAoYXJyKSA9PiB7XG4gICAgICBhcnIubGVuZ3RoICs9IGNvdW50O1xuICAgICAgZm9yIChpID0gYXJyLmxlbmd0aCAtIDE7IGkgPj0gZW5kOyBpLS0pIHtcbiAgICAgICAgYXJyW2ldID0gYXJyW2kgLSBjb3VudF07XG4gICAgICB9XG4gICAgfTtcbiAgICBtb3ZlKGRhdGEpO1xuXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgZGF0YVtpXSA9IG5ldyB0aGlzLmRhdGFFbGVtZW50VHlwZSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9wYXJzaW5nKSB7XG4gICAgICBtb3ZlKG1ldGEuX3BhcnNlZCk7XG4gICAgfVxuICAgIHRoaXMucGFyc2Uoc3RhcnQsIGNvdW50KTtcblxuICAgIGlmIChyZXNldE5ld0VsZW1lbnRzKSB7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKGRhdGEsIHN0YXJ0LCBjb3VudCwgJ3Jlc2V0Jyk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMoZWxlbWVudCwgc3RhcnQsIGNvdW50LCBtb2RlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVtb3ZlRWxlbWVudHMoc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcbiAgICAgIGNvbnN0IHJlbW92ZWQgPSBtZXRhLl9wYXJzZWQuc3BsaWNlKHN0YXJ0LCBjb3VudCk7XG4gICAgICBpZiAobWV0YS5fc3RhY2tlZCkge1xuICAgICAgICBjbGVhclN0YWNrcyhtZXRhLCByZW1vdmVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWV0YS5kYXRhLnNwbGljZShzdGFydCwgY291bnQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG4gICAqL1xuICBfc3luYyhhcmdzKSB7XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcbiAgICAgIHRoaXMuX3N5bmNMaXN0LnB1c2goYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IFttZXRob2QsIGFyZzEsIGFyZzJdID0gYXJncztcbiAgICAgIHRoaXNbbWV0aG9kXShhcmcxLCBhcmcyKTtcbiAgICB9XG4gICAgdGhpcy5jaGFydC5fZGF0YUNoYW5nZXMucHVzaChbdGhpcy5pbmRleCwgLi4uYXJnc10pO1xuICB9XG5cbiAgX29uRGF0YVB1c2goKSB7XG4gICAgY29uc3QgY291bnQgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHRoaXMuX3N5bmMoWydfaW5zZXJ0RWxlbWVudHMnLCB0aGlzLmdldERhdGFzZXQoKS5kYXRhLmxlbmd0aCAtIGNvdW50LCBjb3VudF0pO1xuICB9XG5cbiAgX29uRGF0YVBvcCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX3JlbW92ZUVsZW1lbnRzJywgdGhpcy5fY2FjaGVkTWV0YS5kYXRhLmxlbmd0aCAtIDEsIDFdKTtcbiAgfVxuXG4gIF9vbkRhdGFTaGlmdCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX3JlbW92ZUVsZW1lbnRzJywgMCwgMV0pO1xuICB9XG5cbiAgX29uRGF0YVNwbGljZShzdGFydCwgY291bnQpIHtcbiAgICBpZiAoY291bnQpIHtcbiAgICAgIHRoaXMuX3N5bmMoWydfcmVtb3ZlRWxlbWVudHMnLCBzdGFydCwgY291bnRdKTtcbiAgICB9XG4gICAgY29uc3QgbmV3Q291bnQgPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgICBpZiAobmV3Q291bnQpIHtcbiAgICAgIHRoaXMuX3N5bmMoWydfaW5zZXJ0RWxlbWVudHMnLCBzdGFydCwgbmV3Q291bnRdKTtcbiAgICB9XG4gIH1cblxuICBfb25EYXRhVW5zaGlmdCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX2luc2VydEVsZW1lbnRzJywgMCwgYXJndW1lbnRzLmxlbmd0aF0pO1xuICB9XG59XG4iLCAiaW1wb3J0IERhdGFzZXRDb250cm9sbGVyIGZyb20gJy4uL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyc7XG5pbXBvcnQge1xuICBfYXJyYXlVbmlxdWUsIGlzQXJyYXksIGlzTnVsbE9yVW5kZWYsXG4gIHZhbHVlT3JEZWZhdWx0LCByZXNvbHZlT2JqZWN0S2V5LCBzaWduLCBkZWZpbmVkXG59IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG5mdW5jdGlvbiBnZXRBbGxTY2FsZVZhbHVlcyhzY2FsZSwgdHlwZSkge1xuICBpZiAoIXNjYWxlLl9jYWNoZS4kYmFyKSB7XG4gICAgY29uc3QgdmlzaWJsZU1ldGFzID0gc2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModHlwZSk7XG4gICAgbGV0IHZhbHVlcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSB2aXNpYmxlTWV0YXMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHZpc2libGVNZXRhc1tpXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyhzY2FsZSkpO1xuICAgIH1cbiAgICBzY2FsZS5fY2FjaGUuJGJhciA9IF9hcnJheVVuaXF1ZSh2YWx1ZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpKTtcbiAgfVxuICByZXR1cm4gc2NhbGUuX2NhY2hlLiRiYXI7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIFwib3B0aW1hbFwiIHNhbXBsZSBzaXplIHRvIG1haW50YWluIGJhcnMgZXF1YWxseSBzaXplZCB3aGlsZSBwcmV2ZW50aW5nIG92ZXJsYXAuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb21wdXRlTWluU2FtcGxlU2l6ZShtZXRhKSB7XG4gIGNvbnN0IHNjYWxlID0gbWV0YS5pU2NhbGU7XG4gIGNvbnN0IHZhbHVlcyA9IGdldEFsbFNjYWxlVmFsdWVzKHNjYWxlLCBtZXRhLnR5cGUpO1xuICBsZXQgbWluID0gc2NhbGUuX2xlbmd0aDtcbiAgbGV0IGksIGlsZW4sIGN1cnIsIHByZXY7XG4gIGNvbnN0IHVwZGF0ZU1pbkFuZFByZXYgPSAoKSA9PiB7XG4gICAgaWYgKGN1cnIgPT09IDMyNzY3IHx8IGN1cnIgPT09IC0zMjc2OCkge1xuICAgICAgLy8gSWdub3JlIHRydW5jYXRlZCBwaXhlbHNcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRlZmluZWQocHJldikpIHtcbiAgICAgIC8vIGN1cnIgLSBwcmV2ID09PSAwIGlzIGlnbm9yZWRcbiAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgTWF0aC5hYnMoY3VyciAtIHByZXYpIHx8IG1pbik7XG4gICAgfVxuICAgIHByZXYgPSBjdXJyO1xuICB9O1xuXG4gIGZvciAoaSA9IDAsIGlsZW4gPSB2YWx1ZXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY3VyciA9IHNjYWxlLmdldFBpeGVsRm9yVmFsdWUodmFsdWVzW2ldKTtcbiAgICB1cGRhdGVNaW5BbmRQcmV2KCk7XG4gIH1cblxuICBwcmV2ID0gdW5kZWZpbmVkO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gc2NhbGUudGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY3VyciA9IHNjYWxlLmdldFBpeGVsRm9yVGljayhpKTtcbiAgICB1cGRhdGVNaW5BbmRQcmV2KCk7XG4gIH1cblxuICByZXR1cm4gbWluO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIGFuIFwiaWRlYWxcIiBjYXRlZ29yeSBiYXNlZCBvbiB0aGUgYWJzb2x1dGUgYmFyIHRoaWNrbmVzcyBvciwgaWYgdW5kZWZpbmVkIG9yIG51bGwsXG4gKiB1c2VzIHRoZSBzbWFsbGVzdCBpbnRlcnZhbCAoc2VlIGNvbXB1dGVNaW5TYW1wbGVTaXplKSB0aGF0IHByZXZlbnRzIGJhciBvdmVybGFwcGluZy4gVGhpc1xuICogbW9kZSBjdXJyZW50bHkgYWx3YXlzIGdlbmVyYXRlcyBiYXJzIGVxdWFsbHkgc2l6ZWQgKHVudGlsIHdlIGludHJvZHVjZSBzY3JpcHRhYmxlIG9wdGlvbnM/KS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpIHtcbiAgY29uc3QgdGhpY2tuZXNzID0gb3B0aW9ucy5iYXJUaGlja25lc3M7XG4gIGxldCBzaXplLCByYXRpbztcblxuICBpZiAoaXNOdWxsT3JVbmRlZih0aGlja25lc3MpKSB7XG4gICAgc2l6ZSA9IHJ1bGVyLm1pbiAqIG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xuICAgIHJhdGlvID0gb3B0aW9ucy5iYXJQZXJjZW50YWdlO1xuICB9IGVsc2Uge1xuICAgIC8vIFdoZW4gYmFyIHRoaWNrbmVzcyBpcyBlbmZvcmNlZCwgY2F0ZWdvcnkgYW5kIGJhciBwZXJjZW50YWdlcyBhcmUgaWdub3JlZC5cbiAgICAvLyBOb3RlKFNCKTogd2UgY291bGQgYWRkIHN1cHBvcnQgZm9yIHJlbGF0aXZlIGJhciB0aGlja25lc3MgKGUuZy4gYmFyVGhpY2tuZXNzOiAnNTAlJylcbiAgICAvLyBhbmQgZGVwcmVjYXRlIGJhclBlcmNlbnRhZ2Ugc2luY2UgdGhpcyB2YWx1ZSBpcyBpZ25vcmVkIHdoZW4gdGhpY2tuZXNzIGlzIGFic29sdXRlLlxuICAgIHNpemUgPSB0aGlja25lc3MgKiBzdGFja0NvdW50O1xuICAgIHJhdGlvID0gMTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY2h1bms6IHNpemUgLyBzdGFja0NvdW50LFxuICAgIHJhdGlvLFxuICAgIHN0YXJ0OiBydWxlci5waXhlbHNbaW5kZXhdIC0gKHNpemUgLyAyKVxuICB9O1xufVxuXG4vKipcbiAqIENvbXB1dGVzIGFuIFwib3B0aW1hbFwiIGNhdGVnb3J5IHRoYXQgZ2xvYmFsbHkgYXJyYW5nZXMgYmFycyBzaWRlIGJ5IHNpZGUgKG5vIGdhcCB3aGVuXG4gKiBwZXJjZW50YWdlIG9wdGlvbnMgYXJlIDEpLCBiYXNlZCBvbiB0aGUgcHJldmlvdXMgYW5kIGZvbGxvd2luZyBjYXRlZ29yaWVzLiBUaGlzIG1vZGVcbiAqIGdlbmVyYXRlcyBiYXJzIHdpdGggZGlmZmVyZW50IHdpZHRocyB3aGVuIGRhdGEgYXJlIG5vdCBldmVubHkgc3BhY2VkLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpIHtcbiAgY29uc3QgcGl4ZWxzID0gcnVsZXIucGl4ZWxzO1xuICBjb25zdCBjdXJyID0gcGl4ZWxzW2luZGV4XTtcbiAgbGV0IHByZXYgPSBpbmRleCA+IDAgPyBwaXhlbHNbaW5kZXggLSAxXSA6IG51bGw7XG4gIGxldCBuZXh0ID0gaW5kZXggPCBwaXhlbHMubGVuZ3RoIC0gMSA/IHBpeGVsc1tpbmRleCArIDFdIDogbnVsbDtcbiAgY29uc3QgcGVyY2VudCA9IG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xuXG4gIGlmIChwcmV2ID09PSBudWxsKSB7XG4gICAgLy8gZmlyc3QgZGF0YTogaXRzIHNpemUgaXMgZG91YmxlIGJhc2VkIG9uIHRoZSBuZXh0IHBvaW50IG9yLFxuICAgIC8vIGlmIGl0J3MgYWxzbyB0aGUgbGFzdCBkYXRhLCB3ZSB1c2UgdGhlIHNjYWxlIHNpemUuXG4gICAgcHJldiA9IGN1cnIgLSAobmV4dCA9PT0gbnVsbCA/IHJ1bGVyLmVuZCAtIHJ1bGVyLnN0YXJ0IDogbmV4dCAtIGN1cnIpO1xuICB9XG5cbiAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAvLyBsYXN0IGRhdGE6IGl0cyBzaXplIGlzIGFsc28gZG91YmxlIGJhc2VkIG9uIHRoZSBwcmV2aW91cyBwb2ludC5cbiAgICBuZXh0ID0gY3VyciArIGN1cnIgLSBwcmV2O1xuICB9XG5cbiAgY29uc3Qgc3RhcnQgPSBjdXJyIC0gKGN1cnIgLSBNYXRoLm1pbihwcmV2LCBuZXh0KSkgLyAyICogcGVyY2VudDtcbiAgY29uc3Qgc2l6ZSA9IE1hdGguYWJzKG5leHQgLSBwcmV2KSAvIDIgKiBwZXJjZW50O1xuXG4gIHJldHVybiB7XG4gICAgY2h1bms6IHNpemUgLyBzdGFja0NvdW50LFxuICAgIHJhdGlvOiBvcHRpb25zLmJhclBlcmNlbnRhZ2UsXG4gICAgc3RhcnRcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VGbG9hdEJhcihlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKSB7XG4gIGNvbnN0IHN0YXJ0VmFsdWUgPSB2U2NhbGUucGFyc2UoZW50cnlbMF0sIGkpO1xuICBjb25zdCBlbmRWYWx1ZSA9IHZTY2FsZS5wYXJzZShlbnRyeVsxXSwgaSk7XG4gIGNvbnN0IG1pbiA9IE1hdGgubWluKHN0YXJ0VmFsdWUsIGVuZFZhbHVlKTtcbiAgY29uc3QgbWF4ID0gTWF0aC5tYXgoc3RhcnRWYWx1ZSwgZW5kVmFsdWUpO1xuICBsZXQgYmFyU3RhcnQgPSBtaW47XG4gIGxldCBiYXJFbmQgPSBtYXg7XG5cbiAgaWYgKE1hdGguYWJzKG1pbikgPiBNYXRoLmFicyhtYXgpKSB7XG4gICAgYmFyU3RhcnQgPSBtYXg7XG4gICAgYmFyRW5kID0gbWluO1xuICB9XG5cbiAgLy8gU3RvcmUgYGJhckVuZGAgKGZ1cnRoZXN0IGF3YXkgZnJvbSBvcmlnaW4pIGFzIHBhcnNlZCB2YWx1ZSxcbiAgLy8gdG8gbWFrZSBzdGFja2luZyBzdHJhaWdodCBmb3J3YXJkXG4gIGl0ZW1bdlNjYWxlLmF4aXNdID0gYmFyRW5kO1xuXG4gIGl0ZW0uX2N1c3RvbSA9IHtcbiAgICBiYXJTdGFydCxcbiAgICBiYXJFbmQsXG4gICAgc3RhcnQ6IHN0YXJ0VmFsdWUsXG4gICAgZW5kOiBlbmRWYWx1ZSxcbiAgICBtaW4sXG4gICAgbWF4XG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlVmFsdWUoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSkge1xuICBpZiAoaXNBcnJheShlbnRyeSkpIHtcbiAgICBwYXJzZUZsb2F0QmFyKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpO1xuICB9IGVsc2Uge1xuICAgIGl0ZW1bdlNjYWxlLmF4aXNdID0gdlNjYWxlLnBhcnNlKGVudHJ5LCBpKTtcbiAgfVxuICByZXR1cm4gaXRlbTtcbn1cblxuZnVuY3Rpb24gcGFyc2VBcnJheU9yUHJpbWl0aXZlKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICBjb25zdCBpU2NhbGUgPSBtZXRhLmlTY2FsZTtcbiAgY29uc3QgdlNjYWxlID0gbWV0YS52U2NhbGU7XG4gIGNvbnN0IGxhYmVscyA9IGlTY2FsZS5nZXRMYWJlbHMoKTtcbiAgY29uc3Qgc2luZ2xlU2NhbGUgPSBpU2NhbGUgPT09IHZTY2FsZTtcbiAgY29uc3QgcGFyc2VkID0gW107XG4gIGxldCBpLCBpbGVuLCBpdGVtLCBlbnRyeTtcblxuICBmb3IgKGkgPSBzdGFydCwgaWxlbiA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBlbnRyeSA9IGRhdGFbaV07XG4gICAgaXRlbSA9IHt9O1xuICAgIGl0ZW1baVNjYWxlLmF4aXNdID0gc2luZ2xlU2NhbGUgfHwgaVNjYWxlLnBhcnNlKGxhYmVsc1tpXSwgaSk7XG4gICAgcGFyc2VkLnB1c2gocGFyc2VWYWx1ZShlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn1cblxuZnVuY3Rpb24gaXNGbG9hdEJhcihjdXN0b20pIHtcbiAgcmV0dXJuIGN1c3RvbSAmJiBjdXN0b20uYmFyU3RhcnQgIT09IHVuZGVmaW5lZCAmJiBjdXN0b20uYmFyRW5kICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGJhclNpZ24oc2l6ZSwgdlNjYWxlLCBhY3R1YWxCYXNlKSB7XG4gIGlmIChzaXplICE9PSAwKSB7XG4gICAgcmV0dXJuIHNpZ24oc2l6ZSk7XG4gIH1cbiAgcmV0dXJuICh2U2NhbGUuaXNIb3Jpem9udGFsKCkgPyAxIDogLTEpICogKHZTY2FsZS5taW4gPj0gYWN0dWFsQmFzZSA/IDEgOiAtMSk7XG59XG5cbmZ1bmN0aW9uIGJvcmRlclByb3BzKHByb3BlcnRpZXMpIHtcbiAgbGV0IHJldmVyc2UsIHN0YXJ0LCBlbmQsIHRvcCwgYm90dG9tO1xuICBpZiAocHJvcGVydGllcy5ob3Jpem9udGFsKSB7XG4gICAgcmV2ZXJzZSA9IHByb3BlcnRpZXMuYmFzZSA+IHByb3BlcnRpZXMueDtcbiAgICBzdGFydCA9ICdsZWZ0JztcbiAgICBlbmQgPSAncmlnaHQnO1xuICB9IGVsc2Uge1xuICAgIHJldmVyc2UgPSBwcm9wZXJ0aWVzLmJhc2UgPCBwcm9wZXJ0aWVzLnk7XG4gICAgc3RhcnQgPSAnYm90dG9tJztcbiAgICBlbmQgPSAndG9wJztcbiAgfVxuICBpZiAocmV2ZXJzZSkge1xuICAgIHRvcCA9ICdlbmQnO1xuICAgIGJvdHRvbSA9ICdzdGFydCc7XG4gIH0gZWxzZSB7XG4gICAgdG9wID0gJ3N0YXJ0JztcbiAgICBib3R0b20gPSAnZW5kJztcbiAgfVxuICByZXR1cm4ge3N0YXJ0LCBlbmQsIHJldmVyc2UsIHRvcCwgYm90dG9tfTtcbn1cblxuZnVuY3Rpb24gc2V0Qm9yZGVyU2tpcHBlZChwcm9wZXJ0aWVzLCBvcHRpb25zLCBzdGFjaywgaW5kZXgpIHtcbiAgbGV0IGVkZ2UgPSBvcHRpb25zLmJvcmRlclNraXBwZWQ7XG4gIGNvbnN0IHJlcyA9IHt9O1xuXG4gIGlmICghZWRnZSkge1xuICAgIHByb3BlcnRpZXMuYm9yZGVyU2tpcHBlZCA9IHJlcztcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZWRnZSA9PT0gdHJ1ZSkge1xuICAgIHByb3BlcnRpZXMuYm9yZGVyU2tpcHBlZCA9IHt0b3A6IHRydWUsIHJpZ2h0OiB0cnVlLCBib3R0b206IHRydWUsIGxlZnQ6IHRydWV9O1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHtzdGFydCwgZW5kLCByZXZlcnNlLCB0b3AsIGJvdHRvbX0gPSBib3JkZXJQcm9wcyhwcm9wZXJ0aWVzKTtcblxuICBpZiAoZWRnZSA9PT0gJ21pZGRsZScgJiYgc3RhY2spIHtcbiAgICBwcm9wZXJ0aWVzLmVuYWJsZUJvcmRlclJhZGl1cyA9IHRydWU7XG4gICAgaWYgKChzdGFjay5fdG9wIHx8IDApID09PSBpbmRleCkge1xuICAgICAgZWRnZSA9IHRvcDtcbiAgICB9IGVsc2UgaWYgKChzdGFjay5fYm90dG9tIHx8IDApID09PSBpbmRleCkge1xuICAgICAgZWRnZSA9IGJvdHRvbTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW3BhcnNlRWRnZShib3R0b20sIHN0YXJ0LCBlbmQsIHJldmVyc2UpXSA9IHRydWU7XG4gICAgICBlZGdlID0gdG9wO1xuICAgIH1cbiAgfVxuXG4gIHJlc1twYXJzZUVkZ2UoZWRnZSwgc3RhcnQsIGVuZCwgcmV2ZXJzZSldID0gdHJ1ZTtcbiAgcHJvcGVydGllcy5ib3JkZXJTa2lwcGVkID0gcmVzO1xufVxuXG5mdW5jdGlvbiBwYXJzZUVkZ2UoZWRnZSwgYSwgYiwgcmV2ZXJzZSkge1xuICBpZiAocmV2ZXJzZSkge1xuICAgIGVkZ2UgPSBzd2FwKGVkZ2UsIGEsIGIpO1xuICAgIGVkZ2UgPSBzdGFydEVuZChlZGdlLCBiLCBhKTtcbiAgfSBlbHNlIHtcbiAgICBlZGdlID0gc3RhcnRFbmQoZWRnZSwgYSwgYik7XG4gIH1cbiAgcmV0dXJuIGVkZ2U7XG59XG5cbmZ1bmN0aW9uIHN3YXAob3JpZywgdjEsIHYyKSB7XG4gIHJldHVybiBvcmlnID09PSB2MSA/IHYyIDogb3JpZyA9PT0gdjIgPyB2MSA6IG9yaWc7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0RW5kKHYsIHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIHYgPT09ICdzdGFydCcgPyBzdGFydCA6IHYgPT09ICdlbmQnID8gZW5kIDogdjtcbn1cblxuZnVuY3Rpb24gc2V0SW5mbGF0ZUFtb3VudChwcm9wZXJ0aWVzLCB7aW5mbGF0ZUFtb3VudH0sIHJhdGlvKSB7XG4gIHByb3BlcnRpZXMuaW5mbGF0ZUFtb3VudCA9IGluZmxhdGVBbW91bnQgPT09ICdhdXRvJ1xuICAgID8gcmF0aW8gPT09IDEgPyAwLjMzIDogMFxuICAgIDogaW5mbGF0ZUFtb3VudDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFyQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcblxuICBzdGF0aWMgaWQgPSAnYmFyJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICAgIGRhdGFFbGVtZW50VHlwZTogJ2JhcicsXG5cbiAgICBjYXRlZ29yeVBlcmNlbnRhZ2U6IDAuOCxcbiAgICBiYXJQZXJjZW50YWdlOiAwLjksXG4gICAgZ3JvdXBlZDogdHJ1ZSxcblxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ2Jhc2UnLCAnd2lkdGgnLCAnaGVpZ2h0J11cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuICAgIHNjYWxlczoge1xuICAgICAgX2luZGV4Xzoge1xuICAgICAgICB0eXBlOiAnY2F0ZWdvcnknLFxuICAgICAgICBvZmZzZXQ6IHRydWUsXG4gICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICBvZmZzZXQ6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF92YWx1ZV86IHtcbiAgICAgICAgdHlwZTogJ2xpbmVhcicsXG4gICAgICAgIGJlZ2luQXRaZXJvOiB0cnVlLFxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuXHQgKiBPdmVycmlkaW5nIHByaW1pdGl2ZSBkYXRhIHBhcnNpbmcgc2luY2Ugd2Ugc3VwcG9ydCBtaXhlZCBwcmltaXRpdmUvYXJyYXlcblx0ICogZGF0YSBmb3IgZmxvYXQgYmFyc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgcmV0dXJuIHBhcnNlQXJyYXlPclByaW1pdGl2ZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIE92ZXJyaWRpbmcgYXJyYXkgZGF0YSBwYXJzaW5nIHNpbmNlIHdlIHN1cHBvcnQgbWl4ZWQgcHJpbWl0aXZlL2FycmF5XG5cdCAqIGRhdGEgZm9yIGZsb2F0IGJhcnNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgcmV0dXJuIHBhcnNlQXJyYXlPclByaW1pdGl2ZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIE92ZXJyaWRpbmcgb2JqZWN0IGRhdGEgcGFyc2luZyBzaW5jZSB3ZSBzdXBwb3J0IG1peGVkIHByaW1pdGl2ZS9hcnJheVxuXHQgKiB2YWx1ZS1zY2FsZSBkYXRhIGZvciBmbG9hdCBiYXJzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCB7eEF4aXNLZXkgPSAneCcsIHlBeGlzS2V5ID0gJ3knfSA9IHRoaXMuX3BhcnNpbmc7XG4gICAgY29uc3QgaUF4aXNLZXkgPSBpU2NhbGUuYXhpcyA9PT0gJ3gnID8geEF4aXNLZXkgOiB5QXhpc0tleTtcbiAgICBjb25zdCB2QXhpc0tleSA9IHZTY2FsZS5heGlzID09PSAneCcgPyB4QXhpc0tleSA6IHlBeGlzS2V5O1xuICAgIGNvbnN0IHBhcnNlZCA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCBpdGVtLCBvYmo7XG4gICAgZm9yIChpID0gc3RhcnQsIGlsZW4gPSBzdGFydCArIGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBvYmogPSBkYXRhW2ldO1xuICAgICAgaXRlbSA9IHt9O1xuICAgICAgaXRlbVtpU2NhbGUuYXhpc10gPSBpU2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShvYmosIGlBeGlzS2V5KSwgaSk7XG4gICAgICBwYXJzZWQucHVzaChwYXJzZVZhbHVlKHJlc29sdmVPYmplY3RLZXkob2JqLCB2QXhpc0tleSksIGl0ZW0sIHZTY2FsZSwgaSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spIHtcbiAgICBzdXBlci51cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKTtcbiAgICBjb25zdCBjdXN0b20gPSBwYXJzZWQuX2N1c3RvbTtcbiAgICBpZiAoY3VzdG9tICYmIHNjYWxlID09PSB0aGlzLl9jYWNoZWRNZXRhLnZTY2FsZSkge1xuICAgICAgLy8gZmxvYXQgYmFyOiBvbmx5IG9uZSBlbmQgb2YgdGhlIGJhciBpcyBjb25zaWRlcmVkIGJ5IGBzdXBlcmBcbiAgICAgIHJhbmdlLm1pbiA9IE1hdGgubWluKHJhbmdlLm1pbiwgY3VzdG9tLm1pbik7XG4gICAgICByYW5nZS5tYXggPSBNYXRoLm1heChyYW5nZS5tYXgsIGN1c3RvbS5tYXgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ8Ym9vbGVhbn1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICBjb25zdCBjdXN0b20gPSBwYXJzZWQuX2N1c3RvbTtcbiAgICBjb25zdCB2YWx1ZSA9IGlzRmxvYXRCYXIoY3VzdG9tKVxuICAgICAgPyAnWycgKyBjdXN0b20uc3RhcnQgKyAnLCAnICsgY3VzdG9tLmVuZCArICddJ1xuICAgICAgOiAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiAnJyArIGlTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFtpU2NhbGUuYXhpc10pLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG5cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuXG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuXG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgbWV0YS5zdGFjayA9IHRoaXMuZ2V0RGF0YXNldCgpLnN0YWNrO1xuICB9XG5cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKG1ldGEuZGF0YSwgMCwgbWV0YS5kYXRhLmxlbmd0aCwgbW9kZSk7XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhiYXJzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3Qge2luZGV4LCBfY2FjaGVkTWV0YToge3ZTY2FsZX19ID0gdGhpcztcbiAgICBjb25zdCBiYXNlID0gdlNjYWxlLmdldEJhc2VQaXhlbCgpO1xuICAgIGNvbnN0IGhvcml6b250YWwgPSB2U2NhbGUuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgcnVsZXIgPSB0aGlzLl9nZXRSdWxlcigpO1xuICAgIGNvbnN0IHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc30gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcblxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICBjb25zdCB2cGl4ZWxzID0gcmVzZXQgfHwgaXNOdWxsT3JVbmRlZihwYXJzZWRbdlNjYWxlLmF4aXNdKSA/IHtiYXNlLCBoZWFkOiBiYXNlfSA6IHRoaXMuX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKGkpO1xuICAgICAgY29uc3QgaXBpeGVscyA9IHRoaXMuX2NhbGN1bGF0ZUJhckluZGV4UGl4ZWxzKGksIHJ1bGVyKTtcbiAgICAgIGNvbnN0IHN0YWNrID0gKHBhcnNlZC5fc3RhY2tzIHx8IHt9KVt2U2NhbGUuYXhpc107XG5cbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIGhvcml6b250YWwsXG4gICAgICAgIGJhc2U6IHZwaXhlbHMuYmFzZSxcbiAgICAgICAgZW5hYmxlQm9yZGVyUmFkaXVzOiAhc3RhY2sgfHwgaXNGbG9hdEJhcihwYXJzZWQuX2N1c3RvbSkgfHwgKGluZGV4ID09PSBzdGFjay5fdG9wIHx8IGluZGV4ID09PSBzdGFjay5fYm90dG9tKSxcbiAgICAgICAgeDogaG9yaXpvbnRhbCA/IHZwaXhlbHMuaGVhZCA6IGlwaXhlbHMuY2VudGVyLFxuICAgICAgICB5OiBob3Jpem9udGFsID8gaXBpeGVscy5jZW50ZXIgOiB2cGl4ZWxzLmhlYWQsXG4gICAgICAgIGhlaWdodDogaG9yaXpvbnRhbCA/IGlwaXhlbHMuc2l6ZSA6IE1hdGguYWJzKHZwaXhlbHMuc2l6ZSksXG4gICAgICAgIHdpZHRoOiBob3Jpem9udGFsID8gTWF0aC5hYnModnBpeGVscy5zaXplKSA6IGlwaXhlbHMuc2l6ZVxuICAgICAgfTtcblxuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIGJhcnNbaV0uYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBwcm9wZXJ0aWVzLm9wdGlvbnMgfHwgYmFyc1tpXS5vcHRpb25zO1xuICAgICAgc2V0Qm9yZGVyU2tpcHBlZChwcm9wZXJ0aWVzLCBvcHRpb25zLCBzdGFjaywgaW5kZXgpO1xuICAgICAgc2V0SW5mbGF0ZUFtb3VudChwcm9wZXJ0aWVzLCBvcHRpb25zLCBydWxlci5yYXRpbyk7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoYmFyc1tpXSwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIHN0YWNrcyBiYXNlZCBvbiBncm91cHMgYW5kIGJhciB2aXNpYmlsaXR5LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2xhc3RdIC0gVGhlIGRhdGFzZXQgaW5kZXhcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtkYXRhSW5kZXhdIC0gVGhlIGRhdGEgaW5kZXggb2YgdGhlIHJ1bGVyXG5cdCAqIEByZXR1cm5zIHtzdHJpbmdbXX0gVGhlIGxpc3Qgb2Ygc3RhY2sgSURzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0U3RhY2tzKGxhc3QsIGRhdGFJbmRleCkge1xuICAgIGNvbnN0IHtpU2NhbGV9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBtZXRhc2V0cyA9IGlTY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0aGlzLl90eXBlKVxuICAgICAgLmZpbHRlcihtZXRhID0+IG1ldGEuY29udHJvbGxlci5vcHRpb25zLmdyb3VwZWQpO1xuICAgIGNvbnN0IHN0YWNrZWQgPSBpU2NhbGUub3B0aW9ucy5zdGFja2VkO1xuICAgIGNvbnN0IHN0YWNrcyA9IFtdO1xuXG4gICAgY29uc3Qgc2tpcE51bGwgPSAobWV0YSkgPT4ge1xuICAgICAgY29uc3QgcGFyc2VkID0gbWV0YS5jb250cm9sbGVyLmdldFBhcnNlZChkYXRhSW5kZXgpO1xuICAgICAgY29uc3QgdmFsID0gcGFyc2VkICYmIHBhcnNlZFttZXRhLnZTY2FsZS5heGlzXTtcblxuICAgICAgaWYgKGlzTnVsbE9yVW5kZWYodmFsKSB8fCBpc05hTih2YWwpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKGNvbnN0IG1ldGEgb2YgbWV0YXNldHMpIHtcbiAgICAgIGlmIChkYXRhSW5kZXggIT09IHVuZGVmaW5lZCAmJiBza2lwTnVsbChtZXRhKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gc3RhY2tlZCAgIHwgbWV0YS5zdGFja1xuICAgICAgLy8gICAgICAgICAgIHwgZm91bmQgfCBub3QgZm91bmQgfCB1bmRlZmluZWRcbiAgICAgIC8vIGZhbHNlICAgICB8ICAgeCAgIHwgICAgIHggICAgIHwgICAgIHhcbiAgICAgIC8vIHRydWUgICAgICB8ICAgICAgIHwgICAgIHggICAgIHxcbiAgICAgIC8vIHVuZGVmaW5lZCB8ICAgICAgIHwgICAgIHggICAgIHwgICAgIHhcbiAgICAgIGlmIChzdGFja2VkID09PSBmYWxzZSB8fCBzdGFja3MuaW5kZXhPZihtZXRhLnN0YWNrKSA9PT0gLTEgfHxcblx0XHRcdFx0KHN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBtZXRhLnN0YWNrID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHN0YWNrcy5wdXNoKG1ldGEuc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKG1ldGEuaW5kZXggPT09IGxhc3QpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm8gc3RhY2tzPyB0aGF0IG1lYW5zIHRoZXJlIGlzIG5vIHZpc2libGUgZGF0YS4gTGV0J3Mgc3RpbGwgaW5pdGlhbGl6ZSBhbiBgdW5kZWZpbmVkYFxuICAgIC8vIHN0YWNrIHdoZXJlIHBvc3NpYmxlIGludmlzaWJsZSBiYXJzIHdpbGwgYmUgbG9jYXRlZC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNjM2OFxuICAgIGlmICghc3RhY2tzLmxlbmd0aCkge1xuICAgICAgc3RhY2tzLnB1c2godW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhY2tzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIGVmZmVjdGl2ZSBudW1iZXIgb2Ygc3RhY2tzIGJhc2VkIG9uIGdyb3VwcyBhbmQgYmFyIHZpc2liaWxpdHkuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0U3RhY2tDb3VudChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTdGFja3ModW5kZWZpbmVkLCBpbmRleCkubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIHN0YWNrIGluZGV4IGZvciB0aGUgZ2l2ZW4gZGF0YXNldCBiYXNlZCBvbiBncm91cHMgYW5kIGJhciB2aXNpYmlsaXR5LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2RhdGFzZXRJbmRleF0gLSBUaGUgZGF0YXNldCBpbmRleFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdIC0gVGhlIHN0YWNrIG5hbWUgdG8gZmluZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RhdGFJbmRleF1cblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIHN0YWNrIGluZGV4XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0U3RhY2tJbmRleChkYXRhc2V0SW5kZXgsIG5hbWUsIGRhdGFJbmRleCkge1xuICAgIGNvbnN0IHN0YWNrcyA9IHRoaXMuX2dldFN0YWNrcyhkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCk7XG4gICAgY29uc3QgaW5kZXggPSAobmFtZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgPyBzdGFja3MuaW5kZXhPZihuYW1lKVxuICAgICAgOiAtMTsgLy8gaW5kZXhPZiByZXR1cm5zIC0xIGlmIGVsZW1lbnQgaXMgbm90IHByZXNlbnRcblxuICAgIHJldHVybiAoaW5kZXggPT09IC0xKVxuICAgICAgPyBzdGFja3MubGVuZ3RoIC0gMVxuICAgICAgOiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFJ1bGVyKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgaVNjYWxlID0gbWV0YS5pU2NhbGU7XG4gICAgY29uc3QgcGl4ZWxzID0gW107XG4gICAgbGV0IGksIGlsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YS5kYXRhLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgcGl4ZWxzLnB1c2goaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRQYXJzZWQoaSlbaVNjYWxlLmF4aXNdLCBpKSk7XG4gICAgfVxuXG4gICAgY29uc3QgYmFyVGhpY2tuZXNzID0gb3B0cy5iYXJUaGlja25lc3M7XG4gICAgY29uc3QgbWluID0gYmFyVGhpY2tuZXNzIHx8IGNvbXB1dGVNaW5TYW1wbGVTaXplKG1ldGEpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbixcbiAgICAgIHBpeGVscyxcbiAgICAgIHN0YXJ0OiBpU2NhbGUuX3N0YXJ0UGl4ZWwsXG4gICAgICBlbmQ6IGlTY2FsZS5fZW5kUGl4ZWwsXG4gICAgICBzdGFja0NvdW50OiB0aGlzLl9nZXRTdGFja0NvdW50KCksXG4gICAgICBzY2FsZTogaVNjYWxlLFxuICAgICAgZ3JvdXBlZDogb3B0cy5ncm91cGVkLFxuICAgICAgLy8gYmFyIHRoaWNrbmVzcyByYXRpbyB1c2VkIGZvciBub24tZ3JvdXBlZCBiYXJzXG4gICAgICByYXRpbzogYmFyVGhpY2tuZXNzID8gMSA6IG9wdHMuY2F0ZWdvcnlQZXJjZW50YWdlICogb3B0cy5iYXJQZXJjZW50YWdlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBOb3RlOiBwaXhlbCB2YWx1ZXMgYXJlIG5vdCBjbGFtcGVkIHRvIHRoZSBzY2FsZSBhcmVhLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKGluZGV4KSB7XG4gICAgY29uc3Qge19jYWNoZWRNZXRhOiB7dlNjYWxlLCBfc3RhY2tlZCwgaW5kZXg6IGRhdGFzZXRJbmRleH0sIG9wdGlvbnM6IHtiYXNlOiBiYXNlVmFsdWUsIG1pbkJhckxlbmd0aH19ID0gdGhpcztcbiAgICBjb25zdCBhY3R1YWxCYXNlID0gYmFzZVZhbHVlIHx8IDA7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IGN1c3RvbSA9IHBhcnNlZC5fY3VzdG9tO1xuICAgIGNvbnN0IGZsb2F0aW5nID0gaXNGbG9hdEJhcihjdXN0b20pO1xuICAgIGxldCB2YWx1ZSA9IHBhcnNlZFt2U2NhbGUuYXhpc107XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgbGVuZ3RoID0gX3N0YWNrZWQgPyB0aGlzLmFwcGx5U3RhY2sodlNjYWxlLCBwYXJzZWQsIF9zdGFja2VkKSA6IHZhbHVlO1xuICAgIGxldCBoZWFkLCBzaXplO1xuXG4gICAgaWYgKGxlbmd0aCAhPT0gdmFsdWUpIHtcbiAgICAgIHN0YXJ0ID0gbGVuZ3RoIC0gdmFsdWU7XG4gICAgICBsZW5ndGggPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoZmxvYXRpbmcpIHtcbiAgICAgIHZhbHVlID0gY3VzdG9tLmJhclN0YXJ0O1xuICAgICAgbGVuZ3RoID0gY3VzdG9tLmJhckVuZCAtIGN1c3RvbS5iYXJTdGFydDtcbiAgICAgIC8vIGJhcnMgY3Jvc3Npbmcgb3JpZ2luIGFyZSBub3Qgc3RhY2tlZFxuICAgICAgaWYgKHZhbHVlICE9PSAwICYmIHNpZ24odmFsdWUpICE9PSBzaWduKGN1c3RvbS5iYXJFbmQpKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ICs9IHZhbHVlO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0VmFsdWUgPSAhaXNOdWxsT3JVbmRlZihiYXNlVmFsdWUpICYmICFmbG9hdGluZyA/IGJhc2VWYWx1ZSA6IHN0YXJ0O1xuICAgIGxldCBiYXNlID0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoc3RhcnRWYWx1ZSk7XG5cbiAgICBpZiAodGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleCkpIHtcbiAgICAgIGhlYWQgPSB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdGFydCArIGxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdoZW4gbm90IHZpc2libGUsIG5vIGhlaWdodFxuICAgICAgaGVhZCA9IGJhc2U7XG4gICAgfVxuXG4gICAgc2l6ZSA9IGhlYWQgLSBiYXNlO1xuXG4gICAgaWYgKE1hdGguYWJzKHNpemUpIDwgbWluQmFyTGVuZ3RoKSB7XG4gICAgICBzaXplID0gYmFyU2lnbihzaXplLCB2U2NhbGUsIGFjdHVhbEJhc2UpICogbWluQmFyTGVuZ3RoO1xuICAgICAgaWYgKHZhbHVlID09PSBhY3R1YWxCYXNlKSB7XG4gICAgICAgIGJhc2UgLT0gc2l6ZSAvIDI7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGFydFBpeGVsID0gdlNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgwKTtcbiAgICAgIGNvbnN0IGVuZFBpeGVsID0gdlNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgxKTtcbiAgICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKHN0YXJ0UGl4ZWwsIGVuZFBpeGVsKTtcbiAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHN0YXJ0UGl4ZWwsIGVuZFBpeGVsKTtcbiAgICAgIGJhc2UgPSBNYXRoLm1heChNYXRoLm1pbihiYXNlLCBtYXgpLCBtaW4pO1xuICAgICAgaGVhZCA9IGJhc2UgKyBzaXplO1xuXG4gICAgICBpZiAoX3N0YWNrZWQgJiYgIWZsb2F0aW5nKSB7XG4gICAgICAgIC8vIHZpc3VhbCBkYXRhIGNvb3JkaW5hdGVzIGFmdGVyIGFwcGx5aW5nIG1pbkJhckxlbmd0aFxuICAgICAgICBwYXJzZWQuX3N0YWNrc1t2U2NhbGUuYXhpc10uX3Zpc3VhbFZhbHVlc1tkYXRhc2V0SW5kZXhdID0gdlNjYWxlLmdldFZhbHVlRm9yUGl4ZWwoaGVhZCkgLSB2U2NhbGUuZ2V0VmFsdWVGb3JQaXhlbChiYXNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoYWN0dWFsQmFzZSkpIHtcbiAgICAgIGNvbnN0IGhhbGZHcmlkID0gc2lnbihzaXplKSAqIHZTY2FsZS5nZXRMaW5lV2lkdGhGb3JWYWx1ZShhY3R1YWxCYXNlKSAvIDI7XG4gICAgICBiYXNlICs9IGhhbGZHcmlkO1xuICAgICAgc2l6ZSAtPSBoYWxmR3JpZDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc2l6ZSxcbiAgICAgIGJhc2UsXG4gICAgICBoZWFkLFxuICAgICAgY2VudGVyOiBoZWFkICsgc2l6ZSAvIDJcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY2FsY3VsYXRlQmFySW5kZXhQaXhlbHMoaW5kZXgsIHJ1bGVyKSB7XG4gICAgY29uc3Qgc2NhbGUgPSBydWxlci5zY2FsZTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHNraXBOdWxsID0gb3B0aW9ucy5za2lwTnVsbDtcbiAgICBjb25zdCBtYXhCYXJUaGlja25lc3MgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLm1heEJhclRoaWNrbmVzcywgSW5maW5pdHkpO1xuICAgIGxldCBjZW50ZXIsIHNpemU7XG4gICAgaWYgKHJ1bGVyLmdyb3VwZWQpIHtcbiAgICAgIGNvbnN0IHN0YWNrQ291bnQgPSBza2lwTnVsbCA/IHRoaXMuX2dldFN0YWNrQ291bnQoaW5kZXgpIDogcnVsZXIuc3RhY2tDb3VudDtcbiAgICAgIGNvbnN0IHJhbmdlID0gb3B0aW9ucy5iYXJUaGlja25lc3MgPT09ICdmbGV4J1xuICAgICAgICA/IGNvbXB1dGVGbGV4Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50KVxuICAgICAgICA6IGNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpO1xuXG4gICAgICBjb25zdCBzdGFja0luZGV4ID0gdGhpcy5fZ2V0U3RhY2tJbmRleCh0aGlzLmluZGV4LCB0aGlzLl9jYWNoZWRNZXRhLnN0YWNrLCBza2lwTnVsbCA/IGluZGV4IDogdW5kZWZpbmVkKTtcbiAgICAgIGNlbnRlciA9IHJhbmdlLnN0YXJ0ICsgKHJhbmdlLmNodW5rICogc3RhY2tJbmRleCkgKyAocmFuZ2UuY2h1bmsgLyAyKTtcbiAgICAgIHNpemUgPSBNYXRoLm1pbihtYXhCYXJUaGlja25lc3MsIHJhbmdlLmNodW5rICogcmFuZ2UucmF0aW8pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3Igbm9uLWdyb3VwZWQgYmFyIGNoYXJ0cywgZXhhY3QgcGl4ZWwgdmFsdWVzIGFyZSB1c2VkXG4gICAgICBjZW50ZXIgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0UGFyc2VkKGluZGV4KVtzY2FsZS5heGlzXSwgaW5kZXgpO1xuICAgICAgc2l6ZSA9IE1hdGgubWluKG1heEJhclRoaWNrbmVzcywgcnVsZXIubWluICogcnVsZXIucmF0aW8pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBiYXNlOiBjZW50ZXIgLSBzaXplIC8gMixcbiAgICAgIGhlYWQ6IGNlbnRlciArIHNpemUgLyAyLFxuICAgICAgY2VudGVyLFxuICAgICAgc2l6ZVxuICAgIH07XG4gIH1cblxuICBkcmF3KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHZTY2FsZSA9IG1ldGEudlNjYWxlO1xuICAgIGNvbnN0IHJlY3RzID0gbWV0YS5kYXRhO1xuICAgIGNvbnN0IGlsZW4gPSByZWN0cy5sZW5ndGg7XG4gICAgbGV0IGkgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGlmICh0aGlzLmdldFBhcnNlZChpKVt2U2NhbGUuYXhpc10gIT09IG51bGwpIHtcbiAgICAgICAgcmVjdHNbaV0uZHJhdyh0aGlzLl9jdHgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59XG4iLCAiaW1wb3J0IERhdGFzZXRDb250cm9sbGVyIGZyb20gJy4uL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyc7XG5pbXBvcnQge3ZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJ1YmJsZUNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ2J1YmJsZSc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcbiAgICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG5cbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBudW1iZXJzOiB7XG4gICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICdib3JkZXJXaWR0aCcsICdyYWRpdXMnXVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBvdmVycmlkZXMgPSB7XG4gICAgc2NhbGVzOiB7XG4gICAgICB4OiB7XG4gICAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgICB9LFxuICAgICAgeToge1xuICAgICAgICB0eXBlOiAnbGluZWFyJ1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBpbml0aWFsaXplKCkge1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFBhcnNlIGFycmF5IG9mIHByaW1pdGl2ZSB2YWx1ZXNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHN1cGVyLnBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwYXJzZWRbaV0uX2N1c3RvbSA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpICsgc3RhcnQpLnJhZGl1cztcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBQYXJzZSBhcnJheSBvZiBhcnJheXNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgcGFyc2VkID0gc3VwZXIucGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IGRhdGFbc3RhcnQgKyBpXTtcbiAgICAgIHBhcnNlZFtpXS5fY3VzdG9tID0gdmFsdWVPckRlZmF1bHQoaXRlbVsyXSwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkgKyBzdGFydCkucmFkaXVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBQYXJzZSBhcnJheSBvZiBvYmplY3RzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdXBlci5wYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IGRhdGFbc3RhcnQgKyBpXTtcbiAgICAgIHBhcnNlZFtpXS5fY3VzdG9tID0gdmFsdWVPckRlZmF1bHQoaXRlbSAmJiBpdGVtLnIgJiYgK2l0ZW0uciwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkgKyBzdGFydCkucmFkaXVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuXG4gICAgbGV0IG1heCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgZGF0YVtpXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKSkgLyAyKTtcbiAgICB9XG4gICAgcmV0dXJuIG1heCA+IDAgJiYgbWF4O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmNoYXJ0LmRhdGEubGFiZWxzIHx8IFtdO1xuICAgIGNvbnN0IHt4U2NhbGUsIHlTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICBjb25zdCB4ID0geFNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkLngpO1xuICAgIGNvbnN0IHkgPSB5U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWQueSk7XG4gICAgY29uc3QgciA9IHBhcnNlZC5fY3VzdG9tO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBsYWJlbHNbaW5kZXhdIHx8ICcnLFxuICAgICAgdmFsdWU6ICcoJyArIHggKyAnLCAnICsgeSArIChyID8gJywgJyArIHIgOiAnJykgKyAnKSdcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGE7XG5cbiAgICAvLyBVcGRhdGUgUG9pbnRzXG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIDAsIHBvaW50cy5sZW5ndGgsIG1vZGUpO1xuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlfSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfSA9IHRoaXMuX2dldFNoYXJlZE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcblxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBwYXJzZWQgPSAhcmVzZXQgJiYgdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge307XG4gICAgICBjb25zdCBpUGl4ZWwgPSBwcm9wZXJ0aWVzW2lBeGlzXSA9IHJlc2V0ID8gaVNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgwLjUpIDogaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW2lBeGlzXSk7XG4gICAgICBjb25zdCB2UGl4ZWwgPSBwcm9wZXJ0aWVzW3ZBeGlzXSA9IHJlc2V0ID8gdlNjYWxlLmdldEJhc2VQaXhlbCgpIDogdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW3ZBeGlzXSk7XG5cbiAgICAgIHByb3BlcnRpZXMuc2tpcCA9IGlzTmFOKGlQaXhlbCkgfHwgaXNOYU4odlBpeGVsKTtcblxuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG5cbiAgICAgICAgaWYgKHJlc2V0KSB7XG4gICAgICAgICAgcHJvcGVydGllcy5vcHRpb25zLnJhZGl1cyA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbbW9kZV1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICBsZXQgdmFsdWVzID0gc3VwZXIucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSk7XG5cbiAgICAvLyBJbiBjYXNlIHZhbHVlcyB3ZXJlIGNhY2hlZCAoYW5kIHRodXMgZnJvemVuKSwgd2UgbmVlZCB0byBjbG9uZSB0aGUgdmFsdWVzXG4gICAgaWYgKHZhbHVlcy4kc2hhcmVkKSB7XG4gICAgICB2YWx1ZXMgPSBPYmplY3QuYXNzaWduKHt9LCB2YWx1ZXMsIHskc2hhcmVkOiBmYWxzZX0pO1xuICAgIH1cblxuICAgIC8vIEN1c3RvbSByYWRpdXMgcmVzb2x1dGlvblxuICAgIGNvbnN0IHJhZGl1cyA9IHZhbHVlcy5yYWRpdXM7XG4gICAgaWYgKG1vZGUgIT09ICdhY3RpdmUnKSB7XG4gICAgICB2YWx1ZXMucmFkaXVzID0gMDtcbiAgICB9XG4gICAgdmFsdWVzLnJhZGl1cyArPSB2YWx1ZU9yRGVmYXVsdChwYXJzZWQgJiYgcGFyc2VkLl9jdXN0b20sIHJhZGl1cyk7XG5cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG59XG4iLCAiaW1wb3J0IERhdGFzZXRDb250cm9sbGVyIGZyb20gJy4uL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyc7XG5pbXBvcnQge2lzT2JqZWN0LCByZXNvbHZlT2JqZWN0S2V5LCB0b1BlcmNlbnRhZ2UsIHRvRGltZW5zaW9uLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtmb3JtYXROdW1iZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5pbnRsLmpzJztcbmltcG9ydCB7dG9SYWRpYW5zLCBQSSwgVEFVLCBIQUxGX1BJLCBfYW5nbGVCZXR3ZWVufSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL2NvcmUvY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKi9cblxuZnVuY3Rpb24gZ2V0UmF0aW9BbmRPZmZzZXQocm90YXRpb24sIGNpcmN1bWZlcmVuY2UsIGN1dG91dCkge1xuICBsZXQgcmF0aW9YID0gMTtcbiAgbGV0IHJhdGlvWSA9IDE7XG4gIGxldCBvZmZzZXRYID0gMDtcbiAgbGV0IG9mZnNldFkgPSAwO1xuICAvLyBJZiB0aGUgY2hhcnQncyBjaXJjdW1mZXJlbmNlIGlzbid0IGEgZnVsbCBjaXJjbGUsIGNhbGN1bGF0ZSBzaXplIGFzIGEgcmF0aW8gb2YgdGhlIHdpZHRoL2hlaWdodCBvZiB0aGUgYXJjXG4gIGlmIChjaXJjdW1mZXJlbmNlIDwgVEFVKSB7XG4gICAgY29uc3Qgc3RhcnRBbmdsZSA9IHJvdGF0aW9uO1xuICAgIGNvbnN0IGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2U7XG4gICAgY29uc3Qgc3RhcnRYID0gTWF0aC5jb3Moc3RhcnRBbmdsZSk7XG4gICAgY29uc3Qgc3RhcnRZID0gTWF0aC5zaW4oc3RhcnRBbmdsZSk7XG4gICAgY29uc3QgZW5kWCA9IE1hdGguY29zKGVuZEFuZ2xlKTtcbiAgICBjb25zdCBlbmRZID0gTWF0aC5zaW4oZW5kQW5nbGUpO1xuICAgIGNvbnN0IGNhbGNNYXggPSAoYW5nbGUsIGEsIGIpID0+IF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCB0cnVlKSA/IDEgOiBNYXRoLm1heChhLCBhICogY3V0b3V0LCBiLCBiICogY3V0b3V0KTtcbiAgICBjb25zdCBjYWxjTWluID0gKGFuZ2xlLCBhLCBiKSA9PiBfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgdHJ1ZSkgPyAtMSA6IE1hdGgubWluKGEsIGEgKiBjdXRvdXQsIGIsIGIgKiBjdXRvdXQpO1xuICAgIGNvbnN0IG1heFggPSBjYWxjTWF4KDAsIHN0YXJ0WCwgZW5kWCk7XG4gICAgY29uc3QgbWF4WSA9IGNhbGNNYXgoSEFMRl9QSSwgc3RhcnRZLCBlbmRZKTtcbiAgICBjb25zdCBtaW5YID0gY2FsY01pbihQSSwgc3RhcnRYLCBlbmRYKTtcbiAgICBjb25zdCBtaW5ZID0gY2FsY01pbihQSSArIEhBTEZfUEksIHN0YXJ0WSwgZW5kWSk7XG4gICAgcmF0aW9YID0gKG1heFggLSBtaW5YKSAvIDI7XG4gICAgcmF0aW9ZID0gKG1heFkgLSBtaW5ZKSAvIDI7XG4gICAgb2Zmc2V0WCA9IC0obWF4WCArIG1pblgpIC8gMjtcbiAgICBvZmZzZXRZID0gLShtYXhZICsgbWluWSkgLyAyO1xuICB9XG4gIHJldHVybiB7cmF0aW9YLCByYXRpb1ksIG9mZnNldFgsIG9mZnNldFl9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEb3VnaG51dENvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ2RvdWdobnV0JztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICAgIGRhdGFFbGVtZW50VHlwZTogJ2FyYycsXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICAvLyBCb29sZWFuIC0gV2hldGhlciB3ZSBhbmltYXRlIHRoZSByb3RhdGlvbiBvZiB0aGUgRG91Z2hudXRcbiAgICAgIGFuaW1hdGVSb3RhdGU6IHRydWUsXG4gICAgICAvLyBCb29sZWFuIC0gV2hldGhlciB3ZSBhbmltYXRlIHNjYWxpbmcgdGhlIERvdWdobnV0IGZyb20gdGhlIGNlbnRyZVxuICAgICAgYW5pbWF0ZVNjYWxlOiBmYWxzZVxuICAgIH0sXG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgbnVtYmVyczoge1xuICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgcHJvcGVydGllczogWydjaXJjdW1mZXJlbmNlJywgJ2VuZEFuZ2xlJywgJ2lubmVyUmFkaXVzJywgJ291dGVyUmFkaXVzJywgJ3N0YXJ0QW5nbGUnLCAneCcsICd5JywgJ29mZnNldCcsICdib3JkZXJXaWR0aCcsICdzcGFjaW5nJ11cbiAgICAgIH0sXG4gICAgfSxcbiAgICAvLyBUaGUgcGVyY2VudGFnZSBvZiB0aGUgY2hhcnQgdGhhdCB3ZSBjdXQgb3V0IG9mIHRoZSBtaWRkbGUuXG4gICAgY3V0b3V0OiAnNTAlJyxcblxuICAgIC8vIFRoZSByb3RhdGlvbiBvZiB0aGUgY2hhcnQsIHdoZXJlIHRoZSBmaXJzdCBkYXRhIGFyYyBiZWdpbnMuXG4gICAgcm90YXRpb246IDAsXG5cbiAgICAvLyBUaGUgdG90YWwgY2lyY3VtZmVyZW5jZSBvZiB0aGUgY2hhcnQuXG4gICAgY2lyY3VtZmVyZW5jZTogMzYwLFxuXG4gICAgLy8gVGhlIG91dGVyIHJhZGl1cyBvZiB0aGUgY2hhcnRcbiAgICByYWRpdXM6ICcxMDAlJyxcblxuICAgIC8vIFNwYWNpbmcgYmV0d2VlbiBhcmNzXG4gICAgc3BhY2luZzogMCxcblxuICAgIGluZGV4QXhpczogJ3InLFxuICB9O1xuXG4gIHN0YXRpYyBkZXNjcmlwdG9ycyA9IHtcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdzcGFjaW5nJyxcbiAgICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ3NwYWNpbmcnICYmICFuYW1lLnN0YXJ0c1dpdGgoJ2JvcmRlckRhc2gnKSAmJiAhbmFtZS5zdGFydHNXaXRoKCdob3ZlckJvcmRlckRhc2gnKSxcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBvdmVycmlkZXMgPSB7XG4gICAgYXNwZWN0UmF0aW86IDEsXG5cbiAgICAvLyBOZWVkIHRvIG92ZXJyaWRlIHRoZXNlIHRvIGdpdmUgYSBuaWNlIGRlZmF1bHRcbiAgICBwbHVnaW5zOiB7XG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgZ2VuZXJhdGVMYWJlbHMoY2hhcnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBjaGFydC5kYXRhO1xuICAgICAgICAgICAgaWYgKGRhdGEubGFiZWxzLmxlbmd0aCAmJiBkYXRhLmRhdGFzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBjb25zdCB7bGFiZWxzOiB7cG9pbnRTdHlsZSwgY29sb3J9fSA9IGNoYXJ0LmxlZ2VuZC5vcHRpb25zO1xuXG4gICAgICAgICAgICAgIHJldHVybiBkYXRhLmxhYmVscy5tYXAoKGxhYmVsLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKGkpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHRleHQ6IGxhYmVsLFxuICAgICAgICAgICAgICAgICAgZmlsbFN0eWxlOiBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogc3R5bGUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgICBmb250Q29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgICAgbGluZVdpZHRoOiBzdHlsZS5ib3JkZXJXaWR0aCxcbiAgICAgICAgICAgICAgICAgIHBvaW50U3R5bGU6IHBvaW50U3R5bGUsXG4gICAgICAgICAgICAgICAgICBoaWRkZW46ICFjaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSxcblxuICAgICAgICAgICAgICAgICAgLy8gRXh0cmEgZGF0YSB1c2VkIGZvciB0b2dnbGluZyB0aGUgY29ycmVjdCBpdGVtXG4gICAgICAgICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvbkNsaWNrKGUsIGxlZ2VuZEl0ZW0sIGxlZ2VuZCkge1xuICAgICAgICAgIGxlZ2VuZC5jaGFydC50b2dnbGVEYXRhVmlzaWJpbGl0eShsZWdlbmRJdGVtLmluZGV4KTtcbiAgICAgICAgICBsZWdlbmQuY2hhcnQudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY29uc3RydWN0b3IoY2hhcnQsIGRhdGFzZXRJbmRleCkge1xuICAgIHN1cGVyKGNoYXJ0LCBkYXRhc2V0SW5kZXgpO1xuXG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vZmZzZXRYID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub2Zmc2V0WSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGxpbmtTY2FsZXMoKSB7fVxuXG4gIC8qKlxuXHQgKiBPdmVycmlkZSBkYXRhIHBhcnNpbmcsIHNpbmNlIHdlIGFyZSBub3QgdXNpbmcgc2NhbGVzXG5cdCAqL1xuICBwYXJzZShzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5nZXREYXRhc2V0KCkuZGF0YTtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcblxuICAgIGlmICh0aGlzLl9wYXJzaW5nID09PSBmYWxzZSkge1xuICAgICAgbWV0YS5fcGFyc2VkID0gZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGdldHRlciA9IChpKSA9PiArZGF0YVtpXTtcblxuICAgICAgaWYgKGlzT2JqZWN0KGRhdGFbc3RhcnRdKSkge1xuICAgICAgICBjb25zdCB7a2V5ID0gJ3ZhbHVlJ30gPSB0aGlzLl9wYXJzaW5nO1xuICAgICAgICBnZXR0ZXIgPSAoaSkgPT4gK3Jlc29sdmVPYmplY3RLZXkoZGF0YVtpXSwga2V5KTtcbiAgICAgIH1cblxuICAgICAgbGV0IGksIGlsZW47XG4gICAgICBmb3IgKGkgPSBzdGFydCwgaWxlbiA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgICAgbWV0YS5fcGFyc2VkW2ldID0gZ2V0dGVyKGkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFJvdGF0aW9uKCkge1xuICAgIHJldHVybiB0b1JhZGlhbnModGhpcy5vcHRpb25zLnJvdGF0aW9uIC0gOTApO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0Q2lyY3VtZmVyZW5jZSgpIHtcbiAgICByZXR1cm4gdG9SYWRpYW5zKHRoaXMub3B0aW9ucy5jaXJjdW1mZXJlbmNlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXQgdGhlIG1heGltYWwgcm90YXRpb24gJiBjaXJjdW1mZXJlbmNlIGV4dGVudHNcblx0ICogYWNyb3NzIGFsbCB2aXNpYmxlIGRhdGFzZXRzLlxuXHQgKi9cbiAgX2dldFJvdGF0aW9uRXh0ZW50cygpIHtcbiAgICBsZXQgbWluID0gVEFVO1xuICAgIGxldCBtYXggPSAtVEFVO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmICh0aGlzLmNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkgJiYgdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YShpKS50eXBlID09PSB0aGlzLl90eXBlKSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKGkpLmNvbnRyb2xsZXI7XG4gICAgICAgIGNvbnN0IHJvdGF0aW9uID0gY29udHJvbGxlci5fZ2V0Um90YXRpb24oKTtcbiAgICAgICAgY29uc3QgY2lyY3VtZmVyZW5jZSA9IGNvbnRyb2xsZXIuX2dldENpcmN1bWZlcmVuY2UoKTtcblxuICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHJvdGF0aW9uKTtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCByb3RhdGlvbiArIGNpcmN1bWZlcmVuY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICByb3RhdGlvbjogbWluLFxuICAgICAgY2lyY3VtZmVyZW5jZTogbWF4IC0gbWluLFxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IG1vZGVcblx0ICovXG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IHtjaGFydEFyZWF9ID0gY2hhcnQ7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgYXJjcyA9IG1ldGEuZGF0YTtcbiAgICBjb25zdCBzcGFjaW5nID0gdGhpcy5nZXRNYXhCb3JkZXJXaWR0aCgpICsgdGhpcy5nZXRNYXhPZmZzZXQoYXJjcykgKyB0aGlzLm9wdGlvbnMuc3BhY2luZztcbiAgICBjb25zdCBtYXhTaXplID0gTWF0aC5tYXgoKE1hdGgubWluKGNoYXJ0QXJlYS53aWR0aCwgY2hhcnRBcmVhLmhlaWdodCkgLSBzcGFjaW5nKSAvIDIsIDApO1xuICAgIGNvbnN0IGN1dG91dCA9IE1hdGgubWluKHRvUGVyY2VudGFnZSh0aGlzLm9wdGlvbnMuY3V0b3V0LCBtYXhTaXplKSwgMSk7XG4gICAgY29uc3QgY2hhcnRXZWlnaHQgPSB0aGlzLl9nZXRSaW5nV2VpZ2h0KHRoaXMuaW5kZXgpO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgbWF4aW1hbCByb3RhdGlvbiAmIGNpcmN1bWZlcmVuY2UgbGltaXRzLlxuICAgIC8vIElmIHdlIG9ubHkgY29uc2lkZXIgb3VyIGRhdGFzZXQsIHRoaXMgY2FuIGNhdXNlIHByb2JsZW1zIHdoZW4gdHdvIGRhdGFzZXRzXG4gICAgLy8gYXJlIGJvdGggbGVzcyB0aGFuIGEgY2lyY2xlIHdpdGggZGlmZmVyZW50IHJvdGF0aW9ucyAoc3RhcnRpbmcgYW5nbGVzKVxuICAgIGNvbnN0IHtjaXJjdW1mZXJlbmNlLCByb3RhdGlvbn0gPSB0aGlzLl9nZXRSb3RhdGlvbkV4dGVudHMoKTtcbiAgICBjb25zdCB7cmF0aW9YLCByYXRpb1ksIG9mZnNldFgsIG9mZnNldFl9ID0gZ2V0UmF0aW9BbmRPZmZzZXQocm90YXRpb24sIGNpcmN1bWZlcmVuY2UsIGN1dG91dCk7XG4gICAgY29uc3QgbWF4V2lkdGggPSAoY2hhcnRBcmVhLndpZHRoIC0gc3BhY2luZykgLyByYXRpb1g7XG4gICAgY29uc3QgbWF4SGVpZ2h0ID0gKGNoYXJ0QXJlYS5oZWlnaHQgLSBzcGFjaW5nKSAvIHJhdGlvWTtcbiAgICBjb25zdCBtYXhSYWRpdXMgPSBNYXRoLm1heChNYXRoLm1pbihtYXhXaWR0aCwgbWF4SGVpZ2h0KSAvIDIsIDApO1xuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gdG9EaW1lbnNpb24odGhpcy5vcHRpb25zLnJhZGl1cywgbWF4UmFkaXVzKTtcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IE1hdGgubWF4KG91dGVyUmFkaXVzICogY3V0b3V0LCAwKTtcbiAgICBjb25zdCByYWRpdXNMZW5ndGggPSAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyB0aGlzLl9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsKCk7XG4gICAgdGhpcy5vZmZzZXRYID0gb2Zmc2V0WCAqIG91dGVyUmFkaXVzO1xuICAgIHRoaXMub2Zmc2V0WSA9IG9mZnNldFkgKiBvdXRlclJhZGl1cztcblxuICAgIG1ldGEudG90YWwgPSB0aGlzLmNhbGN1bGF0ZVRvdGFsKCk7XG5cbiAgICB0aGlzLm91dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSByYWRpdXNMZW5ndGggKiB0aGlzLl9nZXRSaW5nV2VpZ2h0T2Zmc2V0KHRoaXMuaW5kZXgpO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSBNYXRoLm1heCh0aGlzLm91dGVyUmFkaXVzIC0gcmFkaXVzTGVuZ3RoICogY2hhcnRXZWlnaHQsIDApO1xuXG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhhcmNzLCAwLCBhcmNzLmxlbmd0aCwgbW9kZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jaXJjdW1mZXJlbmNlKGksIHJlc2V0KSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBjaXJjdW1mZXJlbmNlID0gdGhpcy5fZ2V0Q2lyY3VtZmVyZW5jZSgpO1xuICAgIGlmICgocmVzZXQgJiYgb3B0cy5hbmltYXRpb24uYW5pbWF0ZVJvdGF0ZSkgfHwgIXRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkgfHwgbWV0YS5fcGFyc2VkW2ldID09PSBudWxsIHx8IG1ldGEuZGF0YVtpXS5oaWRkZW4pIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jYWxjdWxhdGVDaXJjdW1mZXJlbmNlKG1ldGEuX3BhcnNlZFtpXSAqIGNpcmN1bWZlcmVuY2UgLyBUQVUpO1xuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMoYXJjcywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBjaGFydEFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgY29uc3Qgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG4gICAgY29uc3QgYW5pbWF0aW9uT3B0cyA9IG9wdHMuYW5pbWF0aW9uO1xuICAgIGNvbnN0IGNlbnRlclggPSAoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMjtcbiAgICBjb25zdCBjZW50ZXJZID0gKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDI7XG4gICAgY29uc3QgYW5pbWF0ZVNjYWxlID0gcmVzZXQgJiYgYW5pbWF0aW9uT3B0cy5hbmltYXRlU2NhbGU7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSBhbmltYXRlU2NhbGUgPyAwIDogdGhpcy5pbm5lclJhZGl1cztcbiAgICBjb25zdCBvdXRlclJhZGl1cyA9IGFuaW1hdGVTY2FsZSA/IDAgOiB0aGlzLm91dGVyUmFkaXVzO1xuICAgIGNvbnN0IHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc30gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBsZXQgc3RhcnRBbmdsZSA9IHRoaXMuX2dldFJvdGF0aW9uKCk7XG4gICAgbGV0IGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhcnQ7ICsraSkge1xuICAgICAgc3RhcnRBbmdsZSArPSB0aGlzLl9jaXJjdW1mZXJlbmNlKGksIHJlc2V0KTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgICAgY29uc3QgY2lyY3VtZmVyZW5jZSA9IHRoaXMuX2NpcmN1bWZlcmVuY2UoaSwgcmVzZXQpO1xuICAgICAgY29uc3QgYXJjID0gYXJjc1tpXTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIHg6IGNlbnRlclggKyB0aGlzLm9mZnNldFgsXG4gICAgICAgIHk6IGNlbnRlclkgKyB0aGlzLm9mZnNldFksXG4gICAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICAgIGVuZEFuZ2xlOiBzdGFydEFuZ2xlICsgY2lyY3VtZmVyZW5jZSxcbiAgICAgICAgY2lyY3VtZmVyZW5jZSxcbiAgICAgICAgb3V0ZXJSYWRpdXMsXG4gICAgICAgIGlubmVyUmFkaXVzXG4gICAgICB9O1xuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIGFyYy5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgfVxuICAgICAgc3RhcnRBbmdsZSArPSBjaXJjdW1mZXJlbmNlO1xuXG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoYXJjLCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cblxuICBjYWxjdWxhdGVUb3RhbCgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBtZXRhRGF0YSA9IG1ldGEuZGF0YTtcbiAgICBsZXQgdG90YWwgPSAwO1xuICAgIGxldCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG1ldGFEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG1ldGEuX3BhcnNlZFtpXTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiAhaXNOYU4odmFsdWUpICYmIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkgJiYgIW1ldGFEYXRhW2ldLmhpZGRlbikge1xuICAgICAgICB0b3RhbCArPSBNYXRoLmFicyh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvdGFsO1xuICB9XG5cbiAgY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZSh2YWx1ZSkge1xuICAgIGNvbnN0IHRvdGFsID0gdGhpcy5fY2FjaGVkTWV0YS50b3RhbDtcbiAgICBpZiAodG90YWwgPiAwICYmICFpc05hTih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBUQVUgKiAoTWF0aC5hYnModmFsdWUpIC8gdG90YWwpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbGFiZWxzID0gY2hhcnQuZGF0YS5sYWJlbHMgfHwgW107XG4gICAgY29uc3QgdmFsdWUgPSBmb3JtYXROdW1iZXIobWV0YS5fcGFyc2VkW2luZGV4XSwgY2hhcnQub3B0aW9ucy5sb2NhbGUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBsYWJlbHNbaW5kZXhdIHx8ICcnLFxuICAgICAgdmFsdWUsXG4gICAgfTtcbiAgfVxuXG4gIGdldE1heEJvcmRlcldpZHRoKGFyY3MpIHtcbiAgICBsZXQgbWF4ID0gMDtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgbGV0IGksIGlsZW4sIG1ldGEsIGNvbnRyb2xsZXIsIG9wdGlvbnM7XG5cbiAgICBpZiAoIWFyY3MpIHtcbiAgICAgIC8vIEZpbmQgdGhlIG91dG1vc3QgdmlzaWJsZSBkYXRhc2V0XG4gICAgICBmb3IgKGkgPSAwLCBpbGVuID0gY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgICAgaWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcbiAgICAgICAgICBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICAgICAgYXJjcyA9IG1ldGEuZGF0YTtcbiAgICAgICAgICBjb250cm9sbGVyID0gbWV0YS5jb250cm9sbGVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFhcmNzKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIG9wdGlvbnMgPSBjb250cm9sbGVyLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSk7XG4gICAgICBpZiAob3B0aW9ucy5ib3JkZXJBbGlnbiAhPT0gJ2lubmVyJykge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIG9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMCwgb3B0aW9ucy5ob3ZlckJvcmRlcldpZHRoIHx8IDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF4O1xuICB9XG5cbiAgZ2V0TWF4T2Zmc2V0KGFyY3MpIHtcbiAgICBsZXQgbWF4ID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSk7XG4gICAgICBtYXggPSBNYXRoLm1heChtYXgsIG9wdGlvbnMub2Zmc2V0IHx8IDAsIG9wdGlvbnMuaG92ZXJPZmZzZXQgfHwgMCk7XG4gICAgfVxuICAgIHJldHVybiBtYXg7XG4gIH1cblxuICAvKipcblx0ICogR2V0IHJhZGl1cyBsZW5ndGggb2Zmc2V0IG9mIHRoZSBkYXRhc2V0IGluIHJlbGF0aW9uIHRvIHRoZSB2aXNpYmxlIGRhdGFzZXRzIHdlaWdodHMuIFRoaXMgYWxsb3dzIGRldGVybWluaW5nIHRoZSBpbm5lciBhbmQgb3V0ZXIgcmFkaXVzIGNvcnJlY3RseVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFJpbmdXZWlnaHRPZmZzZXQoZGF0YXNldEluZGV4KSB7XG4gICAgbGV0IHJpbmdXZWlnaHRPZmZzZXQgPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhc2V0SW5kZXg7ICsraSkge1xuICAgICAgaWYgKHRoaXMuY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuICAgICAgICByaW5nV2VpZ2h0T2Zmc2V0ICs9IHRoaXMuX2dldFJpbmdXZWlnaHQoaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJpbmdXZWlnaHRPZmZzZXQ7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRSaW5nV2VpZ2h0KGRhdGFzZXRJbmRleCkge1xuICAgIHJldHVybiBNYXRoLm1heCh2YWx1ZU9yRGVmYXVsdCh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS53ZWlnaHQsIDEpLCAwKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzdW0gb2YgYWxsIHZpc2libGUgZGF0YSBzZXQgd2VpZ2h0cy5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRSaW5nV2VpZ2h0T2Zmc2V0KHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHx8IDE7XG4gIH1cbn1cbiIsICJpbXBvcnQgRGF0YXNldENvbnRyb2xsZXIgZnJvbSAnLi4vY29yZS9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzJztcbmltcG9ydCB7aXNOdWxsT3JVbmRlZn0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge2lzTnVtYmVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge19nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzLCBfc2NhbGVSYW5nZXNDaGFuZ2VkfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZUNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ2xpbmUnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGRhdGFzZXRFbGVtZW50VHlwZTogJ2xpbmUnLFxuICAgIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcblxuICAgIHNob3dMaW5lOiB0cnVlLFxuICAgIHNwYW5HYXBzOiBmYWxzZSxcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBvdmVycmlkZXMgPSB7XG4gICAgc2NhbGVzOiB7XG4gICAgICBfaW5kZXhfOiB7XG4gICAgICAgIHR5cGU6ICdjYXRlZ29yeScsXG4gICAgICB9LFxuICAgICAgX3ZhbHVlXzoge1xuICAgICAgICB0eXBlOiAnbGluZWFyJyxcbiAgICAgIH0sXG4gICAgfVxuICB9O1xuXG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnN1cHBvcnRzRGVjaW1hdGlvbiA9IHRydWU7XG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICB9XG5cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7ZGF0YXNldDogbGluZSwgZGF0YTogcG9pbnRzID0gW10sIF9kYXRhc2V0fSA9IG1ldGE7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGFuaW1hdGlvbnNEaXNhYmxlZCA9IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZDtcbiAgICBsZXQge3N0YXJ0LCBjb3VudH0gPSBfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyhtZXRhLCBwb2ludHMsIGFuaW1hdGlvbnNEaXNhYmxlZCk7XG5cbiAgICB0aGlzLl9kcmF3U3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLl9kcmF3Q291bnQgPSBjb3VudDtcblxuICAgIGlmIChfc2NhbGVSYW5nZXNDaGFuZ2VkKG1ldGEpKSB7XG4gICAgICBzdGFydCA9IDA7XG4gICAgICBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIExpbmVcbiAgICBsaW5lLl9jaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgbGluZS5fZGF0YXNldEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICBsaW5lLl9kZWNpbWF0ZWQgPSAhIV9kYXRhc2V0Ll9kZWNpbWF0ZWQ7XG4gICAgbGluZS5wb2ludHMgPSBwb2ludHM7XG5cbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpO1xuICAgIGlmICghdGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG4gICAgICBvcHRpb25zLmJvcmRlcldpZHRoID0gMDtcbiAgICB9XG4gICAgb3B0aW9ucy5zZWdtZW50ID0gdGhpcy5vcHRpb25zLnNlZ21lbnQ7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50KGxpbmUsIHVuZGVmaW5lZCwge1xuICAgICAgYW5pbWF0ZWQ6ICFhbmltYXRpb25zRGlzYWJsZWQsXG4gICAgICBvcHRpb25zXG4gICAgfSwgbW9kZSk7XG5cbiAgICAvLyBVcGRhdGUgUG9pbnRzXG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSk7XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGUsIF9zdGFja2VkLCBfZGF0YXNldH0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc30gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgY29uc3Qge3NwYW5HYXBzLCBzZWdtZW50fSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBtYXhHYXBMZW5ndGggPSBpc051bWJlcihzcGFuR2FwcykgPyBzcGFuR2FwcyA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBjb25zdCBkaXJlY3RVcGRhdGUgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQgfHwgcmVzZXQgfHwgbW9kZSA9PT0gJ25vbmUnO1xuICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgY291bnQ7XG4gICAgY29uc3QgcG9pbnRzQ291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAgIGxldCBwcmV2UGFyc2VkID0gc3RhcnQgPiAwICYmIHRoaXMuZ2V0UGFyc2VkKHN0YXJ0IC0gMSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50c0NvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IGRpcmVjdFVwZGF0ZSA/IHBvaW50IDoge307XG5cbiAgICAgIGlmIChpIDwgc3RhcnQgfHwgaSA+PSBlbmQpIHtcbiAgICAgICAgcHJvcGVydGllcy5za2lwID0gdHJ1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGkpO1xuICAgICAgY29uc3QgbnVsbERhdGEgPSBpc051bGxPclVuZGVmKHBhcnNlZFt2QXhpc10pO1xuICAgICAgY29uc3QgaVBpeGVsID0gcHJvcGVydGllc1tpQXhpc10gPSBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbaUF4aXNdLCBpKTtcbiAgICAgIGNvbnN0IHZQaXhlbCA9IHByb3BlcnRpZXNbdkF4aXNdID0gcmVzZXQgfHwgbnVsbERhdGEgPyB2U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShfc3RhY2tlZCA/IHRoaXMuYXBwbHlTdGFjayh2U2NhbGUsIHBhcnNlZCwgX3N0YWNrZWQpIDogcGFyc2VkW3ZBeGlzXSwgaSk7XG5cbiAgICAgIHByb3BlcnRpZXMuc2tpcCA9IGlzTmFOKGlQaXhlbCkgfHwgaXNOYU4odlBpeGVsKSB8fCBudWxsRGF0YTtcbiAgICAgIHByb3BlcnRpZXMuc3RvcCA9IGkgPiAwICYmIChNYXRoLmFicyhwYXJzZWRbaUF4aXNdIC0gcHJldlBhcnNlZFtpQXhpc10pKSA+IG1heEdhcExlbmd0aDtcbiAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgIHByb3BlcnRpZXMucGFyc2VkID0gcGFyc2VkO1xuICAgICAgICBwcm9wZXJ0aWVzLnJhdyA9IF9kYXRhc2V0LmRhdGFbaV07XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRpcmVjdFVwZGF0ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgICAgfVxuXG4gICAgICBwcmV2UGFyc2VkID0gcGFyc2VkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhc2V0ID0gbWV0YS5kYXRhc2V0O1xuICAgIGNvbnN0IGJvcmRlciA9IGRhdGFzZXQub3B0aW9ucyAmJiBkYXRhc2V0Lm9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMDtcbiAgICBjb25zdCBkYXRhID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBib3JkZXI7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBkYXRhWzBdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKDApKTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoZGF0YS5sZW5ndGggLSAxKSk7XG4gICAgcmV0dXJuIE1hdGgubWF4KGJvcmRlciwgZmlyc3RQb2ludCwgbGFzdFBvaW50KSAvIDI7XG4gIH1cblxuICBkcmF3KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIG1ldGEuZGF0YXNldC51cGRhdGVDb250cm9sUG9pbnRzKHRoaXMuY2hhcnQuY2hhcnRBcmVhLCBtZXRhLmlTY2FsZS5heGlzKTtcbiAgICBzdXBlci5kcmF3KCk7XG4gIH1cbn1cbiIsICJpbXBvcnQgRGF0YXNldENvbnRyb2xsZXIgZnJvbSAnLi4vY29yZS9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzJztcbmltcG9ydCB7dG9SYWRpYW5zLCBQSSwgZm9ybWF0TnVtYmVyLCBfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGV9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2xhckFyZWFDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuXG4gIHN0YXRpYyBpZCA9ICdwb2xhckFyZWEnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGRhdGFFbGVtZW50VHlwZTogJ2FyYycsXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBhbmltYXRlUm90YXRlOiB0cnVlLFxuICAgICAgYW5pbWF0ZVNjYWxlOiB0cnVlXG4gICAgfSxcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBudW1iZXJzOiB7XG4gICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICdzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJywgJ2lubmVyUmFkaXVzJywgJ291dGVyUmFkaXVzJ11cbiAgICAgIH0sXG4gICAgfSxcbiAgICBpbmRleEF4aXM6ICdyJyxcbiAgICBzdGFydEFuZ2xlOiAwLFxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIG92ZXJyaWRlcyA9IHtcbiAgICBhc3BlY3RSYXRpbzogMSxcblxuICAgIHBsdWdpbnM6IHtcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICBnZW5lcmF0ZUxhYmVscyhjaGFydCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGNoYXJ0LmRhdGE7XG4gICAgICAgICAgICBpZiAoZGF0YS5sYWJlbHMubGVuZ3RoICYmIGRhdGEuZGF0YXNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHtsYWJlbHM6IHtwb2ludFN0eWxlLCBjb2xvcn19ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGRhdGEubGFiZWxzLm1hcCgobGFiZWwsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUoaSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgdGV4dDogbGFiZWwsXG4gICAgICAgICAgICAgICAgICBmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgICAgICAgIHN0cm9rZVN0eWxlOiBzdHlsZS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICAgIGZvbnRDb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IHN0eWxlLmJvcmRlcldpZHRoLFxuICAgICAgICAgICAgICAgICAgcG9pbnRTdHlsZTogcG9pbnRTdHlsZSxcbiAgICAgICAgICAgICAgICAgIGhpZGRlbjogIWNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpLFxuXG4gICAgICAgICAgICAgICAgICAvLyBFeHRyYSBkYXRhIHVzZWQgZm9yIHRvZ2dsaW5nIHRoZSBjb3JyZWN0IGl0ZW1cbiAgICAgICAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ2xpY2soZSwgbGVnZW5kSXRlbSwgbGVnZW5kKSB7XG4gICAgICAgICAgbGVnZW5kLmNoYXJ0LnRvZ2dsZURhdGFWaXNpYmlsaXR5KGxlZ2VuZEl0ZW0uaW5kZXgpO1xuICAgICAgICAgIGxlZ2VuZC5jaGFydC51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzY2FsZXM6IHtcbiAgICAgIHI6IHtcbiAgICAgICAgdHlwZTogJ3JhZGlhbExpbmVhcicsXG4gICAgICAgIGFuZ2xlTGluZXM6IHtcbiAgICAgICAgICBkaXNwbGF5OiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBiZWdpbkF0WmVybzogdHJ1ZSxcbiAgICAgICAgZ3JpZDoge1xuICAgICAgICAgIGNpcmN1bGFyOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50TGFiZWxzOiB7XG4gICAgICAgICAgZGlzcGxheTogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgc3RhcnRBbmdsZTogMFxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjb25zdHJ1Y3RvcihjaGFydCwgZGF0YXNldEluZGV4KSB7XG4gICAgc3VwZXIoY2hhcnQsIGRhdGFzZXRJbmRleCk7XG5cbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGxhYmVscyA9IGNoYXJ0LmRhdGEubGFiZWxzIHx8IFtdO1xuICAgIGNvbnN0IHZhbHVlID0gZm9ybWF0TnVtYmVyKG1ldGEuX3BhcnNlZFtpbmRleF0uciwgY2hhcnQub3B0aW9ucy5sb2NhbGUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBsYWJlbHNbaW5kZXhdIHx8ICcnLFxuICAgICAgdmFsdWUsXG4gICAgfTtcbiAgfVxuXG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICByZXR1cm4gX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlLmJpbmQodGhpcykobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgfVxuXG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgYXJjcyA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcblxuICAgIHRoaXMuX3VwZGF0ZVJhZGl1cygpO1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMoYXJjcywgMCwgYXJjcy5sZW5ndGgsIG1vZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGdldE1pbk1heCgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCByYW5nZSA9IHttaW46IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgbWF4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFl9O1xuXG4gICAgbWV0YS5kYXRhLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCkucjtcblxuICAgICAgaWYgKCFpc05hTihwYXJzZWQpICYmIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpKSB7XG4gICAgICAgIGlmIChwYXJzZWQgPCByYW5nZS5taW4pIHtcbiAgICAgICAgICByYW5nZS5taW4gPSBwYXJzZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyc2VkID4gcmFuZ2UubWF4KSB7XG4gICAgICAgICAgcmFuZ2UubWF4ID0gcGFyc2VkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVSYWRpdXMoKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICBjb25zdCBvcHRzID0gY2hhcnQub3B0aW9ucztcbiAgICBjb25zdCBtaW5TaXplID0gTWF0aC5taW4oY2hhcnRBcmVhLnJpZ2h0IC0gY2hhcnRBcmVhLmxlZnQsIGNoYXJ0QXJlYS5ib3R0b20gLSBjaGFydEFyZWEudG9wKTtcblxuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gTWF0aC5tYXgobWluU2l6ZSAvIDIsIDApO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gTWF0aC5tYXgob3B0cy5jdXRvdXRQZXJjZW50YWdlID8gKG91dGVyUmFkaXVzIC8gMTAwKSAqIChvcHRzLmN1dG91dFBlcmNlbnRhZ2UpIDogMSwgMCk7XG4gICAgY29uc3QgcmFkaXVzTGVuZ3RoID0gKG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMpIC8gY2hhcnQuZ2V0VmlzaWJsZURhdGFzZXRDb3VudCgpO1xuXG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzIC0gKHJhZGl1c0xlbmd0aCAqIHRoaXMuaW5kZXgpO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB0aGlzLm91dGVyUmFkaXVzIC0gcmFkaXVzTGVuZ3RoO1xuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMoYXJjcywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBvcHRzID0gY2hhcnQub3B0aW9ucztcbiAgICBjb25zdCBhbmltYXRpb25PcHRzID0gb3B0cy5hbmltYXRpb247XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLl9jYWNoZWRNZXRhLnJTY2FsZTtcbiAgICBjb25zdCBjZW50ZXJYID0gc2NhbGUueENlbnRlcjtcbiAgICBjb25zdCBjZW50ZXJZID0gc2NhbGUueUNlbnRlcjtcbiAgICBjb25zdCBkYXRhc2V0U3RhcnRBbmdsZSA9IHNjYWxlLmdldEluZGV4QW5nbGUoMCkgLSAwLjUgKiBQSTtcbiAgICBsZXQgYW5nbGUgPSBkYXRhc2V0U3RhcnRBbmdsZTtcbiAgICBsZXQgaTtcblxuICAgIGNvbnN0IGRlZmF1bHRBbmdsZSA9IDM2MCAvIHRoaXMuY291bnRWaXNpYmxlRWxlbWVudHMoKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzdGFydDsgKytpKSB7XG4gICAgICBhbmdsZSArPSB0aGlzLl9jb21wdXRlQW5nbGUoaSwgbW9kZSwgZGVmYXVsdEFuZ2xlKTtcbiAgICB9XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGFyYyA9IGFyY3NbaV07XG4gICAgICBsZXQgc3RhcnRBbmdsZSA9IGFuZ2xlO1xuICAgICAgbGV0IGVuZEFuZ2xlID0gYW5nbGUgKyB0aGlzLl9jb21wdXRlQW5nbGUoaSwgbW9kZSwgZGVmYXVsdEFuZ2xlKTtcbiAgICAgIGxldCBvdXRlclJhZGl1cyA9IGNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpID8gc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodGhpcy5nZXRQYXJzZWQoaSkucikgOiAwO1xuICAgICAgYW5nbGUgPSBlbmRBbmdsZTtcblxuICAgICAgaWYgKHJlc2V0KSB7XG4gICAgICAgIGlmIChhbmltYXRpb25PcHRzLmFuaW1hdGVTY2FsZSkge1xuICAgICAgICAgIG91dGVyUmFkaXVzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5pbWF0aW9uT3B0cy5hbmltYXRlUm90YXRlKSB7XG4gICAgICAgICAgc3RhcnRBbmdsZSA9IGVuZEFuZ2xlID0gZGF0YXNldFN0YXJ0QW5nbGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgeDogY2VudGVyWCxcbiAgICAgICAgeTogY2VudGVyWSxcbiAgICAgICAgaW5uZXJSYWRpdXM6IDAsXG4gICAgICAgIG91dGVyUmFkaXVzLFxuICAgICAgICBzdGFydEFuZ2xlLFxuICAgICAgICBlbmRBbmdsZSxcbiAgICAgICAgb3B0aW9uczogdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIGFyYy5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoYXJjLCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cblxuICBjb3VudFZpc2libGVFbGVtZW50cygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBsZXQgY291bnQgPSAwO1xuXG4gICAgbWV0YS5kYXRhLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoIWlzTmFOKHRoaXMuZ2V0UGFyc2VkKGluZGV4KS5yKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KSkge1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvdW50O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY29tcHV0ZUFuZ2xlKGluZGV4LCBtb2RlLCBkZWZhdWx0QW5nbGUpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleClcbiAgICAgID8gdG9SYWRpYW5zKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSkuYW5nbGUgfHwgZGVmYXVsdEFuZ2xlKVxuICAgICAgOiAwO1xuICB9XG59XG4iLCAiaW1wb3J0IERvdWdobnV0Q29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIuZG91Z2hudXQuanMnO1xuXG4vLyBQaWUgY2hhcnRzIGFyZSBEb3VnaG51dCBjaGFydCB3aXRoIGRpZmZlcmVudCBkZWZhdWx0c1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGllQ29udHJvbGxlciBleHRlbmRzIERvdWdobnV0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ3BpZSc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgLy8gVGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIGNoYXJ0IHRoYXQgd2UgY3V0IG91dCBvZiB0aGUgbWlkZGxlLlxuICAgIGN1dG91dDogMCxcblxuICAgIC8vIFRoZSByb3RhdGlvbiBvZiB0aGUgY2hhcnQsIHdoZXJlIHRoZSBmaXJzdCBkYXRhIGFyYyBiZWdpbnMuXG4gICAgcm90YXRpb246IDAsXG5cbiAgICAvLyBUaGUgdG90YWwgY2lyY3VtZmVyZW5jZSBvZiB0aGUgY2hhcnQuXG4gICAgY2lyY3VtZmVyZW5jZTogMzYwLFxuXG4gICAgLy8gVGhlIG91dGVyIHJhZGl1cyBvZiB0aGUgY2hhcnRcbiAgICByYWRpdXM6ICcxMDAlJ1xuICB9O1xufVxuIiwgImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuLi9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHtfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGV9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSYWRhckNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ3JhZGFyJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkYXRhc2V0RWxlbWVudFR5cGU6ICdsaW5lJyxcbiAgICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG4gICAgaW5kZXhBeGlzOiAncicsXG4gICAgc2hvd0xpbmU6IHRydWUsXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIGxpbmU6IHtcbiAgICAgICAgZmlsbDogJ3N0YXJ0J1xuICAgICAgfVxuICAgIH0sXG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuICAgIGFzcGVjdFJhdGlvOiAxLFxuXG4gICAgc2NhbGVzOiB7XG4gICAgICByOiB7XG4gICAgICAgIHR5cGU6ICdyYWRpYWxMaW5lYXInLFxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IHZTY2FsZSA9IHRoaXMuX2NhY2hlZE1ldGEudlNjYWxlO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcblxuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogdlNjYWxlLmdldExhYmVscygpW2luZGV4XSxcbiAgICAgIHZhbHVlOiAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pXG4gICAgfTtcbiAgfVxuXG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICByZXR1cm4gX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlLmJpbmQodGhpcykobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgfVxuXG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgbGluZSA9IG1ldGEuZGF0YXNldDtcbiAgICBjb25zdCBwb2ludHMgPSBtZXRhLmRhdGEgfHwgW107XG4gICAgY29uc3QgbGFiZWxzID0gbWV0YS5pU2NhbGUuZ2V0TGFiZWxzKCk7XG5cbiAgICAvLyBVcGRhdGUgTGluZVxuICAgIGxpbmUucG9pbnRzID0gcG9pbnRzO1xuICAgIC8vIEluIHJlc2l6ZSBtb2RlIG9ubHkgcG9pbnQgbG9jYXRpb25zIGNoYW5nZSwgc28gbm8gbmVlZCB0byBzZXQgdGhlIHBvaW50cyBvciBvcHRpb25zLlxuICAgIGlmIChtb2RlICE9PSAncmVzaXplJykge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKTtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG4gICAgICAgIG9wdGlvbnMuYm9yZGVyV2lkdGggPSAwO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBfbG9vcDogdHJ1ZSxcbiAgICAgICAgX2Z1bGxMb29wOiBsYWJlbHMubGVuZ3RoID09PSBwb2ludHMubGVuZ3RoLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQobGluZSwgdW5kZWZpbmVkLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgUG9pbnRzXG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIDAsIHBvaW50cy5sZW5ndGgsIG1vZGUpO1xuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuX2NhY2hlZE1ldGEuclNjYWxlO1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcblxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICBjb25zdCBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGksIHRoaXMuZ2V0UGFyc2VkKGkpLnIpO1xuXG4gICAgICBjb25zdCB4ID0gcmVzZXQgPyBzY2FsZS54Q2VudGVyIDogcG9pbnRQb3NpdGlvbi54O1xuICAgICAgY29uc3QgeSA9IHJlc2V0ID8gc2NhbGUueUNlbnRlciA6IHBvaW50UG9zaXRpb24ueTtcblxuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgYW5nbGU6IHBvaW50UG9zaXRpb24uYW5nbGUsXG4gICAgICAgIHNraXA6IGlzTmFOKHgpIHx8IGlzTmFOKHkpLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuLi9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHtpc051bGxPclVuZGVmfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7aXNOdW1iZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCB7X2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMsIF9zY2FsZVJhbmdlc0NoYW5nZWR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY2F0dGVyQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcblxuICBzdGF0aWMgaWQgPSAnc2NhdHRlcic7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcbiAgICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG4gICAgc2hvd0xpbmU6IGZhbHNlLFxuICAgIGZpbGw6IGZhbHNlXG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuXG4gICAgaW50ZXJhY3Rpb246IHtcbiAgICAgIG1vZGU6ICdwb2ludCdcbiAgICB9LFxuXG4gICAgc2NhbGVzOiB7XG4gICAgICB4OiB7XG4gICAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgICB9LFxuICAgICAgeToge1xuICAgICAgICB0eXBlOiAnbGluZWFyJ1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuY2hhcnQuZGF0YS5sYWJlbHMgfHwgW107XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IHggPSB4U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWQueCk7XG4gICAgY29uc3QgeSA9IHlTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZC55KTtcblxuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogbGFiZWxzW2luZGV4XSB8fCAnJyxcbiAgICAgIHZhbHVlOiAnKCcgKyB4ICsgJywgJyArIHkgKyAnKSdcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7ZGF0YTogcG9pbnRzID0gW119ID0gbWV0YTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgYW5pbWF0aW9uc0Rpc2FibGVkID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkO1xuICAgIGxldCB7c3RhcnQsIGNvdW50fSA9IF9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzKG1ldGEsIHBvaW50cywgYW5pbWF0aW9uc0Rpc2FibGVkKTtcblxuICAgIHRoaXMuX2RyYXdTdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuX2RyYXdDb3VudCA9IGNvdW50O1xuXG4gICAgaWYgKF9zY2FsZVJhbmdlc0NoYW5nZWQobWV0YSkpIHtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8xMTMzM1xuICAgICAgaWYgKCF0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSkge1xuICAgICAgICB0aGlzLmFkZEVsZW1lbnRzKCk7XG4gICAgICB9XG4gICAgICBjb25zdCB7ZGF0YXNldDogbGluZSwgX2RhdGFzZXR9ID0gbWV0YTtcblxuICAgICAgLy8gVXBkYXRlIExpbmVcbiAgICAgIGxpbmUuX2NoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICAgIGxpbmUuX2RhdGFzZXRJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICBsaW5lLl9kZWNpbWF0ZWQgPSAhIV9kYXRhc2V0Ll9kZWNpbWF0ZWQ7XG4gICAgICBsaW5lLnBvaW50cyA9IHBvaW50cztcblxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKTtcbiAgICAgIG9wdGlvbnMuc2VnbWVudCA9IHRoaXMub3B0aW9ucy5zZWdtZW50O1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGxpbmUsIHVuZGVmaW5lZCwge1xuICAgICAgICBhbmltYXRlZDogIWFuaW1hdGlvbnNEaXNhYmxlZCxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfSwgbW9kZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSkge1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzExMzMzXG4gICAgICBkZWxldGUgbWV0YS5kYXRhc2V0O1xuICAgICAgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgUG9pbnRzXG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSk7XG4gIH1cblxuICBhZGRFbGVtZW50cygpIHtcbiAgICBjb25zdCB7c2hvd0xpbmV9ID0gdGhpcy5vcHRpb25zO1xuXG4gICAgaWYgKCF0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSAmJiBzaG93TGluZSkge1xuICAgICAgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUgPSB0aGlzLmNoYXJ0LnJlZ2lzdHJ5LmdldEVsZW1lbnQoJ2xpbmUnKTtcbiAgICB9XG5cbiAgICBzdXBlci5hZGRFbGVtZW50cygpO1xuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlLCBfc3RhY2tlZCwgX2RhdGFzZXR9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBmaXJzdE9wdHMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGNvbnN0IHNoYXJlZE9wdGlvbnMgPSB0aGlzLmdldFNoYXJlZE9wdGlvbnMoZmlyc3RPcHRzKTtcbiAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IHRoaXMuaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucyk7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICAgIGNvbnN0IHtzcGFuR2Fwcywgc2VnbWVudH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWF4R2FwTGVuZ3RoID0gaXNOdW1iZXIoc3BhbkdhcHMpID8gc3BhbkdhcHMgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgY29uc3QgZGlyZWN0VXBkYXRlID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkIHx8IHJlc2V0IHx8IG1vZGUgPT09ICdub25lJztcbiAgICBsZXQgcHJldlBhcnNlZCA9IHN0YXJ0ID4gMCAmJiB0aGlzLmdldFBhcnNlZChzdGFydCAtIDEpO1xuXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGkpO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IGRpcmVjdFVwZGF0ZSA/IHBvaW50IDoge307XG4gICAgICBjb25zdCBudWxsRGF0YSA9IGlzTnVsbE9yVW5kZWYocGFyc2VkW3ZBeGlzXSk7XG4gICAgICBjb25zdCBpUGl4ZWwgPSBwcm9wZXJ0aWVzW2lBeGlzXSA9IGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHBhcnNlZFtpQXhpc10sIGkpO1xuICAgICAgY29uc3QgdlBpeGVsID0gcHJvcGVydGllc1t2QXhpc10gPSByZXNldCB8fCBudWxsRGF0YSA/IHZTY2FsZS5nZXRCYXNlUGl4ZWwoKSA6IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKF9zdGFja2VkID8gdGhpcy5hcHBseVN0YWNrKHZTY2FsZSwgcGFyc2VkLCBfc3RhY2tlZCkgOiBwYXJzZWRbdkF4aXNdLCBpKTtcblxuICAgICAgcHJvcGVydGllcy5za2lwID0gaXNOYU4oaVBpeGVsKSB8fCBpc05hTih2UGl4ZWwpIHx8IG51bGxEYXRhO1xuICAgICAgcHJvcGVydGllcy5zdG9wID0gaSA+IDAgJiYgKE1hdGguYWJzKHBhcnNlZFtpQXhpc10gLSBwcmV2UGFyc2VkW2lBeGlzXSkpID4gbWF4R2FwTGVuZ3RoO1xuICAgICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAgcHJvcGVydGllcy5wYXJzZWQgPSBwYXJzZWQ7XG4gICAgICAgIHByb3BlcnRpZXMucmF3ID0gX2RhdGFzZXQuZGF0YVtpXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZGlyZWN0VXBkYXRlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgICB9XG5cbiAgICAgIHByZXZQYXJzZWQgPSBwYXJzZWQ7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVTaGFyZWRPcHRpb25zKHNoYXJlZE9wdGlvbnMsIG1vZGUsIGZpcnN0T3B0cyk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YSA9IG1ldGEuZGF0YSB8fCBbXTtcblxuICAgIGlmICghdGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG4gICAgICBsZXQgbWF4ID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgZGF0YVtpXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKSkgLyAyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXggPiAwICYmIG1heDtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhc2V0ID0gbWV0YS5kYXRhc2V0O1xuICAgIGNvbnN0IGJvcmRlciA9IGRhdGFzZXQub3B0aW9ucyAmJiBkYXRhc2V0Lm9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMDtcblxuICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBib3JkZXI7XG4gICAgfVxuXG4gICAgY29uc3QgZmlyc3RQb2ludCA9IGRhdGFbMF0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoMCkpO1xuICAgIGNvbnN0IGxhc3RQb2ludCA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhkYXRhLmxlbmd0aCAtIDEpKTtcbiAgICByZXR1cm4gTWF0aC5tYXgoYm9yZGVyLCBmaXJzdFBvaW50LCBsYXN0UG9pbnQpIC8gMjtcbiAgfVxufVxuIiwgIi8qKlxuICogQG5hbWVzcGFjZSBDaGFydC5fYWRhcHRlcnNcbiAqIEBzaW5jZSAyLjguMFxuICogQHByaXZhdGVcbiAqL1xuXG5pbXBvcnQgdHlwZSB7QW55T2JqZWN0fSBmcm9tICcuLi90eXBlcy9iYXNpYy5qcyc7XG5pbXBvcnQgdHlwZSB7Q2hhcnRPcHRpb25zfSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5cbmV4cG9ydCB0eXBlIFRpbWVVbml0ID0gJ21pbGxpc2Vjb25kJyB8ICdzZWNvbmQnIHwgJ21pbnV0ZScgfCAnaG91cicgfCAnZGF5JyB8ICd3ZWVrJyB8ICdtb250aCcgfCAncXVhcnRlcicgfCAneWVhcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0ZUFkYXB0ZXI8VCBleHRlbmRzIEFueU9iamVjdCA9IEFueU9iamVjdD4ge1xuICByZWFkb25seSBvcHRpb25zOiBUO1xuICAvKipcbiAgICogV2lsbCBjYWxsZWQgd2l0aCBjaGFydCBvcHRpb25zIGFmdGVyIGFkYXB0ZXIgY3JlYXRpb24uXG4gICAqL1xuICBpbml0KHRoaXM6IERhdGVBZGFwdGVyPFQ+LCBjaGFydE9wdGlvbnM6IENoYXJ0T3B0aW9ucyk6IHZvaWQ7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbWFwIG9mIHRpbWUgZm9ybWF0cyBmb3IgdGhlIHN1cHBvcnRlZCBmb3JtYXR0aW5nIHVuaXRzIGRlZmluZWRcbiAgICogaW4gVW5pdCBhcyB3ZWxsIGFzICdkYXRldGltZScgcmVwcmVzZW50aW5nIGEgZGV0YWlsZWQgZGF0ZS90aW1lIHN0cmluZy5cbiAgICovXG4gIGZvcm1hdHModGhpczogRGF0ZUFkYXB0ZXI8VD4pOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICAvKipcbiAgICogUGFyc2VzIHRoZSBnaXZlbiBgdmFsdWVgIGFuZCByZXR1cm4gdGhlIGFzc29jaWF0ZWQgdGltZXN0YW1wLlxuICAgKiBAcGFyYW0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gcGFyc2UgKHVzdWFsbHkgY29tZXMgZnJvbSB0aGUgZGF0YSlcbiAgICogQHBhcmFtIFtmb3JtYXRdIC0gdGhlIGV4cGVjdGVkIGRhdGEgZm9ybWF0XG4gICAqL1xuICBwYXJzZSh0aGlzOiBEYXRlQWRhcHRlcjxUPiwgdmFsdWU6IHVua25vd24sIGZvcm1hdD86IFRpbWVVbml0KTogbnVtYmVyIHwgbnVsbDtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZvcm1hdHRlZCBkYXRlIGluIHRoZSBzcGVjaWZpZWQgYGZvcm1hdGAgZm9yIGEgZ2l2ZW4gYHRpbWVzdGFtcGAuXG4gICAqIEBwYXJhbSB0aW1lc3RhbXAgLSB0aGUgdGltZXN0YW1wIHRvIGZvcm1hdFxuICAgKiBAcGFyYW0gZm9ybWF0IC0gdGhlIGRhdGUvdGltZSB0b2tlblxuICAgKi9cbiAgZm9ybWF0KHRoaXM6IERhdGVBZGFwdGVyPFQ+LCB0aW1lc3RhbXA6IG51bWJlciwgZm9ybWF0OiBUaW1lVW5pdCk6IHN0cmluZztcbiAgLyoqXG4gICAqIEFkZHMgdGhlIHNwZWNpZmllZCBgYW1vdW50YCBvZiBgdW5pdGAgdG8gdGhlIGdpdmVuIGB0aW1lc3RhbXBgLlxuICAgKiBAcGFyYW0gdGltZXN0YW1wIC0gdGhlIGlucHV0IHRpbWVzdGFtcFxuICAgKiBAcGFyYW0gYW1vdW50IC0gdGhlIGFtb3VudCB0byBhZGRcbiAgICogQHBhcmFtIHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcbiAgICovXG4gIGFkZCh0aGlzOiBEYXRlQWRhcHRlcjxUPiwgdGltZXN0YW1wOiBudW1iZXIsIGFtb3VudDogbnVtYmVyLCB1bml0OiBUaW1lVW5pdCk6IG51bWJlcjtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBgdW5pdGAgYmV0d2VlbiB0aGUgZ2l2ZW4gdGltZXN0YW1wcy5cbiAgICogQHBhcmFtIGEgLSB0aGUgaW5wdXQgdGltZXN0YW1wIChyZWZlcmVuY2UpXG4gICAqIEBwYXJhbSBiIC0gdGhlIHRpbWVzdGFtcCB0byBzdWJ0cmFjdFxuICAgKiBAcGFyYW0gdW5pdCAtIHRoZSB1bml0IGFzIHN0cmluZ1xuICAgKi9cbiAgZGlmZih0aGlzOiBEYXRlQWRhcHRlcjxUPiwgYTogbnVtYmVyLCBiOiBudW1iZXIsIHVuaXQ6IFRpbWVVbml0KTogbnVtYmVyO1xuICAvKipcbiAgICogUmV0dXJucyBzdGFydCBvZiBgdW5pdGAgZm9yIHRoZSBnaXZlbiBgdGltZXN0YW1wYC5cbiAgICogQHBhcmFtIHRpbWVzdGFtcCAtIHRoZSBpbnB1dCB0aW1lc3RhbXBcbiAgICogQHBhcmFtIHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcbiAgICogQHBhcmFtIFt3ZWVrZGF5XSAtIHRoZSBJU08gZGF5IG9mIHRoZSB3ZWVrIHdpdGggMSBiZWluZyBNb25kYXlcbiAgICogYW5kIDcgYmVpbmcgU3VuZGF5IChvbmx5IG5lZWRlZCBpZiBwYXJhbSAqdW5pdCogaXMgYGlzb1dlZWtgKS5cbiAgICovXG4gIHN0YXJ0T2YodGhpczogRGF0ZUFkYXB0ZXI8VD4sIHRpbWVzdGFtcDogbnVtYmVyLCB1bml0OiBUaW1lVW5pdCB8ICdpc29XZWVrJywgd2Vla2RheT86IG51bWJlcik6IG51bWJlcjtcbiAgLyoqXG4gICAqIFJldHVybnMgZW5kIG9mIGB1bml0YCBmb3IgdGhlIGdpdmVuIGB0aW1lc3RhbXBgLlxuICAgKiBAcGFyYW0gdGltZXN0YW1wIC0gdGhlIGlucHV0IHRpbWVzdGFtcFxuICAgKiBAcGFyYW0gdW5pdCAtIHRoZSB1bml0IGFzIHN0cmluZ1xuICAgKi9cbiAgZW5kT2YodGhpczogRGF0ZUFkYXB0ZXI8VD4sIHRpbWVzdGFtcDogbnVtYmVyLCB1bml0OiBUaW1lVW5pdCB8ICdpc29XZWVrJyk6IG51bWJlcjtcbn1cblxuZnVuY3Rpb24gYWJzdHJhY3Q8VCA9IHZvaWQ+KCk6IFQge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZDogQ2hlY2sgdGhhdCBhIGNvbXBsZXRlIGRhdGUgYWRhcHRlciBpcyBwcm92aWRlZC4nKTtcbn1cblxuLyoqXG4gKiBEYXRlIGFkYXB0ZXIgKGN1cnJlbnQgdXNlZCBieSB0aGUgdGltZSBzY2FsZSlcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuX2FkYXB0ZXJzLl9kYXRlXG4gKiBAbWVtYmVyb2YgQ2hhcnQuX2FkYXB0ZXJzXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBEYXRlQWRhcHRlckJhc2UgaW1wbGVtZW50cyBEYXRlQWRhcHRlciB7XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIGRlZmF1bHQgZGF0ZSBhZGFwdGVyIG1ldGhvZHMuXG4gICAqIEFjY2VwdHMgdHlwZSBwYXJhbWV0ZXIgdG8gZGVmaW5lIG9wdGlvbnMgdHlwZS5cbiAgICogQGV4YW1wbGVcbiAgICogQ2hhcnQuX2FkYXB0ZXJzLl9kYXRlLm92ZXJyaWRlPHtteUFkYXB0ZXJPcHRpb246IHN0cmluZ30+KHtcbiAgICogICBpbml0KCkge1xuICAgKiAgICAgY29uc29sZS5sb2codGhpcy5vcHRpb25zLm15QWRhcHRlck9wdGlvbik7XG4gICAqICAgfVxuICAgKiB9KVxuICAgKi9cbiAgc3RhdGljIG92ZXJyaWRlPFQgZXh0ZW5kcyBBbnlPYmplY3QgPSBBbnlPYmplY3Q+KFxuICAgIG1lbWJlcnM6IFBhcnRpYWw8T21pdDxEYXRlQWRhcHRlcjxUPiwgJ29wdGlvbnMnPj5cbiAgKSB7XG4gICAgT2JqZWN0LmFzc2lnbihEYXRlQWRhcHRlckJhc2UucHJvdG90eXBlLCBtZW1iZXJzKTtcbiAgfVxuXG4gIHJlYWRvbmx5IG9wdGlvbnM6IEFueU9iamVjdDtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBBbnlPYmplY3QpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuICBpbml0KCkge31cblxuICBmb3JtYXRzKCk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4ge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgcGFyc2UoKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICBmb3JtYXQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIGFkZCgpOiBudW1iZXIge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgZGlmZigpOiBudW1iZXIge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgc3RhcnRPZigpOiBudW1iZXIge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgZW5kT2YoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9kYXRlOiBEYXRlQWRhcHRlckJhc2Vcbn07XG4iLCAiaW1wb3J0IHtfbG9va3VwQnlLZXksIF9ybG9va3VwQnlLZXl9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb2xsZWN0aW9uLmpzJztcbmltcG9ydCB7Z2V0UmVsYXRpdmVQb3NpdGlvbn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmRvbS5qcyc7XG5pbXBvcnQge19hbmdsZUJldHdlZW4sIGdldEFuZ2xlRnJvbVBvaW50fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge19pc1BvaW50SW5BcmVhfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLkNoYXJ0RXZlbnQgfSBDaGFydEV2ZW50XG4gKiBAdHlwZWRlZiB7e2F4aXM/OiBzdHJpbmcsIGludGVyc2VjdD86IGJvb2xlYW4sIGluY2x1ZGVJbnZpc2libGU/OiBib29sZWFufX0gSW50ZXJhY3Rpb25PcHRpb25zXG4gKiBAdHlwZWRlZiB7e2RhdGFzZXRJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyLCBlbGVtZW50OiBpbXBvcnQoJy4vY29yZS5lbGVtZW50LmpzJykuZGVmYXVsdH19IEludGVyYWN0aW9uSXRlbVxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuUG9pbnQgfSBQb2ludFxuICovXG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGRvIGJpbmFyeSBzZWFyY2ggd2hlbiBwb3NzaWJsZVxuICogQHBhcmFtIHtvYmplY3R9IG1ldGFzZXQgLSB0aGUgZGF0YXNldCBtZXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGlzIG1vZGUuIHh8eXx4eXxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gZmluZFxuICogQHBhcmFtIHtib29sZWFufSBbaW50ZXJzZWN0XSAtIHNob3VsZCB0aGUgZWxlbWVudCBpbnRlcnNlY3RcbiAqIEByZXR1cm5zIHt7bG86bnVtYmVyLCBoaTpudW1iZXJ9fSBpbmRpY2VzIHRvIHNlYXJjaCBkYXRhIGFycmF5IGJldHdlZW5cbiAqL1xuZnVuY3Rpb24gYmluYXJ5U2VhcmNoKG1ldGFzZXQsIGF4aXMsIHZhbHVlLCBpbnRlcnNlY3QpIHtcbiAgY29uc3Qge2NvbnRyb2xsZXIsIGRhdGEsIF9zb3J0ZWR9ID0gbWV0YXNldDtcbiAgY29uc3QgaVNjYWxlID0gY29udHJvbGxlci5fY2FjaGVkTWV0YS5pU2NhbGU7XG4gIGlmIChpU2NhbGUgJiYgYXhpcyA9PT0gaVNjYWxlLmF4aXMgJiYgYXhpcyAhPT0gJ3InICYmIF9zb3J0ZWQgJiYgZGF0YS5sZW5ndGgpIHtcbiAgICBjb25zdCBsb29rdXBNZXRob2QgPSBpU2NhbGUuX3JldmVyc2VQaXhlbHMgPyBfcmxvb2t1cEJ5S2V5IDogX2xvb2t1cEJ5S2V5O1xuICAgIGlmICghaW50ZXJzZWN0KSB7XG4gICAgICByZXR1cm4gbG9va3VwTWV0aG9kKGRhdGEsIGF4aXMsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRyb2xsZXIuX3NoYXJlZE9wdGlvbnMpIHtcbiAgICAgIC8vIF9zaGFyZWRPcHRpb25zIGluZGljYXRlcyB0aGF0IGVhY2ggZWxlbWVudCBoYXMgZXF1YWwgb3B0aW9ucyAtPiBlcXVhbCBwcm9wb3J0aW9uc1xuICAgICAgLy8gU28gd2UgY2FuIGRvIGEgcmFuZ2VkIGJpbmFyeSBzZWFyY2ggYmFzZWQgb24gdGhlIHJhbmdlIG9mIGZpcnN0IGVsZW1lbnQgYW5kXG4gICAgICAvLyBiZSBjb25maWRlbnQgdG8gZ2V0IHRoZSBmdWxsIHJhbmdlIG9mIGluZGljZXMgdGhhdCBjYW4gaW50ZXJzZWN0IHdpdGggdGhlIHZhbHVlLlxuICAgICAgY29uc3QgZWwgPSBkYXRhWzBdO1xuICAgICAgY29uc3QgcmFuZ2UgPSB0eXBlb2YgZWwuZ2V0UmFuZ2UgPT09ICdmdW5jdGlvbicgJiYgZWwuZ2V0UmFuZ2UoYXhpcyk7XG4gICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBsb29rdXBNZXRob2QoZGF0YSwgYXhpcywgdmFsdWUgLSByYW5nZSk7XG4gICAgICAgIGNvbnN0IGVuZCA9IGxvb2t1cE1ldGhvZChkYXRhLCBheGlzLCB2YWx1ZSArIHJhbmdlKTtcbiAgICAgICAgcmV0dXJuIHtsbzogc3RhcnQubG8sIGhpOiBlbmQuaGl9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBEZWZhdWx0IHRvIGFsbCBlbGVtZW50cywgd2hlbiBiaW5hcnkgc2VhcmNoIGNhbiBub3QgYmUgdXNlZC5cbiAgcmV0dXJuIHtsbzogMCwgaGk6IGRhdGEubGVuZ3RoIC0gMX07XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIHNlbGVjdCBjYW5kaWRhdGUgZWxlbWVudHMgZm9yIGludGVyYWN0aW9uXG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydFxuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhpcyBtb2RlLiB4fHl8eHl8clxuICogQHBhcmFtIHtQb2ludH0gcG9zaXRpb24gLSB0aGUgcG9pbnQgdG8gYmUgbmVhcmVzdCB0bywgaW4gcmVsYXRpdmUgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgLSB0aGUgY2FsbGJhY2sgdG8gZXhlY3V0ZSBmb3IgZWFjaCB2aXNpYmxlIGl0ZW1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ludGVyc2VjdF0gLSBjb25zaWRlciBpbnRlcnNlY3RpbmcgaXRlbXNcbiAqL1xuZnVuY3Rpb24gZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgaGFuZGxlciwgaW50ZXJzZWN0KSB7XG4gIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW2F4aXNdO1xuICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IG1ldGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGNvbnN0IHtpbmRleCwgZGF0YX0gPSBtZXRhc2V0c1tpXTtcbiAgICBjb25zdCB7bG8sIGhpfSA9IGJpbmFyeVNlYXJjaChtZXRhc2V0c1tpXSwgYXhpcywgdmFsdWUsIGludGVyc2VjdCk7XG4gICAgZm9yIChsZXQgaiA9IGxvOyBqIDw9IGhpOyArK2opIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBkYXRhW2pdO1xuICAgICAgaWYgKCFlbGVtZW50LnNraXApIHtcbiAgICAgICAgaGFuZGxlcihlbGVtZW50LCBpbmRleCwgaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2V0IGEgZGlzdGFuY2UgbWV0cmljIGZ1bmN0aW9uIGZvciB0d28gcG9pbnRzIGJhc2VkIG9uIHRoZVxuICogYXhpcyBtb2RlIHNldHRpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIC0gdGhlIGF4aXMgbW9kZS4geHx5fHh5fHJcbiAqL1xuZnVuY3Rpb24gZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzKGF4aXMpIHtcbiAgY29uc3QgdXNlWCA9IGF4aXMuaW5kZXhPZigneCcpICE9PSAtMTtcbiAgY29uc3QgdXNlWSA9IGF4aXMuaW5kZXhPZigneScpICE9PSAtMTtcblxuICByZXR1cm4gZnVuY3Rpb24ocHQxLCBwdDIpIHtcbiAgICBjb25zdCBkZWx0YVggPSB1c2VYID8gTWF0aC5hYnMocHQxLnggLSBwdDIueCkgOiAwO1xuICAgIGNvbnN0IGRlbHRhWSA9IHVzZVkgPyBNYXRoLmFicyhwdDEueSAtIHB0Mi55KSA6IDA7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhkZWx0YVgsIDIpICsgTWF0aC5wb3coZGVsdGFZLCAyKSk7XG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaXRlbXMgdGhhdCBpbnRlcnNlY3QgdGhlIGV2ZW50IHBvc2l0aW9uXG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydFxuICogQHBhcmFtIHtQb2ludH0gcG9zaXRpb24gLSB0aGUgcG9pbnQgdG8gYmUgbmVhcmVzdCB0bywgaW4gcmVsYXRpdmUgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIC0gdGhlIGF4aXMgbW9kZS4geHx5fHh5fHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIHRoZSBlbGVtZW50J3MgYW5pbWF0aW9uIHRhcmdldCBpbnN0ZWFkIG9mIGN1cnJlbnQgcG9zaXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVJbnZpc2libGVdIC0gaW5jbHVkZSBpbnZpc2libGUgcG9pbnRzIHRoYXQgYXJlIG91dHNpZGUgb2YgdGhlIGNoYXJ0IGFyZWFcbiAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSB0aGUgbmVhcmVzdCBpdGVtc1xuICovXG5mdW5jdGlvbiBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpIHtcbiAgY29uc3QgaXRlbXMgPSBbXTtcblxuICBpZiAoIWluY2x1ZGVJbnZpc2libGUgJiYgIWNoYXJ0LmlzUG9pbnRJbkFyZWEocG9zaXRpb24pKSB7XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG5cbiAgY29uc3QgZXZhbHVhdGlvbkZ1bmMgPSBmdW5jdGlvbihlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgaWYgKCFpbmNsdWRlSW52aXNpYmxlICYmICFfaXNQb2ludEluQXJlYShlbGVtZW50LCBjaGFydC5jaGFydEFyZWEsIDApKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdXNlRmluYWxQb3NpdGlvbikpIHtcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcbiAgICB9XG4gIH07XG5cbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgZXZhbHVhdGlvbkZ1bmMsIHRydWUpO1xuICByZXR1cm4gaXRlbXM7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaXRlbXMgbmVhcmVzdCB0byB0aGUgZXZlbnQgcG9zaXRpb24gZm9yIGEgcmFkaWFsIGNoYXJ0XG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byBsb29rIGF0IGVsZW1lbnRzIGZyb21cbiAqIEBwYXJhbSB7UG9pbnR9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG8sIGluIHJlbGF0aXZlIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGVzIGFsb25nIHdoaWNoIHRvIG1lYXN1cmUgZGlzdGFuY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIHRoZSBlbGVtZW50J3MgYW5pbWF0aW9uIHRhcmdldCBpbnN0ZWFkIG9mIGN1cnJlbnQgcG9zaXRpb25cbiAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSB0aGUgbmVhcmVzdCBpdGVtc1xuICovXG5mdW5jdGlvbiBnZXROZWFyZXN0UmFkaWFsSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGxldCBpdGVtcyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGV2YWx1YXRpb25GdW5jKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICBjb25zdCB7c3RhcnRBbmdsZSwgZW5kQW5nbGV9ID0gZWxlbWVudC5nZXRQcm9wcyhbJ3N0YXJ0QW5nbGUnLCAnZW5kQW5nbGUnXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3Qge2FuZ2xlfSA9IGdldEFuZ2xlRnJvbVBvaW50KGVsZW1lbnQsIHt4OiBwb3NpdGlvbi54LCB5OiBwb3NpdGlvbi55fSk7XG5cbiAgICBpZiAoX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpKSB7XG4gICAgICBpdGVtcy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSk7XG4gICAgfVxuICB9XG5cbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgZXZhbHVhdGlvbkZ1bmMpO1xuICByZXR1cm4gaXRlbXM7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaXRlbXMgbmVhcmVzdCB0byB0aGUgZXZlbnQgcG9zaXRpb24gZm9yIGEgY2FydGVzaWFuIGNoYXJ0XG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byBsb29rIGF0IGVsZW1lbnRzIGZyb21cbiAqIEBwYXJhbSB7UG9pbnR9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG8sIGluIHJlbGF0aXZlIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGVzIGFsb25nIHdoaWNoIHRvIG1lYXN1cmUgZGlzdGFuY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ludGVyc2VjdF0gLSBpZiB0cnVlLCBvbmx5IGNvbnNpZGVyIGl0ZW1zIHRoYXQgaW50ZXJzZWN0IHRoZSBwb3NpdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgdGhlIGVsZW1lbnQncyBhbmltYXRpb24gdGFyZ2V0IGluc3RlYWQgb2YgY3VycmVudCBwb3NpdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbaW5jbHVkZUludmlzaWJsZV0gLSBpbmNsdWRlIGludmlzaWJsZSBwb2ludHMgdGhhdCBhcmUgb3V0c2lkZSBvZiB0aGUgY2hhcnQgYXJlYVxuICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IHRoZSBuZWFyZXN0IGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGdldE5lYXJlc3RDYXJ0ZXNpYW5JdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSkge1xuICBsZXQgaXRlbXMgPSBbXTtcbiAgY29uc3QgZGlzdGFuY2VNZXRyaWMgPSBnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMoYXhpcyk7XG4gIGxldCBtaW5EaXN0YW5jZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblxuICBmdW5jdGlvbiBldmFsdWF0aW9uRnVuYyhlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgY29uc3QgaW5SYW5nZSA9IGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBpZiAoaW50ZXJzZWN0ICYmICFpblJhbmdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2VudGVyID0gZWxlbWVudC5nZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCBwb2ludEluQXJlYSA9ICEhaW5jbHVkZUludmlzaWJsZSB8fCBjaGFydC5pc1BvaW50SW5BcmVhKGNlbnRlcik7XG4gICAgaWYgKCFwb2ludEluQXJlYSAmJiAhaW5SYW5nZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGRpc3RhbmNlID0gZGlzdGFuY2VNZXRyaWMocG9zaXRpb24sIGNlbnRlcik7XG4gICAgaWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgIGl0ZW1zID0gW3tlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fV07XG4gICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgIH0gZWxzZSBpZiAoZGlzdGFuY2UgPT09IG1pbkRpc3RhbmNlKSB7XG4gICAgICAvLyBDYW4gaGF2ZSBtdWx0aXBsZSBpdGVtcyBhdCB0aGUgc2FtZSBkaXN0YW5jZSBpbiB3aGljaCBjYXNlIHdlIHNvcnQgYnkgc2l6ZVxuICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0pO1xuICAgIH1cbiAgfVxuXG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGV2YWx1YXRpb25GdW5jKTtcbiAgcmV0dXJuIGl0ZW1zO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGl0ZW1zIG5lYXJlc3QgdG8gdGhlIGV2ZW50IHBvc2l0aW9uIGNvbnNpZGVyaW5nIGFsbCB2aXNpYmxlIGl0ZW1zIGluIHRoZSBjaGFydFxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gbG9vayBhdCBlbGVtZW50cyBmcm9tXG4gKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvbiAtIHRoZSBwb2ludCB0byBiZSBuZWFyZXN0IHRvLCBpbiByZWxhdGl2ZSBjb29yZGluYXRlc1xuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhlcyBhbG9uZyB3aGljaCB0byBtZWFzdXJlIGRpc3RhbmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbnRlcnNlY3RdIC0gaWYgdHJ1ZSwgb25seSBjb25zaWRlciBpdGVtcyB0aGF0IGludGVyc2VjdCB0aGUgcG9zaXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIHRoZSBlbGVtZW50J3MgYW5pbWF0aW9uIHRhcmdldCBpbnN0ZWFkIG9mIGN1cnJlbnQgcG9zaXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVJbnZpc2libGVdIC0gaW5jbHVkZSBpbnZpc2libGUgcG9pbnRzIHRoYXQgYXJlIG91dHNpZGUgb2YgdGhlIGNoYXJ0IGFyZWFcbiAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSB0aGUgbmVhcmVzdCBpdGVtc1xuICovXG5mdW5jdGlvbiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpIHtcbiAgaWYgKCFpbmNsdWRlSW52aXNpYmxlICYmICFjaGFydC5pc1BvaW50SW5BcmVhKHBvc2l0aW9uKSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHJldHVybiBheGlzID09PSAncicgJiYgIWludGVyc2VjdFxuICAgID8gZ2V0TmVhcmVzdFJhZGlhbEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbilcbiAgICA6IGdldE5lYXJlc3RDYXJ0ZXNpYW5JdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaXRlbXMgbWF0Y2hpbmcgYWxvbmcgdGhlIGdpdmVuIFggb3IgWSBheGlzXG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byBsb29rIGF0IGVsZW1lbnRzIGZyb21cbiAqIEBwYXJhbSB7UG9pbnR9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG8sIGluIHJlbGF0aXZlIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGlzIHRvIG1hdGNoXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbnRlcnNlY3RdIC0gaWYgdHJ1ZSwgb25seSBjb25zaWRlciBpdGVtcyB0aGF0IGludGVyc2VjdCB0aGUgcG9zaXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIHRoZSBlbGVtZW50J3MgYW5pbWF0aW9uIHRhcmdldCBpbnN0ZWFkIG9mIGN1cnJlbnQgcG9zaXRpb25cbiAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSB0aGUgbmVhcmVzdCBpdGVtc1xuICovXG5mdW5jdGlvbiBnZXRBeGlzSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgY29uc3QgaXRlbXMgPSBbXTtcbiAgY29uc3QgcmFuZ2VNZXRob2QgPSBheGlzID09PSAneCcgPyAnaW5YUmFuZ2UnIDogJ2luWVJhbmdlJztcbiAgbGV0IGludGVyc2VjdHNJdGVtID0gZmFsc2U7XG5cbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpID0+IHtcbiAgICBpZiAoZWxlbWVudFtyYW5nZU1ldGhvZF0ocG9zaXRpb25bYXhpc10sIHVzZUZpbmFsUG9zaXRpb24pKSB7XG4gICAgICBpdGVtcy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSk7XG4gICAgICBpbnRlcnNlY3RzSXRlbSA9IGludGVyc2VjdHNJdGVtIHx8IGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIElmIHdlIHdhbnQgdG8gdHJpZ2dlciBvbiBhbiBpbnRlcnNlY3QgYW5kIHdlIGRvbid0IGhhdmUgYW55IGl0ZW1zXG4gIC8vIHRoYXQgaW50ZXJzZWN0IHRoZSBwb3NpdGlvbiwgcmV0dXJuIG5vdGhpbmdcbiAgaWYgKGludGVyc2VjdCAmJiAhaW50ZXJzZWN0c0l0ZW0pIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIGl0ZW1zO1xufVxuXG4vKipcbiAqIENvbnRhaW5zIGludGVyYWN0aW9uIHJlbGF0ZWQgZnVuY3Rpb25zXG4gKiBAbmFtZXNwYWNlIENoYXJ0LkludGVyYWN0aW9uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLy8gUGFydCBvZiB0aGUgcHVibGljIEFQSSB0byBmYWNpbGl0YXRlIGRldmVsb3BlcnMgY3JlYXRpbmcgdGhlaXIgb3duIG1vZGVzXG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyxcblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gZm9yIGRpZmZlcmVudCBtb2Rlc1xuICBtb2Rlczoge1xuICAgIC8qKlxuXHRcdCAqIFJldHVybnMgaXRlbXMgYXQgdGhlIHNhbWUgaW5kZXguIElmIHRoZSBvcHRpb25zLmludGVyc2VjdCBwYXJhbWV0ZXIgaXMgdHJ1ZSwgd2Ugb25seSByZXR1cm4gaXRlbXMgaWYgd2UgaW50ZXJzZWN0IHNvbWV0aGluZ1xuXHRcdCAqIElmIHRoZSBvcHRpb25zLmludGVyc2VjdCBtb2RlIGlzIGZhbHNlLCB3ZSBmaW5kIHRoZSBuZWFyZXN0IGl0ZW0gYW5kIHJldHVybiB0aGUgaXRlbXMgYXQgdGhlIHNhbWUgaW5kZXggYXMgdGhhdCBpdGVtXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmluZGV4XG5cdFx0ICogQHNpbmNlIHYyLjQuMFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIGZpbmFsIGVsZW1lbnQgcG9zaXRpb24gKGFuaW1hdGlvbiB0YXJnZXQpXG5cdFx0ICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IC0gaXRlbXMgdGhhdCBhcmUgZm91bmRcblx0XHQgKi9cbiAgICBpbmRleChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIC8vIERlZmF1bHQgYXhpcyBmb3IgaW5kZXggbW9kZSBpcyAneCcgdG8gbWF0Y2ggb2xkIGJlaGF2aW91clxuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneCc7XG4gICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xuICAgICAgY29uc3QgaXRlbXMgPSBvcHRpb25zLmludGVyc2VjdFxuICAgICAgICA/IGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSlcbiAgICAgICAgOiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBmYWxzZSwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG4gICAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuXG4gICAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKS5mb3JFYWNoKChtZXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gaXRlbXNbMF0uaW5kZXg7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBtZXRhLmRhdGFbaW5kZXhdO1xuXG4gICAgICAgIC8vIGRvbid0IGNvdW50IGl0ZW1zIHRoYXQgYXJlIHNraXBwZWQgKG51bGwgZGF0YSlcbiAgICAgICAgaWYgKGVsZW1lbnQgJiYgIWVsZW1lbnQuc2tpcCkge1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleDogbWV0YS5pbmRleCwgaW5kZXh9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICB9LFxuXG4gICAgLyoqXG5cdFx0ICogUmV0dXJucyBpdGVtcyBpbiB0aGUgc2FtZSBkYXRhc2V0LiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgcGFyYW1ldGVyIGlzIHRydWUsIHdlIG9ubHkgcmV0dXJuIGl0ZW1zIGlmIHdlIGludGVyc2VjdCBzb21ldGhpbmdcblx0XHQgKiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgaXMgZmFsc2UsIHdlIGZpbmQgdGhlIG5lYXJlc3QgaXRlbSBhbmQgcmV0dXJuIHRoZSBpdGVtcyBpbiB0aGF0IGRhdGFzZXRcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMuZGF0YXNldFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIGZpbmFsIGVsZW1lbnQgcG9zaXRpb24gKGFuaW1hdGlvbiB0YXJnZXQpXG5cdFx0ICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IC0gaXRlbXMgdGhhdCBhcmUgZm91bmRcblx0XHQgKi9cbiAgICBkYXRhc2V0KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuICAgICAgY29uc3QgaW5jbHVkZUludmlzaWJsZSA9IG9wdGlvbnMuaW5jbHVkZUludmlzaWJsZSB8fCBmYWxzZTtcbiAgICAgIGxldCBpdGVtcyA9IG9wdGlvbnMuaW50ZXJzZWN0XG4gICAgICAgID8gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKSA6XG4gICAgICAgIGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGZhbHNlLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcblxuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgZGF0YXNldEluZGV4ID0gaXRlbXNbMF0uZGF0YXNldEluZGV4O1xuICAgICAgICBjb25zdCBkYXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5kYXRhO1xuICAgICAgICBpdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKHtlbGVtZW50OiBkYXRhW2ldLCBkYXRhc2V0SW5kZXgsIGluZGV4OiBpfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH0sXG5cbiAgICAvKipcblx0XHQgKiBQb2ludCBtb2RlIHJldHVybnMgYWxsIGVsZW1lbnRzIHRoYXQgaGl0IHRlc3QgYmFzZWQgb24gdGhlIGV2ZW50IHBvc2l0aW9uXG5cdFx0ICogb2YgdGhlIGV2ZW50XG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmludGVyc2VjdFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIGZpbmFsIGVsZW1lbnQgcG9zaXRpb24gKGFuaW1hdGlvbiB0YXJnZXQpXG5cdFx0ICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IC0gaXRlbXMgdGhhdCBhcmUgZm91bmRcblx0XHQgKi9cbiAgICBwb2ludChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIGNvbnN0IGF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3h5JztcbiAgICAgIGNvbnN0IGluY2x1ZGVJbnZpc2libGUgPSBvcHRpb25zLmluY2x1ZGVJbnZpc2libGUgfHwgZmFsc2U7XG4gICAgICByZXR1cm4gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcbiAgICB9LFxuXG4gICAgLyoqXG5cdFx0ICogbmVhcmVzdCBtb2RlIHJldHVybnMgdGhlIGVsZW1lbnQgY2xvc2VzdCB0byB0aGUgcG9pbnRcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMuaW50ZXJzZWN0XG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0ge0ludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgZmluYWwgZWxlbWVudCBwb3NpdGlvbiAoYW5pbWF0aW9uIHRhcmdldClcblx0XHQgKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gLSBpdGVtcyB0aGF0IGFyZSBmb3VuZFxuXHRcdCAqL1xuICAgIG5lYXJlc3QoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG4gICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xuICAgICAgcmV0dXJuIGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIG9wdGlvbnMuaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcbiAgICB9LFxuXG4gICAgLyoqXG5cdFx0ICogeCBtb2RlIHJldHVybnMgdGhlIGVsZW1lbnRzIHRoYXQgaGl0LXRlc3QgYXQgdGhlIGN1cnJlbnQgeCBjb29yZGluYXRlXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLnhcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSBmaW5hbCBlbGVtZW50IHBvc2l0aW9uIChhbmltYXRpb24gdGFyZ2V0KVxuXHRcdCAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSAtIGl0ZW1zIHRoYXQgYXJlIGZvdW5kXG5cdFx0ICovXG4gICAgeChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIHJldHVybiBnZXRBeGlzSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCAneCcsIG9wdGlvbnMuaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG5cdFx0ICogeSBtb2RlIHJldHVybnMgdGhlIGVsZW1lbnRzIHRoYXQgaGl0LXRlc3QgYXQgdGhlIGN1cnJlbnQgeSBjb29yZGluYXRlXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLnlcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSBmaW5hbCBlbGVtZW50IHBvc2l0aW9uIChhbmltYXRpb24gdGFyZ2V0KVxuXHRcdCAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSAtIGl0ZW1zIHRoYXQgYXJlIGZvdW5kXG5cdFx0ICovXG4gICAgeShjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIHJldHVybiBnZXRBeGlzSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCAneScsIG9wdGlvbnMuaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9XG4gIH1cbn07XG4iLCAiaW1wb3J0IHtkZWZpbmVkLCBlYWNoLCBpc09iamVjdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHt0b1BhZGRpbmd9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqL1xuXG5jb25zdCBTVEFUSUNfUE9TSVRJT05TID0gWydsZWZ0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nXTtcblxuZnVuY3Rpb24gZmlsdGVyQnlQb3NpdGlvbihhcnJheSwgcG9zaXRpb24pIHtcbiAgcmV0dXJuIGFycmF5LmZpbHRlcih2ID0+IHYucG9zID09PSBwb3NpdGlvbik7XG59XG5cbmZ1bmN0aW9uIGZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyhhcnJheSwgYXhpcykge1xuICByZXR1cm4gYXJyYXkuZmlsdGVyKHYgPT4gU1RBVElDX1BPU0lUSU9OUy5pbmRleE9mKHYucG9zKSA9PT0gLTEgJiYgdi5ib3guYXhpcyA9PT0gYXhpcyk7XG59XG5cbmZ1bmN0aW9uIHNvcnRCeVdlaWdodChhcnJheSwgcmV2ZXJzZSkge1xuICByZXR1cm4gYXJyYXkuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IHYwID0gcmV2ZXJzZSA/IGIgOiBhO1xuICAgIGNvbnN0IHYxID0gcmV2ZXJzZSA/IGEgOiBiO1xuICAgIHJldHVybiB2MC53ZWlnaHQgPT09IHYxLndlaWdodCA/XG4gICAgICB2MC5pbmRleCAtIHYxLmluZGV4IDpcbiAgICAgIHYwLndlaWdodCAtIHYxLndlaWdodDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHdyYXBCb3hlcyhib3hlcykge1xuICBjb25zdCBsYXlvdXRCb3hlcyA9IFtdO1xuICBsZXQgaSwgaWxlbiwgYm94LCBwb3MsIHN0YWNrLCBzdGFja1dlaWdodDtcblxuICBmb3IgKGkgPSAwLCBpbGVuID0gKGJveGVzIHx8IFtdKS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBib3ggPSBib3hlc1tpXTtcbiAgICAoe3Bvc2l0aW9uOiBwb3MsIG9wdGlvbnM6IHtzdGFjaywgc3RhY2tXZWlnaHQgPSAxfX0gPSBib3gpO1xuICAgIGxheW91dEJveGVzLnB1c2goe1xuICAgICAgaW5kZXg6IGksXG4gICAgICBib3gsXG4gICAgICBwb3MsXG4gICAgICBob3Jpem9udGFsOiBib3guaXNIb3Jpem9udGFsKCksXG4gICAgICB3ZWlnaHQ6IGJveC53ZWlnaHQsXG4gICAgICBzdGFjazogc3RhY2sgJiYgKHBvcyArIHN0YWNrKSxcbiAgICAgIHN0YWNrV2VpZ2h0XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGxheW91dEJveGVzO1xufVxuXG5mdW5jdGlvbiBidWlsZFN0YWNrcyhsYXlvdXRzKSB7XG4gIGNvbnN0IHN0YWNrcyA9IHt9O1xuICBmb3IgKGNvbnN0IHdyYXAgb2YgbGF5b3V0cykge1xuICAgIGNvbnN0IHtzdGFjaywgcG9zLCBzdGFja1dlaWdodH0gPSB3cmFwO1xuICAgIGlmICghc3RhY2sgfHwgIVNUQVRJQ19QT1NJVElPTlMuaW5jbHVkZXMocG9zKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IF9zdGFjayA9IHN0YWNrc1tzdGFja10gfHwgKHN0YWNrc1tzdGFja10gPSB7Y291bnQ6IDAsIHBsYWNlZDogMCwgd2VpZ2h0OiAwLCBzaXplOiAwfSk7XG4gICAgX3N0YWNrLmNvdW50Kys7XG4gICAgX3N0YWNrLndlaWdodCArPSBzdGFja1dlaWdodDtcbiAgfVxuICByZXR1cm4gc3RhY2tzO1xufVxuXG4vKipcbiAqIHN0b3JlIGRpbWVuc2lvbnMgdXNlZCBpbnN0ZWFkIG9mIGF2YWlsYWJsZSBjaGFydEFyZWEgaW4gZml0Qm94ZXNcbiAqKi9cbmZ1bmN0aW9uIHNldExheW91dERpbXMobGF5b3V0cywgcGFyYW1zKSB7XG4gIGNvbnN0IHN0YWNrcyA9IGJ1aWxkU3RhY2tzKGxheW91dHMpO1xuICBjb25zdCB7dkJveE1heFdpZHRoLCBoQm94TWF4SGVpZ2h0fSA9IHBhcmFtcztcbiAgbGV0IGksIGlsZW4sIGxheW91dDtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGxheW91dHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgbGF5b3V0ID0gbGF5b3V0c1tpXTtcbiAgICBjb25zdCB7ZnVsbFNpemV9ID0gbGF5b3V0LmJveDtcbiAgICBjb25zdCBzdGFjayA9IHN0YWNrc1tsYXlvdXQuc3RhY2tdO1xuICAgIGNvbnN0IGZhY3RvciA9IHN0YWNrICYmIGxheW91dC5zdGFja1dlaWdodCAvIHN0YWNrLndlaWdodDtcbiAgICBpZiAobGF5b3V0Lmhvcml6b250YWwpIHtcbiAgICAgIGxheW91dC53aWR0aCA9IGZhY3RvciA/IGZhY3RvciAqIHZCb3hNYXhXaWR0aCA6IGZ1bGxTaXplICYmIHBhcmFtcy5hdmFpbGFibGVXaWR0aDtcbiAgICAgIGxheW91dC5oZWlnaHQgPSBoQm94TWF4SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXlvdXQud2lkdGggPSB2Qm94TWF4V2lkdGg7XG4gICAgICBsYXlvdXQuaGVpZ2h0ID0gZmFjdG9yID8gZmFjdG9yICogaEJveE1heEhlaWdodCA6IGZ1bGxTaXplICYmIHBhcmFtcy5hdmFpbGFibGVIZWlnaHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdGFja3M7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkTGF5b3V0Qm94ZXMoYm94ZXMpIHtcbiAgY29uc3QgbGF5b3V0Qm94ZXMgPSB3cmFwQm94ZXMoYm94ZXMpO1xuICBjb25zdCBmdWxsU2l6ZSA9IHNvcnRCeVdlaWdodChsYXlvdXRCb3hlcy5maWx0ZXIod3JhcCA9PiB3cmFwLmJveC5mdWxsU2l6ZSksIHRydWUpO1xuICBjb25zdCBsZWZ0ID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdsZWZ0JyksIHRydWUpO1xuICBjb25zdCByaWdodCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAncmlnaHQnKSk7XG4gIGNvbnN0IHRvcCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAndG9wJyksIHRydWUpO1xuICBjb25zdCBib3R0b20gPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ2JvdHRvbScpKTtcbiAgY29uc3QgY2VudGVySG9yaXpvbnRhbCA9IGZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyhsYXlvdXRCb3hlcywgJ3gnKTtcbiAgY29uc3QgY2VudGVyVmVydGljYWwgPSBmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMobGF5b3V0Qm94ZXMsICd5Jyk7XG5cbiAgcmV0dXJuIHtcbiAgICBmdWxsU2l6ZSxcbiAgICBsZWZ0QW5kVG9wOiBsZWZ0LmNvbmNhdCh0b3ApLFxuICAgIHJpZ2h0QW5kQm90dG9tOiByaWdodC5jb25jYXQoY2VudGVyVmVydGljYWwpLmNvbmNhdChib3R0b20pLmNvbmNhdChjZW50ZXJIb3Jpem9udGFsKSxcbiAgICBjaGFydEFyZWE6IGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdjaGFydEFyZWEnKSxcbiAgICB2ZXJ0aWNhbDogbGVmdC5jb25jYXQocmlnaHQpLmNvbmNhdChjZW50ZXJWZXJ0aWNhbCksXG4gICAgaG9yaXpvbnRhbDogdG9wLmNvbmNhdChib3R0b20pLmNvbmNhdChjZW50ZXJIb3Jpem9udGFsKVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsIGEsIGIpIHtcbiAgcmV0dXJuIE1hdGgubWF4KG1heFBhZGRpbmdbYV0sIGNoYXJ0QXJlYVthXSkgKyBNYXRoLm1heChtYXhQYWRkaW5nW2JdLCBjaGFydEFyZWFbYl0pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVNYXhQYWRkaW5nKG1heFBhZGRpbmcsIGJveFBhZGRpbmcpIHtcbiAgbWF4UGFkZGluZy50b3AgPSBNYXRoLm1heChtYXhQYWRkaW5nLnRvcCwgYm94UGFkZGluZy50b3ApO1xuICBtYXhQYWRkaW5nLmxlZnQgPSBNYXRoLm1heChtYXhQYWRkaW5nLmxlZnQsIGJveFBhZGRpbmcubGVmdCk7XG4gIG1heFBhZGRpbmcuYm90dG9tID0gTWF0aC5tYXgobWF4UGFkZGluZy5ib3R0b20sIGJveFBhZGRpbmcuYm90dG9tKTtcbiAgbWF4UGFkZGluZy5yaWdodCA9IE1hdGgubWF4KG1heFBhZGRpbmcucmlnaHQsIGJveFBhZGRpbmcucmlnaHQpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVEaW1zKGNoYXJ0QXJlYSwgcGFyYW1zLCBsYXlvdXQsIHN0YWNrcykge1xuICBjb25zdCB7cG9zLCBib3h9ID0gbGF5b3V0O1xuICBjb25zdCBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XG5cbiAgLy8gZHluYW1pY2FsbHkgcGxhY2VkIGJveGVzIHNpemUgaXMgbm90IGNvbnNpZGVyZWRcbiAgaWYgKCFpc09iamVjdChwb3MpKSB7XG4gICAgaWYgKGxheW91dC5zaXplKSB7XG4gICAgICAvLyB0aGlzIGxheW91dCB3YXMgYWxyZWFkeSBjb3VudGVkIGZvciwgbGV0cyBmaXJzdCByZWR1Y2Ugb2xkIHNpemVcbiAgICAgIGNoYXJ0QXJlYVtwb3NdIC09IGxheW91dC5zaXplO1xuICAgIH1cbiAgICBjb25zdCBzdGFjayA9IHN0YWNrc1tsYXlvdXQuc3RhY2tdIHx8IHtzaXplOiAwLCBjb3VudDogMX07XG4gICAgc3RhY2suc2l6ZSA9IE1hdGgubWF4KHN0YWNrLnNpemUsIGxheW91dC5ob3Jpem9udGFsID8gYm94LmhlaWdodCA6IGJveC53aWR0aCk7XG4gICAgbGF5b3V0LnNpemUgPSBzdGFjay5zaXplIC8gc3RhY2suY291bnQ7XG4gICAgY2hhcnRBcmVhW3Bvc10gKz0gbGF5b3V0LnNpemU7XG4gIH1cblxuICBpZiAoYm94LmdldFBhZGRpbmcpIHtcbiAgICB1cGRhdGVNYXhQYWRkaW5nKG1heFBhZGRpbmcsIGJveC5nZXRQYWRkaW5nKCkpO1xuICB9XG5cbiAgY29uc3QgbmV3V2lkdGggPSBNYXRoLm1heCgwLCBwYXJhbXMub3V0ZXJXaWR0aCAtIGdldENvbWJpbmVkTWF4KG1heFBhZGRpbmcsIGNoYXJ0QXJlYSwgJ2xlZnQnLCAncmlnaHQnKSk7XG4gIGNvbnN0IG5ld0hlaWdodCA9IE1hdGgubWF4KDAsIHBhcmFtcy5vdXRlckhlaWdodCAtIGdldENvbWJpbmVkTWF4KG1heFBhZGRpbmcsIGNoYXJ0QXJlYSwgJ3RvcCcsICdib3R0b20nKSk7XG4gIGNvbnN0IHdpZHRoQ2hhbmdlZCA9IG5ld1dpZHRoICE9PSBjaGFydEFyZWEudztcbiAgY29uc3QgaGVpZ2h0Q2hhbmdlZCA9IG5ld0hlaWdodCAhPT0gY2hhcnRBcmVhLmg7XG4gIGNoYXJ0QXJlYS53ID0gbmV3V2lkdGg7XG4gIGNoYXJ0QXJlYS5oID0gbmV3SGVpZ2h0O1xuXG4gIC8vIHJldHVybiBib29sZWFucyBvbiB0aGUgY2hhbmdlcyBwZXIgZGlyZWN0aW9uXG4gIHJldHVybiBsYXlvdXQuaG9yaXpvbnRhbFxuICAgID8ge3NhbWU6IHdpZHRoQ2hhbmdlZCwgb3RoZXI6IGhlaWdodENoYW5nZWR9XG4gICAgOiB7c2FtZTogaGVpZ2h0Q2hhbmdlZCwgb3RoZXI6IHdpZHRoQ2hhbmdlZH07XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU1heFBhZGRpbmcoY2hhcnRBcmVhKSB7XG4gIGNvbnN0IG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcblxuICBmdW5jdGlvbiB1cGRhdGVQb3MocG9zKSB7XG4gICAgY29uc3QgY2hhbmdlID0gTWF0aC5tYXgobWF4UGFkZGluZ1twb3NdIC0gY2hhcnRBcmVhW3Bvc10sIDApO1xuICAgIGNoYXJ0QXJlYVtwb3NdICs9IGNoYW5nZTtcbiAgICByZXR1cm4gY2hhbmdlO1xuICB9XG4gIGNoYXJ0QXJlYS55ICs9IHVwZGF0ZVBvcygndG9wJyk7XG4gIGNoYXJ0QXJlYS54ICs9IHVwZGF0ZVBvcygnbGVmdCcpO1xuICB1cGRhdGVQb3MoJ3JpZ2h0Jyk7XG4gIHVwZGF0ZVBvcygnYm90dG9tJyk7XG59XG5cbmZ1bmN0aW9uIGdldE1hcmdpbnMoaG9yaXpvbnRhbCwgY2hhcnRBcmVhKSB7XG4gIGNvbnN0IG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcblxuICBmdW5jdGlvbiBtYXJnaW5Gb3JQb3NpdGlvbnMocG9zaXRpb25zKSB7XG4gICAgY29uc3QgbWFyZ2luID0ge2xlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMH07XG4gICAgcG9zaXRpb25zLmZvckVhY2goKHBvcykgPT4ge1xuICAgICAgbWFyZ2luW3Bvc10gPSBNYXRoLm1heChjaGFydEFyZWFbcG9zXSwgbWF4UGFkZGluZ1twb3NdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbWFyZ2luO1xuICB9XG5cbiAgcmV0dXJuIGhvcml6b250YWxcbiAgICA/IG1hcmdpbkZvclBvc2l0aW9ucyhbJ2xlZnQnLCAncmlnaHQnXSlcbiAgICA6IG1hcmdpbkZvclBvc2l0aW9ucyhbJ3RvcCcsICdib3R0b20nXSk7XG59XG5cbmZ1bmN0aW9uIGZpdEJveGVzKGJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSB7XG4gIGNvbnN0IHJlZml0Qm94ZXMgPSBbXTtcbiAgbGV0IGksIGlsZW4sIGxheW91dCwgYm94LCByZWZpdCwgY2hhbmdlZDtcblxuICBmb3IgKGkgPSAwLCBpbGVuID0gYm94ZXMubGVuZ3RoLCByZWZpdCA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBsYXlvdXQgPSBib3hlc1tpXTtcbiAgICBib3ggPSBsYXlvdXQuYm94O1xuXG4gICAgYm94LnVwZGF0ZShcbiAgICAgIGxheW91dC53aWR0aCB8fCBjaGFydEFyZWEudyxcbiAgICAgIGxheW91dC5oZWlnaHQgfHwgY2hhcnRBcmVhLmgsXG4gICAgICBnZXRNYXJnaW5zKGxheW91dC5ob3Jpem9udGFsLCBjaGFydEFyZWEpXG4gICAgKTtcbiAgICBjb25zdCB7c2FtZSwgb3RoZXJ9ID0gdXBkYXRlRGltcyhjaGFydEFyZWEsIHBhcmFtcywgbGF5b3V0LCBzdGFja3MpO1xuXG4gICAgLy8gRGltZW5zaW9ucyBjaGFuZ2VkIGFuZCB0aGVyZSB3ZXJlIG5vbiBmdWxsIHdpZHRoIGJveGVzIGJlZm9yZSB0aGlzXG4gICAgLy8gLT4gd2UgaGF2ZSB0byByZWZpdCB0aG9zZVxuICAgIHJlZml0IHw9IHNhbWUgJiYgcmVmaXRCb3hlcy5sZW5ndGg7XG5cbiAgICAvLyBDaGFydCBhcmVhIGNoYW5nZWQgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxuICAgIGNoYW5nZWQgPSBjaGFuZ2VkIHx8IG90aGVyO1xuXG4gICAgaWYgKCFib3guZnVsbFNpemUpIHsgLy8gZnVsbFNpemUgYm94ZXMgZG9uJ3QgbmVlZCB0byBiZSByZS1maXR0ZWQgaW4gYW55IGNhc2VcbiAgICAgIHJlZml0Qm94ZXMucHVzaChsYXlvdXQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWZpdCAmJiBmaXRCb3hlcyhyZWZpdEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSB8fCBjaGFuZ2VkO1xufVxuXG5mdW5jdGlvbiBzZXRCb3hEaW1zKGJveCwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGJveC50b3AgPSB0b3A7XG4gIGJveC5sZWZ0ID0gbGVmdDtcbiAgYm94LnJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuICBib3guYm90dG9tID0gdG9wICsgaGVpZ2h0O1xuICBib3gud2lkdGggPSB3aWR0aDtcbiAgYm94LmhlaWdodCA9IGhlaWdodDtcbn1cblxuZnVuY3Rpb24gcGxhY2VCb3hlcyhib3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykge1xuICBjb25zdCB1c2VyUGFkZGluZyA9IHBhcmFtcy5wYWRkaW5nO1xuICBsZXQge3gsIHl9ID0gY2hhcnRBcmVhO1xuXG4gIGZvciAoY29uc3QgbGF5b3V0IG9mIGJveGVzKSB7XG4gICAgY29uc3QgYm94ID0gbGF5b3V0LmJveDtcbiAgICBjb25zdCBzdGFjayA9IHN0YWNrc1tsYXlvdXQuc3RhY2tdIHx8IHtjb3VudDogMSwgcGxhY2VkOiAwLCB3ZWlnaHQ6IDF9O1xuICAgIGNvbnN0IHdlaWdodCA9IChsYXlvdXQuc3RhY2tXZWlnaHQgLyBzdGFjay53ZWlnaHQpIHx8IDE7XG4gICAgaWYgKGxheW91dC5ob3Jpem9udGFsKSB7XG4gICAgICBjb25zdCB3aWR0aCA9IGNoYXJ0QXJlYS53ICogd2VpZ2h0O1xuICAgICAgY29uc3QgaGVpZ2h0ID0gc3RhY2suc2l6ZSB8fCBib3guaGVpZ2h0O1xuICAgICAgaWYgKGRlZmluZWQoc3RhY2suc3RhcnQpKSB7XG4gICAgICAgIHkgPSBzdGFjay5zdGFydDtcbiAgICAgIH1cbiAgICAgIGlmIChib3guZnVsbFNpemUpIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIHVzZXJQYWRkaW5nLmxlZnQsIHksIHBhcmFtcy5vdXRlcldpZHRoIC0gdXNlclBhZGRpbmcucmlnaHQgLSB1c2VyUGFkZGluZy5sZWZ0LCBoZWlnaHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIGNoYXJ0QXJlYS5sZWZ0ICsgc3RhY2sucGxhY2VkLCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnN0YXJ0ID0geTtcbiAgICAgIHN0YWNrLnBsYWNlZCArPSB3aWR0aDtcbiAgICAgIHkgPSBib3guYm90dG9tO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBjaGFydEFyZWEuaCAqIHdlaWdodDtcbiAgICAgIGNvbnN0IHdpZHRoID0gc3RhY2suc2l6ZSB8fCBib3gud2lkdGg7XG4gICAgICBpZiAoZGVmaW5lZChzdGFjay5zdGFydCkpIHtcbiAgICAgICAgeCA9IHN0YWNrLnN0YXJ0O1xuICAgICAgfVxuICAgICAgaWYgKGJveC5mdWxsU2l6ZSkge1xuICAgICAgICBzZXRCb3hEaW1zKGJveCwgeCwgdXNlclBhZGRpbmcudG9wLCB3aWR0aCwgcGFyYW1zLm91dGVySGVpZ2h0IC0gdXNlclBhZGRpbmcuYm90dG9tIC0gdXNlclBhZGRpbmcudG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEJveERpbXMoYm94LCB4LCBjaGFydEFyZWEudG9wICsgc3RhY2sucGxhY2VkLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnN0YXJ0ID0geDtcbiAgICAgIHN0YWNrLnBsYWNlZCArPSBoZWlnaHQ7XG4gICAgICB4ID0gYm94LnJpZ2h0O1xuICAgIH1cbiAgfVxuXG4gIGNoYXJ0QXJlYS54ID0geDtcbiAgY2hhcnRBcmVhLnkgPSB5O1xufVxuXG4vKipcbiAqIEBpbnRlcmZhY2UgTGF5b3V0SXRlbVxuICogQHR5cGVkZWYge29iamVjdH0gTGF5b3V0SXRlbVxuICogQHByb3Age3N0cmluZ30gcG9zaXRpb24gLSBUaGUgcG9zaXRpb24gb2YgdGhlIGl0ZW0gaW4gdGhlIGNoYXJ0IGxheW91dC4gUG9zc2libGUgdmFsdWVzIGFyZVxuICogJ2xlZnQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsIGFuZCAnY2hhcnRBcmVhJ1xuICogQHByb3Age251bWJlcn0gd2VpZ2h0IC0gVGhlIHdlaWdodCB1c2VkIHRvIHNvcnQgdGhlIGl0ZW0uIEhpZ2hlciB3ZWlnaHRzIGFyZSBmdXJ0aGVyIGF3YXkgZnJvbSB0aGUgY2hhcnQgYXJlYVxuICogQHByb3Age2Jvb2xlYW59IGZ1bGxTaXplIC0gaWYgdHJ1ZSwgYW5kIHRoZSBpdGVtIGlzIGhvcml6b250YWwsIHRoZW4gcHVzaCB2ZXJ0aWNhbCBib3hlcyBkb3duXG4gKiBAcHJvcCB7ZnVuY3Rpb259IGlzSG9yaXpvbnRhbCAtIHJldHVybnMgdHJ1ZSBpZiB0aGUgbGF5b3V0IGl0ZW0gaXMgaG9yaXpvbnRhbCAoaWUuIHRvcCBvciBib3R0b20pXG4gKiBAcHJvcCB7ZnVuY3Rpb259IHVwZGF0ZSAtIFRha2VzIHR3byBwYXJhbWV0ZXJzOiB3aWR0aCBhbmQgaGVpZ2h0LiBSZXR1cm5zIHNpemUgb2YgaXRlbVxuICogQHByb3Age2Z1bmN0aW9ufSBkcmF3IC0gRHJhd3MgdGhlIGVsZW1lbnRcbiAqIEBwcm9wIHtmdW5jdGlvbn0gW2dldFBhZGRpbmddIC0gIFJldHVybnMgYW4gb2JqZWN0IHdpdGggcGFkZGluZyBvbiB0aGUgZWRnZXNcbiAqIEBwcm9wIHtudW1iZXJ9IHdpZHRoIC0gV2lkdGggb2YgaXRlbS4gTXVzdCBiZSB2YWxpZCBhZnRlciB1cGRhdGUoKVxuICogQHByb3Age251bWJlcn0gaGVpZ2h0IC0gSGVpZ2h0IG9mIGl0ZW0uIE11c3QgYmUgdmFsaWQgYWZ0ZXIgdXBkYXRlKClcbiAqIEBwcm9wIHtudW1iZXJ9IGxlZnQgLSBMZWZ0IGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcbiAqIEBwcm9wIHtudW1iZXJ9IHRvcCAtIFRvcCBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXG4gKiBAcHJvcCB7bnVtYmVyfSByaWdodCAtIFJpZ2h0IGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcbiAqIEBwcm9wIHtudW1iZXJ9IGJvdHRvbSAtIEJvdHRvbSBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXG4gKi9cblxuLy8gVGhlIGxheW91dCBzZXJ2aWNlIGlzIHZlcnkgc2VsZiBleHBsYW5hdG9yeS4gIEl0J3MgcmVzcG9uc2libGUgZm9yIHRoZSBsYXlvdXQgd2l0aGluIGEgY2hhcnQuXG4vLyBTY2FsZXMsIExlZ2VuZHMgYW5kIFBsdWdpbnMgYWxsIHJlbHkgb24gdGhlIGxheW91dCBzZXJ2aWNlIGFuZCBjYW4gZWFzaWx5IHJlZ2lzdGVyIHRvIGJlIHBsYWNlZCBhbnl3aGVyZSB0aGV5IG5lZWRcbi8vIEl0IGlzIHRoaXMgc2VydmljZSdzIHJlc3BvbnNpYmlsaXR5IG9mIGNhcnJ5aW5nIG91dCB0aGF0IGxheW91dC5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAvKipcblx0ICogUmVnaXN0ZXIgYSBib3ggdG8gYSBjaGFydC5cblx0ICogQSBib3ggaXMgc2ltcGx5IGEgcmVmZXJlbmNlIHRvIGFuIG9iamVjdCB0aGF0IHJlcXVpcmVzIGxheW91dC4gZWcuIFNjYWxlcywgTGVnZW5kLCBUaXRsZS5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gdXNlXG5cdCAqIEBwYXJhbSB7TGF5b3V0SXRlbX0gaXRlbSAtIHRoZSBpdGVtIHRvIGFkZCB0byBiZSBsYWlkIG91dFxuXHQgKi9cbiAgYWRkQm94KGNoYXJ0LCBpdGVtKSB7XG4gICAgaWYgKCFjaGFydC5ib3hlcykge1xuICAgICAgY2hhcnQuYm94ZXMgPSBbXTtcbiAgICB9XG5cbiAgICAvLyBpbml0aWFsaXplIGl0ZW0gd2l0aCBkZWZhdWx0IHZhbHVlc1xuICAgIGl0ZW0uZnVsbFNpemUgPSBpdGVtLmZ1bGxTaXplIHx8IGZhbHNlO1xuICAgIGl0ZW0ucG9zaXRpb24gPSBpdGVtLnBvc2l0aW9uIHx8ICd0b3AnO1xuICAgIGl0ZW0ud2VpZ2h0ID0gaXRlbS53ZWlnaHQgfHwgMDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaXRlbS5fbGF5ZXJzID0gaXRlbS5fbGF5ZXJzIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHo6IDAsXG4gICAgICAgIGRyYXcoY2hhcnRBcmVhKSB7XG4gICAgICAgICAgaXRlbS5kcmF3KGNoYXJ0QXJlYSk7XG4gICAgICAgIH1cbiAgICAgIH1dO1xuICAgIH07XG5cbiAgICBjaGFydC5ib3hlcy5wdXNoKGl0ZW0pO1xuICB9LFxuXG4gIC8qKlxuXHQgKiBSZW1vdmUgYSBsYXlvdXRJdGVtIGZyb20gYSBjaGFydFxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byByZW1vdmUgdGhlIGJveCBmcm9tXG5cdCAqIEBwYXJhbSB7TGF5b3V0SXRlbX0gbGF5b3V0SXRlbSAtIHRoZSBpdGVtIHRvIHJlbW92ZSBmcm9tIHRoZSBsYXlvdXRcblx0ICovXG4gIHJlbW92ZUJveChjaGFydCwgbGF5b3V0SXRlbSkge1xuICAgIGNvbnN0IGluZGV4ID0gY2hhcnQuYm94ZXMgPyBjaGFydC5ib3hlcy5pbmRleE9mKGxheW91dEl0ZW0pIDogLTE7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgY2hhcnQuYm94ZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG5cdCAqIFNldHMgKG9yIHVwZGF0ZXMpIG9wdGlvbnMgb24gdGhlIGdpdmVuIGBpdGVtYC5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgaW4gd2hpY2ggdGhlIGl0ZW0gbGl2ZXMgKG9yIHdpbGwgYmUgYWRkZWQgdG8pXG5cdCAqIEBwYXJhbSB7TGF5b3V0SXRlbX0gaXRlbSAtIHRoZSBpdGVtIHRvIGNvbmZpZ3VyZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gdGhlIG5ldyBpdGVtIG9wdGlvbnMuXG5cdCAqL1xuICBjb25maWd1cmUoY2hhcnQsIGl0ZW0sIG9wdGlvbnMpIHtcbiAgICBpdGVtLmZ1bGxTaXplID0gb3B0aW9ucy5mdWxsU2l6ZTtcbiAgICBpdGVtLnBvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbjtcbiAgICBpdGVtLndlaWdodCA9IG9wdGlvbnMud2VpZ2h0O1xuICB9LFxuXG4gIC8qKlxuXHQgKiBGaXRzIGJveGVzIG9mIHRoZSBnaXZlbiBjaGFydCBpbnRvIHRoZSBnaXZlbiBzaXplIGJ5IGhhdmluZyBlYWNoIGJveCBtZWFzdXJlIGl0c2VsZlxuXHQgKiB0aGVuIHJ1bm5pbmcgYSBmaXR0aW5nIGFsZ29yaXRobVxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydFxuXHQgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSB0aGUgd2lkdGggdG8gZml0IGludG9cblx0ICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIHRoZSBoZWlnaHQgdG8gZml0IGludG9cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pblBhZGRpbmcgLSBtaW5pbXVtIHBhZGRpbmcgcmVxdWlyZWQgZm9yIGVhY2ggc2lkZSBvZiBjaGFydCBhcmVhXG5cdCAqL1xuICB1cGRhdGUoY2hhcnQsIHdpZHRoLCBoZWlnaHQsIG1pblBhZGRpbmcpIHtcbiAgICBpZiAoIWNoYXJ0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhjaGFydC5vcHRpb25zLmxheW91dC5wYWRkaW5nKTtcbiAgICBjb25zdCBhdmFpbGFibGVXaWR0aCA9IE1hdGgubWF4KHdpZHRoIC0gcGFkZGluZy53aWR0aCwgMCk7XG4gICAgY29uc3QgYXZhaWxhYmxlSGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0IC0gcGFkZGluZy5oZWlnaHQsIDApO1xuICAgIGNvbnN0IGJveGVzID0gYnVpbGRMYXlvdXRCb3hlcyhjaGFydC5ib3hlcyk7XG4gICAgY29uc3QgdmVydGljYWxCb3hlcyA9IGJveGVzLnZlcnRpY2FsO1xuICAgIGNvbnN0IGhvcml6b250YWxCb3hlcyA9IGJveGVzLmhvcml6b250YWw7XG5cbiAgICAvLyBCZWZvcmUgYW55IGNoYW5nZXMgYXJlIG1hZGUsIG5vdGlmeSBib3hlcyB0aGF0IGFuIHVwZGF0ZSBpcyBhYm91dCB0byBiZWluZ1xuICAgIC8vIFRoaXMgaXMgdXNlZCB0byBjbGVhciBhbnkgY2FjaGVkIGRhdGEgKGUuZy4gc2NhbGUgbGltaXRzKVxuICAgIGVhY2goY2hhcnQuYm94ZXMsIGJveCA9PiB7XG4gICAgICBpZiAodHlwZW9mIGJveC5iZWZvcmVMYXlvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgYm94LmJlZm9yZUxheW91dCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gRXNzZW50aWFsbHkgd2Ugbm93IGhhdmUgYW55IG51bWJlciBvZiBib3hlcyBvbiBlYWNoIG9mIHRoZSA0IHNpZGVzLlxuICAgIC8vIE91ciBjYW52YXMgbG9va3MgbGlrZSB0aGUgZm9sbG93aW5nLlxuICAgIC8vIFRoZSBhcmVhcyBMMSBhbmQgTDIgYXJlIHRoZSBsZWZ0IGF4ZXMuIFIxIGlzIHRoZSByaWdodCBheGlzLCBUMSBpcyB0aGUgdG9wIGF4aXMgYW5kXG4gICAgLy8gQjEgaXMgdGhlIGJvdHRvbSBheGlzXG4gICAgLy8gVGhlcmUgYXJlIGFsc28gNCBxdWFkcmFudC1saWtlIGxvY2F0aW9ucyAobGVmdCB0byByaWdodCBpbnN0ZWFkIG9mIGNsb2Nrd2lzZSkgcmVzZXJ2ZWQgZm9yIGNoYXJ0IG92ZXJsYXlzXG4gICAgLy8gVGhlc2UgbG9jYXRpb25zIGFyZSBzaW5nbGUtYm94IGxvY2F0aW9ucyBvbmx5LCB3aGVuIHRyeWluZyB0byByZWdpc3RlciBhIGNoYXJ0QXJlYSBsb2NhdGlvbiB0aGF0IGlzIGFscmVhZHkgdGFrZW4sXG4gICAgLy8gYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gICAgLy9cbiAgICAvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAvLyB8ICAgICAgICAgICAgICAgICAgVDEgKEZ1bGwgV2lkdGgpICAgICAgICAgICAgICAgICAgIHxcbiAgICAvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgVDIgICAgICAgICAgICAgICAgICB8ICAgIHxcbiAgICAvLyB8ICAgIHwtLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLXxcbiAgICAvLyB8ICAgIHwgICAgfCBDMSB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBDMiB8ICAgIHxcbiAgICAvLyB8ICAgIHwgICAgfC0tLS18ICAgICAgICAgICAgICAgICAgICAgICAgICAgfC0tLS18ICAgIHxcbiAgICAvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgIHxcbiAgICAvLyB8IEwxIHwgTDIgfCAgICAgICAgICAgQ2hhcnRBcmVhIChDMCkgICAgICAgICAgICB8IFIxIHxcbiAgICAvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgIHxcbiAgICAvLyB8ICAgIHwgICAgfC0tLS18ICAgICAgICAgICAgICAgICAgICAgICAgICAgfC0tLS18ICAgIHxcbiAgICAvLyB8ICAgIHwgICAgfCBDMyB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBDNCB8ICAgIHxcbiAgICAvLyB8ICAgIHwtLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLXxcbiAgICAvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgQjEgICAgICAgICAgICAgICAgICB8ICAgIHxcbiAgICAvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAvLyB8ICAgICAgICAgICAgICAgICAgQjIgKEZ1bGwgV2lkdGgpICAgICAgICAgICAgICAgICAgIHxcbiAgICAvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAvL1xuXG4gICAgY29uc3QgdmlzaWJsZVZlcnRpY2FsQm94Q291bnQgPSB2ZXJ0aWNhbEJveGVzLnJlZHVjZSgodG90YWwsIHdyYXApID0+XG4gICAgICB3cmFwLmJveC5vcHRpb25zICYmIHdyYXAuYm94Lm9wdGlvbnMuZGlzcGxheSA9PT0gZmFsc2UgPyB0b3RhbCA6IHRvdGFsICsgMSwgMCkgfHwgMTtcblxuICAgIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgb3V0ZXJXaWR0aDogd2lkdGgsXG4gICAgICBvdXRlckhlaWdodDogaGVpZ2h0LFxuICAgICAgcGFkZGluZyxcbiAgICAgIGF2YWlsYWJsZVdpZHRoLFxuICAgICAgYXZhaWxhYmxlSGVpZ2h0LFxuICAgICAgdkJveE1heFdpZHRoOiBhdmFpbGFibGVXaWR0aCAvIDIgLyB2aXNpYmxlVmVydGljYWxCb3hDb3VudCxcbiAgICAgIGhCb3hNYXhIZWlnaHQ6IGF2YWlsYWJsZUhlaWdodCAvIDJcbiAgICB9KTtcbiAgICBjb25zdCBtYXhQYWRkaW5nID0gT2JqZWN0LmFzc2lnbih7fSwgcGFkZGluZyk7XG4gICAgdXBkYXRlTWF4UGFkZGluZyhtYXhQYWRkaW5nLCB0b1BhZGRpbmcobWluUGFkZGluZykpO1xuICAgIGNvbnN0IGNoYXJ0QXJlYSA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgbWF4UGFkZGluZyxcbiAgICAgIHc6IGF2YWlsYWJsZVdpZHRoLFxuICAgICAgaDogYXZhaWxhYmxlSGVpZ2h0LFxuICAgICAgeDogcGFkZGluZy5sZWZ0LFxuICAgICAgeTogcGFkZGluZy50b3BcbiAgICB9LCBwYWRkaW5nKTtcblxuICAgIGNvbnN0IHN0YWNrcyA9IHNldExheW91dERpbXModmVydGljYWxCb3hlcy5jb25jYXQoaG9yaXpvbnRhbEJveGVzKSwgcGFyYW1zKTtcblxuICAgIC8vIEZpcnN0IGZpdCB0aGUgZnVsbFNpemUgYm94ZXMsIHRvIHJlZHVjZSBwcm9iYWJpbGl0eSBvZiByZS1maXR0aW5nLlxuICAgIGZpdEJveGVzKGJveGVzLmZ1bGxTaXplLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcblxuICAgIC8vIFRoZW4gZml0IHZlcnRpY2FsIGJveGVzXG4gICAgZml0Qm94ZXModmVydGljYWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG5cbiAgICAvLyBUaGVuIGZpdCBob3Jpem9udGFsIGJveGVzXG4gICAgaWYgKGZpdEJveGVzKGhvcml6b250YWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykpIHtcbiAgICAgIC8vIGlmIHRoZSBhcmVhIGNoYW5nZWQsIHJlLWZpdCB2ZXJ0aWNhbCBib3hlc1xuICAgICAgZml0Qm94ZXModmVydGljYWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG4gICAgfVxuXG4gICAgaGFuZGxlTWF4UGFkZGluZyhjaGFydEFyZWEpO1xuXG4gICAgLy8gRmluYWxseSBwbGFjZSB0aGUgYm94ZXMgdG8gY29ycmVjdCBjb29yZGluYXRlc1xuICAgIHBsYWNlQm94ZXMoYm94ZXMubGVmdEFuZFRvcCwgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG5cbiAgICAvLyBNb3ZlIHRvIG9wcG9zaXRlIHNpZGUgb2YgY2hhcnRcbiAgICBjaGFydEFyZWEueCArPSBjaGFydEFyZWEudztcbiAgICBjaGFydEFyZWEueSArPSBjaGFydEFyZWEuaDtcblxuICAgIHBsYWNlQm94ZXMoYm94ZXMucmlnaHRBbmRCb3R0b20sIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuXG4gICAgY2hhcnQuY2hhcnRBcmVhID0ge1xuICAgICAgbGVmdDogY2hhcnRBcmVhLmxlZnQsXG4gICAgICB0b3A6IGNoYXJ0QXJlYS50b3AsXG4gICAgICByaWdodDogY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEudyxcbiAgICAgIGJvdHRvbTogY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5oLFxuICAgICAgaGVpZ2h0OiBjaGFydEFyZWEuaCxcbiAgICAgIHdpZHRoOiBjaGFydEFyZWEudyxcbiAgICB9O1xuXG4gICAgLy8gRmluYWxseSB1cGRhdGUgYm94ZXMgaW4gY2hhcnRBcmVhIChyYWRpYWwgc2NhbGUgZm9yIGV4YW1wbGUpXG4gICAgZWFjaChib3hlcy5jaGFydEFyZWEsIChsYXlvdXQpID0+IHtcbiAgICAgIGNvbnN0IGJveCA9IGxheW91dC5ib3g7XG4gICAgICBPYmplY3QuYXNzaWduKGJveCwgY2hhcnQuY2hhcnRBcmVhKTtcbiAgICAgIGJveC51cGRhdGUoY2hhcnRBcmVhLncsIGNoYXJ0QXJlYS5oLCB7bGVmdDogMCwgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwfSk7XG4gICAgfSk7XG4gIH1cbn07XG4iLCAiXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9jb3JlL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICovXG5cbi8qKlxuICogQWJzdHJhY3QgY2xhc3MgdGhhdCBhbGxvd3MgYWJzdHJhY3RpbmcgcGxhdGZvcm0gZGVwZW5kZW5jaWVzIGF3YXkgZnJvbSB0aGUgY2hhcnQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VQbGF0Zm9ybSB7XG4gIC8qKlxuXHQgKiBDYWxsZWQgYXQgY2hhcnQgY29uc3RydWN0aW9uIHRpbWUsIHJldHVybnMgYSBjb250ZXh0MmQgaW5zdGFuY2UgaW1wbGVtZW50aW5nXG5cdCAqIHRoZSBbVzNDIENhbnZhcyAyRCBDb250ZXh0IEFQSSBzdGFuZGFyZF17QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSLzJkY29udGV4dC99LlxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgLSBUaGUgY2FudmFzIGZyb20gd2hpY2ggdG8gYWNxdWlyZSBjb250ZXh0IChwbGF0Zm9ybSBzcGVjaWZpYylcblx0ICogQHBhcmFtIHtudW1iZXJ9IFthc3BlY3RSYXRpb10gLSBUaGUgY2hhcnQgb3B0aW9uc1xuXHQgKi9cbiAgYWNxdWlyZUNvbnRleHQoY2FudmFzLCBhc3BlY3RSYXRpbykge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIC8qKlxuXHQgKiBDYWxsZWQgYXQgY2hhcnQgZGVzdHJ1Y3Rpb24gdGltZSwgcmVsZWFzZXMgYW55IHJlc291cmNlcyBhc3NvY2lhdGVkIHRvIHRoZSBjb250ZXh0XG5cdCAqIHByZXZpb3VzbHkgcmV0dXJuZWQgYnkgdGhlIGFjcXVpcmVDb250ZXh0KCkgbWV0aG9kLlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAtIFRoZSBjb250ZXh0MmQgaW5zdGFuY2Vcblx0ICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIG1ldGhvZCBzdWNjZWVkZWQsIGVsc2UgZmFsc2Vcblx0ICovXG4gIHJlbGVhc2VDb250ZXh0KGNvbnRleHQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZWdpc3RlcnMgdGhlIHNwZWNpZmllZCBsaXN0ZW5lciBvbiB0aGUgZ2l2ZW4gY2hhcnQuXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gQ2hhcnQgZnJvbSB3aGljaCB0byBsaXN0ZW4gZm9yIGV2ZW50XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlICh7QGxpbmsgQ2hhcnRFdmVudH0pIHR5cGUgdG8gbGlzdGVuIGZvclxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciAtIFJlY2VpdmVzIGEgbm90aWZpY2F0aW9uIChhbiBvYmplY3QgdGhhdCBpbXBsZW1lbnRzXG5cdCAqIHRoZSB7QGxpbmsgQ2hhcnRFdmVudH0gaW50ZXJmYWNlKSB3aGVuIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBvY2N1cnMuXG5cdCAqL1xuICBhZGRFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIC8qKlxuXHQgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXIgcHJldmlvdXNseSByZWdpc3RlcmVkIHdpdGggYWRkRXZlbnRMaXN0ZW5lci5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBDaGFydCBmcm9tIHdoaWNoIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgKHtAbGluayBDaGFydEV2ZW50fSkgdHlwZSB0byByZW1vdmVcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gcmVtb3ZlIGZyb20gdGhlIGV2ZW50IHRhcmdldC5cblx0ICovXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBjdXJyZW50IGRldmljZVBpeGVsUmF0aW8gb2YgdGhlIGRldmljZSB0aGlzIHBsYXRmb3JtIGlzIGNvbm5lY3RlZCB0by5cblx0ICovXG4gIGdldERldmljZVBpeGVsUmF0aW8oKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgbWF4aW11bSBzaXplIGluIHBpeGVscyBvZiBnaXZlbiBjYW52YXMgZWxlbWVudC5cblx0ICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gZWxlbWVudFxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoXSAtIGNvbnRlbnQgd2lkdGggb2YgcGFyZW50IGVsZW1lbnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHRdIC0gY29udGVudCBoZWlnaHQgb2YgcGFyZW50IGVsZW1lbnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IFthc3BlY3RSYXRpb10gLSBhc3BlY3QgcmF0aW8gdG8gbWFpbnRhaW5cblx0ICovXG4gIGdldE1heGltdW1TaXplKGVsZW1lbnQsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKSB7XG4gICAgd2lkdGggPSBNYXRoLm1heCgwLCB3aWR0aCB8fCBlbGVtZW50LndpZHRoKTtcbiAgICBoZWlnaHQgPSBoZWlnaHQgfHwgZWxlbWVudC5oZWlnaHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0OiBNYXRoLm1heCgwLCBhc3BlY3RSYXRpbyA/IE1hdGguZmxvb3Iod2lkdGggLyBhc3BlY3RSYXRpbykgOiBoZWlnaHQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcblx0ICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGNhbnZhcyBpcyBhdHRhY2hlZCB0byB0aGUgcGxhdGZvcm0sIGZhbHNlIGlmIG5vdC5cblx0ICovXG4gIGlzQXR0YWNoZWQoY2FudmFzKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGNvbmZpZyB3aXRoIHBsYXRmb3JtIHNwZWNpZmljIHJlcXVpcmVtZW50c1xuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vY29yZS9jb3JlLmNvbmZpZy5qcycpLmRlZmF1bHR9IGNvbmZpZ1xuICAgKi9cbiAgdXBkYXRlQ29uZmlnKGNvbmZpZykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgLy8gbm8tb3BcbiAgfVxufVxuIiwgIi8qKlxuICogUGxhdGZvcm0gZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gKG1pbmltYWwpLlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzQ1OTEjaXNzdWVjb21tZW50LTMxOTU3NTkzOVxuICovXG5cbmltcG9ydCBCYXNlUGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybS5iYXNlLmpzJztcblxuLyoqXG4gKiBQbGF0Zm9ybSBjbGFzcyBmb3IgY2hhcnRzIHdpdGhvdXQgYWNjZXNzIHRvIHRoZSBET00gb3IgdG8gbWFueSBlbGVtZW50IHByb3BlcnRpZXNcbiAqIFRoaXMgcGxhdGZvcm0gaXMgdXNlZCBieSBkZWZhdWx0IGZvciBhbnkgY2hhcnQgcGFzc2VkIGFuIE9mZnNjcmVlbkNhbnZhcy5cbiAqIEBleHRlbmRzIEJhc2VQbGF0Zm9ybVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNpY1BsYXRmb3JtIGV4dGVuZHMgQmFzZVBsYXRmb3JtIHtcbiAgYWNxdWlyZUNvbnRleHQoaXRlbSkge1xuICAgIC8vIFRvIHByZXZlbnQgY2FudmFzIGZpbmdlcnByaW50aW5nLCBzb21lIGFkZC1vbnMgdW5kZWZpbmUgdGhlIGdldENvbnRleHRcbiAgICAvLyBtZXRob2QsIGZvciBleGFtcGxlOiBodHRwczovL2dpdGh1Yi5jb20va2thcHNuZXIvQ2FudmFzQmxvY2tlclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yODA3XG4gICAgcmV0dXJuIGl0ZW0gJiYgaXRlbS5nZXRDb250ZXh0ICYmIGl0ZW0uZ2V0Q29udGV4dCgnMmQnKSB8fCBudWxsO1xuICB9XG4gIHVwZGF0ZUNvbmZpZyhjb25maWcpIHtcbiAgICBjb25maWcub3B0aW9ucy5hbmltYXRpb24gPSBmYWxzZTtcbiAgfVxufVxuIiwgIi8qKlxuICogQ2hhcnQuUGxhdGZvcm0gaW1wbGVtZW50YXRpb24gZm9yIHRhcmdldGluZyBhIHdlYiBicm93c2VyXG4gKi9cblxuaW1wb3J0IEJhc2VQbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtLmJhc2UuanMnO1xuaW1wb3J0IHtfZ2V0UGFyZW50Tm9kZSwgZ2V0UmVsYXRpdmVQb3NpdGlvbiwgc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucywgcmVhZFVzZWRTaXplLCBnZXRNYXhpbXVtU2l6ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmRvbS5qcyc7XG5pbXBvcnQge3Rocm90dGxlZH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmV4dHJhcy5qcyc7XG5pbXBvcnQge2lzTnVsbE9yVW5kZWZ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vY29yZS9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqL1xuXG5jb25zdCBFWFBBTkRPX0tFWSA9ICckY2hhcnRqcyc7XG5cbi8qKlxuICogRE9NIGV2ZW50IHR5cGVzIC0+IENoYXJ0LmpzIGV2ZW50IHR5cGVzLlxuICogTm90ZTogb25seSBldmVudHMgd2l0aCBkaWZmZXJlbnQgdHlwZXMgYXJlIG1hcHBlZC5cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvRXZlbnRzXG4gKi9cbmNvbnN0IEVWRU5UX1RZUEVTID0ge1xuICB0b3VjaHN0YXJ0OiAnbW91c2Vkb3duJyxcbiAgdG91Y2htb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgdG91Y2hlbmQ6ICdtb3VzZXVwJyxcbiAgcG9pbnRlcmVudGVyOiAnbW91c2VlbnRlcicsXG4gIHBvaW50ZXJkb3duOiAnbW91c2Vkb3duJyxcbiAgcG9pbnRlcm1vdmU6ICdtb3VzZW1vdmUnLFxuICBwb2ludGVydXA6ICdtb3VzZXVwJyxcbiAgcG9pbnRlcmxlYXZlOiAnbW91c2VvdXQnLFxuICBwb2ludGVyb3V0OiAnbW91c2VvdXQnXG59O1xuXG5jb25zdCBpc051bGxPckVtcHR5ID0gdmFsdWUgPT4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09ICcnO1xuLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgY2FudmFzIHN0eWxlIGFuZCByZW5kZXIgc2l6ZSB3aXRob3V0IG1vZGlmeWluZyB0aGUgY2FudmFzIGRpc3BsYXkgc2l6ZSxcbiAqIHNpbmNlIHJlc3BvbnNpdmVuZXNzIGlzIGhhbmRsZWQgYnkgdGhlIGNvbnRyb2xsZXIucmVzaXplKCkgbWV0aG9kLiBUaGUgY29uZmlnIGlzIHVzZWRcbiAqIHRvIGRldGVybWluZSB0aGUgYXNwZWN0IHJhdGlvIHRvIGFwcGx5IGluIGNhc2Ugbm8gZXhwbGljaXQgaGVpZ2h0IGhhcyBiZWVuIHNwZWNpZmllZC5cbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuICogQHBhcmFtIHtudW1iZXJ9IFthc3BlY3RSYXRpb11cbiAqL1xuZnVuY3Rpb24gaW5pdENhbnZhcyhjYW52YXMsIGFzcGVjdFJhdGlvKSB7XG4gIGNvbnN0IHN0eWxlID0gY2FudmFzLnN0eWxlO1xuXG4gIC8vIE5PVEUoU0IpIGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgIT09IGNhbnZhcy53aWR0aDogaW4gdGhlIGZpcnN0IGNhc2UgaXRcbiAgLy8gcmV0dXJucyBudWxsIG9yICcnIGlmIG5vIGV4cGxpY2l0IHZhbHVlIGhhcyBiZWVuIHNldCB0byB0aGUgY2FudmFzIGF0dHJpYnV0ZS5cbiAgY29uc3QgcmVuZGVySGVpZ2h0ID0gY2FudmFzLmdldEF0dHJpYnV0ZSgnaGVpZ2h0Jyk7XG4gIGNvbnN0IHJlbmRlcldpZHRoID0gY2FudmFzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKTtcblxuICAvLyBDaGFydC5qcyBtb2RpZmllcyBzb21lIGNhbnZhcyB2YWx1ZXMgdGhhdCB3ZSB3YW50IHRvIHJlc3RvcmUgb24gZGVzdHJveVxuICBjYW52YXNbRVhQQU5ET19LRVldID0ge1xuICAgIGluaXRpYWw6IHtcbiAgICAgIGhlaWdodDogcmVuZGVySGVpZ2h0LFxuICAgICAgd2lkdGg6IHJlbmRlcldpZHRoLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZGlzcGxheTogc3R5bGUuZGlzcGxheSxcbiAgICAgICAgaGVpZ2h0OiBzdHlsZS5oZWlnaHQsXG4gICAgICAgIHdpZHRoOiBzdHlsZS53aWR0aFxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBGb3JjZSBjYW52YXMgdG8gZGlzcGxheSBhcyBibG9jayB0byBhdm9pZCBleHRyYSBzcGFjZSBjYXVzZWQgYnkgaW5saW5lXG4gIC8vIGVsZW1lbnRzLCB3aGljaCB3b3VsZCBpbnRlcmZlcmUgd2l0aCB0aGUgcmVzcG9uc2l2ZSByZXNpemUgcHJvY2Vzcy5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI1MzhcbiAgc3R5bGUuZGlzcGxheSA9IHN0eWxlLmRpc3BsYXkgfHwgJ2Jsb2NrJztcbiAgLy8gSW5jbHVkZSBwb3NzaWJsZSBib3JkZXJzIGluIHRoZSBzaXplXG4gIHN0eWxlLmJveFNpemluZyA9IHN0eWxlLmJveFNpemluZyB8fCAnYm9yZGVyLWJveCc7XG5cbiAgaWYgKGlzTnVsbE9yRW1wdHkocmVuZGVyV2lkdGgpKSB7XG4gICAgY29uc3QgZGlzcGxheVdpZHRoID0gcmVhZFVzZWRTaXplKGNhbnZhcywgJ3dpZHRoJyk7XG4gICAgaWYgKGRpc3BsYXlXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjYW52YXMud2lkdGggPSBkaXNwbGF5V2lkdGg7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzTnVsbE9yRW1wdHkocmVuZGVySGVpZ2h0KSkge1xuICAgIGlmIChjYW52YXMuc3R5bGUuaGVpZ2h0ID09PSAnJykge1xuICAgICAgLy8gSWYgbm8gZXhwbGljaXQgcmVuZGVyIGhlaWdodCBhbmQgc3R5bGUgaGVpZ2h0LCBsZXQncyBhcHBseSB0aGUgYXNwZWN0IHJhdGlvLFxuICAgICAgLy8gd2hpY2ggb25lIGNhbiBiZSBzcGVjaWZpZWQgYnkgdGhlIHVzZXIgYnV0IGFsc28gYnkgY2hhcnRzIGFzIGRlZmF1bHQgb3B0aW9uXG4gICAgICAvLyAoaS5lLiBvcHRpb25zLmFzcGVjdFJhdGlvKS4gSWYgbm90IHNwZWNpZmllZCwgdXNlIGNhbnZhcyBhc3BlY3QgcmF0aW8gb2YgMi5cbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXMud2lkdGggLyAoYXNwZWN0UmF0aW8gfHwgMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRpc3BsYXlIZWlnaHQgPSByZWFkVXNlZFNpemUoY2FudmFzLCAnaGVpZ2h0Jyk7XG4gICAgICBpZiAoZGlzcGxheUhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBkaXNwbGF5SGVpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjYW52YXM7XG59XG5cbi8vIERlZmF1bHQgcGFzc2l2ZSB0byB0cnVlIGFzIGV4cGVjdGVkIGJ5IENocm9tZSBmb3IgJ3RvdWNoc3RhcnQnIGFuZCAndG91Y2hlbmQnIGV2ZW50cy5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80Mjg3XG5jb25zdCBldmVudExpc3RlbmVyT3B0aW9ucyA9IHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMgPyB7cGFzc2l2ZTogdHJ1ZX0gOiBmYWxzZTtcblxuZnVuY3Rpb24gYWRkTGlzdGVuZXIobm9kZSwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKG5vZGUpIHtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIGV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKGNoYXJ0ICYmIGNoYXJ0LmNhbnZhcykge1xuICAgIGNoYXJ0LmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBldmVudExpc3RlbmVyT3B0aW9ucyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZnJvbU5hdGl2ZUV2ZW50KGV2ZW50LCBjaGFydCkge1xuICBjb25zdCB0eXBlID0gRVZFTlRfVFlQRVNbZXZlbnQudHlwZV0gfHwgZXZlbnQudHlwZTtcbiAgY29uc3Qge3gsIHl9ID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihldmVudCwgY2hhcnQpO1xuICByZXR1cm4ge1xuICAgIHR5cGUsXG4gICAgY2hhcnQsXG4gICAgbmF0aXZlOiBldmVudCxcbiAgICB4OiB4ICE9PSB1bmRlZmluZWQgPyB4IDogbnVsbCxcbiAgICB5OiB5ICE9PSB1bmRlZmluZWQgPyB5IDogbnVsbCxcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9kZUxpc3RDb250YWlucyhub2RlTGlzdCwgY2FudmFzKSB7XG4gIGZvciAoY29uc3Qgbm9kZSBvZiBub2RlTGlzdCkge1xuICAgIGlmIChub2RlID09PSBjYW52YXMgfHwgbm9kZS5jb250YWlucyhjYW52YXMpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQXR0YWNoT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICBsZXQgdHJpZ2dlciA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgfHwgbm9kZUxpc3RDb250YWlucyhlbnRyeS5hZGRlZE5vZGVzLCBjYW52YXMpO1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgJiYgIW5vZGVMaXN0Q29udGFpbnMoZW50cnkucmVtb3ZlZE5vZGVzLCBjYW52YXMpO1xuICAgIH1cbiAgICBpZiAodHJpZ2dlcikge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LCB7Y2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlfSk7XG4gIHJldHVybiBvYnNlcnZlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGV0YWNoT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICBsZXQgdHJpZ2dlciA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgfHwgbm9kZUxpc3RDb250YWlucyhlbnRyeS5yZW1vdmVkTm9kZXMsIGNhbnZhcyk7XG4gICAgICB0cmlnZ2VyID0gdHJpZ2dlciAmJiAhbm9kZUxpc3RDb250YWlucyhlbnRyeS5hZGRlZE5vZGVzLCBjYW52YXMpO1xuICAgIH1cbiAgICBpZiAodHJpZ2dlcikge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LCB7Y2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlfSk7XG4gIHJldHVybiBvYnNlcnZlcjtcbn1cblxuY29uc3QgZHJwTGlzdGVuaW5nQ2hhcnRzID0gbmV3IE1hcCgpO1xubGV0IG9sZERldmljZVBpeGVsUmF0aW8gPSAwO1xuXG5mdW5jdGlvbiBvbldpbmRvd1Jlc2l6ZSgpIHtcbiAgY29uc3QgZHByID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIGlmIChkcHIgPT09IG9sZERldmljZVBpeGVsUmF0aW8pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb2xkRGV2aWNlUGl4ZWxSYXRpbyA9IGRwcjtcbiAgZHJwTGlzdGVuaW5nQ2hhcnRzLmZvckVhY2goKHJlc2l6ZSwgY2hhcnQpID0+IHtcbiAgICBpZiAoY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8gIT09IGRwcikge1xuICAgICAgcmVzaXplKCk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gbGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQsIHJlc2l6ZSkge1xuICBpZiAoIWRycExpc3RlbmluZ0NoYXJ0cy5zaXplKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uV2luZG93UmVzaXplKTtcbiAgfVxuICBkcnBMaXN0ZW5pbmdDaGFydHMuc2V0KGNoYXJ0LCByZXNpemUpO1xufVxuXG5mdW5jdGlvbiB1bmxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0KSB7XG4gIGRycExpc3RlbmluZ0NoYXJ0cy5kZWxldGUoY2hhcnQpO1xuICBpZiAoIWRycExpc3RlbmluZ0NoYXJ0cy5zaXplKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uV2luZG93UmVzaXplKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVSZXNpemVPYnNlcnZlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBjb250YWluZXIgPSBjYW52YXMgJiYgX2dldFBhcmVudE5vZGUoY2FudmFzKTtcbiAgaWYgKCFjb250YWluZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcmVzaXplID0gdGhyb3R0bGVkKCh3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgY29uc3QgdyA9IGNvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgICBsaXN0ZW5lcih3aWR0aCwgaGVpZ2h0KTtcbiAgICBpZiAodyA8IGNvbnRhaW5lci5jbGllbnRXaWR0aCkge1xuICAgICAgLy8gSWYgdGhlIGNvbnRhaW5lciBzaXplIHNocmFuayBkdXJpbmcgY2hhcnQgcmVzaXplLCBsZXQncyBhc3N1bWVcbiAgICAgIC8vIHNjcm9sbGJhciBhcHBlYXJlZC4gU28gd2UgcmVzaXplIGFnYWluIHdpdGggdGhlIHNjcm9sbGJhciB2aXNpYmxlIC1cbiAgICAgIC8vIGVmZmVjdGl2ZWx5IG1ha2luZyBjaGFydCBzbWFsbGVyIGFuZCB0aGUgc2Nyb2xsYmFyIGhpZGRlbiBhZ2Fpbi5cbiAgICAgIC8vIEJlY2F1c2Ugd2UgYXJlIGluc2lkZSBgdGhyb3R0bGVkYCwgYW5kIGN1cnJlbnRseSBgdGlja2luZ2AsIHNjcm9sbFxuICAgICAgLy8gZXZlbnRzIGFyZSBpZ25vcmVkIGR1cmluZyB0aGlzIHdob2xlIDIgcmVzaXplIHByb2Nlc3MuXG4gICAgICAvLyBJZiB3ZSBhc3N1bWVkIHdyb25nIGFuZCBzb21ldGhpbmcgZWxzZSBoYXBwZW5lZCwgd2UgYXJlIHJlc2l6aW5nXG4gICAgICAvLyB0d2ljZSBpbiBhIGZyYW1lIChwb3RlbnRpYWwgcGVyZm9ybWFuY2UgaXNzdWUpXG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH1cbiAgfSwgd2luZG93KTtcblxuICAvLyBAdHMtaWdub3JlIHVudGlsIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzc4NjEgaW1wbGVtZW50ZWRcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgY29uc3QgZW50cnkgPSBlbnRyaWVzWzBdO1xuICAgIGNvbnN0IHdpZHRoID0gZW50cnkuY29udGVudFJlY3Qud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gZW50cnkuY29udGVudFJlY3QuaGVpZ2h0O1xuICAgIC8vIFdoZW4gaXRzIGNvbnRhaW5lcidzIGRpc3BsYXkgaXMgc2V0IHRvICdub25lJyB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2l0aCBhXG4gICAgLy8gc2l6ZSBvZiAoMCwgMCksIHdoaWNoIHdpbGwgY2F1c2UgdGhlIGNoYXJ0IHRvIGxvc2UgaXRzIG9yaWdpbmFsIGhlaWdodCwgc28gc2tpcFxuICAgIC8vIHJlc2l6aW5nIGluIHN1Y2ggY2FzZS5cbiAgICBpZiAod2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgfSk7XG4gIG9ic2VydmVyLm9ic2VydmUoY29udGFpbmVyKTtcbiAgbGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQsIHJlc2l6ZSk7XG5cbiAgcmV0dXJuIG9ic2VydmVyO1xufVxuXG5mdW5jdGlvbiByZWxlYXNlT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIG9ic2VydmVyKSB7XG4gIGlmIChvYnNlcnZlcikge1xuICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuICBpZiAodHlwZSA9PT0gJ3Jlc2l6ZScpIHtcbiAgICB1bmxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVQcm94eUFuZExpc3RlbihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBwcm94eSA9IHRocm90dGxlZCgoZXZlbnQpID0+IHtcbiAgICAvLyBUaGlzIGNhc2UgY2FuIG9jY3VyIGlmIHRoZSBjaGFydCBpcyBkZXN0cm95ZWQgd2hpbGUgd2FpdGluZ1xuICAgIC8vIGZvciB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHRvIG9jY3VyLiBXZSBwcmV2ZW50IGNyYXNoZXMgYnkgY2hlY2tpbmdcbiAgICAvLyBmb3IgYSBkZXN0cm95ZWQgY2hhcnRcbiAgICBpZiAoY2hhcnQuY3R4ICE9PSBudWxsKSB7XG4gICAgICBsaXN0ZW5lcihmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSk7XG4gICAgfVxuICB9LCBjaGFydCk7XG5cbiAgYWRkTGlzdGVuZXIoY2FudmFzLCB0eXBlLCBwcm94eSk7XG5cbiAgcmV0dXJuIHByb3h5O1xufVxuXG4vKipcbiAqIFBsYXRmb3JtIGNsYXNzIGZvciBjaGFydHMgdGhhdCBjYW4gYWNjZXNzIHRoZSBET00gYW5kIGdsb2JhbCB3aW5kb3cvZG9jdW1lbnQgcHJvcGVydGllc1xuICogQGV4dGVuZHMgQmFzZVBsYXRmb3JtXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERvbVBsYXRmb3JtIGV4dGVuZHMgQmFzZVBsYXRmb3JtIHtcblxuICAvKipcblx0ICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbYXNwZWN0UmF0aW9dXG5cdCAqIEByZXR1cm4ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRHxudWxsfVxuXHQgKi9cbiAgYWNxdWlyZUNvbnRleHQoY2FudmFzLCBhc3BlY3RSYXRpbykge1xuICAgIC8vIFRvIHByZXZlbnQgY2FudmFzIGZpbmdlcnByaW50aW5nLCBzb21lIGFkZC1vbnMgdW5kZWZpbmUgdGhlIGdldENvbnRleHRcbiAgICAvLyBtZXRob2QsIGZvciBleGFtcGxlOiBodHRwczovL2dpdGh1Yi5jb20va2thcHNuZXIvQ2FudmFzQmxvY2tlclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yODA3XG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcyAmJiBjYW52YXMuZ2V0Q29udGV4dCAmJiBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIC8vIGBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50L0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRGAgZmFpbHMgd2hlbiB0aGUgY2FudmFzIGlzXG4gICAgLy8gaW5zaWRlIGFuIGlmcmFtZSBvciB3aGVuIHJ1bm5pbmcgaW4gYSBwcm90ZWN0ZWQgZW52aXJvbm1lbnQuIFdlIGNvdWxkIGd1ZXNzIHRoZVxuICAgIC8vIHR5cGVzIGZyb20gdGhlaXIgdG9TdHJpbmcoKSB2YWx1ZSBidXQgbGV0J3Mga2VlcCB0aGluZ3MgZmxleGlibGUgYW5kIGFzc3VtZSBpdCdzXG4gICAgLy8gYSBzdWZmaWNpZW50IGNvbmRpdGlvbiBpZiB0aGUgY2FudmFzIGhhcyBhIGNvbnRleHQyRCB3aGljaCBoYXMgY2FudmFzIGFzIGBjYW52YXNgLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8zODg3XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQxMDJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDE1MlxuICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuY2FudmFzID09PSBjYW52YXMpIHtcbiAgICAgIC8vIExvYWQgcGxhdGZvcm0gcmVzb3VyY2VzIG9uIGZpcnN0IGNoYXJ0IGNyZWF0aW9uLCB0byBtYWtlIGl0IHBvc3NpYmxlIHRvXG4gICAgICAvLyBpbXBvcnQgdGhlIGxpYnJhcnkgYmVmb3JlIHNldHRpbmcgcGxhdGZvcm0gb3B0aW9ucy5cbiAgICAgIGluaXRDYW52YXMoY2FudmFzLCBhc3BlY3RSYXRpbyk7XG4gICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dFxuXHQgKi9cbiAgcmVsZWFzZUNvbnRleHQoY29udGV4dCkge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNvbnRleHQuY2FudmFzO1xuICAgIGlmICghY2FudmFzW0VYUEFORE9fS0VZXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGluaXRpYWwgPSBjYW52YXNbRVhQQU5ET19LRVldLmluaXRpYWw7XG4gICAgWydoZWlnaHQnLCAnd2lkdGgnXS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGluaXRpYWxbcHJvcF07XG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgICAgY2FudmFzLnJlbW92ZUF0dHJpYnV0ZShwcm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUocHJvcCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3Qgc3R5bGUgPSBpbml0aWFsLnN0eWxlIHx8IHt9O1xuICAgIE9iamVjdC5rZXlzKHN0eWxlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNhbnZhcy5zdHlsZVtrZXldID0gc3R5bGVba2V5XTtcbiAgICB9KTtcblxuICAgIC8vIFRoZSBjYW52YXMgcmVuZGVyIHNpemUgbWlnaHQgaGF2ZSBiZWVuIGNoYW5nZWQgKGFuZCB0aHVzIHRoZSBzdGF0ZSBzdGFjayBkaXNjYXJkZWQpLFxuICAgIC8vIHdlIGNhbid0IHVzZSBzYXZlKCkgYW5kIHJlc3RvcmUoKSB0byByZXN0b3JlIHRoZSBpbml0aWFsIHN0YXRlLiBTbyBtYWtlIHN1cmUgdGhhdCBhdFxuICAgIC8vIGxlYXN0IHRoZSBjYW52YXMgY29udGV4dCBpcyByZXNldCB0byB0aGUgZGVmYXVsdCBzdGF0ZSBieSBzZXR0aW5nIHRoZSBjYW52YXMgd2lkdGguXG4gICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMTEvV0QtaHRtbDUtMjAxMTA1MjUvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1hc3NpZ25cbiAgICBjYW52YXMud2lkdGggPSBjYW52YXMud2lkdGg7XG5cbiAgICBkZWxldGUgY2FudmFzW0VYUEFORE9fS0VZXTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuXHQgKlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lclxuXHQgKi9cbiAgYWRkRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgICAvLyBDYW4gaGF2ZSBvbmx5IG9uZSBsaXN0ZW5lciBwZXIgdHlwZSwgc28gbWFrZSBzdXJlIHByZXZpb3VzIGlzIHJlbW92ZWRcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUpO1xuXG4gICAgY29uc3QgcHJveGllcyA9IGNoYXJ0LiRwcm94aWVzIHx8IChjaGFydC4kcHJveGllcyA9IHt9KTtcbiAgICBjb25zdCBoYW5kbGVycyA9IHtcbiAgICAgIGF0dGFjaDogY3JlYXRlQXR0YWNoT2JzZXJ2ZXIsXG4gICAgICBkZXRhY2g6IGNyZWF0ZURldGFjaE9ic2VydmVyLFxuICAgICAgcmVzaXplOiBjcmVhdGVSZXNpemVPYnNlcnZlclxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW3R5cGVdIHx8IGNyZWF0ZVByb3h5QW5kTGlzdGVuO1xuICAgIHByb3hpZXNbdHlwZV0gPSBoYW5kbGVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuXHQgKi9cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSkge1xuICAgIGNvbnN0IHByb3hpZXMgPSBjaGFydC4kcHJveGllcyB8fCAoY2hhcnQuJHByb3hpZXMgPSB7fSk7XG4gICAgY29uc3QgcHJveHkgPSBwcm94aWVzW3R5cGVdO1xuXG4gICAgaWYgKCFwcm94eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGhhbmRsZXJzID0ge1xuICAgICAgYXR0YWNoOiByZWxlYXNlT2JzZXJ2ZXIsXG4gICAgICBkZXRhY2g6IHJlbGVhc2VPYnNlcnZlcixcbiAgICAgIHJlc2l6ZTogcmVsZWFzZU9ic2VydmVyXG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNbdHlwZV0gfHwgcmVtb3ZlTGlzdGVuZXI7XG4gICAgaGFuZGxlcihjaGFydCwgdHlwZSwgcHJveHkpO1xuICAgIHByb3hpZXNbdHlwZV0gPSB1bmRlZmluZWQ7XG4gIH1cblxuICBnZXREZXZpY2VQaXhlbFJhdGlvKCkge1xuICAgIHJldHVybiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF0gLSBjb250ZW50IHdpZHRoIG9mIHBhcmVudCBlbGVtZW50XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0XSAtIGNvbnRlbnQgaGVpZ2h0IG9mIHBhcmVudCBlbGVtZW50XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbYXNwZWN0UmF0aW9dIC0gYXNwZWN0IHJhdGlvIHRvIG1haW50YWluXG5cdCAqL1xuICBnZXRNYXhpbXVtU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKSB7XG4gICAgcmV0dXJuIGdldE1heGltdW1TaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuXHQgKi9cbiAgaXNBdHRhY2hlZChjYW52YXMpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBfZ2V0UGFyZW50Tm9kZShjYW52YXMpO1xuICAgIHJldHVybiAhIShjb250YWluZXIgJiYgY29udGFpbmVyLmlzQ29ubmVjdGVkKTtcbiAgfVxufVxuIiwgImltcG9ydCB7X2lzRG9tU3VwcG9ydGVkfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCBCYXNlUGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybS5iYXNlLmpzJztcbmltcG9ydCBCYXNpY1BsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm0uYmFzaWMuanMnO1xuaW1wb3J0IERvbVBsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm0uZG9tLmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIF9kZXRlY3RQbGF0Zm9ybShjYW52YXMpIHtcbiAgaWYgKCFfaXNEb21TdXBwb3J0ZWQoKSB8fCAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzKSkge1xuICAgIHJldHVybiBCYXNpY1BsYXRmb3JtO1xuICB9XG4gIHJldHVybiBEb21QbGF0Zm9ybTtcbn1cblxuZXhwb3J0IHtCYXNlUGxhdGZvcm0sIEJhc2ljUGxhdGZvcm0sIERvbVBsYXRmb3JtfTtcbiIsICJpbXBvcnQgdHlwZSB7QW55T2JqZWN0fSBmcm9tICcuLi90eXBlcy9iYXNpYy5qcyc7XG5pbXBvcnQgdHlwZSB7UG9pbnR9IGZyb20gJy4uL3R5cGVzL2dlb21ldHJpYy5qcyc7XG5pbXBvcnQgdHlwZSB7QW5pbWF0aW9ufSBmcm9tICcuLi90eXBlcy9hbmltYXRpb24uanMnO1xuaW1wb3J0IHtpc051bWJlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbGVtZW50PFQgPSBBbnlPYmplY3QsIE8gPSBBbnlPYmplY3Q+IHtcblxuICBzdGF0aWMgZGVmYXVsdHMgPSB7fTtcbiAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB1bmRlZmluZWQ7XG5cbiAgeDogbnVtYmVyO1xuICB5OiBudW1iZXI7XG4gIGFjdGl2ZSA9IGZhbHNlO1xuICBvcHRpb25zOiBPO1xuICAkYW5pbWF0aW9uczogUmVjb3JkPGtleW9mIFQsIEFuaW1hdGlvbj47XG5cbiAgdG9vbHRpcFBvc2l0aW9uKHVzZUZpbmFsUG9zaXRpb246IGJvb2xlYW4pOiBQb2ludCB7XG4gICAgY29uc3Qge3gsIHl9ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICByZXR1cm4ge3gsIHl9IGFzIFBvaW50O1xuICB9XG5cbiAgaGFzVmFsdWUoKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyKHRoaXMueCkgJiYgaXNOdW1iZXIodGhpcy55KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IG9yIGZpbmFsIHZhbHVlIG9mIGVhY2ggcHJvcC4gQ2FuIHJldHVybiBleHRyYSBwcm9wZXJ0aWVzICh3aG9sZSBvYmplY3QpLlxuICAgKiBAcGFyYW0gcHJvcHMgLSBwcm9wZXJ0aWVzIHRvIGdldFxuICAgKiBAcGFyYW0gW2ZpbmFsXSAtIGdldCB0aGUgZmluYWwgdmFsdWUgKGFuaW1hdGlvbiB0YXJnZXQpXG4gICAqL1xuICBnZXRQcm9wczxQIGV4dGVuZHMgKGtleW9mIFQpW10+KHByb3BzOiBQLCBmaW5hbD86IGJvb2xlYW4pOiBQaWNrPFQsIFBbbnVtYmVyXT47XG4gIGdldFByb3BzPFAgZXh0ZW5kcyBzdHJpbmc+KHByb3BzOiBQW10sIGZpbmFsPzogYm9vbGVhbik6IFBhcnRpYWw8UmVjb3JkPFAsIHVua25vd24+PjtcbiAgZ2V0UHJvcHMocHJvcHM6IHN0cmluZ1tdLCBmaW5hbD86IGJvb2xlYW4pOiBQYXJ0aWFsPFJlY29yZDxzdHJpbmcsIHVua25vd24+PiB7XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLiRhbmltYXRpb25zO1xuICAgIGlmICghZmluYWwgfHwgIWFuaW1zKSB7XG4gICAgICAvLyBsZXQncyBub3QgY3JlYXRlIGFuIG9iamVjdCwgaWYgbm90IG5lZWRlZFxuICAgICAgcmV0dXJuIHRoaXMgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gICAgfVxuICAgIGNvbnN0IHJldDogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7fTtcbiAgICBwcm9wcy5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICByZXRbcHJvcF0gPSBhbmltc1twcm9wXSAmJiBhbmltc1twcm9wXS5hY3RpdmUoKSA/IGFuaW1zW3Byb3BdLl90byA6IHRoaXNbcHJvcCBhcyBzdHJpbmddO1xuICAgIH0pO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbn1cbiIsICJpbXBvcnQge2lzTnVsbE9yVW5kZWYsIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge19mYWN0b3JpemV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICogQHR5cGVkZWYge3t2YWx1ZTpudW1iZXIgfCBzdHJpbmcsIGxhYmVsPzpzdHJpbmcsIG1ham9yPzpib29sZWFuLCAkY29udGV4dD86YW55fX0gVGlja1xuICovXG5cbi8qKlxuICogUmV0dXJucyBhIHN1YnNldCBvZiB0aWNrcyB0byBiZSBwbG90dGVkIHRvIGF2b2lkIG92ZXJsYXBwaW5nIGxhYmVscy5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2NvcmUuc2NhbGUuanMnKS5kZWZhdWx0fSBzY2FsZVxuICogQHBhcmFtIHtUaWNrW119IHRpY2tzXG4gKiBAcmV0dXJuIHtUaWNrW119XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXV0b1NraXAoc2NhbGUsIHRpY2tzKSB7XG4gIGNvbnN0IHRpY2tPcHRzID0gc2NhbGUub3B0aW9ucy50aWNrcztcbiAgY29uc3QgZGV0ZXJtaW5lZE1heFRpY2tzID0gZGV0ZXJtaW5lTWF4VGlja3Moc2NhbGUpO1xuICBjb25zdCB0aWNrc0xpbWl0ID0gTWF0aC5taW4odGlja09wdHMubWF4VGlja3NMaW1pdCB8fCBkZXRlcm1pbmVkTWF4VGlja3MsIGRldGVybWluZWRNYXhUaWNrcyk7XG4gIGNvbnN0IG1ham9ySW5kaWNlcyA9IHRpY2tPcHRzLm1ham9yLmVuYWJsZWQgPyBnZXRNYWpvckluZGljZXModGlja3MpIDogW107XG4gIGNvbnN0IG51bU1ham9ySW5kaWNlcyA9IG1ham9ySW5kaWNlcy5sZW5ndGg7XG4gIGNvbnN0IGZpcnN0ID0gbWFqb3JJbmRpY2VzWzBdO1xuICBjb25zdCBsYXN0ID0gbWFqb3JJbmRpY2VzW251bU1ham9ySW5kaWNlcyAtIDFdO1xuICBjb25zdCBuZXdUaWNrcyA9IFtdO1xuXG4gIC8vIElmIHRoZXJlIGFyZSB0b28gbWFueSBtYWpvciB0aWNrcyB0byBkaXNwbGF5IHRoZW0gYWxsXG4gIGlmIChudW1NYWpvckluZGljZXMgPiB0aWNrc0xpbWl0KSB7XG4gICAgc2tpcE1ham9ycyh0aWNrcywgbmV3VGlja3MsIG1ham9ySW5kaWNlcywgbnVtTWFqb3JJbmRpY2VzIC8gdGlja3NMaW1pdCk7XG4gICAgcmV0dXJuIG5ld1RpY2tzO1xuICB9XG5cbiAgY29uc3Qgc3BhY2luZyA9IGNhbGN1bGF0ZVNwYWNpbmcobWFqb3JJbmRpY2VzLCB0aWNrcywgdGlja3NMaW1pdCk7XG5cbiAgaWYgKG51bU1ham9ySW5kaWNlcyA+IDApIHtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBjb25zdCBhdmdNYWpvclNwYWNpbmcgPSBudW1NYWpvckluZGljZXMgPiAxID8gTWF0aC5yb3VuZCgobGFzdCAtIGZpcnN0KSAvIChudW1NYWpvckluZGljZXMgLSAxKSkgOiBudWxsO1xuICAgIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBpc051bGxPclVuZGVmKGF2Z01ham9yU3BhY2luZykgPyAwIDogZmlyc3QgLSBhdmdNYWpvclNwYWNpbmcsIGZpcnN0KTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbnVtTWFqb3JJbmRpY2VzIC0gMTsgaSA8IGlsZW47IGkrKykge1xuICAgICAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcsIG1ham9ySW5kaWNlc1tpXSwgbWFqb3JJbmRpY2VzW2kgKyAxXSk7XG4gICAgfVxuICAgIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBsYXN0LCBpc051bGxPclVuZGVmKGF2Z01ham9yU3BhY2luZykgPyB0aWNrcy5sZW5ndGggOiBsYXN0ICsgYXZnTWFqb3JTcGFjaW5nKTtcbiAgICByZXR1cm4gbmV3VGlja3M7XG4gIH1cbiAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcpO1xuICByZXR1cm4gbmV3VGlja3M7XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZU1heFRpY2tzKHNjYWxlKSB7XG4gIGNvbnN0IG9mZnNldCA9IHNjYWxlLm9wdGlvbnMub2Zmc2V0O1xuICBjb25zdCB0aWNrTGVuZ3RoID0gc2NhbGUuX3RpY2tTaXplKCk7XG4gIGNvbnN0IG1heFNjYWxlID0gc2NhbGUuX2xlbmd0aCAvIHRpY2tMZW5ndGggKyAob2Zmc2V0ID8gMCA6IDEpO1xuICBjb25zdCBtYXhDaGFydCA9IHNjYWxlLl9tYXhMZW5ndGggLyB0aWNrTGVuZ3RoO1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLm1pbihtYXhTY2FsZSwgbWF4Q2hhcnQpKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcltdfSBtYWpvckluZGljZXNcbiAqIEBwYXJhbSB7VGlja1tdfSB0aWNrc1xuICogQHBhcmFtIHtudW1iZXJ9IHRpY2tzTGltaXRcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlU3BhY2luZyhtYWpvckluZGljZXMsIHRpY2tzLCB0aWNrc0xpbWl0KSB7XG4gIGNvbnN0IGV2ZW5NYWpvclNwYWNpbmcgPSBnZXRFdmVuU3BhY2luZyhtYWpvckluZGljZXMpO1xuICBjb25zdCBzcGFjaW5nID0gdGlja3MubGVuZ3RoIC8gdGlja3NMaW1pdDtcblxuICAvLyBJZiB0aGUgbWFqb3IgdGlja3MgYXJlIGV2ZW5seSBzcGFjZWQgYXBhcnQsIHBsYWNlIHRoZSBtaW5vciB0aWNrc1xuICAvLyBzbyB0aGF0IHRoZXkgZGl2aWRlIHRoZSBtYWpvciB0aWNrcyBpbnRvIGV2ZW4gY2h1bmtzXG4gIGlmICghZXZlbk1ham9yU3BhY2luZykge1xuICAgIHJldHVybiBNYXRoLm1heChzcGFjaW5nLCAxKTtcbiAgfVxuXG4gIGNvbnN0IGZhY3RvcnMgPSBfZmFjdG9yaXplKGV2ZW5NYWpvclNwYWNpbmcpO1xuICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IGZhY3RvcnMubGVuZ3RoIC0gMTsgaSA8IGlsZW47IGkrKykge1xuICAgIGNvbnN0IGZhY3RvciA9IGZhY3RvcnNbaV07XG4gICAgaWYgKGZhY3RvciA+IHNwYWNpbmcpIHtcbiAgICAgIHJldHVybiBmYWN0b3I7XG4gICAgfVxuICB9XG4gIHJldHVybiBNYXRoLm1heChzcGFjaW5nLCAxKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpY2tbXX0gdGlja3NcbiAqL1xuZnVuY3Rpb24gZ2V0TWFqb3JJbmRpY2VzKHRpY2tzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgaSwgaWxlbjtcbiAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgIGlmICh0aWNrc1tpXS5tYWpvcikge1xuICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUaWNrW119IHRpY2tzXG4gKiBAcGFyYW0ge1RpY2tbXX0gbmV3VGlja3NcbiAqIEBwYXJhbSB7bnVtYmVyW119IG1ham9ySW5kaWNlc1xuICogQHBhcmFtIHtudW1iZXJ9IHNwYWNpbmdcbiAqL1xuZnVuY3Rpb24gc2tpcE1ham9ycyh0aWNrcywgbmV3VGlja3MsIG1ham9ySW5kaWNlcywgc3BhY2luZykge1xuICBsZXQgY291bnQgPSAwO1xuICBsZXQgbmV4dCA9IG1ham9ySW5kaWNlc1swXTtcbiAgbGV0IGk7XG5cbiAgc3BhY2luZyA9IE1hdGguY2VpbChzcGFjaW5nKTtcbiAgZm9yIChpID0gMDsgaSA8IHRpY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGkgPT09IG5leHQpIHtcbiAgICAgIG5ld1RpY2tzLnB1c2godGlja3NbaV0pO1xuICAgICAgY291bnQrKztcbiAgICAgIG5leHQgPSBtYWpvckluZGljZXNbY291bnQgKiBzcGFjaW5nXTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpY2tbXX0gdGlja3NcbiAqIEBwYXJhbSB7VGlja1tdfSBuZXdUaWNrc1xuICogQHBhcmFtIHtudW1iZXJ9IHNwYWNpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWFqb3JTdGFydF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWFqb3JFbmRdXG4gKi9cbmZ1bmN0aW9uIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBtYWpvclN0YXJ0LCBtYWpvckVuZCkge1xuICBjb25zdCBzdGFydCA9IHZhbHVlT3JEZWZhdWx0KG1ham9yU3RhcnQsIDApO1xuICBjb25zdCBlbmQgPSBNYXRoLm1pbih2YWx1ZU9yRGVmYXVsdChtYWpvckVuZCwgdGlja3MubGVuZ3RoKSwgdGlja3MubGVuZ3RoKTtcbiAgbGV0IGNvdW50ID0gMDtcbiAgbGV0IGxlbmd0aCwgaSwgbmV4dDtcblxuICBzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcpO1xuICBpZiAobWFqb3JFbmQpIHtcbiAgICBsZW5ndGggPSBtYWpvckVuZCAtIG1ham9yU3RhcnQ7XG4gICAgc3BhY2luZyA9IGxlbmd0aCAvIE1hdGguZmxvb3IobGVuZ3RoIC8gc3BhY2luZyk7XG4gIH1cblxuICBuZXh0ID0gc3RhcnQ7XG5cbiAgd2hpbGUgKG5leHQgPCAwKSB7XG4gICAgY291bnQrKztcbiAgICBuZXh0ID0gTWF0aC5yb3VuZChzdGFydCArIGNvdW50ICogc3BhY2luZyk7XG4gIH1cblxuICBmb3IgKGkgPSBNYXRoLm1heChzdGFydCwgMCk7IGkgPCBlbmQ7IGkrKykge1xuICAgIGlmIChpID09PSBuZXh0KSB7XG4gICAgICBuZXdUaWNrcy5wdXNoKHRpY2tzW2ldKTtcbiAgICAgIGNvdW50Kys7XG4gICAgICBuZXh0ID0gTWF0aC5yb3VuZChzdGFydCArIGNvdW50ICogc3BhY2luZyk7XG4gICAgfVxuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcltdfSBhcnJcbiAqL1xuZnVuY3Rpb24gZ2V0RXZlblNwYWNpbmcoYXJyKSB7XG4gIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG4gIGxldCBpLCBkaWZmO1xuXG4gIGlmIChsZW4gPCAyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChkaWZmID0gYXJyWzBdLCBpID0gMTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFycltpXSAtIGFycltpIC0gMV0gIT09IGRpZmYpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRpZmY7XG59XG4iLCAiaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IHtfYWxpZ25QaXhlbCwgX21lYXN1cmVUZXh0LCByZW5kZXJUZXh0LCBjbGlwQXJlYSwgdW5jbGlwQXJlYX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNhbnZhcy5qcyc7XG5pbXBvcnQge2NhbGxiYWNrIGFzIGNhbGwsIGVhY2gsIGZpbml0ZU9yRGVmYXVsdCwgaXNBcnJheSwgaXNGaW5pdGUsIGlzTnVsbE9yVW5kZWYsIGlzT2JqZWN0LCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHt0b0RlZ3JlZXMsIHRvUmFkaWFucywgX2ludDE2UmFuZ2UsIF9saW1pdFZhbHVlLCBIQUxGX1BJfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge19hbGlnblN0YXJ0RW5kLCBfdG9MZWZ0UmlnaHRDZW50ZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuaW1wb3J0IHtjcmVhdGVDb250ZXh0LCB0b0ZvbnQsIHRvUGFkZGluZywgX2FkZEdyYWNlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5pbXBvcnQge2F1dG9Ta2lwfSBmcm9tICcuL2NvcmUuc2NhbGUuYXV0b3NraXAuanMnO1xuXG5jb25zdCByZXZlcnNlQWxpZ24gPSAoYWxpZ24pID0+IGFsaWduID09PSAnbGVmdCcgPyAncmlnaHQnIDogYWxpZ24gPT09ICdyaWdodCcgPyAnbGVmdCcgOiBhbGlnbjtcbmNvbnN0IG9mZnNldEZyb21FZGdlID0gKHNjYWxlLCBlZGdlLCBvZmZzZXQpID0+IGVkZ2UgPT09ICd0b3AnIHx8IGVkZ2UgPT09ICdsZWZ0JyA/IHNjYWxlW2VkZ2VdICsgb2Zmc2V0IDogc2NhbGVbZWRnZV0gLSBvZmZzZXQ7XG5jb25zdCBnZXRUaWNrc0xpbWl0ID0gKHRpY2tzTGVuZ3RoLCBtYXhUaWNrc0xpbWl0KSA9PiBNYXRoLm1pbihtYXhUaWNrc0xpbWl0IHx8IHRpY2tzTGVuZ3RoLCB0aWNrc0xlbmd0aCk7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQ2hhcnQgfSBDaGFydFxuICogQHR5cGVkZWYge3t2YWx1ZTpudW1iZXIgfCBzdHJpbmcsIGxhYmVsPzpzdHJpbmcsIG1ham9yPzpib29sZWFuLCAkY29udGV4dD86YW55fX0gVGlja1xuICovXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBhcnJheSBjb250YWluaW5nIG51bUl0ZW1zIGZyb20gYXJyXG4gKiBAcGFyYW0ge2FueVtdfSBhcnJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1JdGVtc1xuICovXG5mdW5jdGlvbiBzYW1wbGUoYXJyLCBudW1JdGVtcykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgaW5jcmVtZW50ID0gYXJyLmxlbmd0aCAvIG51bUl0ZW1zO1xuICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBsZW47IGkgKz0gaW5jcmVtZW50KSB7XG4gICAgcmVzdWx0LnB1c2goYXJyW01hdGguZmxvb3IoaSldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U2NhbGV9IHNjYWxlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb2Zmc2V0R3JpZExpbmVzXG4gKi9cbmZ1bmN0aW9uIGdldFBpeGVsRm9yR3JpZExpbmUoc2NhbGUsIGluZGV4LCBvZmZzZXRHcmlkTGluZXMpIHtcbiAgY29uc3QgbGVuZ3RoID0gc2NhbGUudGlja3MubGVuZ3RoO1xuICBjb25zdCB2YWxpZEluZGV4ID0gTWF0aC5taW4oaW5kZXgsIGxlbmd0aCAtIDEpO1xuICBjb25zdCBzdGFydCA9IHNjYWxlLl9zdGFydFBpeGVsO1xuICBjb25zdCBlbmQgPSBzY2FsZS5fZW5kUGl4ZWw7XG4gIGNvbnN0IGVwc2lsb24gPSAxZS02OyAvLyAxZS02IGlzIG1hcmdpbiBpbiBwaXhlbHMgZm9yIGFjY3VtdWxhdGVkIGVycm9yLlxuICBsZXQgbGluZVZhbHVlID0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKHZhbGlkSW5kZXgpO1xuICBsZXQgb2Zmc2V0O1xuXG4gIGlmIChvZmZzZXRHcmlkTGluZXMpIHtcbiAgICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgICBvZmZzZXQgPSBNYXRoLm1heChsaW5lVmFsdWUgLSBzdGFydCwgZW5kIC0gbGluZVZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICBvZmZzZXQgPSAoc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKDEpIC0gbGluZVZhbHVlKSAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldCA9IChsaW5lVmFsdWUgLSBzY2FsZS5nZXRQaXhlbEZvclRpY2sodmFsaWRJbmRleCAtIDEpKSAvIDI7XG4gICAgfVxuICAgIGxpbmVWYWx1ZSArPSB2YWxpZEluZGV4IDwgaW5kZXggPyBvZmZzZXQgOiAtb2Zmc2V0O1xuXG4gICAgLy8gUmV0dXJuIHVuZGVmaW5lZCBpZiB0aGUgcGl4ZWwgaXMgb3V0IG9mIHRoZSByYW5nZVxuICAgIGlmIChsaW5lVmFsdWUgPCBzdGFydCAtIGVwc2lsb24gfHwgbGluZVZhbHVlID4gZW5kICsgZXBzaWxvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGluZVZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBjYWNoZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqL1xuZnVuY3Rpb24gZ2FyYmFnZUNvbGxlY3QoY2FjaGVzLCBsZW5ndGgpIHtcbiAgZWFjaChjYWNoZXMsIChjYWNoZSkgPT4ge1xuICAgIGNvbnN0IGdjID0gY2FjaGUuZ2M7XG4gICAgY29uc3QgZ2NMZW4gPSBnYy5sZW5ndGggLyAyO1xuICAgIGxldCBpO1xuICAgIGlmIChnY0xlbiA+IGxlbmd0aCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGdjTGVuOyArK2kpIHtcbiAgICAgICAgZGVsZXRlIGNhY2hlLmRhdGFbZ2NbaV1dO1xuICAgICAgfVxuICAgICAgZ2Muc3BsaWNlKDAsIGdjTGVuKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGdldFRpY2tNYXJrTGVuZ3RoKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuZHJhd1RpY2tzID8gb3B0aW9ucy50aWNrTGVuZ3RoIDogMDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBnZXRUaXRsZUhlaWdodChvcHRpb25zLCBmYWxsYmFjaykge1xuICBpZiAoIW9wdGlvbnMuZGlzcGxheSkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgY29uc3QgZm9udCA9IHRvRm9udChvcHRpb25zLmZvbnQsIGZhbGxiYWNrKTtcbiAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuICBjb25zdCBsaW5lcyA9IGlzQXJyYXkob3B0aW9ucy50ZXh0KSA/IG9wdGlvbnMudGV4dC5sZW5ndGggOiAxO1xuXG4gIHJldHVybiAobGluZXMgKiBmb250LmxpbmVIZWlnaHQpICsgcGFkZGluZy5oZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNjYWxlQ29udGV4dChwYXJlbnQsIHNjYWxlKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIHNjYWxlLFxuICAgIHR5cGU6ICdzY2FsZSdcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRpY2tDb250ZXh0KHBhcmVudCwgaW5kZXgsIHRpY2spIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgdGljayxcbiAgICBpbmRleCxcbiAgICB0eXBlOiAndGljaydcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHRpdGxlQWxpZ24oYWxpZ24sIHBvc2l0aW9uLCByZXZlcnNlKSB7XG4gIC8qKiBAdHlwZSB7Q2FudmFzVGV4dEFsaWdufSAqL1xuICBsZXQgcmV0ID0gX3RvTGVmdFJpZ2h0Q2VudGVyKGFsaWduKTtcbiAgaWYgKChyZXZlcnNlICYmIHBvc2l0aW9uICE9PSAncmlnaHQnKSB8fCAoIXJldmVyc2UgJiYgcG9zaXRpb24gPT09ICdyaWdodCcpKSB7XG4gICAgcmV0ID0gcmV2ZXJzZUFsaWduKHJldCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gdGl0bGVBcmdzKHNjYWxlLCBvZmZzZXQsIHBvc2l0aW9uLCBhbGlnbikge1xuICBjb25zdCB7dG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0LCBjaGFydH0gPSBzY2FsZTtcbiAgY29uc3Qge2NoYXJ0QXJlYSwgc2NhbGVzfSA9IGNoYXJ0O1xuICBsZXQgcm90YXRpb24gPSAwO1xuICBsZXQgbWF4V2lkdGgsIHRpdGxlWCwgdGl0bGVZO1xuICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuXG4gIGlmIChzY2FsZS5pc0hvcml6b250YWwoKSkge1xuICAgIHRpdGxlWCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBsZWZ0LCByaWdodCk7XG5cbiAgICBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgdGl0bGVZID0gc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSArIGhlaWdodCAtIG9mZnNldDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgdGl0bGVZID0gKGNoYXJ0QXJlYS5ib3R0b20gKyBjaGFydEFyZWEudG9wKSAvIDIgKyBoZWlnaHQgLSBvZmZzZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpdGxlWSA9IG9mZnNldEZyb21FZGdlKHNjYWxlLCBwb3NpdGlvbiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgbWF4V2lkdGggPSByaWdodCAtIGxlZnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgIHRpdGxlWCA9IHNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkgLSB3aWR0aCArIG9mZnNldDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgdGl0bGVYID0gKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDIgLSB3aWR0aCArIG9mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGl0bGVYID0gb2Zmc2V0RnJvbUVkZ2Uoc2NhbGUsIHBvc2l0aW9uLCBvZmZzZXQpO1xuICAgIH1cbiAgICB0aXRsZVkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgYm90dG9tLCB0b3ApO1xuICAgIHJvdGF0aW9uID0gcG9zaXRpb24gPT09ICdsZWZ0JyA/IC1IQUxGX1BJIDogSEFMRl9QSTtcbiAgfVxuICByZXR1cm4ge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY2FsZSBleHRlbmRzIEVsZW1lbnQge1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtc3RhdGVtZW50c1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdGhpcy5pZCA9IGNmZy5pZDtcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICB0aGlzLnR5cGUgPSBjZmcudHlwZTtcbiAgICAvKiogQHR5cGUge2FueX0gKi9cbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICovXG4gICAgdGhpcy5jdHggPSBjZmcuY3R4O1xuICAgIC8qKiBAdHlwZSB7Q2hhcnR9ICovXG4gICAgdGhpcy5jaGFydCA9IGNmZy5jaGFydDtcblxuICAgIC8vIGltcGxlbWVudHMgYm94XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMucmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9tYXJnaW5zID0ge1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwXG4gICAgfTtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLm1heFdpZHRoID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMucGFkZGluZ1RvcCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5wYWRkaW5nTGVmdCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnBhZGRpbmdSaWdodCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIHNjYWxlLXNwZWNpZmljIHByb3BlcnRpZXNcbiAgICAvKiogQHR5cGUge3N0cmluZz19ICovXG4gICAgdGhpcy5heGlzID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyPX0gKi9cbiAgICB0aGlzLmxhYmVsUm90YXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5taW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmFuZ2UgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtUaWNrW119ICovXG4gICAgdGhpcy50aWNrcyA9IFtdO1xuICAgIC8qKiBAdHlwZSB7b2JqZWN0W118bnVsbH0gKi9cbiAgICB0aGlzLl9ncmlkTGluZUl0ZW1zID0gbnVsbDtcbiAgICAvKiogQHR5cGUge29iamVjdFtdfG51bGx9ICovXG4gICAgdGhpcy5fbGFiZWxJdGVtcyA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtvYmplY3R8bnVsbH0gKi9cbiAgICB0aGlzLl9sYWJlbFNpemVzID0gbnVsbDtcbiAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgIHRoaXMuX21heExlbmd0aCA9IDA7XG4gICAgdGhpcy5fbG9uZ2VzdFRleHRDYWNoZSA9IHt9O1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX3N0YXJ0UGl4ZWwgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fZW5kUGl4ZWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmV2ZXJzZVBpeGVscyA9IGZhbHNlO1xuICAgIHRoaXMuX3VzZXJNYXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdXNlck1pbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zdWdnZXN0ZWRNYXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3VnZ2VzdGVkTWluID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3RpY2tzTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9ib3JkZXJWYWx1ZSA9IDA7XG4gICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gZmFsc2U7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge2FueX0gb3B0aW9uc1xuXHQgKiBAc2luY2UgMy4wXG5cdCAqL1xuICBpbml0KG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuXG4gICAgdGhpcy5heGlzID0gb3B0aW9ucy5heGlzO1xuXG4gICAgLy8gcGFyc2UgbWluL21heCB2YWx1ZSwgc28gd2UgY2FuIHByb3Blcmx5IGRldGVybWluZSBtaW4vbWF4IGZvciBvdGhlciBzY2FsZXNcbiAgICB0aGlzLl91c2VyTWluID0gdGhpcy5wYXJzZShvcHRpb25zLm1pbik7XG4gICAgdGhpcy5fdXNlck1heCA9IHRoaXMucGFyc2Uob3B0aW9ucy5tYXgpO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1pbiA9IHRoaXMucGFyc2Uob3B0aW9ucy5zdWdnZXN0ZWRNaW4pO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1heCA9IHRoaXMucGFyc2Uob3B0aW9ucy5zdWdnZXN0ZWRNYXgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFBhcnNlIGEgc3VwcG9ydGVkIGlucHV0IHZhbHVlIHRvIGludGVybmFsIHJlcHJlc2VudGF0aW9uLlxuXHQgKiBAcGFyYW0geyp9IHJhd1xuXHQgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4XVxuXHQgKiBAc2luY2UgMy4wXG5cdCAqL1xuICBwYXJzZShyYXcsIGluZGV4KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICByZXR1cm4gcmF3O1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXIsIG1pbkRlZmluZWQ6IGJvb2xlYW4sIG1heERlZmluZWQ6IGJvb2xlYW59fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAzLjBcblx0ICovXG4gIGdldFVzZXJCb3VuZHMoKSB7XG4gICAgbGV0IHtfdXNlck1pbiwgX3VzZXJNYXgsIF9zdWdnZXN0ZWRNaW4sIF9zdWdnZXN0ZWRNYXh9ID0gdGhpcztcbiAgICBfdXNlck1pbiA9IGZpbml0ZU9yRGVmYXVsdChfdXNlck1pbiwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICBfdXNlck1heCA9IGZpbml0ZU9yRGVmYXVsdChfdXNlck1heCwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcbiAgICBfc3VnZ2VzdGVkTWluID0gZmluaXRlT3JEZWZhdWx0KF9zdWdnZXN0ZWRNaW4sIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgX3N1Z2dlc3RlZE1heCA9IGZpbml0ZU9yRGVmYXVsdChfc3VnZ2VzdGVkTWF4LCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO1xuICAgIHJldHVybiB7XG4gICAgICBtaW46IGZpbml0ZU9yRGVmYXVsdChfdXNlck1pbiwgX3N1Z2dlc3RlZE1pbiksXG4gICAgICBtYXg6IGZpbml0ZU9yRGVmYXVsdChfdXNlck1heCwgX3N1Z2dlc3RlZE1heCksXG4gICAgICBtaW5EZWZpbmVkOiBpc0Zpbml0ZShfdXNlck1pbiksXG4gICAgICBtYXhEZWZpbmVkOiBpc0Zpbml0ZShfdXNlck1heClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gY2FuU3RhY2tcblx0ICogQHJldHVybiB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn19XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDMuMFxuXHQgKi9cbiAgZ2V0TWluTWF4KGNhblN0YWNrKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgIGxldCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IHJhbmdlO1xuXG4gICAgaWYgKG1pbkRlZmluZWQgJiYgbWF4RGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHttaW4sIG1heH07XG4gICAgfVxuXG4gICAgY29uc3QgbWV0YXMgPSB0aGlzLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBtZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHJhbmdlID0gbWV0YXNbaV0uY29udHJvbGxlci5nZXRNaW5NYXgodGhpcywgY2FuU3RhY2spO1xuICAgICAgaWYgKCFtaW5EZWZpbmVkKSB7XG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgcmFuZ2UubWluKTtcbiAgICAgIH1cbiAgICAgIGlmICghbWF4RGVmaW5lZCkge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHJhbmdlLm1heCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIG1pbiA8PSBtYXggd2hlbiBvbmx5IG1pbiBvciBtYXggaXMgZGVmaW5lZCBieSB1c2VyIGFuZCB0aGUgZGF0YSBpcyBvdXRzaWRlIHRoYXQgcmFuZ2VcbiAgICBtaW4gPSBtYXhEZWZpbmVkICYmIG1pbiA+IG1heCA/IG1heCA6IG1pbjtcbiAgICBtYXggPSBtaW5EZWZpbmVkICYmIG1pbiA+IG1heCA/IG1pbiA6IG1heDtcblxuICAgIHJldHVybiB7XG4gICAgICBtaW46IGZpbml0ZU9yRGVmYXVsdChtaW4sIGZpbml0ZU9yRGVmYXVsdChtYXgsIG1pbikpLFxuICAgICAgbWF4OiBmaW5pdGVPckRlZmF1bHQobWF4LCBmaW5pdGVPckRlZmF1bHQobWluLCBtYXgpKVxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogR2V0IHRoZSBwYWRkaW5nIG5lZWRlZCBmb3IgdGhlIHNjYWxlXG5cdCAqIEByZXR1cm4ge3t0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyLCBib3R0b206IG51bWJlciwgcmlnaHQ6IG51bWJlcn19IHRoZSBuZWNlc3NhcnkgcGFkZGluZ1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgZ2V0UGFkZGluZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogdGhpcy5wYWRkaW5nTGVmdCB8fCAwLFxuICAgICAgdG9wOiB0aGlzLnBhZGRpbmdUb3AgfHwgMCxcbiAgICAgIHJpZ2h0OiB0aGlzLnBhZGRpbmdSaWdodCB8fCAwLFxuICAgICAgYm90dG9tOiB0aGlzLnBhZGRpbmdCb3R0b20gfHwgMFxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgc2NhbGUgdGljayBvYmplY3RzXG5cdCAqIEByZXR1cm4ge1RpY2tbXX1cblx0ICogQHNpbmNlIDIuN1xuXHQgKi9cbiAgZ2V0VGlja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudGlja3M7XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7c3RyaW5nW119XG5cdCAqL1xuICBnZXRMYWJlbHMoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuY2hhcnQuZGF0YTtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxhYmVscyB8fCAodGhpcy5pc0hvcml6b250YWwoKSA/IGRhdGEueExhYmVscyA6IGRhdGEueUxhYmVscykgfHwgZGF0YS5sYWJlbHMgfHwgW107XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KCcuLi90eXBlcy5qcycpLkxhYmVsSXRlbVtdfVxuICAgKi9cbiAgZ2V0TGFiZWxJdGVtcyhjaGFydEFyZWEgPSB0aGlzLmNoYXJ0LmNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fbGFiZWxJdGVtcyB8fCAodGhpcy5fbGFiZWxJdGVtcyA9IHRoaXMuX2NvbXB1dGVMYWJlbEl0ZW1zKGNoYXJ0QXJlYSkpO1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuXG4gIC8vIFdoZW4gYSBuZXcgbGF5b3V0IGlzIGNyZWF0ZWQsIHJlc2V0IHRoZSBkYXRhIGxpbWl0cyBjYWNoZVxuICBiZWZvcmVMYXlvdXQoKSB7XG4gICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gZmFsc2U7XG4gIH1cblxuICAvLyBUaGVzZSBtZXRob2RzIGFyZSBvcmRlcmVkIGJ5IGxpZmVjeWNsZS4gVXRpbGl0aWVzIHRoZW4gZm9sbG93LlxuICAvLyBBbnkgZnVuY3Rpb24gZGVmaW5lZCBoZXJlIGlzIGluaGVyaXRlZCBieSBhbGwgc2NhbGUgdHlwZXMuXG4gIC8vIEFueSBmdW5jdGlvbiBjYW4gYmUgZXh0ZW5kZWQgYnkgdGhlIHNjYWxlIHR5cGVcblxuICBiZWZvcmVVcGRhdGUoKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYmVmb3JlVXBkYXRlLCBbdGhpc10pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXhXaWR0aCAtIHRoZSBtYXggd2lkdGggaW4gcGl4ZWxzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXhIZWlnaHQgLSB0aGUgbWF4IGhlaWdodCBpbiBwaXhlbHNcblx0ICogQHBhcmFtIHt7dG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlciwgYm90dG9tOiBudW1iZXIsIHJpZ2h0OiBudW1iZXJ9fSBtYXJnaW5zIC0gdGhlIHNwYWNlIGJldHdlZW4gdGhlIGVkZ2Ugb2YgdGhlIG90aGVyIHNjYWxlcyBhbmQgZWRnZSBvZiB0aGUgY2hhcnRcblx0ICogICBUaGlzIHNwYWNlIGNvbWVzIGZyb20gdHdvIHNvdXJjZXM6XG5cdCAqICAgICAtIHBhZGRpbmcgLSBzcGFjZSB0aGF0J3MgcmVxdWlyZWQgdG8gc2hvdyB0aGUgbGFiZWxzIGF0IHRoZSBlZGdlcyBvZiB0aGUgc2NhbGVcblx0ICogICAgIC0gdGhpY2tuZXNzIG9mIHNjYWxlcyBvciBsZWdlbmRzIGluIGFub3RoZXIgb3JpZW50YXRpb25cblx0ICovXG4gIHVwZGF0ZShtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XG4gICAgY29uc3Qge2JlZ2luQXRaZXJvLCBncmFjZSwgdGlja3M6IHRpY2tPcHRzfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBzYW1wbGVTaXplID0gdGlja09wdHMuc2FtcGxlU2l6ZTtcblxuICAgIC8vIFVwZGF0ZSBMaWZlY3ljbGUgLSBQcm9iYWJseSBkb24ndCB3YW50IHRvIGV2ZXIgZXh0ZW5kIG9yIG92ZXJ3cml0ZSB0aGlzIGZ1bmN0aW9uIDspXG4gICAgdGhpcy5iZWZvcmVVcGRhdGUoKTtcblxuICAgIC8vIEFic29yYiB0aGUgbWFzdGVyIG1lYXN1cmVtZW50c1xuICAgIHRoaXMubWF4V2lkdGggPSBtYXhXaWR0aDtcbiAgICB0aGlzLm1heEhlaWdodCA9IG1heEhlaWdodDtcbiAgICB0aGlzLl9tYXJnaW5zID0gbWFyZ2lucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwXG4gICAgfSwgbWFyZ2lucyk7XG5cbiAgICB0aGlzLnRpY2tzID0gbnVsbDtcbiAgICB0aGlzLl9sYWJlbFNpemVzID0gbnVsbDtcbiAgICB0aGlzLl9ncmlkTGluZUl0ZW1zID0gbnVsbDtcbiAgICB0aGlzLl9sYWJlbEl0ZW1zID0gbnVsbDtcblxuICAgIC8vIERpbWVuc2lvbnNcbiAgICB0aGlzLmJlZm9yZVNldERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLnNldERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLmFmdGVyU2V0RGltZW5zaW9ucygpO1xuXG4gICAgdGhpcy5fbWF4TGVuZ3RoID0gdGhpcy5pc0hvcml6b250YWwoKVxuICAgICAgPyB0aGlzLndpZHRoICsgbWFyZ2lucy5sZWZ0ICsgbWFyZ2lucy5yaWdodFxuICAgICAgOiB0aGlzLmhlaWdodCArIG1hcmdpbnMudG9wICsgbWFyZ2lucy5ib3R0b207XG5cbiAgICAvLyBEYXRhIG1pbi9tYXhcbiAgICBpZiAoIXRoaXMuX2RhdGFMaW1pdHNDYWNoZWQpIHtcbiAgICAgIHRoaXMuYmVmb3JlRGF0YUxpbWl0cygpO1xuICAgICAgdGhpcy5kZXRlcm1pbmVEYXRhTGltaXRzKCk7XG4gICAgICB0aGlzLmFmdGVyRGF0YUxpbWl0cygpO1xuICAgICAgdGhpcy5fcmFuZ2UgPSBfYWRkR3JhY2UodGhpcywgZ3JhY2UsIGJlZ2luQXRaZXJvKTtcbiAgICAgIHRoaXMuX2RhdGFMaW1pdHNDYWNoZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuYmVmb3JlQnVpbGRUaWNrcygpO1xuXG4gICAgdGhpcy50aWNrcyA9IHRoaXMuYnVpbGRUaWNrcygpIHx8IFtdO1xuXG4gICAgLy8gQWxsb3cgbW9kaWZpY2F0aW9uIG9mIHRpY2tzIGluIGNhbGxiYWNrLlxuICAgIHRoaXMuYWZ0ZXJCdWlsZFRpY2tzKCk7XG5cbiAgICAvLyBDb21wdXRlIHRpY2sgcm90YXRpb24gYW5kIGZpdCB1c2luZyBhIHNhbXBsZWQgc3Vic2V0IG9mIGxhYmVsc1xuICAgIC8vIFdlIGdlbmVyYWxseSBkb24ndCBuZWVkIHRvIGNvbXB1dGUgdGhlIHNpemUgb2YgZXZlcnkgc2luZ2xlIGxhYmVsIGZvciBkZXRlcm1pbmluZyBzY2FsZSBzaXplXG4gICAgY29uc3Qgc2FtcGxpbmdFbmFibGVkID0gc2FtcGxlU2l6ZSA8IHRoaXMudGlja3MubGVuZ3RoO1xuICAgIHRoaXMuX2NvbnZlcnRUaWNrc1RvTGFiZWxzKHNhbXBsaW5nRW5hYmxlZCA/IHNhbXBsZSh0aGlzLnRpY2tzLCBzYW1wbGVTaXplKSA6IHRoaXMudGlja3MpO1xuXG4gICAgLy8gY29uZmlndXJlIGlzIGNhbGxlZCB0d2ljZSwgb25jZSBoZXJlLCBvbmNlIGZyb20gY29yZS5jb250cm9sbGVyLnVwZGF0ZUxheW91dC5cbiAgICAvLyBIZXJlIHdlIGhhdmVuJ3QgYmVlbiBwb3NpdGlvbmVkIHlldCwgYnV0IGRpbWVuc2lvbnMgYXJlIGNvcnJlY3QuXG4gICAgLy8gVmFyaWFibGVzIHNldCBpbiBjb25maWd1cmUgYXJlIG5lZWRlZCBmb3IgY2FsY3VsYXRlTGFiZWxSb3RhdGlvbiwgYW5kXG4gICAgLy8gaXQncyBvayB0aGF0IGNvb3JkaW5hdGVzIGFyZSBub3QgY29ycmVjdCB0aGVyZSwgb25seSBkaW1lbnNpb25zIG1hdHRlci5cbiAgICB0aGlzLmNvbmZpZ3VyZSgpO1xuXG4gICAgLy8gVGljayBSb3RhdGlvblxuICAgIHRoaXMuYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpO1xuICAgIHRoaXMuY2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpOyAvLyBQcmVjb25kaXRpb25zOiBudW1iZXIgb2YgdGlja3MgYW5kIHNpemVzIG9mIGxhcmdlc3QgbGFiZWxzIG11c3QgYmUgY2FsY3VsYXRlZCBiZWZvcmVoYW5kXG4gICAgdGhpcy5hZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKTtcblxuICAgIC8vIEF1dG8tc2tpcFxuICAgIGlmICh0aWNrT3B0cy5kaXNwbGF5ICYmICh0aWNrT3B0cy5hdXRvU2tpcCB8fCB0aWNrT3B0cy5zb3VyY2UgPT09ICdhdXRvJykpIHtcbiAgICAgIHRoaXMudGlja3MgPSBhdXRvU2tpcCh0aGlzLCB0aGlzLnRpY2tzKTtcbiAgICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBudWxsO1xuICAgICAgdGhpcy5hZnRlckF1dG9Ta2lwKCk7XG4gICAgfVxuXG4gICAgaWYgKHNhbXBsaW5nRW5hYmxlZCkge1xuICAgICAgLy8gR2VuZXJhdGUgbGFiZWxzIHVzaW5nIGFsbCBub24tc2tpcHBlZCB0aWNrc1xuICAgICAgdGhpcy5fY29udmVydFRpY2tzVG9MYWJlbHModGhpcy50aWNrcyk7XG4gICAgfVxuXG4gICAgdGhpcy5iZWZvcmVGaXQoKTtcbiAgICB0aGlzLmZpdCgpOyAvLyBQcmVjb25kaXRpb25zOiBsYWJlbCByb3RhdGlvbiBhbmQgbGFiZWwgc2l6ZXMgbXVzdCBiZSBjYWxjdWxhdGVkIGJlZm9yZWhhbmRcbiAgICB0aGlzLmFmdGVyRml0KCk7XG5cbiAgICAvLyBJTVBPUlRBTlQ6IGFmdGVyIHRoaXMgcG9pbnQsIHdlIGNvbnNpZGVyIHRoYXQgYHRoaXMudGlja3NgIHdpbGwgTkVWRVIgY2hhbmdlIVxuXG4gICAgdGhpcy5hZnRlclVwZGF0ZSgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBsZXQgcmV2ZXJzZVBpeGVscyA9IHRoaXMub3B0aW9ucy5yZXZlcnNlO1xuICAgIGxldCBzdGFydFBpeGVsLCBlbmRQaXhlbDtcblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBzdGFydFBpeGVsID0gdGhpcy5sZWZ0O1xuICAgICAgZW5kUGl4ZWwgPSB0aGlzLnJpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFBpeGVsID0gdGhpcy50b3A7XG4gICAgICBlbmRQaXhlbCA9IHRoaXMuYm90dG9tO1xuICAgICAgLy8gYnkgZGVmYXVsdCB2ZXJ0aWNhbCBzY2FsZXMgYXJlIGZyb20gYm90dG9tIHRvIHRvcCwgc28gcGl4ZWxzIGFyZSByZXZlcnNlZFxuICAgICAgcmV2ZXJzZVBpeGVscyA9ICFyZXZlcnNlUGl4ZWxzO1xuICAgIH1cbiAgICB0aGlzLl9zdGFydFBpeGVsID0gc3RhcnRQaXhlbDtcbiAgICB0aGlzLl9lbmRQaXhlbCA9IGVuZFBpeGVsO1xuICAgIHRoaXMuX3JldmVyc2VQaXhlbHMgPSByZXZlcnNlUGl4ZWxzO1xuICAgIHRoaXMuX2xlbmd0aCA9IGVuZFBpeGVsIC0gc3RhcnRQaXhlbDtcbiAgICB0aGlzLl9hbGlnblRvUGl4ZWxzID0gdGhpcy5vcHRpb25zLmFsaWduVG9QaXhlbHM7XG4gIH1cblxuICBhZnRlclVwZGF0ZSgpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5hZnRlclVwZGF0ZSwgW3RoaXNdKTtcbiAgfVxuXG4gIC8vXG5cbiAgYmVmb3JlU2V0RGltZW5zaW9ucygpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5iZWZvcmVTZXREaW1lbnNpb25zLCBbdGhpc10pO1xuICB9XG4gIHNldERpbWVuc2lvbnMoKSB7XG4gICAgLy8gU2V0IHRoZSB1bmNvbnN0cmFpbmVkIGRpbWVuc2lvbiBiZWZvcmUgbGFiZWwgcm90YXRpb25cbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgLy8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5tYXhXaWR0aDtcbiAgICAgIHRoaXMubGVmdCA9IDA7XG4gICAgICB0aGlzLnJpZ2h0ID0gdGhpcy53aWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLm1heEhlaWdodDtcblxuICAgICAgLy8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXG4gICAgICB0aGlzLnRvcCA9IDA7XG4gICAgICB0aGlzLmJvdHRvbSA9IHRoaXMuaGVpZ2h0O1xuICAgIH1cblxuICAgIC8vIFJlc2V0IHBhZGRpbmdcbiAgICB0aGlzLnBhZGRpbmdMZWZ0ID0gMDtcbiAgICB0aGlzLnBhZGRpbmdUb3AgPSAwO1xuICAgIHRoaXMucGFkZGluZ1JpZ2h0ID0gMDtcbiAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSAwO1xuICB9XG4gIGFmdGVyU2V0RGltZW5zaW9ucygpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5hZnRlclNldERpbWVuc2lvbnMsIFt0aGlzXSk7XG4gIH1cblxuICBfY2FsbEhvb2tzKG5hbWUpIHtcbiAgICB0aGlzLmNoYXJ0Lm5vdGlmeVBsdWdpbnMobmFtZSwgdGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNhbGwodGhpcy5vcHRpb25zW25hbWVdLCBbdGhpc10pO1xuICB9XG5cbiAgLy8gRGF0YSBsaW1pdHNcbiAgYmVmb3JlRGF0YUxpbWl0cygpIHtcbiAgICB0aGlzLl9jYWxsSG9va3MoJ2JlZm9yZURhdGFMaW1pdHMnKTtcbiAgfVxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge31cbiAgYWZ0ZXJEYXRhTGltaXRzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYWZ0ZXJEYXRhTGltaXRzJyk7XG4gIH1cblxuICAvL1xuICBiZWZvcmVCdWlsZFRpY2tzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYmVmb3JlQnVpbGRUaWNrcycpO1xuICB9XG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtvYmplY3RbXX0gdGhlIHRpY2tzXG5cdCAqL1xuICBidWlsZFRpY2tzKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBhZnRlckJ1aWxkVGlja3MoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdhZnRlckJ1aWxkVGlja3MnKTtcbiAgfVxuXG4gIGJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbigpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5iZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24sIFt0aGlzXSk7XG4gIH1cbiAgLyoqXG5cdCAqIENvbnZlcnQgdGlja3MgdG8gbGFiZWwgc3RyaW5nc1xuXHQgKiBAcGFyYW0ge1RpY2tbXX0gdGlja3Ncblx0ICovXG4gIGdlbmVyYXRlVGlja0xhYmVscyh0aWNrcykge1xuICAgIGNvbnN0IHRpY2tPcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgIGxldCBpLCBpbGVuLCB0aWNrO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHRpY2sgPSB0aWNrc1tpXTtcbiAgICAgIHRpY2subGFiZWwgPSBjYWxsKHRpY2tPcHRzLmNhbGxiYWNrLCBbdGljay52YWx1ZSwgaSwgdGlja3NdLCB0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24oKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24sIFt0aGlzXSk7XG4gIH1cblxuICAvL1xuXG4gIGJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiwgW3RoaXNdKTtcbiAgfVxuICBjYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGlja09wdHMgPSBvcHRpb25zLnRpY2tzO1xuICAgIGNvbnN0IG51bVRpY2tzID0gZ2V0VGlja3NMaW1pdCh0aGlzLnRpY2tzLmxlbmd0aCwgb3B0aW9ucy50aWNrcy5tYXhUaWNrc0xpbWl0KTtcbiAgICBjb25zdCBtaW5Sb3RhdGlvbiA9IHRpY2tPcHRzLm1pblJvdGF0aW9uIHx8IDA7XG4gICAgY29uc3QgbWF4Um90YXRpb24gPSB0aWNrT3B0cy5tYXhSb3RhdGlvbjtcbiAgICBsZXQgbGFiZWxSb3RhdGlvbiA9IG1pblJvdGF0aW9uO1xuICAgIGxldCB0aWNrV2lkdGgsIG1heEhlaWdodCwgbWF4TGFiZWxEaWFnb25hbDtcblxuICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkgfHwgIXRpY2tPcHRzLmRpc3BsYXkgfHwgbWluUm90YXRpb24gPj0gbWF4Um90YXRpb24gfHwgbnVtVGlja3MgPD0gMSB8fCAhdGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGhpcy5sYWJlbFJvdGF0aW9uID0gbWluUm90YXRpb247XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBjb25zdCBtYXhMYWJlbFdpZHRoID0gbGFiZWxTaXplcy53aWRlc3Qud2lkdGg7XG4gICAgY29uc3QgbWF4TGFiZWxIZWlnaHQgPSBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0O1xuXG4gICAgLy8gRXN0aW1hdGUgdGhlIHdpZHRoIG9mIGVhY2ggZ3JpZCBiYXNlZCBvbiB0aGUgY2FudmFzIHdpZHRoLCB0aGUgbWF4aW11bVxuICAgIC8vIGxhYmVsIHdpZHRoIGFuZCB0aGUgbnVtYmVyIG9mIHRpY2sgaW50ZXJ2YWxzXG4gICAgY29uc3QgbWF4V2lkdGggPSBfbGltaXRWYWx1ZSh0aGlzLmNoYXJ0LndpZHRoIC0gbWF4TGFiZWxXaWR0aCwgMCwgdGhpcy5tYXhXaWR0aCk7XG4gICAgdGlja1dpZHRoID0gb3B0aW9ucy5vZmZzZXQgPyB0aGlzLm1heFdpZHRoIC8gbnVtVGlja3MgOiBtYXhXaWR0aCAvIChudW1UaWNrcyAtIDEpO1xuXG4gICAgLy8gQWxsb3cgMyBwaXhlbHMgeDIgcGFkZGluZyBlaXRoZXIgc2lkZSBmb3IgbGFiZWwgcmVhZGFiaWxpdHlcbiAgICBpZiAobWF4TGFiZWxXaWR0aCArIDYgPiB0aWNrV2lkdGgpIHtcbiAgICAgIHRpY2tXaWR0aCA9IG1heFdpZHRoIC8gKG51bVRpY2tzIC0gKG9wdGlvbnMub2Zmc2V0ID8gMC41IDogMSkpO1xuICAgICAgbWF4SGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQgLSBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zLmdyaWQpXG5cdFx0XHRcdC0gdGlja09wdHMucGFkZGluZyAtIGdldFRpdGxlSGVpZ2h0KG9wdGlvbnMudGl0bGUsIHRoaXMuY2hhcnQub3B0aW9ucy5mb250KTtcbiAgICAgIG1heExhYmVsRGlhZ29uYWwgPSBNYXRoLnNxcnQobWF4TGFiZWxXaWR0aCAqIG1heExhYmVsV2lkdGggKyBtYXhMYWJlbEhlaWdodCAqIG1heExhYmVsSGVpZ2h0KTtcbiAgICAgIGxhYmVsUm90YXRpb24gPSB0b0RlZ3JlZXMoTWF0aC5taW4oXG4gICAgICAgIE1hdGguYXNpbihfbGltaXRWYWx1ZSgobGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCArIDYpIC8gdGlja1dpZHRoLCAtMSwgMSkpLFxuICAgICAgICBNYXRoLmFzaW4oX2xpbWl0VmFsdWUobWF4SGVpZ2h0IC8gbWF4TGFiZWxEaWFnb25hbCwgLTEsIDEpKSAtIE1hdGguYXNpbihfbGltaXRWYWx1ZShtYXhMYWJlbEhlaWdodCAvIG1heExhYmVsRGlhZ29uYWwsIC0xLCAxKSlcbiAgICAgICkpO1xuICAgICAgbGFiZWxSb3RhdGlvbiA9IE1hdGgubWF4KG1pblJvdGF0aW9uLCBNYXRoLm1pbihtYXhSb3RhdGlvbiwgbGFiZWxSb3RhdGlvbikpO1xuICAgIH1cblxuICAgIHRoaXMubGFiZWxSb3RhdGlvbiA9IGxhYmVsUm90YXRpb247XG4gIH1cbiAgYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiwgW3RoaXNdKTtcbiAgfVxuICBhZnRlckF1dG9Ta2lwKCkge31cblxuICAvL1xuXG4gIGJlZm9yZUZpdCgpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5iZWZvcmVGaXQsIFt0aGlzXSk7XG4gIH1cbiAgZml0KCkge1xuICAgIC8vIFJlc2V0XG4gICAgY29uc3QgbWluU2l6ZSA9IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfTtcblxuICAgIGNvbnN0IHtjaGFydCwgb3B0aW9uczoge3RpY2tzOiB0aWNrT3B0cywgdGl0bGU6IHRpdGxlT3B0cywgZ3JpZDogZ3JpZE9wdHN9fSA9IHRoaXM7XG4gICAgY29uc3QgZGlzcGxheSA9IHRoaXMuX2lzVmlzaWJsZSgpO1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG5cbiAgICBpZiAoZGlzcGxheSkge1xuICAgICAgY29uc3QgdGl0bGVIZWlnaHQgPSBnZXRUaXRsZUhlaWdodCh0aXRsZU9wdHMsIGNoYXJ0Lm9wdGlvbnMuZm9udCk7XG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIG1pblNpemUud2lkdGggPSB0aGlzLm1heFdpZHRoO1xuICAgICAgICBtaW5TaXplLmhlaWdodCA9IGdldFRpY2tNYXJrTGVuZ3RoKGdyaWRPcHRzKSArIHRpdGxlSGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWluU2l6ZS5oZWlnaHQgPSB0aGlzLm1heEhlaWdodDsgLy8gZmlsbCBhbGwgdGhlIGhlaWdodFxuICAgICAgICBtaW5TaXplLndpZHRoID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZE9wdHMpICsgdGl0bGVIZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIC8vIERvbid0IGJvdGhlciBmaXR0aW5nIHRoZSB0aWNrcyBpZiB3ZSBhcmUgbm90IHNob3dpbmcgdGhlIGxhYmVsc1xuICAgICAgaWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgdGhpcy50aWNrcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3Qge2ZpcnN0LCBsYXN0LCB3aWRlc3QsIGhpZ2hlc3R9ID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgICAgICBjb25zdCB0aWNrUGFkZGluZyA9IHRpY2tPcHRzLnBhZGRpbmcgKiAyO1xuICAgICAgICBjb25zdCBhbmdsZVJhZGlhbnMgPSB0b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcbiAgICAgICAgY29uc3QgY29zID0gTWF0aC5jb3MoYW5nbGVSYWRpYW5zKTtcbiAgICAgICAgY29uc3Qgc2luID0gTWF0aC5zaW4oYW5nbGVSYWRpYW5zKTtcblxuICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIC8vIEEgaG9yaXpvbnRhbCBheGlzIGlzIG1vcmUgY29uc3RyYWluZWQgYnkgdGhlIGhlaWdodC5cbiAgICAgICAgICBjb25zdCBsYWJlbEhlaWdodCA9IHRpY2tPcHRzLm1pcnJvciA/IDAgOiBzaW4gKiB3aWRlc3Qud2lkdGggKyBjb3MgKiBoaWdoZXN0LmhlaWdodDtcbiAgICAgICAgICBtaW5TaXplLmhlaWdodCA9IE1hdGgubWluKHRoaXMubWF4SGVpZ2h0LCBtaW5TaXplLmhlaWdodCArIGxhYmVsSGVpZ2h0ICsgdGlja1BhZGRpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBIHZlcnRpY2FsIGF4aXMgaXMgbW9yZSBjb25zdHJhaW5lZCBieSB0aGUgd2lkdGguIExhYmVscyBhcmUgdGhlXG4gICAgICAgIC8vIGRvbWluYW50IGZhY3RvciBoZXJlLCBzbyBnZXQgdGhhdCBsZW5ndGggZmlyc3QgYW5kIGFjY291bnQgZm9yIHBhZGRpbmdcbiAgICAgICAgICBjb25zdCBsYWJlbFdpZHRoID0gdGlja09wdHMubWlycm9yID8gMCA6IGNvcyAqIHdpZGVzdC53aWR0aCArIHNpbiAqIGhpZ2hlc3QuaGVpZ2h0O1xuXG4gICAgICAgICAgbWluU2l6ZS53aWR0aCA9IE1hdGgubWluKHRoaXMubWF4V2lkdGgsIG1pblNpemUud2lkdGggKyBsYWJlbFdpZHRoICsgdGlja1BhZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZVBhZGRpbmcoZmlyc3QsIGxhc3QsIHNpbiwgY29zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9oYW5kbGVNYXJnaW5zKCk7XG5cbiAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5fbGVuZ3RoID0gY2hhcnQud2lkdGggLSB0aGlzLl9tYXJnaW5zLmxlZnQgLSB0aGlzLl9tYXJnaW5zLnJpZ2h0O1xuICAgICAgdGhpcy5oZWlnaHQgPSBtaW5TaXplLmhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53aWR0aCA9IG1pblNpemUud2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuX2xlbmd0aCA9IGNoYXJ0LmhlaWdodCAtIHRoaXMuX21hcmdpbnMudG9wIC0gdGhpcy5fbWFyZ2lucy5ib3R0b207XG4gICAgfVxuICB9XG5cbiAgX2NhbGN1bGF0ZVBhZGRpbmcoZmlyc3QsIGxhc3QsIHNpbiwgY29zKSB7XG4gICAgY29uc3Qge3RpY2tzOiB7YWxpZ24sIHBhZGRpbmd9LCBwb3NpdGlvbn0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgaXNSb3RhdGVkID0gdGhpcy5sYWJlbFJvdGF0aW9uICE9PSAwO1xuICAgIGNvbnN0IGxhYmVsc0JlbG93VGlja3MgPSBwb3NpdGlvbiAhPT0gJ3RvcCcgJiYgdGhpcy5heGlzID09PSAneCc7XG5cbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgY29uc3Qgb2Zmc2V0TGVmdCA9IHRoaXMuZ2V0UGl4ZWxGb3JUaWNrKDApIC0gdGhpcy5sZWZ0O1xuICAgICAgY29uc3Qgb2Zmc2V0UmlnaHQgPSB0aGlzLnJpZ2h0IC0gdGhpcy5nZXRQaXhlbEZvclRpY2sodGhpcy50aWNrcy5sZW5ndGggLSAxKTtcbiAgICAgIGxldCBwYWRkaW5nTGVmdCA9IDA7XG4gICAgICBsZXQgcGFkZGluZ1JpZ2h0ID0gMDtcblxuICAgICAgLy8gRW5zdXJlIHRoYXQgb3VyIHRpY2tzIGFyZSBhbHdheXMgaW5zaWRlIHRoZSBjYW52YXMuIFdoZW4gcm90YXRlZCwgdGlja3MgYXJlIHJpZ2h0IGFsaWduZWRcbiAgICAgIC8vIHdoaWNoIG1lYW5zIHRoYXQgdGhlIHJpZ2h0IHBhZGRpbmcgaXMgZG9taW5hdGVkIGJ5IHRoZSBmb250IGhlaWdodFxuICAgICAgaWYgKGlzUm90YXRlZCkge1xuICAgICAgICBpZiAobGFiZWxzQmVsb3dUaWNrcykge1xuICAgICAgICAgIHBhZGRpbmdMZWZ0ID0gY29zICogZmlyc3Qud2lkdGg7XG4gICAgICAgICAgcGFkZGluZ1JpZ2h0ID0gc2luICogbGFzdC5oZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFkZGluZ0xlZnQgPSBzaW4gKiBmaXJzdC5oZWlnaHQ7XG4gICAgICAgICAgcGFkZGluZ1JpZ2h0ID0gY29zICogbGFzdC53aWR0aDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBwYWRkaW5nUmlnaHQgPSBsYXN0LndpZHRoO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgcGFkZGluZ0xlZnQgPSBmaXJzdC53aWR0aDtcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gIT09ICdpbm5lcicpIHtcbiAgICAgICAgcGFkZGluZ0xlZnQgPSBmaXJzdC53aWR0aCAvIDI7XG4gICAgICAgIHBhZGRpbmdSaWdodCA9IGxhc3Qud2lkdGggLyAyO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGp1c3QgcGFkZGluZyB0YWtpbmcgaW50byBhY2NvdW50IGNoYW5nZXMgaW4gb2Zmc2V0c1xuICAgICAgdGhpcy5wYWRkaW5nTGVmdCA9IE1hdGgubWF4KChwYWRkaW5nTGVmdCAtIG9mZnNldExlZnQgKyBwYWRkaW5nKSAqIHRoaXMud2lkdGggLyAodGhpcy53aWR0aCAtIG9mZnNldExlZnQpLCAwKTtcbiAgICAgIHRoaXMucGFkZGluZ1JpZ2h0ID0gTWF0aC5tYXgoKHBhZGRpbmdSaWdodCAtIG9mZnNldFJpZ2h0ICsgcGFkZGluZykgKiB0aGlzLndpZHRoIC8gKHRoaXMud2lkdGggLSBvZmZzZXRSaWdodCksIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcGFkZGluZ1RvcCA9IGxhc3QuaGVpZ2h0IC8gMjtcbiAgICAgIGxldCBwYWRkaW5nQm90dG9tID0gZmlyc3QuaGVpZ2h0IC8gMjtcblxuICAgICAgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgIHBhZGRpbmdUb3AgPSAwO1xuICAgICAgICBwYWRkaW5nQm90dG9tID0gZmlyc3QuaGVpZ2h0O1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgcGFkZGluZ1RvcCA9IGxhc3QuaGVpZ2h0O1xuICAgICAgICBwYWRkaW5nQm90dG9tID0gMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wYWRkaW5nVG9wID0gcGFkZGluZ1RvcCArIHBhZGRpbmc7XG4gICAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSBwYWRkaW5nQm90dG9tICsgcGFkZGluZztcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogSGFuZGxlIG1hcmdpbnMgYW5kIHBhZGRpbmcgaW50ZXJhY3Rpb25zXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfaGFuZGxlTWFyZ2lucygpIHtcbiAgICBpZiAodGhpcy5fbWFyZ2lucykge1xuICAgICAgdGhpcy5fbWFyZ2lucy5sZWZ0ID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nTGVmdCwgdGhpcy5fbWFyZ2lucy5sZWZ0KTtcbiAgICAgIHRoaXMuX21hcmdpbnMudG9wID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nVG9wLCB0aGlzLl9tYXJnaW5zLnRvcCk7XG4gICAgICB0aGlzLl9tYXJnaW5zLnJpZ2h0ID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nUmlnaHQsIHRoaXMuX21hcmdpbnMucmlnaHQpO1xuICAgICAgdGhpcy5fbWFyZ2lucy5ib3R0b20gPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdCb3R0b20sIHRoaXMuX21hcmdpbnMuYm90dG9tKTtcbiAgICB9XG4gIH1cblxuICBhZnRlckZpdCgpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5hZnRlckZpdCwgW3RoaXNdKTtcbiAgfVxuXG4gIC8vIFNoYXJlZCBNZXRob2RzXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cbiAgaXNIb3Jpem9udGFsKCkge1xuICAgIGNvbnN0IHtheGlzLCBwb3NpdGlvbn0gPSB0aGlzLm9wdGlvbnM7XG4gICAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScgfHwgYXhpcyA9PT0gJ3gnO1xuICB9XG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cbiAgaXNGdWxsU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmZ1bGxTaXplO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7VGlja1tdfSB0aWNrc1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NvbnZlcnRUaWNrc1RvTGFiZWxzKHRpY2tzKSB7XG4gICAgdGhpcy5iZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24oKTtcblxuICAgIHRoaXMuZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKTtcblxuICAgIC8vIFRpY2tzIHNob3VsZCBiZSBza2lwcGVkIHdoZW4gY2FsbGJhY2sgcmV0dXJucyBudWxsIG9yIHVuZGVmLCBzbyBsZXRzIHJlbW92ZSB0aG9zZS5cbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZih0aWNrc1tpXS5sYWJlbCkpIHtcbiAgICAgICAgdGlja3Muc3BsaWNlKGksIDEpO1xuICAgICAgICBpbGVuLS07XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uKCk7XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7eyBmaXJzdDogb2JqZWN0LCBsYXN0OiBvYmplY3QsIHdpZGVzdDogb2JqZWN0LCBoaWdoZXN0OiBvYmplY3QsIHdpZHRoczogQXJyYXksIGhlaWdodHM6IGFycmF5IH19XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0TGFiZWxTaXplcygpIHtcbiAgICBsZXQgbGFiZWxTaXplcyA9IHRoaXMuX2xhYmVsU2l6ZXM7XG5cbiAgICBpZiAoIWxhYmVsU2l6ZXMpIHtcbiAgICAgIGNvbnN0IHNhbXBsZVNpemUgPSB0aGlzLm9wdGlvbnMudGlja3Muc2FtcGxlU2l6ZTtcbiAgICAgIGxldCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgICBpZiAoc2FtcGxlU2l6ZSA8IHRpY2tzLmxlbmd0aCkge1xuICAgICAgICB0aWNrcyA9IHNhbXBsZSh0aWNrcywgc2FtcGxlU2l6ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBsYWJlbFNpemVzID0gdGhpcy5fY29tcHV0ZUxhYmVsU2l6ZXModGlja3MsIHRpY2tzLmxlbmd0aCwgdGhpcy5vcHRpb25zLnRpY2tzLm1heFRpY2tzTGltaXQpO1xuICAgIH1cblxuICAgIHJldHVybiBsYWJlbFNpemVzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMge3dpZHRoLCBoZWlnaHQsIG9mZnNldH0gb2JqZWN0cyBmb3IgdGhlIGZpcnN0LCBsYXN0LCB3aWRlc3QsIGhpZ2hlc3QgdGlja1xuXHQgKiBsYWJlbHMgd2hlcmUgb2Zmc2V0IGluZGljYXRlcyB0aGUgYW5jaG9yIHBvaW50IG9mZnNldCBmcm9tIHRoZSB0b3AgaW4gcGl4ZWxzLlxuXHQgKiBAcmV0dXJuIHt7IGZpcnN0OiBvYmplY3QsIGxhc3Q6IG9iamVjdCwgd2lkZXN0OiBvYmplY3QsIGhpZ2hlc3Q6IG9iamVjdCwgd2lkdGhzOiBBcnJheSwgaGVpZ2h0czogYXJyYXkgfX1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jb21wdXRlTGFiZWxTaXplcyh0aWNrcywgbGVuZ3RoLCBtYXhUaWNrc0xpbWl0KSB7XG4gICAgY29uc3Qge2N0eCwgX2xvbmdlc3RUZXh0Q2FjaGU6IGNhY2hlc30gPSB0aGlzO1xuICAgIGNvbnN0IHdpZHRocyA9IFtdO1xuICAgIGNvbnN0IGhlaWdodHMgPSBbXTtcbiAgICBjb25zdCBpbmNyZW1lbnQgPSBNYXRoLmZsb29yKGxlbmd0aCAvIGdldFRpY2tzTGltaXQobGVuZ3RoLCBtYXhUaWNrc0xpbWl0KSk7XG4gICAgbGV0IHdpZGVzdExhYmVsU2l6ZSA9IDA7XG4gICAgbGV0IGhpZ2hlc3RMYWJlbFNpemUgPSAwO1xuICAgIGxldCBpLCBqLCBqbGVuLCBsYWJlbCwgdGlja0ZvbnQsIGZvbnRTdHJpbmcsIGNhY2hlLCBsaW5lSGVpZ2h0LCB3aWR0aCwgaGVpZ2h0LCBuZXN0ZWRMYWJlbDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gaW5jcmVtZW50KSB7XG4gICAgICBsYWJlbCA9IHRpY2tzW2ldLmxhYmVsO1xuICAgICAgdGlja0ZvbnQgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKGkpO1xuICAgICAgY3R4LmZvbnQgPSBmb250U3RyaW5nID0gdGlja0ZvbnQuc3RyaW5nO1xuICAgICAgY2FjaGUgPSBjYWNoZXNbZm9udFN0cmluZ10gPSBjYWNoZXNbZm9udFN0cmluZ10gfHwge2RhdGE6IHt9LCBnYzogW119O1xuICAgICAgbGluZUhlaWdodCA9IHRpY2tGb250LmxpbmVIZWlnaHQ7XG4gICAgICB3aWR0aCA9IGhlaWdodCA9IDA7XG4gICAgICAvLyBVbmRlZmluZWQgbGFiZWxzIGFuZCBhcnJheXMgc2hvdWxkIG5vdCBiZSBtZWFzdXJlZFxuICAgICAgaWYgKCFpc051bGxPclVuZGVmKGxhYmVsKSAmJiAhaXNBcnJheShsYWJlbCkpIHtcbiAgICAgICAgd2lkdGggPSBfbWVhc3VyZVRleHQoY3R4LCBjYWNoZS5kYXRhLCBjYWNoZS5nYywgd2lkdGgsIGxhYmVsKTtcbiAgICAgICAgaGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShsYWJlbCkpIHtcbiAgICAgICAgLy8gaWYgaXQgaXMgYW4gYXJyYXkgbGV0J3MgbWVhc3VyZSBlYWNoIGVsZW1lbnRcbiAgICAgICAgZm9yIChqID0gMCwgamxlbiA9IGxhYmVsLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuICAgICAgICAgIG5lc3RlZExhYmVsID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChsYWJlbFtqXSk7XG4gICAgICAgICAgLy8gVW5kZWZpbmVkIGxhYmVscyBhbmQgYXJyYXlzIHNob3VsZCBub3QgYmUgbWVhc3VyZWRcbiAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWYobmVzdGVkTGFiZWwpICYmICFpc0FycmF5KG5lc3RlZExhYmVsKSkge1xuICAgICAgICAgICAgd2lkdGggPSBfbWVhc3VyZVRleHQoY3R4LCBjYWNoZS5kYXRhLCBjYWNoZS5nYywgd2lkdGgsIG5lc3RlZExhYmVsKTtcbiAgICAgICAgICAgIGhlaWdodCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2lkdGhzLnB1c2god2lkdGgpO1xuICAgICAgaGVpZ2h0cy5wdXNoKGhlaWdodCk7XG4gICAgICB3aWRlc3RMYWJlbFNpemUgPSBNYXRoLm1heCh3aWR0aCwgd2lkZXN0TGFiZWxTaXplKTtcbiAgICAgIGhpZ2hlc3RMYWJlbFNpemUgPSBNYXRoLm1heChoZWlnaHQsIGhpZ2hlc3RMYWJlbFNpemUpO1xuICAgIH1cbiAgICBnYXJiYWdlQ29sbGVjdChjYWNoZXMsIGxlbmd0aCk7XG5cbiAgICBjb25zdCB3aWRlc3QgPSB3aWR0aHMuaW5kZXhPZih3aWRlc3RMYWJlbFNpemUpO1xuICAgIGNvbnN0IGhpZ2hlc3QgPSBoZWlnaHRzLmluZGV4T2YoaGlnaGVzdExhYmVsU2l6ZSk7XG5cbiAgICBjb25zdCB2YWx1ZUF0ID0gKGlkeCkgPT4gKHt3aWR0aDogd2lkdGhzW2lkeF0gfHwgMCwgaGVpZ2h0OiBoZWlnaHRzW2lkeF0gfHwgMH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZpcnN0OiB2YWx1ZUF0KDApLFxuICAgICAgbGFzdDogdmFsdWVBdChsZW5ndGggLSAxKSxcbiAgICAgIHdpZGVzdDogdmFsdWVBdCh3aWRlc3QpLFxuICAgICAgaGlnaGVzdDogdmFsdWVBdChoaWdoZXN0KSxcbiAgICAgIHdpZHRocyxcbiAgICAgIGhlaWdodHMsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVc2VkIHRvIGdldCB0aGUgbGFiZWwgdG8gZGlzcGxheSBpbiB0aGUgdG9vbHRpcCBmb3IgdGhlIGdpdmVuIHZhbHVlXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWVcblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBsb2NhdGlvbiBvZiB0aGUgZ2l2ZW4gZGF0YSBwb2ludC4gVmFsdWUgY2FuIGVpdGhlciBiZSBhbiBpbmRleCBvciBhIG51bWVyaWNhbCB2YWx1ZVxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHsqfSB2YWx1ZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4XVxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlLCBpbmRleCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVc2VkIHRvIGdldCB0aGUgZGF0YSB2YWx1ZSBmcm9tIGEgZ2l2ZW4gcGl4ZWwuIFRoaXMgaXMgdGhlIGludmVyc2Ugb2YgZ2V0UGl4ZWxGb3JWYWx1ZVxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsXG5cdCAqIEByZXR1cm4geyp9XG5cdCAqL1xuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIGxvY2F0aW9uIG9mIHRoZSB0aWNrIGF0IHRoZSBnaXZlbiBpbmRleFxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldFBpeGVsRm9yVGljayhpbmRleCkge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGlja3MubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGlja3NbaW5kZXhdLnZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVdGlsaXR5IGZvciBnZXR0aW5nIHRoZSBwaXhlbCBsb2NhdGlvbiBvZiBhIHBlcmNlbnRhZ2Ugb2Ygc2NhbGVcblx0ICogVGhlIGNvb3JkaW5hdGUgKDAsIDApIGlzIGF0IHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkZWNpbWFsXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldFBpeGVsRm9yRGVjaW1hbChkZWNpbWFsKSB7XG4gICAgaWYgKHRoaXMuX3JldmVyc2VQaXhlbHMpIHtcbiAgICAgIGRlY2ltYWwgPSAxIC0gZGVjaW1hbDtcbiAgICB9XG5cbiAgICBjb25zdCBwaXhlbCA9IHRoaXMuX3N0YXJ0UGl4ZWwgKyBkZWNpbWFsICogdGhpcy5fbGVuZ3RoO1xuICAgIHJldHVybiBfaW50MTZSYW5nZSh0aGlzLl9hbGlnblRvUGl4ZWxzID8gX2FsaWduUGl4ZWwodGhpcy5jaGFydCwgcGl4ZWwsIDApIDogcGl4ZWwpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBkZWNpbWFsID0gKHBpeGVsIC0gdGhpcy5fc3RhcnRQaXhlbCkgLyB0aGlzLl9sZW5ndGg7XG4gICAgcmV0dXJuIHRoaXMuX3JldmVyc2VQaXhlbHMgPyAxIC0gZGVjaW1hbCA6IGRlY2ltYWw7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgcGl4ZWwgZm9yIHRoZSBtaW5pbXVtIGNoYXJ0IHZhbHVlXG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRCYXNlUGl4ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLmdldEJhc2VWYWx1ZSgpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRCYXNlVmFsdWUoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXM7XG5cbiAgICByZXR1cm4gbWluIDwgMCAmJiBtYXggPCAwID8gbWF4IDpcbiAgICAgIG1pbiA+IDAgJiYgbWF4ID4gMCA/IG1pbiA6XG4gICAgICAwO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldENvbnRleHQoaW5kZXgpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3MgfHwgW107XG5cbiAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRpY2tzLmxlbmd0aCkge1xuICAgICAgY29uc3QgdGljayA9IHRpY2tzW2luZGV4XTtcbiAgICAgIHJldHVybiB0aWNrLiRjb250ZXh0IHx8XG5cdFx0XHRcdCh0aWNrLiRjb250ZXh0ID0gY3JlYXRlVGlja0NvbnRleHQodGhpcy5nZXRDb250ZXh0KCksIGluZGV4LCB0aWNrKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiRjb250ZXh0IHx8XG5cdFx0XHQodGhpcy4kY29udGV4dCA9IGNyZWF0ZVNjYWxlQ29udGV4dCh0aGlzLmNoYXJ0LmdldENvbnRleHQoKSwgdGhpcykpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF90aWNrU2l6ZSgpIHtcbiAgICBjb25zdCBvcHRpb25UaWNrcyA9IHRoaXMub3B0aW9ucy50aWNrcztcblxuICAgIC8vIENhbGN1bGF0ZSBzcGFjZSBuZWVkZWQgYnkgbGFiZWwgaW4gYXhpcyBkaXJlY3Rpb24uXG4gICAgY29uc3Qgcm90ID0gdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG4gICAgY29uc3QgY29zID0gTWF0aC5hYnMoTWF0aC5jb3Mocm90KSk7XG4gICAgY29uc3Qgc2luID0gTWF0aC5hYnMoTWF0aC5zaW4ocm90KSk7XG5cbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGNvbnN0IHBhZGRpbmcgPSBvcHRpb25UaWNrcy5hdXRvU2tpcFBhZGRpbmcgfHwgMDtcbiAgICBjb25zdCB3ID0gbGFiZWxTaXplcyA/IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoICsgcGFkZGluZyA6IDA7XG4gICAgY29uc3QgaCA9IGxhYmVsU2l6ZXMgPyBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0ICsgcGFkZGluZyA6IDA7XG5cbiAgICAvLyBDYWxjdWxhdGUgc3BhY2UgbmVlZGVkIGZvciAxIHRpY2sgaW4gYXhpcyBkaXJlY3Rpb24uXG4gICAgcmV0dXJuIHRoaXMuaXNIb3Jpem9udGFsKClcbiAgICAgID8gaCAqIGNvcyA+IHcgKiBzaW4gPyB3IC8gY29zIDogaCAvIHNpblxuICAgICAgOiBoICogc2luIDwgdyAqIGNvcyA/IGggLyBjb3MgOiB3IC8gc2luO1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfaXNWaXNpYmxlKCkge1xuICAgIGNvbnN0IGRpc3BsYXkgPSB0aGlzLm9wdGlvbnMuZGlzcGxheTtcblxuICAgIGlmIChkaXNwbGF5ICE9PSAnYXV0bycpIHtcbiAgICAgIHJldHVybiAhIWRpc3BsYXk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKS5sZW5ndGggPiAwO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY29tcHV0ZUdyaWRMaW5lSXRlbXMoY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgYXhpcyA9IHRoaXMuYXhpcztcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7Z3JpZCwgcG9zaXRpb24sIGJvcmRlcn0gPSBvcHRpb25zO1xuICAgIGNvbnN0IG9mZnNldCA9IGdyaWQub2Zmc2V0O1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGNvbnN0IHRpY2tzTGVuZ3RoID0gdGlja3MubGVuZ3RoICsgKG9mZnNldCA/IDEgOiAwKTtcbiAgICBjb25zdCB0bCA9IGdldFRpY2tNYXJrTGVuZ3RoKGdyaWQpO1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG5cbiAgICBjb25zdCBib3JkZXJPcHRzID0gYm9yZGVyLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IGF4aXNXaWR0aCA9IGJvcmRlck9wdHMuZGlzcGxheSA/IGJvcmRlck9wdHMud2lkdGggOiAwO1xuICAgIGNvbnN0IGF4aXNIYWxmV2lkdGggPSBheGlzV2lkdGggLyAyO1xuICAgIGNvbnN0IGFsaWduQm9yZGVyVmFsdWUgPSBmdW5jdGlvbihwaXhlbCkge1xuICAgICAgcmV0dXJuIF9hbGlnblBpeGVsKGNoYXJ0LCBwaXhlbCwgYXhpc1dpZHRoKTtcbiAgICB9O1xuICAgIGxldCBib3JkZXJWYWx1ZSwgaSwgbGluZVZhbHVlLCBhbGlnbmVkTGluZVZhbHVlO1xuICAgIGxldCB0eDEsIHR5MSwgdHgyLCB0eTIsIHgxLCB5MSwgeDIsIHkyO1xuXG4gICAgaWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMuYm90dG9tKTtcbiAgICAgIHR5MSA9IHRoaXMuYm90dG9tIC0gdGw7XG4gICAgICB0eTIgPSBib3JkZXJWYWx1ZSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB5MSA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLnRvcCkgKyBheGlzSGFsZldpZHRoO1xuICAgICAgeTIgPSBjaGFydEFyZWEuYm90dG9tO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy50b3ApO1xuICAgICAgeTEgPSBjaGFydEFyZWEudG9wO1xuICAgICAgeTIgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5ib3R0b20pIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR5MSA9IGJvcmRlclZhbHVlICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR5MiA9IHRoaXMudG9wICsgdGw7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5yaWdodCk7XG4gICAgICB0eDEgPSB0aGlzLnJpZ2h0IC0gdGw7XG4gICAgICB0eDIgPSBib3JkZXJWYWx1ZSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB4MSA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLmxlZnQpICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHgyID0gY2hhcnRBcmVhLnJpZ2h0O1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmxlZnQpO1xuICAgICAgeDEgPSBjaGFydEFyZWEubGVmdDtcbiAgICAgIHgyID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEucmlnaHQpIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR4MSA9IGJvcmRlclZhbHVlICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR4MiA9IHRoaXMubGVmdCArIHRsO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3gnKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSgoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMiArIDAuNSk7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkpO1xuICAgICAgfVxuXG4gICAgICB5MSA9IGNoYXJ0QXJlYS50b3A7XG4gICAgICB5MiA9IGNoYXJ0QXJlYS5ib3R0b207XG4gICAgICB0eTEgPSBib3JkZXJWYWx1ZSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eTIgPSB0eTEgKyB0bDtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUoKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDIpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpKTtcbiAgICAgIH1cblxuICAgICAgdHgxID0gYm9yZGVyVmFsdWUgLSBheGlzSGFsZldpZHRoO1xuICAgICAgdHgyID0gdHgxIC0gdGw7XG4gICAgICB4MSA9IGNoYXJ0QXJlYS5sZWZ0O1xuICAgICAgeDIgPSBjaGFydEFyZWEucmlnaHQ7XG4gICAgfVxuXG4gICAgY29uc3QgbGltaXQgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnRpY2tzLm1heFRpY2tzTGltaXQsIHRpY2tzTGVuZ3RoKTtcbiAgICBjb25zdCBzdGVwID0gTWF0aC5tYXgoMSwgTWF0aC5jZWlsKHRpY2tzTGVuZ3RoIC8gbGltaXQpKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGlja3NMZW5ndGg7IGkgKz0gc3RlcCkge1xuICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0Q29udGV4dChpKTtcbiAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gZ3JpZC5zZXRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgY29uc3Qgb3B0c0F0SW5kZXhCb3JkZXIgPSBib3JkZXIuc2V0Q29udGV4dChjb250ZXh0KTtcblxuICAgICAgY29uc3QgbGluZVdpZHRoID0gb3B0c0F0SW5kZXgubGluZVdpZHRoO1xuICAgICAgY29uc3QgbGluZUNvbG9yID0gb3B0c0F0SW5kZXguY29sb3I7XG4gICAgICBjb25zdCBib3JkZXJEYXNoID0gb3B0c0F0SW5kZXhCb3JkZXIuZGFzaCB8fCBbXTtcbiAgICAgIGNvbnN0IGJvcmRlckRhc2hPZmZzZXQgPSBvcHRzQXRJbmRleEJvcmRlci5kYXNoT2Zmc2V0O1xuXG4gICAgICBjb25zdCB0aWNrV2lkdGggPSBvcHRzQXRJbmRleC50aWNrV2lkdGg7XG4gICAgICBjb25zdCB0aWNrQ29sb3IgPSBvcHRzQXRJbmRleC50aWNrQ29sb3I7XG4gICAgICBjb25zdCB0aWNrQm9yZGVyRGFzaCA9IG9wdHNBdEluZGV4LnRpY2tCb3JkZXJEYXNoIHx8IFtdO1xuICAgICAgY29uc3QgdGlja0JvcmRlckRhc2hPZmZzZXQgPSBvcHRzQXRJbmRleC50aWNrQm9yZGVyRGFzaE9mZnNldDtcblxuICAgICAgbGluZVZhbHVlID0gZ2V0UGl4ZWxGb3JHcmlkTGluZSh0aGlzLCBpLCBvZmZzZXQpO1xuXG4gICAgICAvLyBTa2lwIGlmIHRoZSBwaXhlbCBpcyBvdXQgb2YgdGhlIHJhbmdlXG4gICAgICBpZiAobGluZVZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGFsaWduZWRMaW5lVmFsdWUgPSBfYWxpZ25QaXhlbChjaGFydCwgbGluZVZhbHVlLCBsaW5lV2lkdGgpO1xuXG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIHR4MSA9IHR4MiA9IHgxID0geDIgPSBhbGlnbmVkTGluZVZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHkxID0gdHkyID0geTEgPSB5MiA9IGFsaWduZWRMaW5lVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICB0eDEsXG4gICAgICAgIHR5MSxcbiAgICAgICAgdHgyLFxuICAgICAgICB0eTIsXG4gICAgICAgIHgxLFxuICAgICAgICB5MSxcbiAgICAgICAgeDIsXG4gICAgICAgIHkyLFxuICAgICAgICB3aWR0aDogbGluZVdpZHRoLFxuICAgICAgICBjb2xvcjogbGluZUNvbG9yLFxuICAgICAgICBib3JkZXJEYXNoLFxuICAgICAgICBib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgICB0aWNrV2lkdGgsXG4gICAgICAgIHRpY2tDb2xvcixcbiAgICAgICAgdGlja0JvcmRlckRhc2gsXG4gICAgICAgIHRpY2tCb3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5fdGlja3NMZW5ndGggPSB0aWNrc0xlbmd0aDtcbiAgICB0aGlzLl9ib3JkZXJWYWx1ZSA9IGJvcmRlclZhbHVlO1xuXG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY29tcHV0ZUxhYmVsSXRlbXMoY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgYXhpcyA9IHRoaXMuYXhpcztcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHtwb3NpdGlvbiwgdGlja3M6IG9wdGlvblRpY2tzfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgY29uc3Qge2FsaWduLCBjcm9zc0FsaWduLCBwYWRkaW5nLCBtaXJyb3J9ID0gb3B0aW9uVGlja3M7XG4gICAgY29uc3QgdGwgPSBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zLmdyaWQpO1xuICAgIGNvbnN0IHRpY2tBbmRQYWRkaW5nID0gdGwgKyBwYWRkaW5nO1xuICAgIGNvbnN0IGhUaWNrQW5kUGFkZGluZyA9IG1pcnJvciA/IC1wYWRkaW5nIDogdGlja0FuZFBhZGRpbmc7XG4gICAgY29uc3Qgcm90YXRpb24gPSAtdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgdGljaywgbGFiZWwsIHgsIHksIHRleHRBbGlnbiwgcGl4ZWwsIGZvbnQsIGxpbmVIZWlnaHQsIGxpbmVDb3VudCwgdGV4dE9mZnNldDtcbiAgICBsZXQgdGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cbiAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICB5ID0gdGhpcy5ib3R0b20gLSBoVGlja0FuZFBhZGRpbmc7XG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCk7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHkgPSB0aGlzLnRvcCArIGhUaWNrQW5kUGFkZGluZztcbiAgICAgIHRleHRBbGlnbiA9IHRoaXMuX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgIGNvbnN0IHJldCA9IHRoaXMuX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpO1xuICAgICAgdGV4dEFsaWduID0gcmV0LnRleHRBbGlnbjtcbiAgICAgIHggPSByZXQueDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICBjb25zdCByZXQgPSB0aGlzLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKTtcbiAgICAgIHRleHRBbGlnbiA9IHJldC50ZXh0QWxpZ247XG4gICAgICB4ID0gcmV0Lng7XG4gICAgfSBlbHNlIGlmIChheGlzID09PSAneCcpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgeSA9ICgoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMikgKyB0aWNrQW5kUGFkZGluZztcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgeSA9IHRoaXMuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSArIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgfVxuICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3knKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHggPSAoKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDIpIC0gdGlja0FuZFBhZGRpbmc7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIHggPSB0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKS50ZXh0QWxpZ247XG4gICAgfVxuXG4gICAgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgICAgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgIHRleHRCYXNlbGluZSA9ICd0b3AnO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgdGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aWNrID0gdGlja3NbaV07XG4gICAgICBsYWJlbCA9IHRpY2subGFiZWw7XG5cbiAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gb3B0aW9uVGlja3Muc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaSkpO1xuICAgICAgcGl4ZWwgPSB0aGlzLmdldFBpeGVsRm9yVGljayhpKSArIG9wdGlvblRpY2tzLmxhYmVsT2Zmc2V0O1xuICAgICAgZm9udCA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoaSk7XG4gICAgICBsaW5lSGVpZ2h0ID0gZm9udC5saW5lSGVpZ2h0O1xuICAgICAgbGluZUNvdW50ID0gaXNBcnJheShsYWJlbCkgPyBsYWJlbC5sZW5ndGggOiAxO1xuICAgICAgY29uc3QgaGFsZkNvdW50ID0gbGluZUNvdW50IC8gMjtcbiAgICAgIGNvbnN0IGNvbG9yID0gb3B0c0F0SW5kZXguY29sb3I7XG4gICAgICBjb25zdCBzdHJva2VDb2xvciA9IG9wdHNBdEluZGV4LnRleHRTdHJva2VDb2xvcjtcbiAgICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gb3B0c0F0SW5kZXgudGV4dFN0cm9rZVdpZHRoO1xuICAgICAgbGV0IHRpY2tUZXh0QWxpZ24gPSB0ZXh0QWxpZ247XG5cbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgeCA9IHBpeGVsO1xuXG4gICAgICAgIGlmICh0ZXh0QWxpZ24gPT09ICdpbm5lcicpIHtcbiAgICAgICAgICBpZiAoaSA9PT0gaWxlbiAtIDEpIHtcbiAgICAgICAgICAgIHRpY2tUZXh0QWxpZ24gPSAhdGhpcy5vcHRpb25zLnJldmVyc2UgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgdGlja1RleHRBbGlnbiA9ICF0aGlzLm9wdGlvbnMucmV2ZXJzZSA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpY2tUZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJyB8fCByb3RhdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IC1saW5lQ291bnQgKiBsaW5lSGVpZ2h0ICsgbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IC1sYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0IC8gMiAtIGhhbGZDb3VudCAqIGxpbmVIZWlnaHQgKyBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gLWxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgKyBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmVseS1pZlxuICAgICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicgfHwgcm90YXRpb24gIT09IDApIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCAvIDIgLSBoYWxmQ291bnQgKiBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCAtIGxpbmVDb3VudCAqIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgICB0ZXh0T2Zmc2V0ICo9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3RhdGlvbiAhPT0gMCAmJiAhb3B0c0F0SW5kZXguc2hvd0xhYmVsQmFja2Ryb3ApIHtcbiAgICAgICAgICB4ICs9IChsaW5lSGVpZ2h0IC8gMikgKiBNYXRoLnNpbihyb3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkgPSBwaXhlbDtcbiAgICAgICAgdGV4dE9mZnNldCA9ICgxIC0gbGluZUNvdW50KSAqIGxpbmVIZWlnaHQgLyAyO1xuICAgICAgfVxuXG4gICAgICBsZXQgYmFja2Ryb3A7XG5cbiAgICAgIGlmIChvcHRzQXRJbmRleC5zaG93TGFiZWxCYWNrZHJvcCkge1xuICAgICAgICBjb25zdCBsYWJlbFBhZGRpbmcgPSB0b1BhZGRpbmcob3B0c0F0SW5kZXguYmFja2Ryb3BQYWRkaW5nKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gbGFiZWxTaXplcy5oZWlnaHRzW2ldO1xuICAgICAgICBjb25zdCB3aWR0aCA9IGxhYmVsU2l6ZXMud2lkdGhzW2ldO1xuXG4gICAgICAgIGxldCB0b3AgPSB0ZXh0T2Zmc2V0IC0gbGFiZWxQYWRkaW5nLnRvcDtcbiAgICAgICAgbGV0IGxlZnQgPSAwIC0gbGFiZWxQYWRkaW5nLmxlZnQ7XG5cbiAgICAgICAgc3dpdGNoICh0ZXh0QmFzZWxpbmUpIHtcbiAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICB0b3AgLT0gaGVpZ2h0IC8gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICB0b3AgLT0gaGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICh0ZXh0QWxpZ24pIHtcbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICBsZWZ0IC09IHdpZHRoIC8gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2lubmVyJzpcbiAgICAgICAgICBpZiAoaSA9PT0gaWxlbiAtIDEpIHtcbiAgICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgICAgfSBlbHNlIGlmIChpID4gMCkge1xuICAgICAgICAgICAgbGVmdCAtPSB3aWR0aCAvIDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgYmFja2Ryb3AgPSB7XG4gICAgICAgICAgbGVmdCxcbiAgICAgICAgICB0b3AsXG4gICAgICAgICAgd2lkdGg6IHdpZHRoICsgbGFiZWxQYWRkaW5nLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0ICsgbGFiZWxQYWRkaW5nLmhlaWdodCxcblxuICAgICAgICAgIGNvbG9yOiBvcHRzQXRJbmRleC5iYWNrZHJvcENvbG9yLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGZvbnQsXG4gICAgICAgIHRleHRPZmZzZXQsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICBjb2xvcixcbiAgICAgICAgICBzdHJva2VDb2xvcixcbiAgICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgICB0ZXh0QWxpZ246IHRpY2tUZXh0QWxpZ24sXG4gICAgICAgICAgdGV4dEJhc2VsaW5lLFxuICAgICAgICAgIHRyYW5zbGF0aW9uOiBbeCwgeV0sXG4gICAgICAgICAgYmFja2Ryb3AsXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBpdGVtcztcbiAgfVxuXG4gIF9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCkge1xuICAgIGNvbnN0IHtwb3NpdGlvbiwgdGlja3N9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gLXRvUmFkaWFucyh0aGlzLmxhYmVsUm90YXRpb24pO1xuXG4gICAgaWYgKHJvdGF0aW9uKSB7XG4gICAgICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB9XG5cbiAgICBsZXQgYWxpZ24gPSAnY2VudGVyJztcblxuICAgIGlmICh0aWNrcy5hbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgYWxpZ24gPSAnbGVmdCc7XG4gICAgfSBlbHNlIGlmICh0aWNrcy5hbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgIGFsaWduID0gJ3JpZ2h0JztcbiAgICB9IGVsc2UgaWYgKHRpY2tzLmFsaWduID09PSAnaW5uZXInKSB7XG4gICAgICBhbGlnbiA9ICdpbm5lcic7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFsaWduO1xuICB9XG5cbiAgX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpIHtcbiAgICBjb25zdCB7cG9zaXRpb24sIHRpY2tzOiB7Y3Jvc3NBbGlnbiwgbWlycm9yLCBwYWRkaW5nfX0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBjb25zdCB0aWNrQW5kUGFkZGluZyA9IHRsICsgcGFkZGluZztcbiAgICBjb25zdCB3aWRlc3QgPSBsYWJlbFNpemVzLndpZGVzdC53aWR0aDtcblxuICAgIGxldCB0ZXh0QWxpZ247XG4gICAgbGV0IHg7XG5cbiAgICBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgaWYgKG1pcnJvcikge1xuICAgICAgICB4ID0gdGhpcy5yaWdodCArIHBhZGRpbmc7XG5cbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIHggKz0gKHdpZGVzdCAvIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgeCArPSB3aWRlc3Q7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB0aGlzLnJpZ2h0IC0gdGlja0FuZFBhZGRpbmc7XG5cbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4IC09ICh3aWRlc3QgLyAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgeCA9IHRoaXMubGVmdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgeCA9IHRoaXMubGVmdCArIHBhZGRpbmc7XG5cbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4IC09ICh3aWRlc3QgLyAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgeCAtPSB3aWRlc3Q7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB0aGlzLmxlZnQgKyB0aWNrQW5kUGFkZGluZztcblxuICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCArPSB3aWRlc3QgLyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgeCA9IHRoaXMucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICB9XG5cbiAgICByZXR1cm4ge3RleHRBbGlnbiwgeH07XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jb21wdXRlTGFiZWxBcmVhKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudGlja3MubWlycm9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xuXG4gICAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcgfHwgcG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIHJldHVybiB7dG9wOiAwLCBsZWZ0OiB0aGlzLmxlZnQsIGJvdHRvbTogY2hhcnQuaGVpZ2h0LCByaWdodDogdGhpcy5yaWdodH07XG4gICAgfSBpZiAocG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgcmV0dXJuIHt0b3A6IHRoaXMudG9wLCBsZWZ0OiAwLCBib3R0b206IHRoaXMuYm90dG9tLCByaWdodDogY2hhcnQud2lkdGh9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBkcmF3QmFja2dyb3VuZCgpIHtcbiAgICBjb25zdCB7Y3R4LCBvcHRpb25zOiB7YmFja2dyb3VuZENvbG9yfSwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0fSA9IHRoaXM7XG4gICAgaWYgKGJhY2tncm91bmRDb2xvcikge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgICBjdHguZmlsbFJlY3QobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0TGluZVdpZHRoRm9yVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBncmlkID0gdGhpcy5vcHRpb25zLmdyaWQ7XG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSB8fCAhZ3JpZC5kaXNwbGF5KSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGNvbnN0IGluZGV4ID0gdGlja3MuZmluZEluZGV4KHQgPT4gdC52YWx1ZSA9PT0gdmFsdWUpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBjb25zdCBvcHRzID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpbmRleCkpO1xuICAgICAgcmV0dXJuIG9wdHMubGluZVdpZHRoO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3R3JpZChjaGFydEFyZWEpIHtcbiAgICBjb25zdCBncmlkID0gdGhpcy5vcHRpb25zLmdyaWQ7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLl9ncmlkTGluZUl0ZW1zIHx8ICh0aGlzLl9ncmlkTGluZUl0ZW1zID0gdGhpcy5fY29tcHV0ZUdyaWRMaW5lSXRlbXMoY2hhcnRBcmVhKSk7XG4gICAgbGV0IGksIGlsZW47XG5cbiAgICBjb25zdCBkcmF3TGluZSA9IChwMSwgcDIsIHN0eWxlKSA9PiB7XG4gICAgICBpZiAoIXN0eWxlLndpZHRoIHx8ICFzdHlsZS5jb2xvcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IHN0eWxlLndpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGUuY29sb3I7XG4gICAgICBjdHguc2V0TGluZURhc2goc3R5bGUuYm9yZGVyRGFzaCB8fCBbXSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBzdHlsZS5ib3JkZXJEYXNoT2Zmc2V0O1xuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHAxLngsIHAxLnkpO1xuICAgICAgY3R4LmxpbmVUbyhwMi54LCBwMi55KTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfTtcblxuICAgIGlmIChncmlkLmRpc3BsYXkpIHtcbiAgICAgIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuXG4gICAgICAgIGlmIChncmlkLmRyYXdPbkNoYXJ0QXJlYSkge1xuICAgICAgICAgIGRyYXdMaW5lKFxuICAgICAgICAgICAge3g6IGl0ZW0ueDEsIHk6IGl0ZW0ueTF9LFxuICAgICAgICAgICAge3g6IGl0ZW0ueDIsIHk6IGl0ZW0ueTJ9LFxuICAgICAgICAgICAgaXRlbVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ3JpZC5kcmF3VGlja3MpIHtcbiAgICAgICAgICBkcmF3TGluZShcbiAgICAgICAgICAgIHt4OiBpdGVtLnR4MSwgeTogaXRlbS50eTF9LFxuICAgICAgICAgICAge3g6IGl0ZW0udHgyLCB5OiBpdGVtLnR5Mn0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbG9yOiBpdGVtLnRpY2tDb2xvcixcbiAgICAgICAgICAgICAgd2lkdGg6IGl0ZW0udGlja1dpZHRoLFxuICAgICAgICAgICAgICBib3JkZXJEYXNoOiBpdGVtLnRpY2tCb3JkZXJEYXNoLFxuICAgICAgICAgICAgICBib3JkZXJEYXNoT2Zmc2V0OiBpdGVtLnRpY2tCb3JkZXJEYXNoT2Zmc2V0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3Qm9yZGVyKCkge1xuICAgIGNvbnN0IHtjaGFydCwgY3R4LCBvcHRpb25zOiB7Ym9yZGVyLCBncmlkfX0gPSB0aGlzO1xuICAgIGNvbnN0IGJvcmRlck9wdHMgPSBib3JkZXIuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3QgYXhpc1dpZHRoID0gYm9yZGVyLmRpc3BsYXkgPyBib3JkZXJPcHRzLndpZHRoIDogMDtcbiAgICBpZiAoIWF4aXNXaWR0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXN0TGluZVdpZHRoID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgwKSkubGluZVdpZHRoO1xuICAgIGNvbnN0IGJvcmRlclZhbHVlID0gdGhpcy5fYm9yZGVyVmFsdWU7XG4gICAgbGV0IHgxLCB4MiwgeTEsIHkyO1xuXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHgxID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMubGVmdCwgYXhpc1dpZHRoKSAtIGF4aXNXaWR0aCAvIDI7XG4gICAgICB4MiA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLnJpZ2h0LCBsYXN0TGluZVdpZHRoKSArIGxhc3RMaW5lV2lkdGggLyAyO1xuICAgICAgeTEgPSB5MiA9IGJvcmRlclZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB5MSA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLnRvcCwgYXhpc1dpZHRoKSAtIGF4aXNXaWR0aCAvIDI7XG4gICAgICB5MiA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLmJvdHRvbSwgbGFzdExpbmVXaWR0aCkgKyBsYXN0TGluZVdpZHRoIC8gMjtcbiAgICAgIHgxID0geDIgPSBib3JkZXJWYWx1ZTtcbiAgICB9XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyT3B0cy53aWR0aDtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBib3JkZXJPcHRzLmNvbG9yO1xuXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcbiAgICBjdHgubGluZVRvKHgyLCB5Mik7XG4gICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3TGFiZWxzKGNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IG9wdGlvblRpY2tzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuXG4gICAgaWYgKCFvcHRpb25UaWNrcy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG5cbiAgICBjb25zdCBhcmVhID0gdGhpcy5fY29tcHV0ZUxhYmVsQXJlYSgpO1xuICAgIGlmIChhcmVhKSB7XG4gICAgICBjbGlwQXJlYShjdHgsIGFyZWEpO1xuICAgIH1cblxuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5nZXRMYWJlbEl0ZW1zKGNoYXJ0QXJlYSk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICBjb25zdCByZW5kZXJUZXh0T3B0aW9ucyA9IGl0ZW0ub3B0aW9ucztcbiAgICAgIGNvbnN0IHRpY2tGb250ID0gaXRlbS5mb250O1xuICAgICAgY29uc3QgbGFiZWwgPSBpdGVtLmxhYmVsO1xuICAgICAgY29uc3QgeSA9IGl0ZW0udGV4dE9mZnNldDtcbiAgICAgIHJlbmRlclRleHQoY3R4LCBsYWJlbCwgMCwgeSwgdGlja0ZvbnQsIHJlbmRlclRleHRPcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoYXJlYSkge1xuICAgICAgdW5jbGlwQXJlYShjdHgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3VGl0bGUoKSB7XG4gICAgY29uc3Qge2N0eCwgb3B0aW9uczoge3Bvc2l0aW9uLCB0aXRsZSwgcmV2ZXJzZX19ID0gdGhpcztcblxuICAgIGlmICghdGl0bGUuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGZvbnQgPSB0b0ZvbnQodGl0bGUuZm9udCk7XG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyh0aXRsZS5wYWRkaW5nKTtcbiAgICBjb25zdCBhbGlnbiA9IHRpdGxlLmFsaWduO1xuICAgIGxldCBvZmZzZXQgPSBmb250LmxpbmVIZWlnaHQgLyAyO1xuXG4gICAgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJyB8fCBwb3NpdGlvbiA9PT0gJ2NlbnRlcicgfHwgaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICBvZmZzZXQgKz0gcGFkZGluZy5ib3R0b207XG4gICAgICBpZiAoaXNBcnJheSh0aXRsZS50ZXh0KSkge1xuICAgICAgICBvZmZzZXQgKz0gZm9udC5saW5lSGVpZ2h0ICogKHRpdGxlLnRleHQubGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldCArPSBwYWRkaW5nLnRvcDtcbiAgICB9XG5cbiAgICBjb25zdCB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn0gPSB0aXRsZUFyZ3ModGhpcywgb2Zmc2V0LCBwb3NpdGlvbiwgYWxpZ24pO1xuXG4gICAgcmVuZGVyVGV4dChjdHgsIHRpdGxlLnRleHQsIDAsIDAsIGZvbnQsIHtcbiAgICAgIGNvbG9yOiB0aXRsZS5jb2xvcixcbiAgICAgIG1heFdpZHRoLFxuICAgICAgcm90YXRpb24sXG4gICAgICB0ZXh0QWxpZ246IHRpdGxlQWxpZ24oYWxpZ24sIHBvc2l0aW9uLCByZXZlcnNlKSxcbiAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZScsXG4gICAgICB0cmFuc2xhdGlvbjogW3RpdGxlWCwgdGl0bGVZXSxcbiAgICB9KTtcbiAgfVxuXG4gIGRyYXcoY2hhcnRBcmVhKSB7XG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZHJhd0JhY2tncm91bmQoKTtcbiAgICB0aGlzLmRyYXdHcmlkKGNoYXJ0QXJlYSk7XG4gICAgdGhpcy5kcmF3Qm9yZGVyKCk7XG4gICAgdGhpcy5kcmF3VGl0bGUoKTtcbiAgICB0aGlzLmRyYXdMYWJlbHMoY2hhcnRBcmVhKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtvYmplY3RbXX1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9sYXllcnMoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0eiA9IG9wdHMudGlja3MgJiYgb3B0cy50aWNrcy56IHx8IDA7XG4gICAgY29uc3QgZ3ogPSB2YWx1ZU9yRGVmYXVsdChvcHRzLmdyaWQgJiYgb3B0cy5ncmlkLnosIC0xKTtcbiAgICBjb25zdCBieiA9IHZhbHVlT3JEZWZhdWx0KG9wdHMuYm9yZGVyICYmIG9wdHMuYm9yZGVyLnosIDApO1xuXG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSB8fCB0aGlzLmRyYXcgIT09IFNjYWxlLnByb3RvdHlwZS5kcmF3KSB7XG4gICAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5OiBkcmF3IGhhcyBiZWVuIG92ZXJyaWRkZW4gYnkgY3VzdG9tIHNjYWxlXG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgejogdHosXG4gICAgICAgIGRyYXc6IChjaGFydEFyZWEpID0+IHtcbiAgICAgICAgICB0aGlzLmRyYXcoY2hhcnRBcmVhKTtcbiAgICAgICAgfVxuICAgICAgfV07XG4gICAgfVxuXG4gICAgcmV0dXJuIFt7XG4gICAgICB6OiBneixcbiAgICAgIGRyYXc6IChjaGFydEFyZWEpID0+IHtcbiAgICAgICAgdGhpcy5kcmF3QmFja2dyb3VuZCgpO1xuICAgICAgICB0aGlzLmRyYXdHcmlkKGNoYXJ0QXJlYSk7XG4gICAgICAgIHRoaXMuZHJhd1RpdGxlKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgejogYnosXG4gICAgICBkcmF3OiAoKSA9PiB7XG4gICAgICAgIHRoaXMuZHJhd0JvcmRlcigpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHo6IHR6LFxuICAgICAgZHJhdzogKGNoYXJ0QXJlYSkgPT4ge1xuICAgICAgICB0aGlzLmRyYXdMYWJlbHMoY2hhcnRBcmVhKTtcbiAgICAgIH1cbiAgICB9XTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHZpc2libGUgZGF0YXNldCBtZXRhcyB0aGF0IGFyZSBhdHRhY2hlZCB0byB0aGlzIHNjYWxlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gLSBpZiBzcGVjaWZpZWQsIGFsc28gZmlsdGVyIGJ5IGRhdGFzZXQgdHlwZVxuXHQgKiBAcmV0dXJuIHtvYmplY3RbXX1cblx0ICovXG4gIGdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHR5cGUpIHtcbiAgICBjb25zdCBtZXRhcyA9IHRoaXMuY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGNvbnN0IGF4aXNJRCA9IHRoaXMuYXhpcyArICdBeGlzSUQnO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGFzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3QgbWV0YSA9IG1ldGFzW2ldO1xuICAgICAgaWYgKG1ldGFbYXhpc0lEXSA9PT0gdGhpcy5pZCAmJiAoIXR5cGUgfHwgbWV0YS50eXBlID09PSB0eXBlKSkge1xuICAgICAgICByZXN1bHQucHVzaChtZXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcblx0ICogQHJldHVybiB7b2JqZWN0fVxuXHQgKiBAcHJvdGVjdGVkXG4gXHQgKi9cbiAgX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoaW5kZXgpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGluZGV4KSk7XG4gICAgcmV0dXJuIHRvRm9udChvcHRzLmZvbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9tYXhEaWdpdHMoKSB7XG4gICAgY29uc3QgZm9udFNpemUgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKDApLmxpbmVIZWlnaHQ7XG4gICAgcmV0dXJuICh0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGhpcy53aWR0aCA6IHRoaXMuaGVpZ2h0KSAvIGZvbnRTaXplO1xuICB9XG59XG4iLCAiaW1wb3J0IHttZXJnZX0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQgZGVmYXVsdHMsIHtvdmVycmlkZXN9IGZyb20gJy4vY29yZS5kZWZhdWx0cy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge3tpZDogc3RyaW5nLCBkZWZhdWx0czogYW55LCBvdmVycmlkZXM/OiBhbnksIGRlZmF1bHRSb3V0ZXM6IGFueX19IElDaGFydENvbXBvbmVudFxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFR5cGVkUmVnaXN0cnkge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBzY29wZSwgb3ZlcnJpZGUpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB0aGlzLm92ZXJyaWRlID0gb3ZlcnJpZGU7XG4gICAgdGhpcy5pdGVtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cblxuICBpc0ZvclR5cGUodHlwZSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YuY2FsbCh0aGlzLnR5cGUucHJvdG90eXBlLCB0eXBlLnByb3RvdHlwZSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtJQ2hhcnRDb21wb25lbnR9IGl0ZW1cblx0ICogQHJldHVybnMge3N0cmluZ30gVGhlIHNjb3BlIHdoZXJlIGl0ZW1zIGRlZmF1bHRzIHdlcmUgcmVnaXN0ZXJlZCB0by5cblx0ICovXG4gIHJlZ2lzdGVyKGl0ZW0pIHtcbiAgICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihpdGVtKTtcbiAgICBsZXQgcGFyZW50U2NvcGU7XG5cbiAgICBpZiAoaXNJQ2hhcnRDb21wb25lbnQocHJvdG8pKSB7XG4gICAgICAvLyBNYWtlIHN1cmUgdGhlIHBhcmVudCBpcyByZWdpc3RlcmVkIGFuZCBub3RlIHRoZSBzY29wZSB3aGVyZSBpdHMgZGVmYXVsdHMgYXJlLlxuICAgICAgcGFyZW50U2NvcGUgPSB0aGlzLnJlZ2lzdGVyKHByb3RvKTtcbiAgICB9XG5cbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgY29uc3QgaWQgPSBpdGVtLmlkO1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZSArICcuJyArIGlkO1xuXG4gICAgaWYgKCFpZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbGFzcyBkb2VzIG5vdCBoYXZlIGlkOiAnICsgaXRlbSk7XG4gICAgfVxuXG4gICAgaWYgKGlkIGluIGl0ZW1zKSB7XG4gICAgICAvLyBhbHJlYWR5IHJlZ2lzdGVyZWRcbiAgICAgIHJldHVybiBzY29wZTtcbiAgICB9XG5cbiAgICBpdGVtc1tpZF0gPSBpdGVtO1xuICAgIHJlZ2lzdGVyRGVmYXVsdHMoaXRlbSwgc2NvcGUsIHBhcmVudFNjb3BlKTtcbiAgICBpZiAodGhpcy5vdmVycmlkZSkge1xuICAgICAgZGVmYXVsdHMub3ZlcnJpZGUoaXRlbS5pZCwgaXRlbS5vdmVycmlkZXMpO1xuICAgIH1cblxuICAgIHJldHVybiBzY29wZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWRcblx0ICogQHJldHVybnMge29iamVjdD99XG5cdCAqL1xuICBnZXQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtc1tpZF07XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtJQ2hhcnRDb21wb25lbnR9IGl0ZW1cblx0ICovXG4gIHVucmVnaXN0ZXIoaXRlbSkge1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5pdGVtcztcbiAgICBjb25zdCBpZCA9IGl0ZW0uaWQ7XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzLnNjb3BlO1xuXG4gICAgaWYgKGlkIGluIGl0ZW1zKSB7XG4gICAgICBkZWxldGUgaXRlbXNbaWRdO1xuICAgIH1cblxuICAgIGlmIChzY29wZSAmJiBpZCBpbiBkZWZhdWx0c1tzY29wZV0pIHtcbiAgICAgIGRlbGV0ZSBkZWZhdWx0c1tzY29wZV1baWRdO1xuICAgICAgaWYgKHRoaXMub3ZlcnJpZGUpIHtcbiAgICAgICAgZGVsZXRlIG92ZXJyaWRlc1tpZF07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdHMoaXRlbSwgc2NvcGUsIHBhcmVudFNjb3BlKSB7XG4gIC8vIEluaGVyaXQgdGhlIHBhcmVudCdzIGRlZmF1bHRzIGFuZCBrZWVwIGV4aXN0aW5nIGRlZmF1bHRzXG4gIGNvbnN0IGl0ZW1EZWZhdWx0cyA9IG1lcmdlKE9iamVjdC5jcmVhdGUobnVsbCksIFtcbiAgICBwYXJlbnRTY29wZSA/IGRlZmF1bHRzLmdldChwYXJlbnRTY29wZSkgOiB7fSxcbiAgICBkZWZhdWx0cy5nZXQoc2NvcGUpLFxuICAgIGl0ZW0uZGVmYXVsdHNcbiAgXSk7XG5cbiAgZGVmYXVsdHMuc2V0KHNjb3BlLCBpdGVtRGVmYXVsdHMpO1xuXG4gIGlmIChpdGVtLmRlZmF1bHRSb3V0ZXMpIHtcbiAgICByb3V0ZURlZmF1bHRzKHNjb3BlLCBpdGVtLmRlZmF1bHRSb3V0ZXMpO1xuICB9XG5cbiAgaWYgKGl0ZW0uZGVzY3JpcHRvcnMpIHtcbiAgICBkZWZhdWx0cy5kZXNjcmliZShzY29wZSwgaXRlbS5kZXNjcmlwdG9ycyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcm91dGVEZWZhdWx0cyhzY29wZSwgcm91dGVzKSB7XG4gIE9iamVjdC5rZXlzKHJvdXRlcykuZm9yRWFjaChwcm9wZXJ0eSA9PiB7XG4gICAgY29uc3QgcHJvcGVydHlQYXJ0cyA9IHByb3BlcnR5LnNwbGl0KCcuJyk7XG4gICAgY29uc3Qgc291cmNlTmFtZSA9IHByb3BlcnR5UGFydHMucG9wKCk7XG4gICAgY29uc3Qgc291cmNlU2NvcGUgPSBbc2NvcGVdLmNvbmNhdChwcm9wZXJ0eVBhcnRzKS5qb2luKCcuJyk7XG4gICAgY29uc3QgcGFydHMgPSByb3V0ZXNbcHJvcGVydHldLnNwbGl0KCcuJyk7XG4gICAgY29uc3QgdGFyZ2V0TmFtZSA9IHBhcnRzLnBvcCgpO1xuICAgIGNvbnN0IHRhcmdldFNjb3BlID0gcGFydHMuam9pbignLicpO1xuICAgIGRlZmF1bHRzLnJvdXRlKHNvdXJjZVNjb3BlLCBzb3VyY2VOYW1lLCB0YXJnZXRTY29wZSwgdGFyZ2V0TmFtZSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc0lDaGFydENvbXBvbmVudChwcm90bykge1xuICByZXR1cm4gJ2lkJyBpbiBwcm90byAmJiAnZGVmYXVsdHMnIGluIHByb3RvO1xufVxuIiwgImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IFNjYWxlIGZyb20gJy4vY29yZS5zY2FsZS5qcyc7XG5pbXBvcnQgVHlwZWRSZWdpc3RyeSBmcm9tICcuL2NvcmUudHlwZWRSZWdpc3RyeS5qcyc7XG5pbXBvcnQge2VhY2gsIGNhbGxiYWNrIGFzIGNhbGwsIF9jYXBpdGFsaXplfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5cbi8qKlxuICogUGxlYXNlIHVzZSB0aGUgbW9kdWxlJ3MgZGVmYXVsdCBleHBvcnQgd2hpY2ggcHJvdmlkZXMgYSBzaW5nbGV0b24gaW5zdGFuY2VcbiAqIE5vdGU6IGNsYXNzIGlzIGV4cG9ydGVkIGZvciB0eXBlZG9jXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWdpc3RyeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY29udHJvbGxlcnMgPSBuZXcgVHlwZWRSZWdpc3RyeShEYXRhc2V0Q29udHJvbGxlciwgJ2RhdGFzZXRzJywgdHJ1ZSk7XG4gICAgdGhpcy5lbGVtZW50cyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KEVsZW1lbnQsICdlbGVtZW50cycpO1xuICAgIHRoaXMucGx1Z2lucyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KE9iamVjdCwgJ3BsdWdpbnMnKTtcbiAgICB0aGlzLnNjYWxlcyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KFNjYWxlLCAnc2NhbGVzJyk7XG4gICAgLy8gT3JkZXIgaXMgaW1wb3J0YW50LCBTY2FsZSBoYXMgRWxlbWVudCBpbiBwcm90b3R5cGUgY2hhaW4sXG4gICAgLy8gc28gU2NhbGVzIG11c3QgYmUgYmVmb3JlIEVsZW1lbnRzLiBQbHVnaW5zIGFyZSBhIGZhbGxiYWNrLCBzbyBub3QgbGlzdGVkIGhlcmUuXG4gICAgdGhpcy5fdHlwZWRSZWdpc3RyaWVzID0gW3RoaXMuY29udHJvbGxlcnMsIHRoaXMuc2NhbGVzLCB0aGlzLmVsZW1lbnRzXTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3Ncblx0ICovXG4gIGFkZCguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzKTtcbiAgfVxuXG4gIHJlbW92ZSguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLnR5cGVvZiBEYXRhc2V0Q29udHJvbGxlcn0gYXJnc1xuXHQgKi9cbiAgYWRkQ29udHJvbGxlcnMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5jb250cm9sbGVycyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtICB7Li4udHlwZW9mIEVsZW1lbnR9IGFyZ3Ncblx0ICovXG4gIGFkZEVsZW1lbnRzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMuZWxlbWVudHMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLmFueX0gYXJnc1xuXHQgKi9cbiAgYWRkUGx1Z2lucyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLnBsdWdpbnMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLnR5cGVvZiBTY2FsZX0gYXJnc1xuXHQgKi9cbiAgYWRkU2NhbGVzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMuc2NhbGVzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWRcblx0ICogQHJldHVybnMge3R5cGVvZiBEYXRhc2V0Q29udHJvbGxlcn1cblx0ICovXG4gIGdldENvbnRyb2xsZXIoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLmNvbnRyb2xsZXJzLCAnY29udHJvbGxlcicpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuXHQgKiBAcmV0dXJucyB7dHlwZW9mIEVsZW1lbnR9XG5cdCAqL1xuICBnZXRFbGVtZW50KGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5lbGVtZW50cywgJ2VsZW1lbnQnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWRcblx0ICogQHJldHVybnMge29iamVjdH1cblx0ICovXG4gIGdldFBsdWdpbihpZCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoaWQsIHRoaXMucGx1Z2lucywgJ3BsdWdpbicpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuXHQgKiBAcmV0dXJucyB7dHlwZW9mIFNjYWxlfVxuXHQgKi9cbiAgZ2V0U2NhbGUoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLnNjYWxlcywgJ3NjYWxlJyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtICB7Li4udHlwZW9mIERhdGFzZXRDb250cm9sbGVyfSBhcmdzXG5cdCAqL1xuICByZW1vdmVDb250cm9sbGVycyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMuY29udHJvbGxlcnMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLnR5cGVvZiBFbGVtZW50fSBhcmdzXG5cdCAqL1xuICByZW1vdmVFbGVtZW50cyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMuZWxlbWVudHMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLmFueX0gYXJnc1xuXHQgKi9cbiAgcmVtb3ZlUGx1Z2lucyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMucGx1Z2lucyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtICB7Li4udHlwZW9mIFNjYWxlfSBhcmdzXG5cdCAqL1xuICByZW1vdmVTY2FsZXMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLnNjYWxlcyk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9lYWNoKG1ldGhvZCwgYXJncywgdHlwZWRSZWdpc3RyeSkge1xuICAgIFsuLi5hcmdzXS5mb3JFYWNoKGFyZyA9PiB7XG4gICAgICBjb25zdCByZWcgPSB0eXBlZFJlZ2lzdHJ5IHx8IHRoaXMuX2dldFJlZ2lzdHJ5Rm9yVHlwZShhcmcpO1xuICAgICAgaWYgKHR5cGVkUmVnaXN0cnkgfHwgcmVnLmlzRm9yVHlwZShhcmcpIHx8IChyZWcgPT09IHRoaXMucGx1Z2lucyAmJiBhcmcuaWQpKSB7XG4gICAgICAgIHRoaXMuX2V4ZWMobWV0aG9kLCByZWcsIGFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBIYW5kbGUgbG9vcGFibGUgYXJnc1xuICAgICAgICAvLyBVc2UgY2FzZTpcbiAgICAgICAgLy8gIGltcG9ydCAqIGFzIHBsdWdpbnMgZnJvbSAnLi9wbHVnaW5zLmpzJztcbiAgICAgICAgLy8gIENoYXJ0LnJlZ2lzdGVyKHBsdWdpbnMpO1xuICAgICAgICBlYWNoKGFyZywgaXRlbSA9PiB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG1peGVkIHR5cGVzIGluIHRoZSBsb29wYWJsZSwgbWFrZSBzdXJlIHRob3NlIGFyZVxuICAgICAgICAgIC8vIHJlZ2lzdGVyZWQgaW4gY29ycmVjdCByZWdpc3RyeVxuICAgICAgICAgIC8vIFVzZSBjYXNlOiAodHJlZW1hcCBleHBvcnRpbmcgY29udHJvbGxlciwgZWxlbWVudHMgZXRjKVxuICAgICAgICAgIC8vICBpbXBvcnQgKiBhcyB0cmVlbWFwIGZyb20gJ2NoYXJ0anMtY2hhcnQtdHJlZW1hcC5qcyc7XG4gICAgICAgICAgLy8gIENoYXJ0LnJlZ2lzdGVyKHRyZWVtYXApO1xuXG4gICAgICAgICAgY29uc3QgaXRlbVJlZyA9IHR5cGVkUmVnaXN0cnkgfHwgdGhpcy5fZ2V0UmVnaXN0cnlGb3JUeXBlKGl0ZW0pO1xuICAgICAgICAgIHRoaXMuX2V4ZWMobWV0aG9kLCBpdGVtUmVnLCBpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9leGVjKG1ldGhvZCwgcmVnaXN0cnksIGNvbXBvbmVudCkge1xuICAgIGNvbnN0IGNhbWVsTWV0aG9kID0gX2NhcGl0YWxpemUobWV0aG9kKTtcbiAgICBjYWxsKGNvbXBvbmVudFsnYmVmb3JlJyArIGNhbWVsTWV0aG9kXSwgW10sIGNvbXBvbmVudCk7IC8vIGJlZm9yZVJlZ2lzdGVyIC8gYmVmb3JlVW5yZWdpc3RlclxuICAgIHJlZ2lzdHJ5W21ldGhvZF0oY29tcG9uZW50KTtcbiAgICBjYWxsKGNvbXBvbmVudFsnYWZ0ZXInICsgY2FtZWxNZXRob2RdLCBbXSwgY29tcG9uZW50KTsgLy8gYWZ0ZXJSZWdpc3RlciAvIGFmdGVyVW5yZWdpc3RlclxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0UmVnaXN0cnlGb3JUeXBlKHR5cGUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3R5cGVkUmVnaXN0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVnID0gdGhpcy5fdHlwZWRSZWdpc3RyaWVzW2ldO1xuICAgICAgaWYgKHJlZy5pc0ZvclR5cGUodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHJlZztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcGx1Z2lucyBpcyB0aGUgZmFsbGJhY2sgcmVnaXN0cnlcbiAgICByZXR1cm4gdGhpcy5wbHVnaW5zO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0KGlkLCB0eXBlZFJlZ2lzdHJ5LCB0eXBlKSB7XG4gICAgY29uc3QgaXRlbSA9IHR5cGVkUmVnaXN0cnkuZ2V0KGlkKTtcbiAgICBpZiAoaXRlbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGlkICsgJ1wiIGlzIG5vdCBhIHJlZ2lzdGVyZWQgJyArIHR5cGUgKyAnLicpO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbTtcbiAgfVxuXG59XG5cbi8vIHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGRlZmF1bHQgLyogI19fUFVSRV9fICovIG5ldyBSZWdpc3RyeSgpO1xuIiwgImltcG9ydCByZWdpc3RyeSBmcm9tICcuL2NvcmUucmVnaXN0cnkuanMnO1xuaW1wb3J0IHtjYWxsYmFjayBhcyBjYWxsQ2FsbGJhY2ssIGlzTnVsbE9yVW5kZWYsIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5DaGFydEV2ZW50IH0gQ2hhcnRFdmVudFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3BsdWdpbnMvcGx1Z2luLnRvb2x0aXAuanMnKS5kZWZhdWx0IH0gVG9vbHRpcFxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIGZpbHRlckNhbGxiYWNrXG4gKiBAcGFyYW0ge3twbHVnaW46IG9iamVjdCwgb3B0aW9uczogb2JqZWN0fX0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXhdXG4gKiBAcGFyYW0ge2FycmF5fSBbYXJyYXldXG4gKiBAcGFyYW0ge29iamVjdH0gW3RoaXNBcmddXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGx1Z2luU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2luaXQgPSBbXTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBDYWxscyBlbmFibGVkIHBsdWdpbnMgZm9yIGBjaGFydGAgb24gdGhlIHNwZWNpZmllZCBob29rIGFuZCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuXHQgKiBUaGlzIG1ldGhvZCBpbW1lZGlhdGVseSByZXR1cm5zIGFzIHNvb24gYXMgYSBwbHVnaW4gZXhwbGljaXRseSByZXR1cm5zIGZhbHNlLiBUaGVcblx0ICogcmV0dXJuZWQgdmFsdWUgY2FuIGJlIHVzZWQsIGZvciBpbnN0YW5jZSwgdG8gaW50ZXJydXB0IHRoZSBjdXJyZW50IGFjdGlvbi5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBUaGUgY2hhcnQgaW5zdGFuY2UgZm9yIHdoaWNoIHBsdWdpbnMgc2hvdWxkIGJlIGNhbGxlZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGhvb2sgLSBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luIG1ldGhvZCB0byBjYWxsIChlLmcuICdiZWZvcmVVcGRhdGUnKS5cblx0ICogQHBhcmFtIHtvYmplY3R9IFthcmdzXSAtIEV4dHJhIGFyZ3VtZW50cyB0byBhcHBseSB0byB0aGUgaG9vayBjYWxsLlxuICAgKiBAcGFyYW0ge2ZpbHRlckNhbGxiYWNrfSBbZmlsdGVyXSAtIEZpbHRlcmluZyBmdW5jdGlvbiBmb3IgbGltaXRpbmcgd2hpY2ggcGx1Z2lucyBhcmUgbm90aWZpZWRcblx0ICogQHJldHVybnMge2Jvb2xlYW59IGZhbHNlIGlmIGFueSBvZiB0aGUgcGx1Z2lucyByZXR1cm4gZmFsc2UsIGVsc2UgcmV0dXJucyB0cnVlLlxuXHQgKi9cbiAgbm90aWZ5KGNoYXJ0LCBob29rLCBhcmdzLCBmaWx0ZXIpIHtcbiAgICBpZiAoaG9vayA9PT0gJ2JlZm9yZUluaXQnKSB7XG4gICAgICB0aGlzLl9pbml0ID0gdGhpcy5fY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIHRydWUpO1xuICAgICAgdGhpcy5fbm90aWZ5KHRoaXMuX2luaXQsIGNoYXJ0LCAnaW5zdGFsbCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gZmlsdGVyID8gdGhpcy5fZGVzY3JpcHRvcnMoY2hhcnQpLmZpbHRlcihmaWx0ZXIpIDogdGhpcy5fZGVzY3JpcHRvcnMoY2hhcnQpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX25vdGlmeShkZXNjcmlwdG9ycywgY2hhcnQsIGhvb2ssIGFyZ3MpO1xuXG4gICAgaWYgKGhvb2sgPT09ICdhZnRlckRlc3Ryb3knKSB7XG4gICAgICB0aGlzLl9ub3RpZnkoZGVzY3JpcHRvcnMsIGNoYXJ0LCAnc3RvcCcpO1xuICAgICAgdGhpcy5fbm90aWZ5KHRoaXMuX2luaXQsIGNoYXJ0LCAndW5pbnN0YWxsJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9ub3RpZnkoZGVzY3JpcHRvcnMsIGNoYXJ0LCBob29rLCBhcmdzKSB7XG4gICAgYXJncyA9IGFyZ3MgfHwge307XG4gICAgZm9yIChjb25zdCBkZXNjcmlwdG9yIG9mIGRlc2NyaXB0b3JzKSB7XG4gICAgICBjb25zdCBwbHVnaW4gPSBkZXNjcmlwdG9yLnBsdWdpbjtcbiAgICAgIGNvbnN0IG1ldGhvZCA9IHBsdWdpbltob29rXTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IFtjaGFydCwgYXJncywgZGVzY3JpcHRvci5vcHRpb25zXTtcbiAgICAgIGlmIChjYWxsQ2FsbGJhY2sobWV0aG9kLCBwYXJhbXMsIHBsdWdpbikgPT09IGZhbHNlICYmIGFyZ3MuY2FuY2VsYWJsZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpbnZhbGlkYXRlKCkge1xuICAgIC8vIFdoZW4gcGx1Z2lucyBhcmUgcmVnaXN0ZXJlZCwgdGhlcmUgaXMgdGhlIHBvc3NpYmlsaXR5IG9mIGEgZG91YmxlXG4gICAgLy8gaW52YWxpZGF0ZSBzaXR1YXRpb24uIEluIHRoaXMgY2FzZSwgd2Ugb25seSB3YW50IHRvIGludmFsaWRhdGUgb25jZS5cbiAgICAvLyBJZiB3ZSBpbnZhbGlkYXRlIG11bHRpcGxlIHRpbWVzLCB0aGUgYF9vbGRDYWNoZWAgaXMgbG9zdCBhbmQgYWxsIG9mIHRoZVxuICAgIC8vIHBsdWdpbnMgYXJlIHJlc3RhcnRlZCB3aXRob3V0IGJlaW5nIGNvcnJlY3RseSBzdG9wcGVkLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvODE0N1xuICAgIGlmICghaXNOdWxsT3JVbmRlZih0aGlzLl9jYWNoZSkpIHtcbiAgICAgIHRoaXMuX29sZENhY2hlID0gdGhpcy5fY2FjaGU7XG4gICAgICB0aGlzLl9jYWNoZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kZXNjcmlwdG9ycyhjaGFydCkge1xuICAgIGlmICh0aGlzLl9jYWNoZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlO1xuICAgIH1cblxuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gdGhpcy5fY2FjaGUgPSB0aGlzLl9jcmVhdGVEZXNjcmlwdG9ycyhjaGFydCk7XG5cbiAgICB0aGlzLl9ub3RpZnlTdGF0ZUNoYW5nZXMoY2hhcnQpO1xuXG4gICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xuICB9XG5cbiAgX2NyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCBhbGwpIHtcbiAgICBjb25zdCBjb25maWcgPSBjaGFydCAmJiBjaGFydC5jb25maWc7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHZhbHVlT3JEZWZhdWx0KGNvbmZpZy5vcHRpb25zICYmIGNvbmZpZy5vcHRpb25zLnBsdWdpbnMsIHt9KTtcbiAgICBjb25zdCBwbHVnaW5zID0gYWxsUGx1Z2lucyhjb25maWcpO1xuICAgIC8vIG9wdGlvbnMgPT09IGZhbHNlID0+IGFsbCBwbHVnaW5zIGFyZSBkaXNhYmxlZFxuICAgIHJldHVybiBvcHRpb25zID09PSBmYWxzZSAmJiAhYWxsID8gW10gOiBjcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwgcGx1Z2lucywgb3B0aW9ucywgYWxsKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX25vdGlmeVN0YXRlQ2hhbmdlcyhjaGFydCkge1xuICAgIGNvbnN0IHByZXZpb3VzRGVzY3JpcHRvcnMgPSB0aGlzLl9vbGRDYWNoZSB8fCBbXTtcbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IHRoaXMuX2NhY2hlO1xuICAgIGNvbnN0IGRpZmYgPSAoYSwgYikgPT4gYS5maWx0ZXIoeCA9PiAhYi5zb21lKHkgPT4geC5wbHVnaW4uaWQgPT09IHkucGx1Z2luLmlkKSk7XG4gICAgdGhpcy5fbm90aWZ5KGRpZmYocHJldmlvdXNEZXNjcmlwdG9ycywgZGVzY3JpcHRvcnMpLCBjaGFydCwgJ3N0b3AnKTtcbiAgICB0aGlzLl9ub3RpZnkoZGlmZihkZXNjcmlwdG9ycywgcHJldmlvdXNEZXNjcmlwdG9ycyksIGNoYXJ0LCAnc3RhcnQnKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2NvcmUuY29uZmlnLmpzJykuZGVmYXVsdH0gY29uZmlnXG4gKi9cbmZ1bmN0aW9uIGFsbFBsdWdpbnMoY29uZmlnKSB7XG4gIGNvbnN0IGxvY2FsSWRzID0ge307XG4gIGNvbnN0IHBsdWdpbnMgPSBbXTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHJlZ2lzdHJ5LnBsdWdpbnMuaXRlbXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBwbHVnaW5zLnB1c2gocmVnaXN0cnkuZ2V0UGx1Z2luKGtleXNbaV0pKTtcbiAgfVxuXG4gIGNvbnN0IGxvY2FsID0gY29uZmlnLnBsdWdpbnMgfHwgW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwbHVnaW4gPSBsb2NhbFtpXTtcblxuICAgIGlmIChwbHVnaW5zLmluZGV4T2YocGx1Z2luKSA9PT0gLTEpIHtcbiAgICAgIHBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgICAgbG9jYWxJZHNbcGx1Z2luLmlkXSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtwbHVnaW5zLCBsb2NhbElkc307XG59XG5cbmZ1bmN0aW9uIGdldE9wdHMob3B0aW9ucywgYWxsKSB7XG4gIGlmICghYWxsICYmIG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKG9wdGlvbnMgPT09IHRydWUpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCB7cGx1Z2lucywgbG9jYWxJZHN9LCBvcHRpb25zLCBhbGwpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IGNvbnRleHQgPSBjaGFydC5nZXRDb250ZXh0KCk7XG5cbiAgZm9yIChjb25zdCBwbHVnaW4gb2YgcGx1Z2lucykge1xuICAgIGNvbnN0IGlkID0gcGx1Z2luLmlkO1xuICAgIGNvbnN0IG9wdHMgPSBnZXRPcHRzKG9wdGlvbnNbaWRdLCBhbGwpO1xuICAgIGlmIChvcHRzID09PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2goe1xuICAgICAgcGx1Z2luLFxuICAgICAgb3B0aW9uczogcGx1Z2luT3B0cyhjaGFydC5jb25maWcsIHtwbHVnaW4sIGxvY2FsOiBsb2NhbElkc1tpZF19LCBvcHRzLCBjb250ZXh0KVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGx1Z2luT3B0cyhjb25maWcsIHtwbHVnaW4sIGxvY2FsfSwgb3B0cywgY29udGV4dCkge1xuICBjb25zdCBrZXlzID0gY29uZmlnLnBsdWdpblNjb3BlS2V5cyhwbHVnaW4pO1xuICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKG9wdHMsIGtleXMpO1xuICBpZiAobG9jYWwgJiYgcGx1Z2luLmRlZmF1bHRzKSB7XG4gICAgLy8gbWFrZSBzdXJlIHBsdWdpbiBkZWZhdWx0cyBhcmUgaW4gc2NvcGVzIGZvciBsb2NhbCAobm90IHJlZ2lzdGVyZWQpIHBsdWdpbnNcbiAgICBzY29wZXMucHVzaChwbHVnaW4uZGVmYXVsdHMpO1xuICB9XG4gIHJldHVybiBjb25maWcuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBjb250ZXh0LCBbJyddLCB7XG4gICAgLy8gVGhlc2UgYXJlIGp1c3QgZGVmYXVsdHMgdGhhdCBwbHVnaW5zIGNhbiBvdmVycmlkZVxuICAgIHNjcmlwdGFibGU6IGZhbHNlLFxuICAgIGluZGV4YWJsZTogZmFsc2UsXG4gICAgYWxsS2V5czogdHJ1ZVxuICB9KTtcbn1cbiIsICJpbXBvcnQgZGVmYXVsdHMsIHtvdmVycmlkZXMsIGRlc2NyaXB0b3JzfSBmcm9tICcuL2NvcmUuZGVmYXVsdHMuanMnO1xuaW1wb3J0IHttZXJnZUlmLCByZXNvbHZlT2JqZWN0S2V5LCBpc0FycmF5LCBpc0Z1bmN0aW9uLCB2YWx1ZU9yRGVmYXVsdCwgaXNPYmplY3R9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7X2F0dGFjaENvbnRleHQsIF9jcmVhdGVSZXNvbHZlciwgX2Rlc2NyaXB0b3JzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29uZmlnLmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEluZGV4QXhpcyh0eXBlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGRhdGFzZXREZWZhdWx0cyA9IGRlZmF1bHRzLmRhdGFzZXRzW3R5cGVdIHx8IHt9O1xuICBjb25zdCBkYXRhc2V0T3B0aW9ucyA9IChvcHRpb25zLmRhdGFzZXRzIHx8IHt9KVt0eXBlXSB8fCB7fTtcbiAgcmV0dXJuIGRhdGFzZXRPcHRpb25zLmluZGV4QXhpcyB8fCBvcHRpb25zLmluZGV4QXhpcyB8fCBkYXRhc2V0RGVmYXVsdHMuaW5kZXhBeGlzIHx8ICd4Jztcbn1cblxuZnVuY3Rpb24gZ2V0QXhpc0Zyb21EZWZhdWx0U2NhbGVJRChpZCwgaW5kZXhBeGlzKSB7XG4gIGxldCBheGlzID0gaWQ7XG4gIGlmIChpZCA9PT0gJ19pbmRleF8nKSB7XG4gICAgYXhpcyA9IGluZGV4QXhpcztcbiAgfSBlbHNlIGlmIChpZCA9PT0gJ192YWx1ZV8nKSB7XG4gICAgYXhpcyA9IGluZGV4QXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xuICB9XG4gIHJldHVybiBheGlzO1xufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0U2NhbGVJREZyb21BeGlzKGF4aXMsIGluZGV4QXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gaW5kZXhBeGlzID8gJ19pbmRleF8nIDogJ192YWx1ZV8nO1xufVxuXG5mdW5jdGlvbiBpZE1hdGNoZXNBeGlzKGlkKSB7XG4gIGlmIChpZCA9PT0gJ3gnIHx8IGlkID09PSAneScgfHwgaWQgPT09ICdyJykge1xuICAgIHJldHVybiBpZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBheGlzRnJvbVBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgcmV0dXJuICd4JztcbiAgfVxuICBpZiAocG9zaXRpb24gPT09ICdsZWZ0JyB8fCBwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHJldHVybiAneSc7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluZUF4aXMoaWQsIC4uLnNjYWxlT3B0aW9ucykge1xuICBpZiAoaWRNYXRjaGVzQXhpcyhpZCkpIHtcbiAgICByZXR1cm4gaWQ7XG4gIH1cbiAgZm9yIChjb25zdCBvcHRzIG9mIHNjYWxlT3B0aW9ucykge1xuICAgIGNvbnN0IGF4aXMgPSBvcHRzLmF4aXNcbiAgICAgIHx8IGF4aXNGcm9tUG9zaXRpb24ob3B0cy5wb3NpdGlvbilcbiAgICAgIHx8IGlkLmxlbmd0aCA+IDEgJiYgaWRNYXRjaGVzQXhpcyhpZFswXS50b0xvd2VyQ2FzZSgpKTtcbiAgICBpZiAoYXhpcykge1xuICAgICAgcmV0dXJuIGF4aXM7XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGRldGVybWluZSB0eXBlIG9mICcke2lkfScgYXhpcy4gUGxlYXNlIHByb3ZpZGUgJ2F4aXMnIG9yICdwb3NpdGlvbicgb3B0aW9uLmApO1xufVxuXG5mdW5jdGlvbiBnZXRBeGlzRnJvbURhdGFzZXQoaWQsIGF4aXMsIGRhdGFzZXQpIHtcbiAgaWYgKGRhdGFzZXRbYXhpcyArICdBeGlzSUQnXSA9PT0gaWQpIHtcbiAgICByZXR1cm4ge2F4aXN9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJldHJpZXZlQXhpc0Zyb21EYXRhc2V0cyhpZCwgY29uZmlnKSB7XG4gIGlmIChjb25maWcuZGF0YSAmJiBjb25maWcuZGF0YS5kYXRhc2V0cykge1xuICAgIGNvbnN0IGJvdW5kRHMgPSBjb25maWcuZGF0YS5kYXRhc2V0cy5maWx0ZXIoKGQpID0+IGQueEF4aXNJRCA9PT0gaWQgfHwgZC55QXhpc0lEID09PSBpZCk7XG4gICAgaWYgKGJvdW5kRHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZ2V0QXhpc0Zyb21EYXRhc2V0KGlkLCAneCcsIGJvdW5kRHNbMF0pIHx8IGdldEF4aXNGcm9tRGF0YXNldChpZCwgJ3knLCBib3VuZERzWzBdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiBtZXJnZVNjYWxlQ29uZmlnKGNvbmZpZywgb3B0aW9ucykge1xuICBjb25zdCBjaGFydERlZmF1bHRzID0gb3ZlcnJpZGVzW2NvbmZpZy50eXBlXSB8fCB7c2NhbGVzOiB7fX07XG4gIGNvbnN0IGNvbmZpZ1NjYWxlcyA9IG9wdGlvbnMuc2NhbGVzIHx8IHt9O1xuICBjb25zdCBjaGFydEluZGV4QXhpcyA9IGdldEluZGV4QXhpcyhjb25maWcudHlwZSwgb3B0aW9ucyk7XG4gIGNvbnN0IHNjYWxlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy8gRmlyc3QgZmlndXJlIG91dCBmaXJzdCBzY2FsZSBpZCdzIHBlciBheGlzLlxuICBPYmplY3Qua2V5cyhjb25maWdTY2FsZXMpLmZvckVhY2goaWQgPT4ge1xuICAgIGNvbnN0IHNjYWxlQ29uZiA9IGNvbmZpZ1NjYWxlc1tpZF07XG4gICAgaWYgKCFpc09iamVjdChzY2FsZUNvbmYpKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcihgSW52YWxpZCBzY2FsZSBjb25maWd1cmF0aW9uIGZvciBzY2FsZTogJHtpZH1gKTtcbiAgICB9XG4gICAgaWYgKHNjYWxlQ29uZi5fcHJveHkpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLndhcm4oYElnbm9yaW5nIHJlc29sdmVyIHBhc3NlZCBhcyBvcHRpb25zIGZvciBzY2FsZTogJHtpZH1gKTtcbiAgICB9XG4gICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlQ29uZiwgcmV0cmlldmVBeGlzRnJvbURhdGFzZXRzKGlkLCBjb25maWcpLCBkZWZhdWx0cy5zY2FsZXNbc2NhbGVDb25mLnR5cGVdKTtcbiAgICBjb25zdCBkZWZhdWx0SWQgPSBnZXREZWZhdWx0U2NhbGVJREZyb21BeGlzKGF4aXMsIGNoYXJ0SW5kZXhBeGlzKTtcbiAgICBjb25zdCBkZWZhdWx0U2NhbGVPcHRpb25zID0gY2hhcnREZWZhdWx0cy5zY2FsZXMgfHwge307XG4gICAgc2NhbGVzW2lkXSA9IG1lcmdlSWYoT2JqZWN0LmNyZWF0ZShudWxsKSwgW3theGlzfSwgc2NhbGVDb25mLCBkZWZhdWx0U2NhbGVPcHRpb25zW2F4aXNdLCBkZWZhdWx0U2NhbGVPcHRpb25zW2RlZmF1bHRJZF1dKTtcbiAgfSk7XG5cbiAgLy8gVGhlbiBtZXJnZSBkYXRhc2V0IGRlZmF1bHRzIHRvIHNjYWxlIGNvbmZpZ3NcbiAgY29uZmlnLmRhdGEuZGF0YXNldHMuZm9yRWFjaChkYXRhc2V0ID0+IHtcbiAgICBjb25zdCB0eXBlID0gZGF0YXNldC50eXBlIHx8IGNvbmZpZy50eXBlO1xuICAgIGNvbnN0IGluZGV4QXhpcyA9IGRhdGFzZXQuaW5kZXhBeGlzIHx8IGdldEluZGV4QXhpcyh0eXBlLCBvcHRpb25zKTtcbiAgICBjb25zdCBkYXRhc2V0RGVmYXVsdHMgPSBvdmVycmlkZXNbdHlwZV0gfHwge307XG4gICAgY29uc3QgZGVmYXVsdFNjYWxlT3B0aW9ucyA9IGRhdGFzZXREZWZhdWx0cy5zY2FsZXMgfHwge307XG4gICAgT2JqZWN0LmtleXMoZGVmYXVsdFNjYWxlT3B0aW9ucykuZm9yRWFjaChkZWZhdWx0SUQgPT4ge1xuICAgICAgY29uc3QgYXhpcyA9IGdldEF4aXNGcm9tRGVmYXVsdFNjYWxlSUQoZGVmYXVsdElELCBpbmRleEF4aXMpO1xuICAgICAgY29uc3QgaWQgPSBkYXRhc2V0W2F4aXMgKyAnQXhpc0lEJ10gfHwgYXhpcztcbiAgICAgIHNjYWxlc1tpZF0gPSBzY2FsZXNbaWRdIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBtZXJnZUlmKHNjYWxlc1tpZF0sIFt7YXhpc30sIGNvbmZpZ1NjYWxlc1tpZF0sIGRlZmF1bHRTY2FsZU9wdGlvbnNbZGVmYXVsdElEXV0pO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBhcHBseSBzY2FsZSBkZWZhdWx0cywgaWYgbm90IG92ZXJyaWRkZW4gYnkgZGF0YXNldCBkZWZhdWx0c1xuICBPYmplY3Qua2V5cyhzY2FsZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICBjb25zdCBzY2FsZSA9IHNjYWxlc1trZXldO1xuICAgIG1lcmdlSWYoc2NhbGUsIFtkZWZhdWx0cy5zY2FsZXNbc2NhbGUudHlwZV0sIGRlZmF1bHRzLnNjYWxlXSk7XG4gIH0pO1xuXG4gIHJldHVybiBzY2FsZXM7XG59XG5cbmZ1bmN0aW9uIGluaXRPcHRpb25zKGNvbmZpZykge1xuICBjb25zdCBvcHRpb25zID0gY29uZmlnLm9wdGlvbnMgfHwgKGNvbmZpZy5vcHRpb25zID0ge30pO1xuXG4gIG9wdGlvbnMucGx1Z2lucyA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMucGx1Z2lucywge30pO1xuICBvcHRpb25zLnNjYWxlcyA9IG1lcmdlU2NhbGVDb25maWcoY29uZmlnLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEoZGF0YSkge1xuICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgZGF0YS5kYXRhc2V0cyA9IGRhdGEuZGF0YXNldHMgfHwgW107XG4gIGRhdGEubGFiZWxzID0gZGF0YS5sYWJlbHMgfHwgW107XG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBpbml0Q29uZmlnKGNvbmZpZykge1xuICBjb25maWcgPSBjb25maWcgfHwge307XG4gIGNvbmZpZy5kYXRhID0gaW5pdERhdGEoY29uZmlnLmRhdGEpO1xuXG4gIGluaXRPcHRpb25zKGNvbmZpZyk7XG5cbiAgcmV0dXJuIGNvbmZpZztcbn1cblxuY29uc3Qga2V5Q2FjaGUgPSBuZXcgTWFwKCk7XG5jb25zdCBrZXlzQ2FjaGVkID0gbmV3IFNldCgpO1xuXG5mdW5jdGlvbiBjYWNoZWRLZXlzKGNhY2hlS2V5LCBnZW5lcmF0ZSkge1xuICBsZXQga2V5cyA9IGtleUNhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmICgha2V5cykge1xuICAgIGtleXMgPSBnZW5lcmF0ZSgpO1xuICAgIGtleUNhY2hlLnNldChjYWNoZUtleSwga2V5cyk7XG4gICAga2V5c0NhY2hlZC5hZGQoa2V5cyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5cbmNvbnN0IGFkZElmRm91bmQgPSAoc2V0LCBvYmosIGtleSkgPT4ge1xuICBjb25zdCBvcHRzID0gcmVzb2x2ZU9iamVjdEtleShvYmosIGtleSk7XG4gIGlmIChvcHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICBzZXQuYWRkKG9wdHMpO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb25maWcge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLl9jb25maWcgPSBpbml0Q29uZmlnKGNvbmZpZyk7XG4gICAgdGhpcy5fc2NvcGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9yZXNvbHZlckNhY2hlID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgZ2V0IHBsYXRmb3JtKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcucGxhdGZvcm07XG4gIH1cblxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLnR5cGU7XG4gIH1cblxuICBzZXQgdHlwZSh0eXBlKSB7XG4gICAgdGhpcy5fY29uZmlnLnR5cGUgPSB0eXBlO1xuICB9XG5cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5kYXRhO1xuICB9XG5cbiAgc2V0IGRhdGEoZGF0YSkge1xuICAgIHRoaXMuX2NvbmZpZy5kYXRhID0gaW5pdERhdGEoZGF0YSk7XG4gIH1cblxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLm9wdGlvbnM7XG4gIH1cblxuICBzZXQgb3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdGhpcy5fY29uZmlnLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG5cbiAgZ2V0IHBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5wbHVnaW5zO1xuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuX2NvbmZpZztcbiAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcbiAgICBpbml0T3B0aW9ucyhjb25maWcpO1xuICB9XG5cbiAgY2xlYXJDYWNoZSgpIHtcbiAgICB0aGlzLl9zY29wZUNhY2hlLmNsZWFyKCk7XG4gICAgdGhpcy5fcmVzb2x2ZXJDYWNoZS5jbGVhcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9wdGlvbiBzY29wZSBrZXlzIGZvciByZXNvbHZpbmcgZGF0YXNldCBvcHRpb25zLlxuICAgKiBUaGVzZSBrZXlzIGRvIG5vdCBpbmNsdWRlIHRoZSBkYXRhc2V0IGl0c2VsZiwgYmVjYXVzZSBpdCBpcyBub3QgdW5kZXIgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFzZXRUeXBlXG4gICAqIEByZXR1cm4ge3N0cmluZ1tdW119XG4gICAqL1xuICBkYXRhc2V0U2NvcGVLZXlzKGRhdGFzZXRUeXBlKSB7XG4gICAgcmV0dXJuIGNhY2hlZEtleXMoZGF0YXNldFR5cGUsXG4gICAgICAoKSA9PiBbW1xuICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX1gLFxuICAgICAgICAnJ1xuICAgICAgXV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9wdGlvbiBzY29wZSBrZXlzIGZvciByZXNvbHZpbmcgZGF0YXNldCBhbmltYXRpb24gb3B0aW9ucy5cbiAgICogVGhlc2Uga2V5cyBkbyBub3QgaW5jbHVkZSB0aGUgZGF0YXNldCBpdHNlbGYsIGJlY2F1c2UgaXQgaXMgbm90IHVuZGVyIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhc2V0VHlwZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhbnNpdGlvblxuICAgKiBAcmV0dXJuIHtzdHJpbmdbXVtdfVxuICAgKi9cbiAgZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyhkYXRhc2V0VHlwZSwgdHJhbnNpdGlvbikge1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGAke2RhdGFzZXRUeXBlfS50cmFuc2l0aW9uLiR7dHJhbnNpdGlvbn1gLFxuICAgICAgKCkgPT4gW1xuICAgICAgICBbXG4gICAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9LnRyYW5zaXRpb25zLiR7dHJhbnNpdGlvbn1gLFxuICAgICAgICAgIGB0cmFuc2l0aW9ucy4ke3RyYW5zaXRpb259YCxcbiAgICAgICAgXSxcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBhcmUgdXNlZCBmb3IgbG9va2luZyB1cCB0aGUgYGFuaW1hdGlvbnNgIGFuZCBgYW5pbWF0aW9uYCBrZXlzXG4gICAgICAgIFtcbiAgICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX1gLFxuICAgICAgICAgICcnXG4gICAgICAgIF1cbiAgICAgIF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9wdGlvbnMgc2NvcGUga2V5cyBmb3IgcmVzb2x2aW5nIGVsZW1lbnQgb3B0aW9ucyB0aGF0IGJlbG9uZ1xuICAgKiB0byBhbiBkYXRhc2V0LiBUaGVzZSBrZXlzIGRvIG5vdCBpbmNsdWRlIHRoZSBkYXRhc2V0IGl0c2VsZiwgYmVjYXVzZSBpdFxuICAgKiBpcyBub3QgdW5kZXIgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFzZXRUeXBlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50VHlwZVxuICAgKiBAcmV0dXJuIHtzdHJpbmdbXVtdfVxuICAgKi9cbiAgZGF0YXNldEVsZW1lbnRTY29wZUtleXMoZGF0YXNldFR5cGUsIGVsZW1lbnRUeXBlKSB7XG4gICAgcmV0dXJuIGNhY2hlZEtleXMoYCR7ZGF0YXNldFR5cGV9LSR7ZWxlbWVudFR5cGV9YCxcbiAgICAgICgpID0+IFtbXG4gICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfS5lbGVtZW50cy4ke2VsZW1lbnRUeXBlfWAsXG4gICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfWAsXG4gICAgICAgIGBlbGVtZW50cy4ke2VsZW1lbnRUeXBlfWAsXG4gICAgICAgICcnXG4gICAgICBdXSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3B0aW9ucyBzY29wZSBrZXlzIGZvciByZXNvbHZpbmcgcGx1Z2luIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7e2lkOiBzdHJpbmcsIGFkZGl0aW9uYWxPcHRpb25TY29wZXM/OiBzdHJpbmdbXX19IHBsdWdpblxuICAgKiBAcmV0dXJuIHtzdHJpbmdbXVtdfVxuICAgKi9cbiAgcGx1Z2luU2NvcGVLZXlzKHBsdWdpbikge1xuICAgIGNvbnN0IGlkID0gcGx1Z2luLmlkO1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLnR5cGU7XG4gICAgcmV0dXJuIGNhY2hlZEtleXMoYCR7dHlwZX0tcGx1Z2luLSR7aWR9YCxcbiAgICAgICgpID0+IFtbXG4gICAgICAgIGBwbHVnaW5zLiR7aWR9YCxcbiAgICAgICAgLi4ucGx1Z2luLmFkZGl0aW9uYWxPcHRpb25TY29wZXMgfHwgW10sXG4gICAgICBdXSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jYWNoZWRTY29wZXMobWFpblNjb3BlLCByZXNldENhY2hlKSB7XG4gICAgY29uc3QgX3Njb3BlQ2FjaGUgPSB0aGlzLl9zY29wZUNhY2hlO1xuICAgIGxldCBjYWNoZSA9IF9zY29wZUNhY2hlLmdldChtYWluU2NvcGUpO1xuICAgIGlmICghY2FjaGUgfHwgcmVzZXRDYWNoZSkge1xuICAgICAgY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICBfc2NvcGVDYWNoZS5zZXQobWFpblNjb3BlLCBjYWNoZSk7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyB0aGUgb2JqZWN0cyBmcm9tIG9wdGlvbnMgYW5kIGRlZmF1bHRzIGZvciBvcHRpb24gdmFsdWUgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtvYmplY3R9IG1haW5TY29wZSAtIFRoZSBtYWluIHNjb3BlIG9iamVjdCBmb3Igb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ1tdW119IGtleUxpc3RzIC0gVGhlIGFycmF5cyBvZiBrZXlzIGluIHJlc29sdXRpb24gb3JkZXJcbiAgICogQHBhcmFtIHtib29sZWFufSBbcmVzZXRDYWNoZV0gLSByZXNldCB0aGUgY2FjaGUgZm9yIHRoaXMgbWFpblNjb3BlXG4gICAqL1xuICBnZXRPcHRpb25TY29wZXMobWFpblNjb3BlLCBrZXlMaXN0cywgcmVzZXRDYWNoZSkge1xuICAgIGNvbnN0IHtvcHRpb25zLCB0eXBlfSA9IHRoaXM7XG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLl9jYWNoZWRTY29wZXMobWFpblNjb3BlLCByZXNldENhY2hlKTtcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoa2V5TGlzdHMpO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuXG4gICAgY29uc3Qgc2NvcGVzID0gbmV3IFNldCgpO1xuXG4gICAga2V5TGlzdHMuZm9yRWFjaChrZXlzID0+IHtcbiAgICAgIGlmIChtYWluU2NvcGUpIHtcbiAgICAgICAgc2NvcGVzLmFkZChtYWluU2NvcGUpO1xuICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBtYWluU2NvcGUsIGtleSkpO1xuICAgICAgfVxuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3Blcywgb3B0aW9ucywga2V5KSk7XG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBvdmVycmlkZXNbdHlwZV0gfHwge30sIGtleSkpO1xuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3BlcywgZGVmYXVsdHMsIGtleSkpO1xuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3BlcywgZGVzY3JpcHRvcnMsIGtleSkpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgYXJyYXkgPSBBcnJheS5mcm9tKHNjb3Blcyk7XG4gICAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgYXJyYXkucHVzaChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICB9XG4gICAgaWYgKGtleXNDYWNoZWQuaGFzKGtleUxpc3RzKSkge1xuICAgICAgY2FjaGUuc2V0KGtleUxpc3RzLCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcHRpb24gc2NvcGVzIGZvciByZXNvbHZpbmcgY2hhcnQgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtvYmplY3RbXX1cbiAgICovXG4gIGNoYXJ0T3B0aW9uU2NvcGVzKCkge1xuICAgIGNvbnN0IHtvcHRpb25zLCB0eXBlfSA9IHRoaXM7XG5cbiAgICByZXR1cm4gW1xuICAgICAgb3B0aW9ucyxcbiAgICAgIG92ZXJyaWRlc1t0eXBlXSB8fCB7fSxcbiAgICAgIGRlZmF1bHRzLmRhdGFzZXRzW3R5cGVdIHx8IHt9LCAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvODUzMVxuICAgICAge3R5cGV9LFxuICAgICAgZGVmYXVsdHMsXG4gICAgICBkZXNjcmlwdG9yc1xuICAgIF07XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3RbXX0gc2NvcGVzXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IG5hbWVzXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb258b2JqZWN0fSBjb250ZXh0XG4gICAqIEBwYXJhbSB7c3RyaW5nW119IFtwcmVmaXhlc11cbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKi9cbiAgcmVzb2x2ZU5hbWVkT3B0aW9ucyhzY29wZXMsIG5hbWVzLCBjb250ZXh0LCBwcmVmaXhlcyA9IFsnJ10pIHtcbiAgICBjb25zdCByZXN1bHQgPSB7JHNoYXJlZDogdHJ1ZX07XG4gICAgY29uc3Qge3Jlc29sdmVyLCBzdWJQcmVmaXhlc30gPSBnZXRSZXNvbHZlcih0aGlzLl9yZXNvbHZlckNhY2hlLCBzY29wZXMsIHByZWZpeGVzKTtcbiAgICBsZXQgb3B0aW9ucyA9IHJlc29sdmVyO1xuICAgIGlmIChuZWVkQ29udGV4dChyZXNvbHZlciwgbmFtZXMpKSB7XG4gICAgICByZXN1bHQuJHNoYXJlZCA9IGZhbHNlO1xuICAgICAgY29udGV4dCA9IGlzRnVuY3Rpb24oY29udGV4dCkgPyBjb250ZXh0KCkgOiBjb250ZXh0O1xuICAgICAgLy8gc3ViUmVzb2x2ZXIgaXMgcGFzc2VkIHRvIHNjcmlwdGFibGUgb3B0aW9ucy4gSXQgc2hvdWxkIG5vdCByZXNvbHZlIHRvIGhvdmVyIG9wdGlvbnMuXG4gICAgICBjb25zdCBzdWJSZXNvbHZlciA9IHRoaXMuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBjb250ZXh0LCBzdWJQcmVmaXhlcyk7XG4gICAgICBvcHRpb25zID0gX2F0dGFjaENvbnRleHQocmVzb2x2ZXIsIGNvbnRleHQsIHN1YlJlc29sdmVyKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgbmFtZXMpIHtcbiAgICAgIHJlc3VsdFtwcm9wXSA9IG9wdGlvbnNbcHJvcF07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3RbXX0gc2NvcGVzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF1cbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gW3ByZWZpeGVzXVxuICAgKiBAcGFyYW0ge3tzY3JpcHRhYmxlOiBib29sZWFuLCBpbmRleGFibGU6IGJvb2xlYW4sIGFsbEtleXM/OiBib29sZWFufX0gW2Rlc2NyaXB0b3JEZWZhdWx0c11cbiAgICovXG4gIGNyZWF0ZVJlc29sdmVyKHNjb3BlcywgY29udGV4dCwgcHJlZml4ZXMgPSBbJyddLCBkZXNjcmlwdG9yRGVmYXVsdHMpIHtcbiAgICBjb25zdCB7cmVzb2x2ZXJ9ID0gZ2V0UmVzb2x2ZXIodGhpcy5fcmVzb2x2ZXJDYWNoZSwgc2NvcGVzLCBwcmVmaXhlcyk7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGNvbnRleHQpXG4gICAgICA/IF9hdHRhY2hDb250ZXh0KHJlc29sdmVyLCBjb250ZXh0LCB1bmRlZmluZWQsIGRlc2NyaXB0b3JEZWZhdWx0cylcbiAgICAgIDogcmVzb2x2ZXI7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmVzb2x2ZXIocmVzb2x2ZXJDYWNoZSwgc2NvcGVzLCBwcmVmaXhlcykge1xuICBsZXQgY2FjaGUgPSByZXNvbHZlckNhY2hlLmdldChzY29wZXMpO1xuICBpZiAoIWNhY2hlKSB7XG4gICAgY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgcmVzb2x2ZXJDYWNoZS5zZXQoc2NvcGVzLCBjYWNoZSk7XG4gIH1cbiAgY29uc3QgY2FjaGVLZXkgPSBwcmVmaXhlcy5qb2luKCk7XG4gIGxldCBjYWNoZWQgPSBjYWNoZS5nZXQoY2FjaGVLZXkpO1xuICBpZiAoIWNhY2hlZCkge1xuICAgIGNvbnN0IHJlc29sdmVyID0gX2NyZWF0ZVJlc29sdmVyKHNjb3BlcywgcHJlZml4ZXMpO1xuICAgIGNhY2hlZCA9IHtcbiAgICAgIHJlc29sdmVyLFxuICAgICAgc3ViUHJlZml4ZXM6IHByZWZpeGVzLmZpbHRlcihwID0+ICFwLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2hvdmVyJykpXG4gICAgfTtcbiAgICBjYWNoZS5zZXQoY2FjaGVLZXksIGNhY2hlZCk7XG4gIH1cbiAgcmV0dXJuIGNhY2hlZDtcbn1cblxuY29uc3QgaGFzRnVuY3Rpb24gPSB2YWx1ZSA9PiBpc09iamVjdCh2YWx1ZSlcbiAgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpLnNvbWUoKGtleSkgPT4gaXNGdW5jdGlvbih2YWx1ZVtrZXldKSk7XG5cbmZ1bmN0aW9uIG5lZWRDb250ZXh0KHByb3h5LCBuYW1lcykge1xuICBjb25zdCB7aXNTY3JpcHRhYmxlLCBpc0luZGV4YWJsZX0gPSBfZGVzY3JpcHRvcnMocHJveHkpO1xuXG4gIGZvciAoY29uc3QgcHJvcCBvZiBuYW1lcykge1xuICAgIGNvbnN0IHNjcmlwdGFibGUgPSBpc1NjcmlwdGFibGUocHJvcCk7XG4gICAgY29uc3QgaW5kZXhhYmxlID0gaXNJbmRleGFibGUocHJvcCk7XG4gICAgY29uc3QgdmFsdWUgPSAoaW5kZXhhYmxlIHx8IHNjcmlwdGFibGUpICYmIHByb3h5W3Byb3BdO1xuICAgIGlmICgoc2NyaXB0YWJsZSAmJiAoaXNGdW5jdGlvbih2YWx1ZSkgfHwgaGFzRnVuY3Rpb24odmFsdWUpKSlcbiAgICAgIHx8IChpbmRleGFibGUgJiYgaXNBcnJheSh2YWx1ZSkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuIiwgImltcG9ydCBhbmltYXRvciBmcm9tICcuL2NvcmUuYW5pbWF0b3IuanMnO1xuaW1wb3J0IGRlZmF1bHRzLCB7b3ZlcnJpZGVzfSBmcm9tICcuL2NvcmUuZGVmYXVsdHMuanMnO1xuaW1wb3J0IEludGVyYWN0aW9uIGZyb20gJy4vY29yZS5pbnRlcmFjdGlvbi5qcyc7XG5pbXBvcnQgbGF5b3V0cyBmcm9tICcuL2NvcmUubGF5b3V0cy5qcyc7XG5pbXBvcnQge19kZXRlY3RQbGF0Zm9ybX0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXguanMnO1xuaW1wb3J0IFBsdWdpblNlcnZpY2UgZnJvbSAnLi9jb3JlLnBsdWdpbnMuanMnO1xuaW1wb3J0IHJlZ2lzdHJ5IGZyb20gJy4vY29yZS5yZWdpc3RyeS5qcyc7XG5pbXBvcnQgQ29uZmlnLCB7ZGV0ZXJtaW5lQXhpcywgZ2V0SW5kZXhBeGlzfSBmcm9tICcuL2NvcmUuY29uZmlnLmpzJztcbmltcG9ydCB7cmV0aW5hU2NhbGUsIF9pc0RvbVN1cHBvcnRlZH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmRvbS5qcyc7XG5pbXBvcnQge2VhY2gsIGNhbGxiYWNrIGFzIGNhbGxDYWxsYmFjaywgdWlkLCB2YWx1ZU9yRGVmYXVsdCwgX2VsZW1lbnRzRXF1YWwsIGlzTnVsbE9yVW5kZWYsIHNldHNFcXVhbCwgZGVmaW5lZCwgaXNGdW5jdGlvbiwgX2lzQ2xpY2tFdmVudH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtjbGVhckNhbnZhcywgY2xpcEFyZWEsIGNyZWF0ZUNvbnRleHQsIHVuY2xpcEFyZWEsIF9pc1BvaW50SW5BcmVhfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7dmVyc2lvbn0gZnJvbSAnLi4vLi4vcGFja2FnZS5qc29uJztcbmltcG9ydCB7ZGVib3VuY2V9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLkNoYXJ0RXZlbnQgfSBDaGFydEV2ZW50XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5Qb2ludCB9IFBvaW50XG4gKi9cblxuY29uc3QgS05PV05fUE9TSVRJT05TID0gWyd0b3AnLCAnYm90dG9tJywgJ2xlZnQnLCAncmlnaHQnLCAnY2hhcnRBcmVhJ107XG5mdW5jdGlvbiBwb3NpdGlvbklzSG9yaXpvbnRhbChwb3NpdGlvbiwgYXhpcykge1xuICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJyB8fCAoS05PV05fUE9TSVRJT05TLmluZGV4T2YocG9zaXRpb24pID09PSAtMSAmJiBheGlzID09PSAneCcpO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlMkxldmVsKGwxLCBsMikge1xuICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBhW2wxXSA9PT0gYltsMV1cbiAgICAgID8gYVtsMl0gLSBiW2wyXVxuICAgICAgOiBhW2wxXSAtIGJbbDFdO1xuICB9O1xufVxuXG5mdW5jdGlvbiBvbkFuaW1hdGlvbnNDb21wbGV0ZShjb250ZXh0KSB7XG4gIGNvbnN0IGNoYXJ0ID0gY29udGV4dC5jaGFydDtcbiAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uO1xuXG4gIGNoYXJ0Lm5vdGlmeVBsdWdpbnMoJ2FmdGVyUmVuZGVyJyk7XG4gIGNhbGxDYWxsYmFjayhhbmltYXRpb25PcHRpb25zICYmIGFuaW1hdGlvbk9wdGlvbnMub25Db21wbGV0ZSwgW2NvbnRleHRdLCBjaGFydCk7XG59XG5cbmZ1bmN0aW9uIG9uQW5pbWF0aW9uUHJvZ3Jlc3MoY29udGV4dCkge1xuICBjb25zdCBjaGFydCA9IGNvbnRleHQuY2hhcnQ7XG4gIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmFuaW1hdGlvbjtcbiAgY2FsbENhbGxiYWNrKGFuaW1hdGlvbk9wdGlvbnMgJiYgYW5pbWF0aW9uT3B0aW9ucy5vblByb2dyZXNzLCBbY29udGV4dF0sIGNoYXJ0KTtcbn1cblxuLyoqXG4gKiBDaGFydC5qcyBjYW4gdGFrZSBhIHN0cmluZyBpZCBvZiBhIGNhbnZhcyBlbGVtZW50LCBhIDJkIGNvbnRleHQsIG9yIGEgY2FudmFzIGVsZW1lbnQgaXRzZWxmLlxuICogQXR0ZW1wdCB0byB1bndyYXAgdGhlIGl0ZW0gcGFzc2VkIGludG8gdGhlIGNoYXJ0IGNvbnN0cnVjdG9yIHNvIHRoYXQgaXQgaXMgYSBjYW52YXMgZWxlbWVudCAoaWYgcG9zc2libGUpLlxuICovXG5mdW5jdGlvbiBnZXRDYW52YXMoaXRlbSkge1xuICBpZiAoX2lzRG9tU3VwcG9ydGVkKCkgJiYgdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgaXRlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGl0ZW0pO1xuICB9IGVsc2UgaWYgKGl0ZW0gJiYgaXRlbS5sZW5ndGgpIHtcbiAgICAvLyBTdXBwb3J0IGZvciBhcnJheSBiYXNlZCBxdWVyaWVzIChzdWNoIGFzIGpRdWVyeSlcbiAgICBpdGVtID0gaXRlbVswXTtcbiAgfVxuXG4gIGlmIChpdGVtICYmIGl0ZW0uY2FudmFzKSB7XG4gICAgLy8gU3VwcG9ydCBmb3IgYW55IG9iamVjdCBhc3NvY2lhdGVkIHRvIGEgY2FudmFzIChpbmNsdWRpbmcgYSBjb250ZXh0MmQpXG4gICAgaXRlbSA9IGl0ZW0uY2FudmFzO1xuICB9XG4gIHJldHVybiBpdGVtO1xufVxuXG5jb25zdCBpbnN0YW5jZXMgPSB7fTtcbmNvbnN0IGdldENoYXJ0ID0gKGtleSkgPT4ge1xuICBjb25zdCBjYW52YXMgPSBnZXRDYW52YXMoa2V5KTtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoaW5zdGFuY2VzKS5maWx0ZXIoKGMpID0+IGMuY2FudmFzID09PSBjYW52YXMpLnBvcCgpO1xufTtcblxuZnVuY3Rpb24gbW92ZU51bWVyaWNLZXlzKG9iaiwgc3RhcnQsIG1vdmUpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBjb25zdCBpbnRLZXkgPSAra2V5O1xuICAgIGlmIChpbnRLZXkgPj0gc3RhcnQpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XG4gICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICBpZiAobW92ZSA+IDAgfHwgaW50S2V5ID4gc3RhcnQpIHtcbiAgICAgICAgb2JqW2ludEtleSArIG1vdmVdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaGFydEV2ZW50fSBlXG4gKiBAcGFyYW0ge0NoYXJ0RXZlbnR8bnVsbH0gbGFzdEV2ZW50XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluQ2hhcnRBcmVhXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzQ2xpY2tcbiAqIEByZXR1cm5zIHtDaGFydEV2ZW50fG51bGx9XG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZUxhc3RFdmVudChlLCBsYXN0RXZlbnQsIGluQ2hhcnRBcmVhLCBpc0NsaWNrKSB7XG4gIGlmICghaW5DaGFydEFyZWEgfHwgZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGlzQ2xpY2spIHtcbiAgICByZXR1cm4gbGFzdEV2ZW50O1xuICB9XG4gIHJldHVybiBlO1xufVxuXG5mdW5jdGlvbiBnZXRTaXplRm9yQXJlYShzY2FsZSwgY2hhcnRBcmVhLCBmaWVsZCkge1xuICByZXR1cm4gc2NhbGUub3B0aW9ucy5jbGlwID8gc2NhbGVbZmllbGRdIDogY2hhcnRBcmVhW2ZpZWxkXTtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YXNldEFyZWEobWV0YSwgY2hhcnRBcmVhKSB7XG4gIGNvbnN0IHt4U2NhbGUsIHlTY2FsZX0gPSBtZXRhO1xuICBpZiAoeFNjYWxlICYmIHlTY2FsZSkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBnZXRTaXplRm9yQXJlYSh4U2NhbGUsIGNoYXJ0QXJlYSwgJ2xlZnQnKSxcbiAgICAgIHJpZ2h0OiBnZXRTaXplRm9yQXJlYSh4U2NhbGUsIGNoYXJ0QXJlYSwgJ3JpZ2h0JyksXG4gICAgICB0b3A6IGdldFNpemVGb3JBcmVhKHlTY2FsZSwgY2hhcnRBcmVhLCAndG9wJyksXG4gICAgICBib3R0b206IGdldFNpemVGb3JBcmVhKHlTY2FsZSwgY2hhcnRBcmVhLCAnYm90dG9tJylcbiAgICB9O1xuICB9XG4gIHJldHVybiBjaGFydEFyZWE7XG59XG5cbmNsYXNzIENoYXJ0IHtcblxuICBzdGF0aWMgZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgc3RhdGljIGluc3RhbmNlcyA9IGluc3RhbmNlcztcbiAgc3RhdGljIG92ZXJyaWRlcyA9IG92ZXJyaWRlcztcbiAgc3RhdGljIHJlZ2lzdHJ5ID0gcmVnaXN0cnk7XG4gIHN0YXRpYyB2ZXJzaW9uID0gdmVyc2lvbjtcbiAgc3RhdGljIGdldENoYXJ0ID0gZ2V0Q2hhcnQ7XG5cbiAgc3RhdGljIHJlZ2lzdGVyKC4uLml0ZW1zKSB7XG4gICAgcmVnaXN0cnkuYWRkKC4uLml0ZW1zKTtcbiAgICBpbnZhbGlkYXRlUGx1Z2lucygpO1xuICB9XG5cbiAgc3RhdGljIHVucmVnaXN0ZXIoLi4uaXRlbXMpIHtcbiAgICByZWdpc3RyeS5yZW1vdmUoLi4uaXRlbXMpO1xuICAgIGludmFsaWRhdGVQbHVnaW5zKCk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXN0YXRlbWVudHNcbiAgY29uc3RydWN0b3IoaXRlbSwgdXNlckNvbmZpZykge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnID0gbmV3IENvbmZpZyh1c2VyQ29uZmlnKTtcbiAgICBjb25zdCBpbml0aWFsQ2FudmFzID0gZ2V0Q2FudmFzKGl0ZW0pO1xuICAgIGNvbnN0IGV4aXN0aW5nQ2hhcnQgPSBnZXRDaGFydChpbml0aWFsQ2FudmFzKTtcbiAgICBpZiAoZXhpc3RpbmdDaGFydCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQ2FudmFzIGlzIGFscmVhZHkgaW4gdXNlLiBDaGFydCB3aXRoIElEIFxcJycgKyBleGlzdGluZ0NoYXJ0LmlkICsgJ1xcJycgK1xuXHRcdFx0XHQnIG11c3QgYmUgZGVzdHJveWVkIGJlZm9yZSB0aGUgY2FudmFzIHdpdGggSUQgXFwnJyArIGV4aXN0aW5nQ2hhcnQuY2FudmFzLmlkICsgJ1xcJyBjYW4gYmUgcmV1c2VkLidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihjb25maWcuY2hhcnRPcHRpb25TY29wZXMoKSwgdGhpcy5nZXRDb250ZXh0KCkpO1xuXG4gICAgdGhpcy5wbGF0Zm9ybSA9IG5ldyAoY29uZmlnLnBsYXRmb3JtIHx8IF9kZXRlY3RQbGF0Zm9ybShpbml0aWFsQ2FudmFzKSkoKTtcbiAgICB0aGlzLnBsYXRmb3JtLnVwZGF0ZUNvbmZpZyhjb25maWcpO1xuXG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMucGxhdGZvcm0uYWNxdWlyZUNvbnRleHQoaW5pdGlhbENhbnZhcywgb3B0aW9ucy5hc3BlY3RSYXRpbyk7XG4gICAgY29uc3QgY2FudmFzID0gY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcztcbiAgICBjb25zdCBoZWlnaHQgPSBjYW52YXMgJiYgY2FudmFzLmhlaWdodDtcbiAgICBjb25zdCB3aWR0aCA9IGNhbnZhcyAmJiBjYW52YXMud2lkdGg7XG5cbiAgICB0aGlzLmlkID0gdWlkKCk7XG4gICAgdGhpcy5jdHggPSBjb250ZXh0O1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICAvLyBTdG9yZSB0aGUgcHJldmlvdXNseSB1c2VkIGFzcGVjdCByYXRpbyB0byBkZXRlcm1pbmUgaWYgYSByZXNpemVcbiAgICAvLyBpcyBuZWVkZWQgZHVyaW5nIHVwZGF0ZXMuIERvIHRoaXMgYWZ0ZXIgX29wdGlvbnMgaXMgc2V0IHNpbmNlXG4gICAgLy8gYXNwZWN0UmF0aW8gdXNlcyBhIGdldHRlclxuICAgIHRoaXMuX2FzcGVjdFJhdGlvID0gdGhpcy5hc3BlY3RSYXRpbztcbiAgICB0aGlzLl9sYXllcnMgPSBbXTtcbiAgICB0aGlzLl9tZXRhc2V0cyA9IFtdO1xuICAgIHRoaXMuX3N0YWNrcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJveGVzID0gW107XG4gICAgdGhpcy5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNoYXJ0QXJlYSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9hY3RpdmUgPSBbXTtcbiAgICB0aGlzLl9sYXN0RXZlbnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgLyoqIEB0eXBlIHs/e2F0dGFjaD86IGZ1bmN0aW9uLCBkZXRhY2g/OiBmdW5jdGlvbiwgcmVzaXplPzogZnVuY3Rpb259fSAqL1xuICAgIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc29ydGVkTWV0YXNldHMgPSBbXTtcbiAgICB0aGlzLnNjYWxlcyA9IHt9O1xuICAgIHRoaXMuX3BsdWdpbnMgPSBuZXcgUGx1Z2luU2VydmljZSgpO1xuICAgIHRoaXMuJHByb3hpZXMgPSB7fTtcbiAgICB0aGlzLl9oaWRkZW5JbmRpY2VzID0ge307XG4gICAgdGhpcy5hdHRhY2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2FuaW1hdGlvbnNEaXNhYmxlZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RvUmVzaXplID0gZGVib3VuY2UobW9kZSA9PiB0aGlzLnVwZGF0ZShtb2RlKSwgb3B0aW9ucy5yZXNpemVEZWxheSB8fCAwKTtcbiAgICB0aGlzLl9kYXRhQ2hhbmdlcyA9IFtdO1xuXG4gICAgLy8gQWRkIHRoZSBjaGFydCBpbnN0YW5jZSB0byB0aGUgZ2xvYmFsIG5hbWVzcGFjZVxuICAgIGluc3RhbmNlc1t0aGlzLmlkXSA9IHRoaXM7XG5cbiAgICBpZiAoIWNvbnRleHQgfHwgIWNhbnZhcykge1xuICAgICAgLy8gVGhlIGdpdmVuIGl0ZW0gaXMgbm90IGEgY29tcGF0aWJsZSBjb250ZXh0MmQgZWxlbWVudCwgbGV0J3MgcmV0dXJuIGJlZm9yZSBmaW5hbGl6aW5nXG4gICAgICAvLyB0aGUgY2hhcnQgaW5pdGlhbGl6YXRpb24gYnV0IGFmdGVyIHNldHRpbmcgYmFzaWMgY2hhcnQgLyBjb250cm9sbGVyIHByb3BlcnRpZXMgdGhhdFxuICAgICAgLy8gY2FuIGhlbHAgdG8gZmlndXJlIG91dCB0aGF0IHRoZSBjaGFydCBpcyBub3QgdmFsaWQgKGUuZyBjaGFydC5jYW52YXMgIT09IG51bGwpO1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI4MDdcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIGNoYXJ0OiBjYW4ndCBhY3F1aXJlIGNvbnRleHQgZnJvbSB0aGUgZ2l2ZW4gaXRlbVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhbmltYXRvci5saXN0ZW4odGhpcywgJ2NvbXBsZXRlJywgb25BbmltYXRpb25zQ29tcGxldGUpO1xuICAgIGFuaW1hdG9yLmxpc3Rlbih0aGlzLCAncHJvZ3Jlc3MnLCBvbkFuaW1hdGlvblByb2dyZXNzKTtcblxuICAgIHRoaXMuX2luaXRpYWxpemUoKTtcbiAgICBpZiAodGhpcy5hdHRhY2hlZCkge1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gIH1cblxuICBnZXQgYXNwZWN0UmF0aW8oKSB7XG4gICAgY29uc3Qge29wdGlvbnM6IHthc3BlY3RSYXRpbywgbWFpbnRhaW5Bc3BlY3RSYXRpb30sIHdpZHRoLCBoZWlnaHQsIF9hc3BlY3RSYXRpb30gPSB0aGlzO1xuICAgIGlmICghaXNOdWxsT3JVbmRlZihhc3BlY3RSYXRpbykpIHtcbiAgICAgIC8vIElmIGFzcGVjdFJhdGlvIGlzIGRlZmluZWQgaW4gb3B0aW9ucywgdXNlIHRoYXQuXG4gICAgICByZXR1cm4gYXNwZWN0UmF0aW87XG4gICAgfVxuXG4gICAgaWYgKG1haW50YWluQXNwZWN0UmF0aW8gJiYgX2FzcGVjdFJhdGlvKSB7XG4gICAgICAvLyBJZiBtYWludGFpbkFzcGVjdFJhdGlvIGlzIHRydXRobHkgYW5kIHdlIGhhZCBwcmV2aW91c2x5IGRldGVybWluZWQgX2FzcGVjdFJhdGlvLCB1c2UgdGhhdFxuICAgICAgcmV0dXJuIF9hc3BlY3RSYXRpbztcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGVcbiAgICByZXR1cm4gaGVpZ2h0ID8gd2lkdGggLyBoZWlnaHQgOiBudWxsO1xuICB9XG5cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmRhdGE7XG4gIH1cblxuICBzZXQgZGF0YShkYXRhKSB7XG4gICAgdGhpcy5jb25maWcuZGF0YSA9IGRhdGE7XG4gIH1cblxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgfVxuXG4gIHNldCBvcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLmNvbmZpZy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIGdldCByZWdpc3RyeSgpIHtcbiAgICByZXR1cm4gcmVnaXN0cnk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9pbml0aWFsaXplKCkge1xuICAgIC8vIEJlZm9yZSBpbml0IHBsdWdpbiBub3RpZmljYXRpb25cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUluaXQnKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0aW5hU2NhbGUodGhpcywgdGhpcy5vcHRpb25zLmRldmljZVBpeGVsUmF0aW8pO1xuICAgIH1cblxuICAgIHRoaXMuYmluZEV2ZW50cygpO1xuXG4gICAgLy8gQWZ0ZXIgaW5pdCBwbHVnaW4gbm90aWZpY2F0aW9uXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckluaXQnKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgY2xlYXJDYW52YXModGhpcy5jYW52YXMsIHRoaXMuY3R4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgYW5pbWF0b3Iuc3RvcCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXNpemUgdGhlIGNoYXJ0IHRvIGl0cyBjb250YWluZXIgb3IgdG8gZXhwbGljaXQgZGltZW5zaW9ucy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF1cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHRdXG5cdCAqL1xuICByZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGlmICghYW5pbWF0b3IucnVubmluZyh0aGlzKSkge1xuICAgICAgdGhpcy5fcmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXNpemVCZWZvcmVEcmF3ID0ge3dpZHRoLCBoZWlnaHR9O1xuICAgIH1cbiAgfVxuXG4gIF9yZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgY29uc3QgYXNwZWN0UmF0aW8gPSBvcHRpb25zLm1haW50YWluQXNwZWN0UmF0aW8gJiYgdGhpcy5hc3BlY3RSYXRpbztcbiAgICBjb25zdCBuZXdTaXplID0gdGhpcy5wbGF0Zm9ybS5nZXRNYXhpbXVtU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKTtcbiAgICBjb25zdCBuZXdSYXRpbyA9IG9wdGlvbnMuZGV2aWNlUGl4ZWxSYXRpbyB8fCB0aGlzLnBsYXRmb3JtLmdldERldmljZVBpeGVsUmF0aW8oKTtcbiAgICBjb25zdCBtb2RlID0gdGhpcy53aWR0aCA/ICdyZXNpemUnIDogJ2F0dGFjaCc7XG5cbiAgICB0aGlzLndpZHRoID0gbmV3U2l6ZS53aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IG5ld1NpemUuaGVpZ2h0O1xuICAgIHRoaXMuX2FzcGVjdFJhdGlvID0gdGhpcy5hc3BlY3RSYXRpbztcbiAgICBpZiAoIXJldGluYVNjYWxlKHRoaXMsIG5ld1JhdGlvLCB0cnVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygncmVzaXplJywge3NpemU6IG5ld1NpemV9KTtcblxuICAgIGNhbGxDYWxsYmFjayhvcHRpb25zLm9uUmVzaXplLCBbdGhpcywgbmV3U2l6ZV0sIHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuYXR0YWNoZWQpIHtcbiAgICAgIGlmICh0aGlzLl9kb1Jlc2l6ZShtb2RlKSkge1xuICAgICAgICAvLyBUaGUgcmVzaXplIHVwZGF0ZSBpcyBkZWxheWVkLCBvbmx5IGRyYXcgd2l0aG91dCB1cGRhdGluZy5cbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlbnN1cmVTY2FsZXNIYXZlSURzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgc2NhbGVzT3B0aW9ucyA9IG9wdGlvbnMuc2NhbGVzIHx8IHt9O1xuXG4gICAgZWFjaChzY2FsZXNPcHRpb25zLCAoYXhpc09wdGlvbnMsIGF4aXNJRCkgPT4ge1xuICAgICAgYXhpc09wdGlvbnMuaWQgPSBheGlzSUQ7XG4gICAgfSk7XG4gIH1cblxuICAvKipcblx0ICogQnVpbGRzIGEgbWFwIG9mIHNjYWxlIElEIHRvIHNjYWxlIG9iamVjdCBmb3IgZnV0dXJlIGxvb2t1cC5cblx0ICovXG4gIGJ1aWxkT3JVcGRhdGVTY2FsZXMoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBzY2FsZU9wdHMgPSBvcHRpb25zLnNjYWxlcztcbiAgICBjb25zdCBzY2FsZXMgPSB0aGlzLnNjYWxlcztcbiAgICBjb25zdCB1cGRhdGVkID0gT2JqZWN0LmtleXMoc2NhbGVzKS5yZWR1Y2UoKG9iaiwgaWQpID0+IHtcbiAgICAgIG9ialtpZF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSwge30pO1xuICAgIGxldCBpdGVtcyA9IFtdO1xuXG4gICAgaWYgKHNjYWxlT3B0cykge1xuICAgICAgaXRlbXMgPSBpdGVtcy5jb25jYXQoXG4gICAgICAgIE9iamVjdC5rZXlzKHNjYWxlT3B0cykubWFwKChpZCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHNjYWxlT3B0aW9ucyA9IHNjYWxlT3B0c1tpZF07XG4gICAgICAgICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlT3B0aW9ucyk7XG4gICAgICAgICAgY29uc3QgaXNSYWRpYWwgPSBheGlzID09PSAncic7XG4gICAgICAgICAgY29uc3QgaXNIb3Jpem9udGFsID0gYXhpcyA9PT0gJ3gnO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcHRpb25zOiBzY2FsZU9wdGlvbnMsXG4gICAgICAgICAgICBkcG9zaXRpb246IGlzUmFkaWFsID8gJ2NoYXJ0QXJlYScgOiBpc0hvcml6b250YWwgPyAnYm90dG9tJyA6ICdsZWZ0JyxcbiAgICAgICAgICAgIGR0eXBlOiBpc1JhZGlhbCA/ICdyYWRpYWxMaW5lYXInIDogaXNIb3Jpem9udGFsID8gJ2NhdGVnb3J5JyA6ICdsaW5lYXInXG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZWFjaChpdGVtcywgKGl0ZW0pID0+IHtcbiAgICAgIGNvbnN0IHNjYWxlT3B0aW9ucyA9IGl0ZW0ub3B0aW9ucztcbiAgICAgIGNvbnN0IGlkID0gc2NhbGVPcHRpb25zLmlkO1xuICAgICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlT3B0aW9ucyk7XG4gICAgICBjb25zdCBzY2FsZVR5cGUgPSB2YWx1ZU9yRGVmYXVsdChzY2FsZU9wdGlvbnMudHlwZSwgaXRlbS5kdHlwZSk7XG5cbiAgICAgIGlmIChzY2FsZU9wdGlvbnMucG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbklzSG9yaXpvbnRhbChzY2FsZU9wdGlvbnMucG9zaXRpb24sIGF4aXMpICE9PSBwb3NpdGlvbklzSG9yaXpvbnRhbChpdGVtLmRwb3NpdGlvbikpIHtcbiAgICAgICAgc2NhbGVPcHRpb25zLnBvc2l0aW9uID0gaXRlbS5kcG9zaXRpb247XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZWRbaWRdID0gdHJ1ZTtcbiAgICAgIGxldCBzY2FsZSA9IG51bGw7XG4gICAgICBpZiAoaWQgaW4gc2NhbGVzICYmIHNjYWxlc1tpZF0udHlwZSA9PT0gc2NhbGVUeXBlKSB7XG4gICAgICAgIHNjYWxlID0gc2NhbGVzW2lkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNjYWxlQ2xhc3MgPSByZWdpc3RyeS5nZXRTY2FsZShzY2FsZVR5cGUpO1xuICAgICAgICBzY2FsZSA9IG5ldyBzY2FsZUNsYXNzKHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICB0eXBlOiBzY2FsZVR5cGUsXG4gICAgICAgICAgY3R4OiB0aGlzLmN0eCxcbiAgICAgICAgICBjaGFydDogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgc2NhbGVzW3NjYWxlLmlkXSA9IHNjYWxlO1xuICAgICAgfVxuXG4gICAgICBzY2FsZS5pbml0KHNjYWxlT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgfSk7XG4gICAgLy8gY2xlYXIgdXAgZGlzY2FyZGVkIHNjYWxlc1xuICAgIGVhY2godXBkYXRlZCwgKGhhc1VwZGF0ZWQsIGlkKSA9PiB7XG4gICAgICBpZiAoIWhhc1VwZGF0ZWQpIHtcbiAgICAgICAgZGVsZXRlIHNjYWxlc1tpZF07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBlYWNoKHNjYWxlcywgKHNjYWxlKSA9PiB7XG4gICAgICBsYXlvdXRzLmNvbmZpZ3VyZSh0aGlzLCBzY2FsZSwgc2NhbGUub3B0aW9ucyk7XG4gICAgICBsYXlvdXRzLmFkZEJveCh0aGlzLCBzY2FsZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVNZXRhc2V0cygpIHtcbiAgICBjb25zdCBtZXRhc2V0cyA9IHRoaXMuX21ldGFzZXRzO1xuICAgIGNvbnN0IG51bURhdGEgPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoO1xuICAgIGNvbnN0IG51bU1ldGEgPSBtZXRhc2V0cy5sZW5ndGg7XG5cbiAgICBtZXRhc2V0cy5zb3J0KChhLCBiKSA9PiBhLmluZGV4IC0gYi5pbmRleCk7XG4gICAgaWYgKG51bU1ldGEgPiBudW1EYXRhKSB7XG4gICAgICBmb3IgKGxldCBpID0gbnVtRGF0YTsgaSA8IG51bU1ldGE7ICsraSkge1xuICAgICAgICB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEoaSk7XG4gICAgICB9XG4gICAgICBtZXRhc2V0cy5zcGxpY2UobnVtRGF0YSwgbnVtTWV0YSAtIG51bURhdGEpO1xuICAgIH1cbiAgICB0aGlzLl9zb3J0ZWRNZXRhc2V0cyA9IG1ldGFzZXRzLnNsaWNlKDApLnNvcnQoY29tcGFyZTJMZXZlbCgnb3JkZXInLCAnaW5kZXgnKSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9yZW1vdmVVbnJlZmVyZW5jZWRNZXRhc2V0cygpIHtcbiAgICBjb25zdCB7X21ldGFzZXRzOiBtZXRhc2V0cywgZGF0YToge2RhdGFzZXRzfX0gPSB0aGlzO1xuICAgIGlmIChtZXRhc2V0cy5sZW5ndGggPiBkYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9zdGFja3M7XG4gICAgfVxuICAgIG1ldGFzZXRzLmZvckVhY2goKG1ldGEsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoZGF0YXNldHMuZmlsdGVyKHggPT4geCA9PT0gbWV0YS5fZGF0YXNldCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpbmRleCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBidWlsZE9yVXBkYXRlQ29udHJvbGxlcnMoKSB7XG4gICAgY29uc3QgbmV3Q29udHJvbGxlcnMgPSBbXTtcbiAgICBjb25zdCBkYXRhc2V0cyA9IHRoaXMuZGF0YS5kYXRhc2V0cztcbiAgICBsZXQgaSwgaWxlbjtcblxuICAgIHRoaXMuX3JlbW92ZVVucmVmZXJlbmNlZE1ldGFzZXRzKCk7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBkYXRhc2V0ID0gZGF0YXNldHNbaV07XG4gICAgICBsZXQgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICBjb25zdCB0eXBlID0gZGF0YXNldC50eXBlIHx8IHRoaXMuY29uZmlnLnR5cGU7XG5cbiAgICAgIGlmIChtZXRhLnR5cGUgJiYgbWV0YS50eXBlICE9PSB0eXBlKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpKTtcbiAgICAgICAgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICB9XG4gICAgICBtZXRhLnR5cGUgPSB0eXBlO1xuICAgICAgbWV0YS5pbmRleEF4aXMgPSBkYXRhc2V0LmluZGV4QXhpcyB8fCBnZXRJbmRleEF4aXModHlwZSwgdGhpcy5vcHRpb25zKTtcbiAgICAgIG1ldGEub3JkZXIgPSBkYXRhc2V0Lm9yZGVyIHx8IDA7XG4gICAgICBtZXRhLmluZGV4ID0gaTtcbiAgICAgIG1ldGEubGFiZWwgPSAnJyArIGRhdGFzZXQubGFiZWw7XG4gICAgICBtZXRhLnZpc2libGUgPSB0aGlzLmlzRGF0YXNldFZpc2libGUoaSk7XG5cbiAgICAgIGlmIChtZXRhLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgbWV0YS5jb250cm9sbGVyLnVwZGF0ZUluZGV4KGkpO1xuICAgICAgICBtZXRhLmNvbnRyb2xsZXIubGlua1NjYWxlcygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgQ29udHJvbGxlckNsYXNzID0gcmVnaXN0cnkuZ2V0Q29udHJvbGxlcih0eXBlKTtcbiAgICAgICAgY29uc3Qge2RhdGFzZXRFbGVtZW50VHlwZSwgZGF0YUVsZW1lbnRUeXBlfSA9IGRlZmF1bHRzLmRhdGFzZXRzW3R5cGVdO1xuICAgICAgICBPYmplY3QuYXNzaWduKENvbnRyb2xsZXJDbGFzcywge1xuICAgICAgICAgIGRhdGFFbGVtZW50VHlwZTogcmVnaXN0cnkuZ2V0RWxlbWVudChkYXRhRWxlbWVudFR5cGUpLFxuICAgICAgICAgIGRhdGFzZXRFbGVtZW50VHlwZTogZGF0YXNldEVsZW1lbnRUeXBlICYmIHJlZ2lzdHJ5LmdldEVsZW1lbnQoZGF0YXNldEVsZW1lbnRUeXBlKVxuICAgICAgICB9KTtcbiAgICAgICAgbWV0YS5jb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXJDbGFzcyh0aGlzLCBpKTtcbiAgICAgICAgbmV3Q29udHJvbGxlcnMucHVzaChtZXRhLmNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZU1ldGFzZXRzKCk7XG4gICAgcmV0dXJuIG5ld0NvbnRyb2xsZXJzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJlc2V0IHRoZSBlbGVtZW50cyBvZiBhbGwgZGF0YXNldHNcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9yZXNldEVsZW1lbnRzKCkge1xuICAgIGVhY2godGhpcy5kYXRhLmRhdGFzZXRzLCAoZGF0YXNldCwgZGF0YXNldEluZGV4KSA9PiB7XG4gICAgICB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlci5yZXNldCgpO1xuICAgIH0sIHRoaXMpO1xuICB9XG5cbiAgLyoqXG5cdCogUmVzZXRzIHRoZSBjaGFydCBiYWNrIHRvIGl0cyBzdGF0ZSBiZWZvcmUgdGhlIGluaXRpYWwgYW5pbWF0aW9uXG5cdCovXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3Jlc2V0RWxlbWVudHMoKTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ3Jlc2V0Jyk7XG4gIH1cblxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuXG4gICAgY29uZmlnLnVwZGF0ZSgpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKGNvbmZpZy5jaGFydE9wdGlvblNjb3BlcygpLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3QgYW5pbXNEaXNhYmxlZCA9IHRoaXMuX2FuaW1hdGlvbnNEaXNhYmxlZCA9ICFvcHRpb25zLmFuaW1hdGlvbjtcblxuICAgIHRoaXMuX3VwZGF0ZVNjYWxlcygpO1xuICAgIHRoaXMuX2NoZWNrRXZlbnRCaW5kaW5ncygpO1xuICAgIHRoaXMuX3VwZGF0ZUhpZGRlbkluZGljZXMoKTtcblxuICAgIC8vIHBsdWdpbnMgb3B0aW9ucyByZWZlcmVuY2VzIG1pZ2h0IGhhdmUgY2hhbmdlLCBsZXQncyBpbnZhbGlkYXRlIHRoZSBjYWNoZVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81MTExI2lzc3VlY29tbWVudC0zNTU5MzQxNjdcbiAgICB0aGlzLl9wbHVnaW5zLmludmFsaWRhdGUoKTtcblxuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZVVwZGF0ZScsIHttb2RlLCBjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIGRhdGFzZXQgY29udHJvbGxlcnMgYXJlIHVwZGF0ZWQgYW5kIG5ldyBjb250cm9sbGVycyBhcmUgcmVzZXRcbiAgICBjb25zdCBuZXdDb250cm9sbGVycyA9IHRoaXMuYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzKCk7XG5cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUVsZW1lbnRzVXBkYXRlJyk7XG5cbiAgICAvLyBNYWtlIHN1cmUgYWxsIGRhdGFzZXQgY29udHJvbGxlcnMgaGF2ZSBjb3JyZWN0IG1ldGEgZGF0YSBjb3VudHNcbiAgICBsZXQgbWluUGFkZGluZyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBjb25zdCB7Y29udHJvbGxlcn0gPSB0aGlzLmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgY29uc3QgcmVzZXQgPSAhYW5pbXNEaXNhYmxlZCAmJiBuZXdDb250cm9sbGVycy5pbmRleE9mKGNvbnRyb2xsZXIpID09PSAtMTtcbiAgICAgIC8vIE5ldyBjb250cm9sbGVycyB3aWxsIGJlIHJlc2V0IGFmdGVyIHRoZSBsYXlvdXQgcGFzcywgc28gd2Ugb25seSB3YW50IHRvIG1vZGlmeVxuICAgICAgLy8gZWxlbWVudHMgYWRkZWQgdG8gbmV3IGRhdGFzZXRzXG4gICAgICBjb250cm9sbGVyLmJ1aWxkT3JVcGRhdGVFbGVtZW50cyhyZXNldCk7XG4gICAgICBtaW5QYWRkaW5nID0gTWF0aC5tYXgoK2NvbnRyb2xsZXIuZ2V0TWF4T3ZlcmZsb3coKSwgbWluUGFkZGluZyk7XG4gICAgfVxuICAgIG1pblBhZGRpbmcgPSB0aGlzLl9taW5QYWRkaW5nID0gb3B0aW9ucy5sYXlvdXQuYXV0b1BhZGRpbmcgPyBtaW5QYWRkaW5nIDogMDtcbiAgICB0aGlzLl91cGRhdGVMYXlvdXQobWluUGFkZGluZyk7XG5cbiAgICAvLyBPbmx5IHJlc2V0IHRoZSBjb250cm9sbGVycyBpZiB3ZSBoYXZlIGFuaW1hdGlvbnNcbiAgICBpZiAoIWFuaW1zRGlzYWJsZWQpIHtcbiAgICAgIC8vIENhbiBvbmx5IHJlc2V0IHRoZSBuZXcgY29udHJvbGxlcnMgYWZ0ZXIgdGhlIHNjYWxlcyBoYXZlIGJlZW4gdXBkYXRlZFxuICAgICAgLy8gUmVzZXQgaXMgZG9uZSB0byBnZXQgdGhlIHN0YXJ0aW5nIHBvaW50IGZvciB0aGUgaW5pdGlhbCBhbmltYXRpb25cbiAgICAgIGVhY2gobmV3Q29udHJvbGxlcnMsIChjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIucmVzZXQoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZURhdGFzZXRzKG1vZGUpO1xuXG4gICAgLy8gRG8gdGhpcyBiZWZvcmUgcmVuZGVyIHNvIHRoYXQgYW55IHBsdWdpbnMgdGhhdCBuZWVkIGZpbmFsIHNjYWxlIHVwZGF0ZXMgY2FuIHVzZSBpdFxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJVcGRhdGUnLCB7bW9kZX0pO1xuXG4gICAgdGhpcy5fbGF5ZXJzLnNvcnQoY29tcGFyZTJMZXZlbCgneicsICdfaWR4JykpO1xuXG4gICAgLy8gUmVwbGF5IGxhc3QgZXZlbnQgZnJvbSBiZWZvcmUgdXBkYXRlLCBvciBzZXQgaG92ZXIgc3R5bGVzIG9uIGFjdGl2ZSBlbGVtZW50c1xuICAgIGNvbnN0IHtfYWN0aXZlLCBfbGFzdEV2ZW50fSA9IHRoaXM7XG4gICAgaWYgKF9sYXN0RXZlbnQpIHtcbiAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcihfbGFzdEV2ZW50LCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKF9hY3RpdmUubGVuZ3RoKSB7XG4gICAgICB0aGlzLl91cGRhdGVIb3ZlclN0eWxlcyhfYWN0aXZlLCBfYWN0aXZlLCB0cnVlKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlU2NhbGVzKCkge1xuICAgIGVhY2godGhpcy5zY2FsZXMsIChzY2FsZSkgPT4ge1xuICAgICAgbGF5b3V0cy5yZW1vdmVCb3godGhpcywgc2NhbGUpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5lbnN1cmVTY2FsZXNIYXZlSURzKCk7XG4gICAgdGhpcy5idWlsZE9yVXBkYXRlU2NhbGVzKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jaGVja0V2ZW50QmluZGluZ3MoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBleGlzdGluZ0V2ZW50cyA9IG5ldyBTZXQoT2JqZWN0LmtleXModGhpcy5fbGlzdGVuZXJzKSk7XG4gICAgY29uc3QgbmV3RXZlbnRzID0gbmV3IFNldChvcHRpb25zLmV2ZW50cyk7XG5cbiAgICBpZiAoIXNldHNFcXVhbChleGlzdGluZ0V2ZW50cywgbmV3RXZlbnRzKSB8fCAhIXRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgIT09IG9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgLy8gVGhlIGNvbmZpZ3VyZWQgZXZlbnRzIGhhdmUgY2hhbmdlZC4gUmViaW5kLlxuICAgICAgdGhpcy51bmJpbmRFdmVudHMoKTtcbiAgICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZUhpZGRlbkluZGljZXMoKSB7XG4gICAgY29uc3Qge19oaWRkZW5JbmRpY2VzfSA9IHRoaXM7XG4gICAgY29uc3QgY2hhbmdlcyA9IHRoaXMuX2dldFVuaWZvcm1EYXRhQ2hhbmdlcygpIHx8IFtdO1xuICAgIGZvciAoY29uc3Qge21ldGhvZCwgc3RhcnQsIGNvdW50fSBvZiBjaGFuZ2VzKSB7XG4gICAgICBjb25zdCBtb3ZlID0gbWV0aG9kID09PSAnX3JlbW92ZUVsZW1lbnRzJyA/IC1jb3VudCA6IGNvdW50O1xuICAgICAgbW92ZU51bWVyaWNLZXlzKF9oaWRkZW5JbmRpY2VzLCBzdGFydCwgbW92ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0VW5pZm9ybURhdGFDaGFuZ2VzKCkge1xuICAgIGNvbnN0IF9kYXRhQ2hhbmdlcyA9IHRoaXMuX2RhdGFDaGFuZ2VzO1xuICAgIGlmICghX2RhdGFDaGFuZ2VzIHx8ICFfZGF0YUNoYW5nZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fZGF0YUNoYW5nZXMgPSBbXTtcbiAgICBjb25zdCBkYXRhc2V0Q291bnQgPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoO1xuICAgIGNvbnN0IG1ha2VTZXQgPSAoaWR4KSA9PiBuZXcgU2V0KFxuICAgICAgX2RhdGFDaGFuZ2VzXG4gICAgICAgIC5maWx0ZXIoYyA9PiBjWzBdID09PSBpZHgpXG4gICAgICAgIC5tYXAoKGMsIGkpID0+IGkgKyAnLCcgKyBjLnNwbGljZSgxKS5qb2luKCcsJykpXG4gICAgKTtcblxuICAgIGNvbnN0IGNoYW5nZVNldCA9IG1ha2VTZXQoMCk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBkYXRhc2V0Q291bnQ7IGkrKykge1xuICAgICAgaWYgKCFzZXRzRXF1YWwoY2hhbmdlU2V0LCBtYWtlU2V0KGkpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKGNoYW5nZVNldClcbiAgICAgIC5tYXAoYyA9PiBjLnNwbGl0KCcsJykpXG4gICAgICAubWFwKGEgPT4gKHttZXRob2Q6IGFbMV0sIHN0YXJ0OiArYVsyXSwgY291bnQ6ICthWzNdfSkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFVwZGF0ZXMgdGhlIGNoYXJ0IGxheW91dCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlTGF5b3V0YFxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJMYXlvdXRgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZUxheW91dChtaW5QYWRkaW5nKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlTGF5b3V0Jywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsYXlvdXRzLnVwZGF0ZSh0aGlzLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgbWluUGFkZGluZyk7XG5cbiAgICBjb25zdCBhcmVhID0gdGhpcy5jaGFydEFyZWE7XG4gICAgY29uc3Qgbm9BcmVhID0gYXJlYS53aWR0aCA8PSAwIHx8IGFyZWEuaGVpZ2h0IDw9IDA7XG5cbiAgICB0aGlzLl9sYXllcnMgPSBbXTtcbiAgICBlYWNoKHRoaXMuYm94ZXMsIChib3gpID0+IHtcbiAgICAgIGlmIChub0FyZWEgJiYgYm94LnBvc2l0aW9uID09PSAnY2hhcnRBcmVhJykge1xuICAgICAgICAvLyBTa2lwIGRyYXdpbmcgYW5kIGNvbmZpZ3VyaW5nIGNoYXJ0QXJlYSBib3hlcyB3aGVuIGNoYXJ0QXJlYSBpcyB6ZXJvIG9yIG5lZ2F0aXZlXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gY29uZmlndXJlIGlzIGNhbGxlZCB0d2ljZSwgb25jZSBpbiBjb3JlLnNjYWxlLnVwZGF0ZSBhbmQgb25jZSBoZXJlLlxuICAgICAgLy8gSGVyZSB0aGUgYm94ZXMgYXJlIGZ1bGx5IHVwZGF0ZWQgYW5kIGF0IHRoZWlyIGZpbmFsIHBvc2l0aW9ucy5cbiAgICAgIGlmIChib3guY29uZmlndXJlKSB7XG4gICAgICAgIGJveC5jb25maWd1cmUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2xheWVycy5wdXNoKC4uLmJveC5fbGF5ZXJzKCkpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5fbGF5ZXJzLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICBpdGVtLl9pZHggPSBpbmRleDtcbiAgICB9KTtcblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJMYXlvdXQnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVcGRhdGVzIGFsbCBkYXRhc2V0cyB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldHNVcGRhdGVgXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckRhdGFzZXRzVXBkYXRlYC5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVEYXRhc2V0cyhtb2RlKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldHNVcGRhdGUnLCB7bW9kZSwgY2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGhpcy5nZXREYXRhc2V0TWV0YShpKS5jb250cm9sbGVyLmNvbmZpZ3VyZSgpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGhpcy5fdXBkYXRlRGF0YXNldChpLCBpc0Z1bmN0aW9uKG1vZGUpID8gbW9kZSh7ZGF0YXNldEluZGV4OiBpfSkgOiBtb2RlKTtcbiAgICB9XG5cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldHNVcGRhdGUnLCB7bW9kZX0pO1xuICB9XG5cbiAgLyoqXG5cdCAqIFVwZGF0ZXMgZGF0YXNldCBhdCBpbmRleCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldFVwZGF0ZWBcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldFVwZGF0ZWAuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlRGF0YXNldChpbmRleCwgbW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGluZGV4KTtcbiAgICBjb25zdCBhcmdzID0ge21ldGEsIGluZGV4LCBtb2RlLCBjYW5jZWxhYmxlOiB0cnVlfTtcblxuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXRVcGRhdGUnLCBhcmdzKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBtZXRhLmNvbnRyb2xsZXIuX3VwZGF0ZShtb2RlKTtcblxuICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0VXBkYXRlJywgYXJncyk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlUmVuZGVyJywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYW5pbWF0b3IuaGFzKHRoaXMpKSB7XG4gICAgICBpZiAodGhpcy5hdHRhY2hlZCAmJiAhYW5pbWF0b3IucnVubmluZyh0aGlzKSkge1xuICAgICAgICBhbmltYXRvci5zdGFydCh0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kcmF3KCk7XG4gICAgICBvbkFuaW1hdGlvbnNDb21wbGV0ZSh7Y2hhcnQ6IHRoaXN9KTtcbiAgICB9XG4gIH1cblxuICBkcmF3KCkge1xuICAgIGxldCBpO1xuICAgIGlmICh0aGlzLl9yZXNpemVCZWZvcmVEcmF3KSB7XG4gICAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0aGlzLl9yZXNpemVCZWZvcmVEcmF3O1xuICAgICAgdGhpcy5fcmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5fcmVzaXplQmVmb3JlRHJhdyA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuY2xlYXIoKTtcblxuICAgIGlmICh0aGlzLndpZHRoIDw9IDAgfHwgdGhpcy5oZWlnaHQgPD0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURyYXcnLCB7Y2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEJlY2F1c2Ugb2YgcGx1Z2luIGhvb2tzIChiZWZvcmUvYWZ0ZXJEYXRhc2V0c0RyYXcpLCBkYXRhc2V0cyBjYW4ndFxuICAgIC8vIGN1cnJlbnRseSBiZSBwYXJ0IG9mIGxheWVycy4gSW5zdGVhZCwgd2UgZHJhd1xuICAgIC8vIGxheWVycyA8PSAwIGJlZm9yZShkZWZhdWx0LCBiYWNrd2FyZCBjb21wYXQpLCBhbmQgdGhlIHJlc3QgYWZ0ZXJcbiAgICBjb25zdCBsYXllcnMgPSB0aGlzLl9sYXllcnM7XG4gICAgZm9yIChpID0gMDsgaSA8IGxheWVycy5sZW5ndGggJiYgbGF5ZXJzW2ldLnogPD0gMDsgKytpKSB7XG4gICAgICBsYXllcnNbaV0uZHJhdyh0aGlzLmNoYXJ0QXJlYSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZHJhd0RhdGFzZXRzKCk7XG5cbiAgICAvLyBSZXN0IG9mIGxheWVyc1xuICAgIGZvciAoOyBpIDwgbGF5ZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICBsYXllcnNbaV0uZHJhdyh0aGlzLmNoYXJ0QXJlYSk7XG4gICAgfVxuXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRyYXcnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFNvcnRlZERhdGFzZXRNZXRhcyhmaWx0ZXJWaXNpYmxlKSB7XG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLl9zb3J0ZWRNZXRhc2V0cztcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgaSwgaWxlbjtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IG1ldGEgPSBtZXRhc2V0c1tpXTtcbiAgICAgIGlmICghZmlsdGVyVmlzaWJsZSB8fCBtZXRhLnZpc2libGUpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobWV0YSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXRzIHRoZSB2aXNpYmxlIGRhdGFzZXQgbWV0YXMgaW4gZHJhd2luZyBvcmRlclxuXHQgKiBAcmV0dXJuIHtvYmplY3RbXX1cblx0ICovXG4gIGdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFNvcnRlZERhdGFzZXRNZXRhcyh0cnVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBEcmF3cyBhbGwgZGF0YXNldHMgdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZURhdGFzZXRzRHJhd2Bcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldHNEcmF3YC5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kcmF3RGF0YXNldHMoKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldHNEcmF3Jywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBtZXRhc2V0cyA9IHRoaXMuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGZvciAobGV0IGkgPSBtZXRhc2V0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGhpcy5fZHJhd0RhdGFzZXQobWV0YXNldHNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0c0RyYXcnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBEcmF3cyBkYXRhc2V0IGF0IGluZGV4IHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVEYXRhc2V0RHJhd2Bcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldERyYXdgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2RyYXdEYXRhc2V0KG1ldGEpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBjbGlwID0gbWV0YS5fY2xpcDtcbiAgICBjb25zdCB1c2VDbGlwID0gIWNsaXAuZGlzYWJsZWQ7XG4gICAgY29uc3QgYXJlYSA9IGdldERhdGFzZXRBcmVhKG1ldGEsIHRoaXMuY2hhcnRBcmVhKTtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgbWV0YSxcbiAgICAgIGluZGV4OiBtZXRhLmluZGV4LFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgIH07XG5cbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0RHJhdycsIGFyZ3MpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh1c2VDbGlwKSB7XG4gICAgICBjbGlwQXJlYShjdHgsIHtcbiAgICAgICAgbGVmdDogY2xpcC5sZWZ0ID09PSBmYWxzZSA/IDAgOiBhcmVhLmxlZnQgLSBjbGlwLmxlZnQsXG4gICAgICAgIHJpZ2h0OiBjbGlwLnJpZ2h0ID09PSBmYWxzZSA/IHRoaXMud2lkdGggOiBhcmVhLnJpZ2h0ICsgY2xpcC5yaWdodCxcbiAgICAgICAgdG9wOiBjbGlwLnRvcCA9PT0gZmFsc2UgPyAwIDogYXJlYS50b3AgLSBjbGlwLnRvcCxcbiAgICAgICAgYm90dG9tOiBjbGlwLmJvdHRvbSA9PT0gZmFsc2UgPyB0aGlzLmhlaWdodCA6IGFyZWEuYm90dG9tICsgY2xpcC5ib3R0b21cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIG1ldGEuY29udHJvbGxlci5kcmF3KCk7XG5cbiAgICBpZiAodXNlQ2xpcCkge1xuICAgICAgdW5jbGlwQXJlYShjdHgpO1xuICAgIH1cblxuICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0RHJhdycsIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBwb2ludCBpcyBpbiB0aGUgY2hhcnQgYXJlYS5cbiAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSBpbiByZWxhdGl2ZSBjb29yZGluYXRlcyAoc2VlLCBlLmcuLCBnZXRSZWxhdGl2ZVBvc2l0aW9uKVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGlzUG9pbnRJbkFyZWEocG9pbnQpIHtcbiAgICByZXR1cm4gX2lzUG9pbnRJbkFyZWEocG9pbnQsIHRoaXMuY2hhcnRBcmVhLCB0aGlzLl9taW5QYWRkaW5nKTtcbiAgfVxuXG4gIGdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgbW9kZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IG1ldGhvZCA9IEludGVyYWN0aW9uLm1vZGVzW21vZGVdO1xuICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbWV0aG9kKHRoaXMsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgICBjb25zdCBtZXRhc2V0cyA9IHRoaXMuX21ldGFzZXRzO1xuICAgIGxldCBtZXRhID0gbWV0YXNldHMuZmlsdGVyKHggPT4geCAmJiB4Ll9kYXRhc2V0ID09PSBkYXRhc2V0KS5wb3AoKTtcblxuICAgIGlmICghbWV0YSkge1xuICAgICAgbWV0YSA9IHtcbiAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgZGF0YTogW10sXG4gICAgICAgIGRhdGFzZXQ6IG51bGwsXG4gICAgICAgIGNvbnRyb2xsZXI6IG51bGwsXG4gICAgICAgIGhpZGRlbjogbnVsbCxcdFx0XHQvLyBTZWUgaXNEYXRhc2V0VmlzaWJsZSgpIGNvbW1lbnRcbiAgICAgICAgeEF4aXNJRDogbnVsbCxcbiAgICAgICAgeUF4aXNJRDogbnVsbCxcbiAgICAgICAgb3JkZXI6IGRhdGFzZXQgJiYgZGF0YXNldC5vcmRlciB8fCAwLFxuICAgICAgICBpbmRleDogZGF0YXNldEluZGV4LFxuICAgICAgICBfZGF0YXNldDogZGF0YXNldCxcbiAgICAgICAgX3BhcnNlZDogW10sXG4gICAgICAgIF9zb3J0ZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgICAgbWV0YXNldHMucHVzaChtZXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWV0YTtcbiAgfVxuXG4gIGdldENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQgfHwgKHRoaXMuJGNvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwsIHtjaGFydDogdGhpcywgdHlwZTogJ2NoYXJ0J30pKTtcbiAgfVxuXG4gIGdldFZpc2libGVEYXRhc2V0Q291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpLmxlbmd0aDtcbiAgfVxuXG4gIGlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuICAgIGlmICghZGF0YXNldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cbiAgICAvLyBtZXRhLmhpZGRlbiBpcyBhIHBlciBjaGFydCBkYXRhc2V0IGhpZGRlbiBmbGFnIG92ZXJyaWRlIHdpdGggMyBzdGF0ZXM6IGlmIHRydWUgb3IgZmFsc2UsXG4gICAgLy8gdGhlIGRhdGFzZXQuaGlkZGVuIHZhbHVlIGlzIGlnbm9yZWQsIGVsc2UgaWYgbnVsbCwgdGhlIGRhdGFzZXQgaGlkZGVuIHN0YXRlIGlzIHJldHVybmVkLlxuICAgIHJldHVybiB0eXBlb2YgbWV0YS5oaWRkZW4gPT09ICdib29sZWFuJyA/ICFtZXRhLmhpZGRlbiA6ICFkYXRhc2V0LmhpZGRlbjtcbiAgfVxuXG4gIHNldERhdGFzZXRWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgdmlzaWJsZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgbWV0YS5oaWRkZW4gPSAhdmlzaWJsZTtcbiAgfVxuXG4gIHRvZ2dsZURhdGFWaXNpYmlsaXR5KGluZGV4KSB7XG4gICAgdGhpcy5faGlkZGVuSW5kaWNlc1tpbmRleF0gPSAhdGhpcy5faGlkZGVuSW5kaWNlc1tpbmRleF07XG4gIH1cblxuICBnZXREYXRhVmlzaWJpbGl0eShpbmRleCkge1xuICAgIHJldHVybiAhdGhpcy5faGlkZGVuSW5kaWNlc1tpbmRleF07XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4LCB2aXNpYmxlKSB7XG4gICAgY29uc3QgbW9kZSA9IHZpc2libGUgPyAnc2hvdycgOiAnaGlkZSc7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICBjb25zdCBhbmltcyA9IG1ldGEuY29udHJvbGxlci5fcmVzb2x2ZUFuaW1hdGlvbnModW5kZWZpbmVkLCBtb2RlKTtcblxuICAgIGlmIChkZWZpbmVkKGRhdGFJbmRleCkpIHtcbiAgICAgIG1ldGEuZGF0YVtkYXRhSW5kZXhdLmhpZGRlbiA9ICF2aXNpYmxlO1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXREYXRhc2V0VmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIHZpc2libGUpO1xuICAgICAgLy8gQW5pbWF0ZSB2aXNpYmxlIHN0YXRlLCBzbyBoaWRlIGFuaW1hdGlvbiBjYW4gYmUgc2Vlbi4gVGhpcyBjb3VsZCBiZSBoYW5kbGVkIGJldHRlciBpZiB1cGRhdGUgLyB1cGRhdGVEYXRhc2V0IHJldHVybmVkIGEgUHJvbWlzZS5cbiAgICAgIGFuaW1zLnVwZGF0ZShtZXRhLCB7dmlzaWJsZX0pO1xuICAgICAgdGhpcy51cGRhdGUoKGN0eCkgPT4gY3R4LmRhdGFzZXRJbmRleCA9PT0gZGF0YXNldEluZGV4ID8gbW9kZSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICB9XG5cbiAgaGlkZShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCkge1xuICAgIHRoaXMuX3VwZGF0ZVZpc2liaWxpdHkoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgsIGZhbHNlKTtcbiAgfVxuXG4gIHNob3coZGF0YXNldEluZGV4LCBkYXRhSW5kZXgpIHtcbiAgICB0aGlzLl91cGRhdGVWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2Rlc3Ryb3lEYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fbWV0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgICBpZiAobWV0YSAmJiBtZXRhLmNvbnRyb2xsZXIpIHtcbiAgICAgIG1ldGEuY29udHJvbGxlci5fZGVzdHJveSgpO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5fbWV0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgfVxuXG4gIF9zdG9wKCkge1xuICAgIGxldCBpLCBpbGVuO1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIGFuaW1hdG9yLnJlbW92ZSh0aGlzKTtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEoaSk7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURlc3Ryb3knKTtcbiAgICBjb25zdCB7Y2FudmFzLCBjdHh9ID0gdGhpcztcblxuICAgIHRoaXMuX3N0b3AoKTtcbiAgICB0aGlzLmNvbmZpZy5jbGVhckNhY2hlKCk7XG5cbiAgICBpZiAoY2FudmFzKSB7XG4gICAgICB0aGlzLnVuYmluZEV2ZW50cygpO1xuICAgICAgY2xlYXJDYW52YXMoY2FudmFzLCBjdHgpO1xuICAgICAgdGhpcy5wbGF0Zm9ybS5yZWxlYXNlQ29udGV4dChjdHgpO1xuICAgICAgdGhpcy5jYW52YXMgPSBudWxsO1xuICAgICAgdGhpcy5jdHggPSBudWxsO1xuICAgIH1cblxuICAgIGRlbGV0ZSBpbnN0YW5jZXNbdGhpcy5pZF07XG5cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGVzdHJveScpO1xuICB9XG5cbiAgdG9CYXNlNjRJbWFnZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzLnRvRGF0YVVSTCguLi5hcmdzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLmJpbmRVc2VyRXZlbnRzKCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICB0aGlzLmJpbmRSZXNwb25zaXZlRXZlbnRzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXR0YWNoZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYmluZFVzZXJFdmVudHMoKSB7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgIGNvbnN0IHBsYXRmb3JtID0gdGhpcy5wbGF0Zm9ybTtcblxuICAgIGNvbnN0IF9hZGQgPSAodHlwZSwgbGlzdGVuZXIpID0+IHtcbiAgICAgIHBsYXRmb3JtLmFkZEV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgbGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgfTtcblxuICAgIGNvbnN0IGxpc3RlbmVyID0gKGUsIHgsIHkpID0+IHtcbiAgICAgIGUub2Zmc2V0WCA9IHg7XG4gICAgICBlLm9mZnNldFkgPSB5O1xuICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyKGUpO1xuICAgIH07XG5cbiAgICBlYWNoKHRoaXMub3B0aW9ucy5ldmVudHMsICh0eXBlKSA9PiBfYWRkKHR5cGUsIGxpc3RlbmVyKSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGJpbmRSZXNwb25zaXZlRXZlbnRzKCkge1xuICAgIGlmICghdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycykge1xuICAgICAgdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyA9IHt9O1xuICAgIH1cbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzO1xuICAgIGNvbnN0IHBsYXRmb3JtID0gdGhpcy5wbGF0Zm9ybTtcblxuICAgIGNvbnN0IF9hZGQgPSAodHlwZSwgbGlzdGVuZXIpID0+IHtcbiAgICAgIHBsYXRmb3JtLmFkZEV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgbGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgfTtcbiAgICBjb25zdCBfcmVtb3ZlID0gKHR5cGUsIGxpc3RlbmVyKSA9PiB7XG4gICAgICBpZiAobGlzdGVuZXJzW3R5cGVdKSB7XG4gICAgICAgIHBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICBkZWxldGUgbGlzdGVuZXJzW3R5cGVdO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBsaXN0ZW5lciA9ICh3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxldCBkZXRhY2hlZDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItY29uc3RcbiAgICBjb25zdCBhdHRhY2hlZCA9ICgpID0+IHtcbiAgICAgIF9yZW1vdmUoJ2F0dGFjaCcsIGF0dGFjaGVkKTtcblxuICAgICAgdGhpcy5hdHRhY2hlZCA9IHRydWU7XG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuXG4gICAgICBfYWRkKCdyZXNpemUnLCBsaXN0ZW5lcik7XG4gICAgICBfYWRkKCdkZXRhY2gnLCBkZXRhY2hlZCk7XG4gICAgfTtcblxuICAgIGRldGFjaGVkID0gKCkgPT4ge1xuICAgICAgdGhpcy5hdHRhY2hlZCA9IGZhbHNlO1xuXG4gICAgICBfcmVtb3ZlKCdyZXNpemUnLCBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFN0b3AgYW5pbWF0aW5nIGFuZCByZW1vdmUgbWV0YXNldHMsIHNvIHdoZW4gcmUtYXR0YWNoZWQsIHRoZSBhbmltYXRpb25zIHN0YXJ0IGZyb20gYmVnaW5uaW5nLlxuICAgICAgdGhpcy5fc3RvcCgpO1xuICAgICAgdGhpcy5fcmVzaXplKDAsIDApO1xuXG4gICAgICBfYWRkKCdhdHRhY2gnLCBhdHRhY2hlZCk7XG4gICAgfTtcblxuICAgIGlmIChwbGF0Zm9ybS5pc0F0dGFjaGVkKHRoaXMuY2FudmFzKSkge1xuICAgICAgYXR0YWNoZWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGV0YWNoZWQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIHVuYmluZEV2ZW50cygpIHtcbiAgICBlYWNoKHRoaXMuX2xpc3RlbmVycywgKGxpc3RlbmVyLCB0eXBlKSA9PiB7XG4gICAgICB0aGlzLnBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgIH0pO1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuXG4gICAgZWFjaCh0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzLCAobGlzdGVuZXIsIHR5cGUpID0+IHtcbiAgICAgIHRoaXMucGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgfSk7XG4gICAgdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHVwZGF0ZUhvdmVyU3R5bGUoaXRlbXMsIG1vZGUsIGVuYWJsZWQpIHtcbiAgICBjb25zdCBwcmVmaXggPSBlbmFibGVkID8gJ3NldCcgOiAncmVtb3ZlJztcbiAgICBsZXQgbWV0YSwgaXRlbSwgaSwgaWxlbjtcblxuICAgIGlmIChtb2RlID09PSAnZGF0YXNldCcpIHtcbiAgICAgIG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGl0ZW1zWzBdLmRhdGFzZXRJbmRleCk7XG4gICAgICBtZXRhLmNvbnRyb2xsZXJbJ18nICsgcHJlZml4ICsgJ0RhdGFzZXRIb3ZlclN0eWxlJ10oKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICBjb25zdCBjb250cm9sbGVyID0gaXRlbSAmJiB0aGlzLmdldERhdGFzZXRNZXRhKGl0ZW0uZGF0YXNldEluZGV4KS5jb250cm9sbGVyO1xuICAgICAgaWYgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlcltwcmVmaXggKyAnSG92ZXJTdHlsZSddKGl0ZW0uZWxlbWVudCwgaXRlbS5kYXRhc2V0SW5kZXgsIGl0ZW0uaW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXQgYWN0aXZlIChob3ZlcmVkKSBlbGVtZW50c1xuXHQgKiBAcmV0dXJucyBhcnJheVxuXHQgKi9cbiAgZ2V0QWN0aXZlRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBTZXQgYWN0aXZlIChob3ZlcmVkKSBlbGVtZW50c1xuXHQgKiBAcGFyYW0ge2FycmF5fSBhY3RpdmVFbGVtZW50cyBOZXcgYWN0aXZlIGRhdGEgcG9pbnRzXG5cdCAqL1xuICBzZXRBY3RpdmVFbGVtZW50cyhhY3RpdmVFbGVtZW50cykge1xuICAgIGNvbnN0IGxhc3RBY3RpdmUgPSB0aGlzLl9hY3RpdmUgfHwgW107XG4gICAgY29uc3QgYWN0aXZlID0gYWN0aXZlRWxlbWVudHMubWFwKCh7ZGF0YXNldEluZGV4LCBpbmRleH0pID0+IHtcbiAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgICBpZiAoIW1ldGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBkYXRhc2V0IGZvdW5kIGF0IGluZGV4ICcgKyBkYXRhc2V0SW5kZXgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhc2V0SW5kZXgsXG4gICAgICAgIGVsZW1lbnQ6IG1ldGEuZGF0YVtpbmRleF0sXG4gICAgICAgIGluZGV4LFxuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBjaGFuZ2VkID0gIV9lbGVtZW50c0VxdWFsKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG5cbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gYWN0aXZlO1xuICAgICAgLy8gTWFrZSBzdXJlIHdlIGRvbid0IHVzZSB0aGUgcHJldmlvdXMgbW91c2UgZXZlbnQgdG8gb3ZlcnJpZGUgdGhlIGFjdGl2ZSBlbGVtZW50cyBpbiB1cGRhdGUuXG4gICAgICB0aGlzLl9sYXN0RXZlbnQgPSBudWxsO1xuICAgICAgdGhpcy5fdXBkYXRlSG92ZXJTdHlsZXMoYWN0aXZlLCBsYXN0QWN0aXZlKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQ2FsbHMgZW5hYmxlZCBwbHVnaW5zIG9uIHRoZSBzcGVjaWZpZWQgaG9vayBhbmQgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cblx0ICogVGhpcyBtZXRob2QgaW1tZWRpYXRlbHkgcmV0dXJucyBhcyBzb29uIGFzIGEgcGx1Z2luIGV4cGxpY2l0bHkgcmV0dXJucyBmYWxzZS4gVGhlXG5cdCAqIHJldHVybmVkIHZhbHVlIGNhbiBiZSB1c2VkLCBmb3IgaW5zdGFuY2UsIHRvIGludGVycnVwdCB0aGUgY3VycmVudCBhY3Rpb24uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBob29rIC0gVGhlIG5hbWUgb2YgdGhlIHBsdWdpbiBtZXRob2QgdG8gY2FsbCAoZS5nLiAnYmVmb3JlVXBkYXRlJykuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnc10gLSBFeHRyYSBhcmd1bWVudHMgdG8gYXBwbHkgdG8gdGhlIGhvb2sgY2FsbC5cbiAgICogQHBhcmFtIHtpbXBvcnQoJy4vY29yZS5wbHVnaW5zLmpzJykuZmlsdGVyQ2FsbGJhY2t9IFtmaWx0ZXJdIC0gRmlsdGVyaW5nIGZ1bmN0aW9uIGZvciBsaW1pdGluZyB3aGljaCBwbHVnaW5zIGFyZSBub3RpZmllZFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gZmFsc2UgaWYgYW55IG9mIHRoZSBwbHVnaW5zIHJldHVybiBmYWxzZSwgZWxzZSByZXR1cm5zIHRydWUuXG5cdCAqL1xuICBub3RpZnlQbHVnaW5zKGhvb2ssIGFyZ3MsIGZpbHRlcikge1xuICAgIHJldHVybiB0aGlzLl9wbHVnaW5zLm5vdGlmeSh0aGlzLCBob29rLCBhcmdzLCBmaWx0ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgcGx1Z2luIHdpdGggdGhlIHNwZWNpZmljIElEIGlzIHJlZ2lzdGVyZWQgYW5kIGVuYWJsZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBsdWdpbklkIC0gVGhlIElEIG9mIHRoZSBwbHVnaW4gb2Ygd2hpY2ggdG8gY2hlY2sgaWYgaXQgaXMgZW5hYmxlZFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGlzUGx1Z2luRW5hYmxlZChwbHVnaW5JZCkge1xuICAgIHJldHVybiB0aGlzLl9wbHVnaW5zLl9jYWNoZS5maWx0ZXIocCA9PiBwLnBsdWdpbi5pZCA9PT0gcGx1Z2luSWQpLmxlbmd0aCA9PT0gMTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZUhvdmVyU3R5bGVzKGFjdGl2ZSwgbGFzdEFjdGl2ZSwgcmVwbGF5KSB7XG4gICAgY29uc3QgaG92ZXJPcHRpb25zID0gdGhpcy5vcHRpb25zLmhvdmVyO1xuICAgIGNvbnN0IGRpZmYgPSAoYSwgYikgPT4gYS5maWx0ZXIoeCA9PiAhYi5zb21lKHkgPT4geC5kYXRhc2V0SW5kZXggPT09IHkuZGF0YXNldEluZGV4ICYmIHguaW5kZXggPT09IHkuaW5kZXgpKTtcbiAgICBjb25zdCBkZWFjdGl2YXRlZCA9IGRpZmYobGFzdEFjdGl2ZSwgYWN0aXZlKTtcbiAgICBjb25zdCBhY3RpdmF0ZWQgPSByZXBsYXkgPyBhY3RpdmUgOiBkaWZmKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG5cbiAgICBpZiAoZGVhY3RpdmF0ZWQubGVuZ3RoKSB7XG4gICAgICB0aGlzLnVwZGF0ZUhvdmVyU3R5bGUoZGVhY3RpdmF0ZWQsIGhvdmVyT3B0aW9ucy5tb2RlLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGl2YXRlZC5sZW5ndGggJiYgaG92ZXJPcHRpb25zLm1vZGUpIHtcbiAgICAgIHRoaXMudXBkYXRlSG92ZXJTdHlsZShhY3RpdmF0ZWQsIGhvdmVyT3B0aW9ucy5tb2RlLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9ldmVudEhhbmRsZXIoZSwgcmVwbGF5KSB7XG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgIGV2ZW50OiBlLFxuICAgICAgcmVwbGF5LFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGluQ2hhcnRBcmVhOiB0aGlzLmlzUG9pbnRJbkFyZWEoZSlcbiAgICB9O1xuICAgIGNvbnN0IGV2ZW50RmlsdGVyID0gKHBsdWdpbikgPT4gKHBsdWdpbi5vcHRpb25zLmV2ZW50cyB8fCB0aGlzLm9wdGlvbnMuZXZlbnRzKS5pbmNsdWRlcyhlLm5hdGl2ZS50eXBlKTtcblxuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUV2ZW50JywgYXJncywgZXZlbnRGaWx0ZXIpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLl9oYW5kbGVFdmVudChlLCByZXBsYXksIGFyZ3MuaW5DaGFydEFyZWEpO1xuXG4gICAgYXJncy5jYW5jZWxhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckV2ZW50JywgYXJncywgZXZlbnRGaWx0ZXIpO1xuXG4gICAgaWYgKGNoYW5nZWQgfHwgYXJncy5jaGFuZ2VkKSB7XG4gICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEhhbmRsZSBhbiBldmVudFxuXHQgKiBAcGFyYW0ge0NoYXJ0RXZlbnR9IGUgdGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXBsYXldIC0gdHJ1ZSBpZiB0aGUgZXZlbnQgd2FzIHJlcGxheWVkIGJ5IGB1cGRhdGVgXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luQ2hhcnRBcmVhXSAtIHRydWUgaWYgdGhlIGV2ZW50IGlzIGluc2lkZSBjaGFydEFyZWFcblx0ICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgY2hhcnQgbmVlZHMgdG8gcmUtcmVuZGVyXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfaGFuZGxlRXZlbnQoZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IHtfYWN0aXZlOiBsYXN0QWN0aXZlID0gW10sIG9wdGlvbnN9ID0gdGhpcztcblxuICAgIC8vIElmIHRoZSBldmVudCBpcyByZXBsYXllZCBmcm9tIGB1cGRhdGVgLCB3ZSBzaG91bGQgZXZhbHVhdGUgd2l0aCB0aGUgZmluYWwgcG9zaXRpb25zLlxuICAgIC8vXG4gICAgLy8gVGhlIGByZXBsYXlgOlxuICAgIC8vIEl0J3MgdGhlIGxhc3QgZXZlbnQgKGV4Y2x1ZGluZyBjbGljaykgdGhhdCBoYXMgb2NjdXJyZWQgYmVmb3JlIGB1cGRhdGVgLlxuICAgIC8vIFNvIG1vdXNlIGhhcyBub3QgbW92ZWQuIEl0J3MgYWxzbyBvdmVyIHRoZSBjaGFydCwgYmVjYXVzZSB0aGVyZSBpcyBhIGByZXBsYXlgLlxuICAgIC8vXG4gICAgLy8gVGhlIHdoeTpcbiAgICAvLyBJZiBhbmltYXRpb25zIGFyZSBhY3RpdmUsIHRoZSBlbGVtZW50cyBoYXZlbid0IG1vdmVkIHlldCBjb21wYXJlZCB0byBzdGF0ZSBiZWZvcmUgdXBkYXRlLlxuICAgIC8vIEJ1dCBpZiB0aGV5IHdpbGwsIHdlIGFyZSBhY3RpdmF0aW5nIHRoZSBlbGVtZW50cyB0aGF0IHdvdWxkIGJlIGFjdGl2ZSwgaWYgdGhpcyBjaGVja1xuICAgIC8vIHdhcyBkb25lIGFmdGVyIHRoZSBhbmltYXRpb25zIGhhdmUgY29tcGxldGVkLiA9PiBcImZpbmFsIHBvc2l0aW9uc1wiLlxuICAgIC8vIElmIHRoZXJlIGlzIG5vIGFuaW1hdGlvbnMsIHRoZSBcImZpbmFsXCIgYW5kIFwiY3VycmVudFwiIHBvc2l0aW9ucyBhcmUgZXF1YWwuXG4gICAgLy8gVGhpcyBpcyBkb25lIHNvIHdlIGRvIG5vdCBoYXZlIHRvIGV2YWx1YXRlIHRoZSBhY3RpdmUgZWxlbWVudHMgZWFjaCBhbmltYXRpb24gZnJhbWVcbiAgICAvLyAtIGl0IHdvdWxkIGJlIGV4cGVuc2l2ZS5cbiAgICBjb25zdCB1c2VGaW5hbFBvc2l0aW9uID0gcmVwbGF5O1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2dldEFjdGl2ZUVsZW1lbnRzKGUsIGxhc3RBY3RpdmUsIGluQ2hhcnRBcmVhLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCBpc0NsaWNrID0gX2lzQ2xpY2tFdmVudChlKTtcbiAgICBjb25zdCBsYXN0RXZlbnQgPSBkZXRlcm1pbmVMYXN0RXZlbnQoZSwgdGhpcy5fbGFzdEV2ZW50LCBpbkNoYXJ0QXJlYSwgaXNDbGljayk7XG5cbiAgICBpZiAoaW5DaGFydEFyZWEpIHtcbiAgICAgIC8vIFNldCBfbGFzdEV2ZW50IHRvIG51bGwgd2hpbGUgd2UgYXJlIHByb2Nlc3NpbmcgdGhlIGV2ZW50IGhhbmRsZXJzLlxuICAgICAgLy8gVGhpcyBwcmV2ZW50cyByZWN1cnNpb24gaWYgdGhlIGhhbmRsZXIgY2FsbHMgY2hhcnQudXBkYXRlKClcbiAgICAgIHRoaXMuX2xhc3RFdmVudCA9IG51bGw7XG5cbiAgICAgIC8vIEludm9rZSBvbkhvdmVyIGhvb2tcbiAgICAgIGNhbGxDYWxsYmFjayhvcHRpb25zLm9uSG92ZXIsIFtlLCBhY3RpdmUsIHRoaXNdLCB0aGlzKTtcblxuICAgICAgaWYgKGlzQ2xpY2spIHtcbiAgICAgICAgY2FsbENhbGxiYWNrKG9wdGlvbnMub25DbGljaywgW2UsIGFjdGl2ZSwgdGhpc10sIHRoaXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGNoYW5nZWQgPSAhX2VsZW1lbnRzRXF1YWwoYWN0aXZlLCBsYXN0QWN0aXZlKTtcbiAgICBpZiAoY2hhbmdlZCB8fCByZXBsYXkpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKGFjdGl2ZSwgbGFzdEFjdGl2ZSwgcmVwbGF5KTtcbiAgICB9XG5cbiAgICB0aGlzLl9sYXN0RXZlbnQgPSBsYXN0RXZlbnQ7XG5cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NoYXJ0RXZlbnR9IGUgLSBUaGUgZXZlbnRcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQWN0aXZlRWxlbWVudFtdfSBsYXN0QWN0aXZlIC0gUHJldmlvdXNseSBhY3RpdmUgZWxlbWVudHNcbiAgICogQHBhcmFtIHtib29sZWFufSBpbkNoYXJ0QXJlYSAtIElzIHRoZSBlbnZlbnQgaW5zaWRlIGNoYXJ0QXJlYVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVzZUZpbmFsUG9zaXRpb24gLSBTaG91bGQgdGhlIGV2YWx1YXRpb24gYmUgZG9uZSB3aXRoIGN1cnJlbnQgb3IgZmluYWwgKGFmdGVyIGFuaW1hdGlvbikgZWxlbWVudCBwb3NpdGlvbnNcbiAgICogQHJldHVybnMge2ltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5BY3RpdmVFbGVtZW50W119IC0gVGhlIGFjdGl2ZSBlbGVtZW50c1xuICAgKiBAcHJhdmF0ZVxuICAgKi9cbiAgX2dldEFjdGl2ZUVsZW1lbnRzKGUsIGxhc3RBY3RpdmUsIGluQ2hhcnRBcmVhLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGlmICghaW5DaGFydEFyZWEpIHtcbiAgICAgIC8vIExldCB1c2VyIGNvbnRyb2wgdGhlIGFjdGl2ZSBlbGVtZW50cyBvdXRzaWRlIGNoYXJ0QXJlYS4gRWcuIHVzaW5nIExlZ2VuZC5cbiAgICAgIHJldHVybiBsYXN0QWN0aXZlO1xuICAgIH1cblxuICAgIGNvbnN0IGhvdmVyT3B0aW9ucyA9IHRoaXMub3B0aW9ucy5ob3ZlcjtcbiAgICByZXR1cm4gdGhpcy5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIGhvdmVyT3B0aW9ucy5tb2RlLCBob3Zlck9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG59XG5cbi8vIEB0cy1pZ25vcmVcbmZ1bmN0aW9uIGludmFsaWRhdGVQbHVnaW5zKCkge1xuICByZXR1cm4gZWFjaChDaGFydC5pbnN0YW5jZXMsIChjaGFydCkgPT4gY2hhcnQuX3BsdWdpbnMuaW52YWxpZGF0ZSgpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2hhcnQ7XG4iLCAiaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi4vY29yZS9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IHtfYW5nbGVCZXR3ZWVuLCBnZXRBbmdsZUZyb21Qb2ludCwgVEFVLCBIQUxGX1BJLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge1BJLCBfaXNCZXR3ZWVuLCBfbGltaXRWYWx1ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtfcmVhZFZhbHVlVG9Qcm9wc30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm9wdGlvbnMuanMnO1xuaW1wb3J0IHR5cGUge0FyY09wdGlvbnMsIFBvaW50fSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5cblxuZnVuY3Rpb24gY2xpcEFyYyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgZWxlbWVudDogQXJjRWxlbWVudCwgZW5kQW5nbGU6IG51bWJlcikge1xuICBjb25zdCB7c3RhcnRBbmdsZSwgcGl4ZWxNYXJnaW4sIHgsIHksIG91dGVyUmFkaXVzLCBpbm5lclJhZGl1c30gPSBlbGVtZW50O1xuICBsZXQgYW5nbGVNYXJnaW4gPSBwaXhlbE1hcmdpbiAvIG91dGVyUmFkaXVzO1xuXG4gIC8vIERyYXcgYW4gaW5uZXIgYm9yZGVyIGJ5IGNsaXBwaW5nIHRoZSBhcmMgYW5kIGRyYXdpbmcgYSBkb3VibGUtd2lkdGggYm9yZGVyXG4gIC8vIEVubGFyZ2UgdGhlIGNsaXBwaW5nIGFyYyBieSAwLjMzIHBpeGVscyB0byBlbGltaW5hdGUgZ2xpdGNoZXMgYmV0d2VlbiBib3JkZXJzXG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCBvdXRlclJhZGl1cywgc3RhcnRBbmdsZSAtIGFuZ2xlTWFyZ2luLCBlbmRBbmdsZSArIGFuZ2xlTWFyZ2luKTtcbiAgaWYgKGlubmVyUmFkaXVzID4gcGl4ZWxNYXJnaW4pIHtcbiAgICBhbmdsZU1hcmdpbiA9IHBpeGVsTWFyZ2luIC8gaW5uZXJSYWRpdXM7XG4gICAgY3R4LmFyYyh4LCB5LCBpbm5lclJhZGl1cywgZW5kQW5nbGUgKyBhbmdsZU1hcmdpbiwgc3RhcnRBbmdsZSAtIGFuZ2xlTWFyZ2luLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBjdHguYXJjKHgsIHksIHBpeGVsTWFyZ2luLCBlbmRBbmdsZSArIEhBTEZfUEksIHN0YXJ0QW5nbGUgLSBIQUxGX1BJKTtcbiAgfVxuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5jbGlwKCk7XG59XG5cbmZ1bmN0aW9uIHRvUmFkaXVzQ29ybmVycyh2YWx1ZSkge1xuICByZXR1cm4gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIFsnb3V0ZXJTdGFydCcsICdvdXRlckVuZCcsICdpbm5lclN0YXJ0JywgJ2lubmVyRW5kJ10pO1xufVxuXG4vKipcbiAqIFBhcnNlIGJvcmRlciByYWRpdXMgZnJvbSB0aGUgcHJvdmlkZWQgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBwYXJzZUJvcmRlclJhZGl1cyhhcmM6IEFyY0VsZW1lbnQsIGlubmVyUmFkaXVzOiBudW1iZXIsIG91dGVyUmFkaXVzOiBudW1iZXIsIGFuZ2xlRGVsdGE6IG51bWJlcikge1xuICBjb25zdCBvID0gdG9SYWRpdXNDb3JuZXJzKGFyYy5vcHRpb25zLmJvcmRlclJhZGl1cyk7XG4gIGNvbnN0IGhhbGZUaGlja25lc3MgPSAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyAyO1xuICBjb25zdCBpbm5lckxpbWl0ID0gTWF0aC5taW4oaGFsZlRoaWNrbmVzcywgYW5nbGVEZWx0YSAqIGlubmVyUmFkaXVzIC8gMik7XG5cbiAgLy8gT3V0ZXIgbGltaXRzIGFyZSBjb21wbGljYXRlZC4gV2Ugd2FudCB0byBjb21wdXRlIHRoZSBhdmFpbGFibGUgYW5ndWxhciBkaXN0YW5jZSBhdFxuICAvLyBhIHJhZGl1cyBvZiBvdXRlclJhZGl1cyAtIGJvcmRlclJhZGl1cyBiZWNhdXNlIGZvciBzbWFsbCBhbmd1bGFyIGRpc3RhbmNlcywgdGhpcyB0ZXJtIGxpbWl0cy5cbiAgLy8gV2UgY29tcHV0ZSBhdCByID0gb3V0ZXJSYWRpdXMgLSBib3JkZXJSYWRpdXMgYmVjYXVzZSB0aGlzIGNpcmNsZSBkZWZpbmVzIHRoZSBjZW50ZXIgb2YgdGhlIGJvcmRlciBjb3JuZXJzLlxuICAvL1xuICAvLyBJZiB0aGUgYm9yZGVyUmFkaXVzIGlzIGxhcmdlLCB0aGF0IHZhbHVlIGNhbiBiZWNvbWUgbmVnYXRpdmUuXG4gIC8vIFRoaXMgY2F1c2VzIHRoZSBvdXRlciBib3JkZXJzIHRvIGxvc2UgdGhlaXIgcmFkaXVzIGVudGlyZWx5LCB3aGljaCBpcyByYXRoZXIgdW5leHBlY3RlZC4gVG8gc29sdmUgdGhhdCwgaWYgYm9yZGVyUmFkaXVzID4gb3V0ZXJSYWRpdXNcbiAgLy8gd2Uga25vdyB0aGF0IHRoZSB0aGlja25lc3MgdGVybSB3aWxsIGRvbWluYXRlIGFuZCBjb21wdXRlIHRoZSBsaW1pdHMgYXQgdGhhdCBwb2ludFxuICBjb25zdCBjb21wdXRlT3V0ZXJMaW1pdCA9ICh2YWwpID0+IHtcbiAgICBjb25zdCBvdXRlckFyY0xpbWl0ID0gKG91dGVyUmFkaXVzIC0gTWF0aC5taW4oaGFsZlRoaWNrbmVzcywgdmFsKSkgKiBhbmdsZURlbHRhIC8gMjtcbiAgICByZXR1cm4gX2xpbWl0VmFsdWUodmFsLCAwLCBNYXRoLm1pbihoYWxmVGhpY2tuZXNzLCBvdXRlckFyY0xpbWl0KSk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBvdXRlclN0YXJ0OiBjb21wdXRlT3V0ZXJMaW1pdChvLm91dGVyU3RhcnQpLFxuICAgIG91dGVyRW5kOiBjb21wdXRlT3V0ZXJMaW1pdChvLm91dGVyRW5kKSxcbiAgICBpbm5lclN0YXJ0OiBfbGltaXRWYWx1ZShvLmlubmVyU3RhcnQsIDAsIGlubmVyTGltaXQpLFxuICAgIGlubmVyRW5kOiBfbGltaXRWYWx1ZShvLmlubmVyRW5kLCAwLCBpbm5lckxpbWl0KSxcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IChyLCDwnZyDKSB0byAoeCwgeSlcbiAqL1xuZnVuY3Rpb24gclRoZXRhVG9YWShyOiBudW1iZXIsIHRoZXRhOiBudW1iZXIsIHg6IG51bWJlciwgeTogbnVtYmVyKSB7XG4gIHJldHVybiB7XG4gICAgeDogeCArIHIgKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgeTogeSArIHIgKiBNYXRoLnNpbih0aGV0YSksXG4gIH07XG59XG5cblxuLyoqXG4gKiBQYXRoIHRoZSBhcmMsIHJlc3BlY3RpbmcgYm9yZGVyIHJhZGl1cyBieSBzZXBhcmF0aW5nIGludG8gbGVmdCBhbmQgcmlnaHQgaGFsdmVzLlxuICpcbiAqICAgU3RhcnQgICAgICBFbmRcbiAqXG4gKiAgICAxLS0tPmEtLS0+MiAgICBPdXRlclxuICogICAvICAgICAgICAgICBcXFxuICogICA4ICAgICAgICAgICAzXG4gKiAgIHwgICAgICAgICAgIHxcbiAqICAgfCAgICAgICAgICAgfFxuICogICA3ICAgICAgICAgICA0XG4gKiAgIFxcICAgICAgICAgICAvXG4gKiAgICA2PC0tLWI8LS0tNSAgICBJbm5lclxuICovXG5mdW5jdGlvbiBwYXRoQXJjKFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgZWxlbWVudDogQXJjRWxlbWVudCxcbiAgb2Zmc2V0OiBudW1iZXIsXG4gIHNwYWNpbmc6IG51bWJlcixcbiAgZW5kOiBudW1iZXIsXG4gIGNpcmN1bGFyOiBib29sZWFuLFxuKSB7XG4gIGNvbnN0IHt4LCB5LCBzdGFydEFuZ2xlOiBzdGFydCwgcGl4ZWxNYXJnaW4sIGlubmVyUmFkaXVzOiBpbm5lclJ9ID0gZWxlbWVudDtcblxuICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KGVsZW1lbnQub3V0ZXJSYWRpdXMgKyBzcGFjaW5nICsgb2Zmc2V0IC0gcGl4ZWxNYXJnaW4sIDApO1xuICBjb25zdCBpbm5lclJhZGl1cyA9IGlubmVyUiA+IDAgPyBpbm5lclIgKyBzcGFjaW5nICsgb2Zmc2V0ICsgcGl4ZWxNYXJnaW4gOiAwO1xuXG4gIGxldCBzcGFjaW5nT2Zmc2V0ID0gMDtcbiAgY29uc3QgYWxwaGEgPSBlbmQgLSBzdGFydDtcblxuICBpZiAoc3BhY2luZykge1xuICAgIC8vIFdoZW4gc3BhY2luZyBpcyBwcmVzZW50LCBpdCBpcyB0aGUgc2FtZSBmb3IgYWxsIGl0ZW1zXG4gICAgLy8gU28gd2UgYWRqdXN0IHRoZSBzdGFydCBhbmQgZW5kIGFuZ2xlIG9mIHRoZSBhcmMgc3VjaCB0aGF0XG4gICAgLy8gdGhlIGRpc3RhbmNlIGlzIHRoZSBzYW1lIGFzIGl0IHdvdWxkIGJlIHdpdGhvdXQgdGhlIHNwYWNpbmdcbiAgICBjb25zdCBub1NwYWNpbmdJbm5lclJhZGl1cyA9IGlubmVyUiA+IDAgPyBpbm5lclIgLSBzcGFjaW5nIDogMDtcbiAgICBjb25zdCBub1NwYWNpbmdPdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzID4gMCA/IG91dGVyUmFkaXVzIC0gc3BhY2luZyA6IDA7XG4gICAgY29uc3QgYXZOb2dTcGFjaW5nUmFkaXVzID0gKG5vU3BhY2luZ0lubmVyUmFkaXVzICsgbm9TcGFjaW5nT3V0ZXJSYWRpdXMpIC8gMjtcbiAgICBjb25zdCBhZGp1c3RlZEFuZ2xlID0gYXZOb2dTcGFjaW5nUmFkaXVzICE9PSAwID8gKGFscGhhICogYXZOb2dTcGFjaW5nUmFkaXVzKSAvIChhdk5vZ1NwYWNpbmdSYWRpdXMgKyBzcGFjaW5nKSA6IGFscGhhO1xuICAgIHNwYWNpbmdPZmZzZXQgPSAoYWxwaGEgLSBhZGp1c3RlZEFuZ2xlKSAvIDI7XG4gIH1cblxuICBjb25zdCBiZXRhID0gTWF0aC5tYXgoMC4wMDEsIGFscGhhICogb3V0ZXJSYWRpdXMgLSBvZmZzZXQgLyBQSSkgLyBvdXRlclJhZGl1cztcbiAgY29uc3QgYW5nbGVPZmZzZXQgPSAoYWxwaGEgLSBiZXRhKSAvIDI7XG4gIGNvbnN0IHN0YXJ0QW5nbGUgPSBzdGFydCArIGFuZ2xlT2Zmc2V0ICsgc3BhY2luZ09mZnNldDtcbiAgY29uc3QgZW5kQW5nbGUgPSBlbmQgLSBhbmdsZU9mZnNldCAtIHNwYWNpbmdPZmZzZXQ7XG4gIGNvbnN0IHtvdXRlclN0YXJ0LCBvdXRlckVuZCwgaW5uZXJTdGFydCwgaW5uZXJFbmR9ID0gcGFyc2VCb3JkZXJSYWRpdXMoZWxlbWVudCwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpO1xuXG4gIGNvbnN0IG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cyA9IG91dGVyUmFkaXVzIC0gb3V0ZXJTdGFydDtcbiAgY29uc3Qgb3V0ZXJFbmRBZGp1c3RlZFJhZGl1cyA9IG91dGVyUmFkaXVzIC0gb3V0ZXJFbmQ7XG4gIGNvbnN0IG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlID0gc3RhcnRBbmdsZSArIG91dGVyU3RhcnQgLyBvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXM7XG4gIGNvbnN0IG91dGVyRW5kQWRqdXN0ZWRBbmdsZSA9IGVuZEFuZ2xlIC0gb3V0ZXJFbmQgLyBvdXRlckVuZEFkanVzdGVkUmFkaXVzO1xuXG4gIGNvbnN0IGlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cyA9IGlubmVyUmFkaXVzICsgaW5uZXJTdGFydDtcbiAgY29uc3QgaW5uZXJFbmRBZGp1c3RlZFJhZGl1cyA9IGlubmVyUmFkaXVzICsgaW5uZXJFbmQ7XG4gIGNvbnN0IGlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlID0gc3RhcnRBbmdsZSArIGlubmVyU3RhcnQgLyBpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXM7XG4gIGNvbnN0IGlubmVyRW5kQWRqdXN0ZWRBbmdsZSA9IGVuZEFuZ2xlIC0gaW5uZXJFbmQgLyBpbm5lckVuZEFkanVzdGVkUmFkaXVzO1xuXG4gIGN0eC5iZWdpblBhdGgoKTtcblxuICBpZiAoY2lyY3VsYXIpIHtcbiAgICAvLyBUaGUgZmlyc3QgYXJjIHNlZ21lbnRzIGZyb20gcG9pbnQgMSB0byBwb2ludCBhIHRvIHBvaW50IDJcbiAgICBjb25zdCBvdXRlck1pZEFkanVzdGVkQW5nbGUgPSAob3V0ZXJTdGFydEFkanVzdGVkQW5nbGUgKyBvdXRlckVuZEFkanVzdGVkQW5nbGUpIC8gMjtcbiAgICBjdHguYXJjKHgsIHksIG91dGVyUmFkaXVzLCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSwgb3V0ZXJNaWRBZGp1c3RlZEFuZ2xlKTtcbiAgICBjdHguYXJjKHgsIHksIG91dGVyUmFkaXVzLCBvdXRlck1pZEFkanVzdGVkQW5nbGUsIG91dGVyRW5kQWRqdXN0ZWRBbmdsZSk7XG5cbiAgICAvLyBUaGUgY29ybmVyIHNlZ21lbnQgZnJvbSBwb2ludCAyIHRvIHBvaW50IDNcbiAgICBpZiAob3V0ZXJFbmQgPiAwKSB7XG4gICAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShvdXRlckVuZEFkanVzdGVkUmFkaXVzLCBvdXRlckVuZEFkanVzdGVkQW5nbGUsIHgsIHkpO1xuICAgICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgb3V0ZXJFbmQsIG91dGVyRW5kQWRqdXN0ZWRBbmdsZSwgZW5kQW5nbGUgKyBIQUxGX1BJKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgbGluZSBmcm9tIHBvaW50IDMgdG8gcG9pbnQgNFxuICAgIGNvbnN0IHA0ID0gclRoZXRhVG9YWShpbm5lckVuZEFkanVzdGVkUmFkaXVzLCBlbmRBbmdsZSwgeCwgeSk7XG4gICAgY3R4LmxpbmVUbyhwNC54LCBwNC55KTtcblxuICAgIC8vIFRoZSBjb3JuZXIgc2VnbWVudCBmcm9tIHBvaW50IDQgdG8gcG9pbnQgNVxuICAgIGlmIChpbm5lckVuZCA+IDApIHtcbiAgICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKGlubmVyRW5kQWRqdXN0ZWRSYWRpdXMsIGlubmVyRW5kQWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBpbm5lckVuZCwgZW5kQW5nbGUgKyBIQUxGX1BJLCBpbm5lckVuZEFkanVzdGVkQW5nbGUgKyBNYXRoLlBJKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgaW5uZXIgYXJjIGZyb20gcG9pbnQgNSB0byBwb2ludCBiIHRvIHBvaW50IDZcbiAgICBjb25zdCBpbm5lck1pZEFkanVzdGVkQW5nbGUgPSAoKGVuZEFuZ2xlIC0gKGlubmVyRW5kIC8gaW5uZXJSYWRpdXMpKSArIChzdGFydEFuZ2xlICsgKGlubmVyU3RhcnQgLyBpbm5lclJhZGl1cykpKSAvIDI7XG4gICAgY3R4LmFyYyh4LCB5LCBpbm5lclJhZGl1cywgZW5kQW5nbGUgLSAoaW5uZXJFbmQgLyBpbm5lclJhZGl1cyksIGlubmVyTWlkQWRqdXN0ZWRBbmdsZSwgdHJ1ZSk7XG4gICAgY3R4LmFyYyh4LCB5LCBpbm5lclJhZGl1cywgaW5uZXJNaWRBZGp1c3RlZEFuZ2xlLCBzdGFydEFuZ2xlICsgKGlubmVyU3RhcnQgLyBpbm5lclJhZGl1cyksIHRydWUpO1xuXG4gICAgLy8gVGhlIGNvcm5lciBzZWdtZW50IGZyb20gcG9pbnQgNiB0byBwb2ludCA3XG4gICAgaWYgKGlubmVyU3RhcnQgPiAwKSB7XG4gICAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXMsIGlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIGlubmVyU3RhcnQsIGlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlICsgTWF0aC5QSSwgc3RhcnRBbmdsZSAtIEhBTEZfUEkpO1xuICAgIH1cblxuICAgIC8vIFRoZSBsaW5lIGZyb20gcG9pbnQgNyB0byBwb2ludCA4XG4gICAgY29uc3QgcDggPSByVGhldGFUb1hZKG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cywgc3RhcnRBbmdsZSwgeCwgeSk7XG4gICAgY3R4LmxpbmVUbyhwOC54LCBwOC55KTtcblxuICAgIC8vIFRoZSBjb3JuZXIgc2VnbWVudCBmcm9tIHBvaW50IDggdG8gcG9pbnQgMVxuICAgIGlmIChvdXRlclN0YXJ0ID4gMCkge1xuICAgICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkob3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzLCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBvdXRlclN0YXJ0LCBzdGFydEFuZ2xlIC0gSEFMRl9QSSwgb3V0ZXJTdGFydEFkanVzdGVkQW5nbGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjdHgubW92ZVRvKHgsIHkpO1xuXG4gICAgY29uc3Qgb3V0ZXJTdGFydFggPSBNYXRoLmNvcyhvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSkgKiBvdXRlclJhZGl1cyArIHg7XG4gICAgY29uc3Qgb3V0ZXJTdGFydFkgPSBNYXRoLnNpbihvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSkgKiBvdXRlclJhZGl1cyArIHk7XG4gICAgY3R4LmxpbmVUbyhvdXRlclN0YXJ0WCwgb3V0ZXJTdGFydFkpO1xuXG4gICAgY29uc3Qgb3V0ZXJFbmRYID0gTWF0aC5jb3Mob3V0ZXJFbmRBZGp1c3RlZEFuZ2xlKSAqIG91dGVyUmFkaXVzICsgeDtcbiAgICBjb25zdCBvdXRlckVuZFkgPSBNYXRoLnNpbihvdXRlckVuZEFkanVzdGVkQW5nbGUpICogb3V0ZXJSYWRpdXMgKyB5O1xuICAgIGN0eC5saW5lVG8ob3V0ZXJFbmRYLCBvdXRlckVuZFkpO1xuICB9XG5cbiAgY3R4LmNsb3NlUGF0aCgpO1xufVxuXG5mdW5jdGlvbiBkcmF3QXJjKFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgZWxlbWVudDogQXJjRWxlbWVudCxcbiAgb2Zmc2V0OiBudW1iZXIsXG4gIHNwYWNpbmc6IG51bWJlcixcbiAgY2lyY3VsYXI6IGJvb2xlYW4sXG4pIHtcbiAgY29uc3Qge2Z1bGxDaXJjbGVzLCBzdGFydEFuZ2xlLCBjaXJjdW1mZXJlbmNlfSA9IGVsZW1lbnQ7XG4gIGxldCBlbmRBbmdsZSA9IGVsZW1lbnQuZW5kQW5nbGU7XG4gIGlmIChmdWxsQ2lyY2xlcykge1xuICAgIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlLCBjaXJjdWxhcik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmdWxsQ2lyY2xlczsgKytpKSB7XG4gICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgICBpZiAoIWlzTmFOKGNpcmN1bWZlcmVuY2UpKSB7XG4gICAgICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyAoY2lyY3VtZmVyZW5jZSAlIFRBVSB8fCBUQVUpO1xuICAgIH1cbiAgfVxuICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSwgY2lyY3VsYXIpO1xuICBjdHguZmlsbCgpO1xuICByZXR1cm4gZW5kQW5nbGU7XG59XG5cbmZ1bmN0aW9uIGRyYXdCb3JkZXIoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBlbGVtZW50OiBBcmNFbGVtZW50LFxuICBvZmZzZXQ6IG51bWJlcixcbiAgc3BhY2luZzogbnVtYmVyLFxuICBjaXJjdWxhcjogYm9vbGVhbixcbikge1xuICBjb25zdCB7ZnVsbENpcmNsZXMsIHN0YXJ0QW5nbGUsIGNpcmN1bWZlcmVuY2UsIG9wdGlvbnN9ID0gZWxlbWVudDtcbiAgY29uc3Qge2JvcmRlcldpZHRoLCBib3JkZXJKb2luU3R5bGUsIGJvcmRlckRhc2gsIGJvcmRlckRhc2hPZmZzZXR9ID0gb3B0aW9ucztcbiAgY29uc3QgaW5uZXIgPSBvcHRpb25zLmJvcmRlckFsaWduID09PSAnaW5uZXInO1xuXG4gIGlmICghYm9yZGVyV2lkdGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjdHguc2V0TGluZURhc2goYm9yZGVyRGFzaCB8fCBbXSk7XG4gIGN0eC5saW5lRGFzaE9mZnNldCA9IGJvcmRlckRhc2hPZmZzZXQ7XG5cbiAgaWYgKGlubmVyKSB7XG4gICAgY3R4LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoICogMjtcbiAgICBjdHgubGluZUpvaW4gPSBib3JkZXJKb2luU3R5bGUgfHwgJ3JvdW5kJztcbiAgfSBlbHNlIHtcbiAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyV2lkdGg7XG4gICAgY3R4LmxpbmVKb2luID0gYm9yZGVySm9pblN0eWxlIHx8ICdiZXZlbCc7XG4gIH1cblxuICBsZXQgZW5kQW5nbGUgPSBlbGVtZW50LmVuZEFuZ2xlO1xuICBpZiAoZnVsbENpcmNsZXMpIHtcbiAgICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSwgY2lyY3VsYXIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnVsbENpcmNsZXM7ICsraSkge1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgICBpZiAoIWlzTmFOKGNpcmN1bWZlcmVuY2UpKSB7XG4gICAgICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyAoY2lyY3VtZmVyZW5jZSAlIFRBVSB8fCBUQVUpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpbm5lcikge1xuICAgIGNsaXBBcmMoY3R4LCBlbGVtZW50LCBlbmRBbmdsZSk7XG4gIH1cblxuICBpZiAoIWZ1bGxDaXJjbGVzKSB7XG4gICAgcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kQW5nbGUsIGNpcmN1bGFyKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBBcmNQcm9wcyBleHRlbmRzIFBvaW50IHtcbiAgc3RhcnRBbmdsZTogbnVtYmVyO1xuICBlbmRBbmdsZTogbnVtYmVyO1xuICBpbm5lclJhZGl1czogbnVtYmVyO1xuICBvdXRlclJhZGl1czogbnVtYmVyO1xuICBjaXJjdW1mZXJlbmNlOiBudW1iZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFyY0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PEFyY1Byb3BzLCBBcmNPcHRpb25zPiB7XG5cbiAgc3RhdGljIGlkID0gJ2FyYyc7XG5cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGJvcmRlckFsaWduOiAnY2VudGVyJyxcbiAgICBib3JkZXJDb2xvcjogJyNmZmYnLFxuICAgIGJvcmRlckRhc2g6IFtdLFxuICAgIGJvcmRlckRhc2hPZmZzZXQ6IDAsXG4gICAgYm9yZGVySm9pblN0eWxlOiB1bmRlZmluZWQsXG4gICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgIGJvcmRlcldpZHRoOiAyLFxuICAgIG9mZnNldDogMCxcbiAgICBzcGFjaW5nOiAwLFxuICAgIGFuZ2xlOiB1bmRlZmluZWQsXG4gICAgY2lyY3VsYXI6IHRydWUsXG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJ1xuICB9O1xuXG4gIHN0YXRpYyBkZXNjcmlwdG9ycyA9IHtcbiAgICBfc2NyaXB0YWJsZTogdHJ1ZSxcbiAgICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JvcmRlckRhc2gnXG4gIH07XG5cbiAgY2lyY3VtZmVyZW5jZTogbnVtYmVyO1xuICBlbmRBbmdsZTogbnVtYmVyO1xuICBmdWxsQ2lyY2xlczogbnVtYmVyO1xuICBpbm5lclJhZGl1czogbnVtYmVyO1xuICBvdXRlclJhZGl1czogbnVtYmVyO1xuICBwaXhlbE1hcmdpbjogbnVtYmVyO1xuICBzdGFydEFuZ2xlOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNpcmN1bWZlcmVuY2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zdGFydEFuZ2xlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW5kQW5nbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGl4ZWxNYXJnaW4gPSAwO1xuICAgIHRoaXMuZnVsbENpcmNsZXMgPSAwO1xuXG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuXG4gIGluUmFuZ2UoY2hhcnRYOiBudW1iZXIsIGNoYXJ0WTogbnVtYmVyLCB1c2VGaW5hbFBvc2l0aW9uOiBib29sZWFuKSB7XG4gICAgY29uc3QgcG9pbnQgPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHthbmdsZSwgZGlzdGFuY2V9ID0gZ2V0QW5nbGVGcm9tUG9pbnQocG9pbnQsIHt4OiBjaGFydFgsIHk6IGNoYXJ0WX0pO1xuICAgIGNvbnN0IHtzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBjaXJjdW1mZXJlbmNlfSA9IHRoaXMuZ2V0UHJvcHMoW1xuICAgICAgJ3N0YXJ0QW5nbGUnLFxuICAgICAgJ2VuZEFuZ2xlJyxcbiAgICAgICdpbm5lclJhZGl1cycsXG4gICAgICAnb3V0ZXJSYWRpdXMnLFxuICAgICAgJ2NpcmN1bWZlcmVuY2UnXG4gICAgXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3QgckFkanVzdCA9ICh0aGlzLm9wdGlvbnMuc3BhY2luZyArIHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aCkgLyAyO1xuICAgIGNvbnN0IF9jaXJjdW1mZXJlbmNlID0gdmFsdWVPckRlZmF1bHQoY2lyY3VtZmVyZW5jZSwgZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcbiAgICBjb25zdCBiZXR3ZWVuQW5nbGVzID0gX2NpcmN1bWZlcmVuY2UgPj0gVEFVIHx8IF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTtcbiAgICBjb25zdCB3aXRoaW5SYWRpdXMgPSBfaXNCZXR3ZWVuKGRpc3RhbmNlLCBpbm5lclJhZGl1cyArIHJBZGp1c3QsIG91dGVyUmFkaXVzICsgckFkanVzdCk7XG5cbiAgICByZXR1cm4gKGJldHdlZW5BbmdsZXMgJiYgd2l0aGluUmFkaXVzKTtcbiAgfVxuXG4gIGdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb246IGJvb2xlYW4pIHtcbiAgICBjb25zdCB7eCwgeSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1c30gPSB0aGlzLmdldFByb3BzKFtcbiAgICAgICd4JyxcbiAgICAgICd5JyxcbiAgICAgICdzdGFydEFuZ2xlJyxcbiAgICAgICdlbmRBbmdsZScsXG4gICAgICAnaW5uZXJSYWRpdXMnLFxuICAgICAgJ291dGVyUmFkaXVzJ1xuICAgIF0sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHtvZmZzZXQsIHNwYWNpbmd9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGhhbGZBbmdsZSA9IChzdGFydEFuZ2xlICsgZW5kQW5nbGUpIC8gMjtcbiAgICBjb25zdCBoYWxmUmFkaXVzID0gKGlubmVyUmFkaXVzICsgb3V0ZXJSYWRpdXMgKyBzcGFjaW5nICsgb2Zmc2V0KSAvIDI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHggKyBNYXRoLmNvcyhoYWxmQW5nbGUpICogaGFsZlJhZGl1cyxcbiAgICAgIHk6IHkgKyBNYXRoLnNpbihoYWxmQW5nbGUpICogaGFsZlJhZGl1c1xuICAgIH07XG4gIH1cblxuICB0b29sdGlwUG9zaXRpb24odXNlRmluYWxQb3NpdGlvbjogYm9vbGVhbikge1xuICAgIHJldHVybiB0aGlzLmdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG5cbiAgZHJhdyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xuICAgIGNvbnN0IHtvcHRpb25zLCBjaXJjdW1mZXJlbmNlfSA9IHRoaXM7XG4gICAgY29uc3Qgb2Zmc2V0ID0gKG9wdGlvbnMub2Zmc2V0IHx8IDApIC8gNDtcbiAgICBjb25zdCBzcGFjaW5nID0gKG9wdGlvbnMuc3BhY2luZyB8fCAwKSAvIDI7XG4gICAgY29uc3QgY2lyY3VsYXIgPSBvcHRpb25zLmNpcmN1bGFyO1xuICAgIHRoaXMucGl4ZWxNYXJnaW4gPSAob3B0aW9ucy5ib3JkZXJBbGlnbiA9PT0gJ2lubmVyJykgPyAwLjMzIDogMDtcbiAgICB0aGlzLmZ1bGxDaXJjbGVzID0gY2lyY3VtZmVyZW5jZSA+IFRBVSA/IE1hdGguZmxvb3IoY2lyY3VtZmVyZW5jZSAvIFRBVSkgOiAwO1xuXG4gICAgaWYgKGNpcmN1bWZlcmVuY2UgPT09IDAgfHwgdGhpcy5pbm5lclJhZGl1cyA8IDAgfHwgdGhpcy5vdXRlclJhZGl1cyA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdHguc2F2ZSgpO1xuXG4gICAgY29uc3QgaGFsZkFuZ2xlID0gKHRoaXMuc3RhcnRBbmdsZSArIHRoaXMuZW5kQW5nbGUpIC8gMjtcbiAgICBjdHgudHJhbnNsYXRlKE1hdGguY29zKGhhbGZBbmdsZSkgKiBvZmZzZXQsIE1hdGguc2luKGhhbGZBbmdsZSkgKiBvZmZzZXQpO1xuICAgIGNvbnN0IGZpeCA9IDEgLSBNYXRoLnNpbihNYXRoLm1pbihQSSwgY2lyY3VtZmVyZW5jZSB8fCAwKSk7XG4gICAgY29uc3QgcmFkaXVzT2Zmc2V0ID0gb2Zmc2V0ICogZml4O1xuXG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG5cbiAgICBkcmF3QXJjKGN0eCwgdGhpcywgcmFkaXVzT2Zmc2V0LCBzcGFjaW5nLCBjaXJjdWxhcik7XG4gICAgZHJhd0JvcmRlcihjdHgsIHRoaXMsIHJhZGl1c09mZnNldCwgc3BhY2luZywgY2lyY3VsYXIpO1xuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxufVxuIiwgImltcG9ydCBFbGVtZW50IGZyb20gJy4uL2NvcmUvY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCB7X2JlemllckludGVycG9sYXRpb24sIF9wb2ludEluTGluZSwgX3N0ZXBwZWRJbnRlcnBvbGF0aW9ufSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuaW50ZXJwb2xhdGlvbi5qcyc7XG5pbXBvcnQge19jb21wdXRlU2VnbWVudHMsIF9ib3VuZFNlZ21lbnRzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuc2VnbWVudC5qcyc7XG5pbXBvcnQge19zdGVwcGVkTGluZVRvLCBfYmV6aWVyQ3VydmVUb30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNhbnZhcy5qcyc7XG5pbXBvcnQge191cGRhdGVCZXppZXJDb250cm9sUG9pbnRzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY3VydmUuanMnO1xuaW1wb3J0IHt2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vZWxlbWVudC5wb2ludC5qcycpLmRlZmF1bHQgfSBQb2ludEVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBzZXRTdHlsZShjdHgsIG9wdGlvbnMsIHN0eWxlID0gb3B0aW9ucykge1xuICBjdHgubGluZUNhcCA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckNhcFN0eWxlLCBvcHRpb25zLmJvcmRlckNhcFN0eWxlKTtcbiAgY3R4LnNldExpbmVEYXNoKHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckRhc2gsIG9wdGlvbnMuYm9yZGVyRGFzaCkpO1xuICBjdHgubGluZURhc2hPZmZzZXQgPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJEYXNoT2Zmc2V0LCBvcHRpb25zLmJvcmRlckRhc2hPZmZzZXQpO1xuICBjdHgubGluZUpvaW4gPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJKb2luU3R5bGUsIG9wdGlvbnMuYm9yZGVySm9pblN0eWxlKTtcbiAgY3R4LmxpbmVXaWR0aCA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlcldpZHRoLCBvcHRpb25zLmJvcmRlcldpZHRoKTtcbiAgY3R4LnN0cm9rZVN0eWxlID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyQ29sb3IsIG9wdGlvbnMuYm9yZGVyQ29sb3IpO1xufVxuXG5mdW5jdGlvbiBsaW5lVG8oY3R4LCBwcmV2aW91cywgdGFyZ2V0KSB7XG4gIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5mdW5jdGlvbiBnZXRMaW5lTWV0aG9kKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuc3RlcHBlZCkge1xuICAgIHJldHVybiBfc3RlcHBlZExpbmVUbztcbiAgfVxuXG4gIGlmIChvcHRpb25zLnRlbnNpb24gfHwgb3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSB7XG4gICAgcmV0dXJuIF9iZXppZXJDdXJ2ZVRvO1xuICB9XG5cbiAgcmV0dXJuIGxpbmVUbztcbn1cblxuZnVuY3Rpb24gcGF0aFZhcnMocG9pbnRzLCBzZWdtZW50LCBwYXJhbXMgPSB7fSkge1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IHtzdGFydDogcGFyYW1zU3RhcnQgPSAwLCBlbmQ6IHBhcmFtc0VuZCA9IGNvdW50IC0gMX0gPSBwYXJhbXM7XG4gIGNvbnN0IHtzdGFydDogc2VnbWVudFN0YXJ0LCBlbmQ6IHNlZ21lbnRFbmR9ID0gc2VnbWVudDtcbiAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heChwYXJhbXNTdGFydCwgc2VnbWVudFN0YXJ0KTtcbiAgY29uc3QgZW5kID0gTWF0aC5taW4ocGFyYW1zRW5kLCBzZWdtZW50RW5kKTtcbiAgY29uc3Qgb3V0c2lkZSA9IHBhcmFtc1N0YXJ0IDwgc2VnbWVudFN0YXJ0ICYmIHBhcmFtc0VuZCA8IHNlZ21lbnRTdGFydCB8fCBwYXJhbXNTdGFydCA+IHNlZ21lbnRFbmQgJiYgcGFyYW1zRW5kID4gc2VnbWVudEVuZDtcblxuICByZXR1cm4ge1xuICAgIGNvdW50LFxuICAgIHN0YXJ0LFxuICAgIGxvb3A6IHNlZ21lbnQubG9vcCxcbiAgICBpbGVuOiBlbmQgPCBzdGFydCAmJiAhb3V0c2lkZSA/IGNvdW50ICsgZW5kIC0gc3RhcnQgOiBlbmQgLSBzdGFydFxuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZSBwYXRoIGZyb20gcG9pbnRzLCBncm91cGluZyBieSB0cnVuY2F0ZWQgeC1jb29yZGluYXRlXG4gKiBQb2ludHMgbmVlZCB0byBiZSBpbiBvcmRlciBieSB4LWNvb3JkaW5hdGUgZm9yIHRoaXMgdG8gd29yayBlZmZpY2llbnRseVxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR8UGF0aDJEfSBjdHggLSBDb250ZXh0XG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcGFyYW0ge29iamVjdH0gc2VnbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnQuc3RhcnQgLSBzdGFydCBpbmRleCBvZiB0aGUgc2VnbWVudCwgcmVmZXJyaW5nIHRoZSBwb2ludHMgYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LmVuZCAtIGVuZCBpbmRleCBvZiB0aGUgc2VnbWVudCwgcmVmZXJyaW5nIHRoZSBwb2ludHMgYXJyYXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VnbWVudC5sb29wIC0gaW5kaWNhdGVzIHRoYXQgdGhlIHNlZ21lbnQgaXMgYSBsb29wXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5tb3ZlIC0gbW92ZSB0byBzdGFydGluZyBwb2ludCAodnMgbGluZSB0byBpdClcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLnJldmVyc2UgLSBwYXRoIHRoZSBzZWdtZW50IGZyb20gZW5kIHRvIHN0YXJ0XG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnN0YXJ0IC0gbGltaXQgc2VnbWVudCB0byBwb2ludHMgc3RhcnRpbmcgZnJvbSBgc3RhcnRgIGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmVuZCAtIGxpbWl0IHNlZ21lbnQgdG8gcG9pbnRzIGVuZGluZyBhdCBgc3RhcnRgICsgYGNvdW50YCBpbmRleFxuICovXG5mdW5jdGlvbiBwYXRoU2VnbWVudChjdHgsIGxpbmUsIHNlZ21lbnQsIHBhcmFtcykge1xuICBjb25zdCB7cG9pbnRzLCBvcHRpb25zfSA9IGxpbmU7XG4gIGNvbnN0IHtjb3VudCwgc3RhcnQsIGxvb3AsIGlsZW59ID0gcGF0aFZhcnMocG9pbnRzLCBzZWdtZW50LCBwYXJhbXMpO1xuICBjb25zdCBsaW5lTWV0aG9kID0gZ2V0TGluZU1ldGhvZChvcHRpb25zKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICBsZXQge21vdmUgPSB0cnVlLCByZXZlcnNlfSA9IHBhcmFtcyB8fCB7fTtcbiAgbGV0IGksIHBvaW50LCBwcmV2O1xuXG4gIGZvciAoaSA9IDA7IGkgPD0gaWxlbjsgKytpKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbKHN0YXJ0ICsgKHJldmVyc2UgPyBpbGVuIC0gaSA6IGkpKSAlIGNvdW50XTtcblxuICAgIGlmIChwb2ludC5za2lwKSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBhIHNraXBwZWQgcG9pbnQgaW5zaWRlIGEgc2VnbWVudCwgc3BhbkdhcHMgbXVzdCBiZSB0cnVlXG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKG1vdmUpIHtcbiAgICAgIGN0eC5tb3ZlVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICBtb3ZlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmVNZXRob2QoY3R4LCBwcmV2LCBwb2ludCwgcmV2ZXJzZSwgb3B0aW9ucy5zdGVwcGVkKTtcbiAgICB9XG5cbiAgICBwcmV2ID0gcG9pbnQ7XG4gIH1cblxuICBpZiAobG9vcCkge1xuICAgIHBvaW50ID0gcG9pbnRzWyhzdGFydCArIChyZXZlcnNlID8gaWxlbiA6IDApKSAlIGNvdW50XTtcbiAgICBsaW5lTWV0aG9kKGN0eCwgcHJldiwgcG9pbnQsIHJldmVyc2UsIG9wdGlvbnMuc3RlcHBlZCk7XG4gIH1cblxuICByZXR1cm4gISFsb29wO1xufVxuXG4vKipcbiAqIENyZWF0ZSBwYXRoIGZyb20gcG9pbnRzLCBncm91cGluZyBieSB0cnVuY2F0ZWQgeC1jb29yZGluYXRlXG4gKiBQb2ludHMgbmVlZCB0byBiZSBpbiBvcmRlciBieSB4LWNvb3JkaW5hdGUgZm9yIHRoaXMgdG8gd29yayBlZmZpY2llbnRseVxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR8UGF0aDJEfSBjdHggLSBDb250ZXh0XG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcGFyYW0ge29iamVjdH0gc2VnbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnQuc3RhcnQgLSBzdGFydCBpbmRleCBvZiB0aGUgc2VnbWVudCwgcmVmZXJyaW5nIHRoZSBwb2ludHMgYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LmVuZCAtIGVuZCBpbmRleCBvZiB0aGUgc2VnbWVudCwgcmVmZXJyaW5nIHRoZSBwb2ludHMgYXJyYXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VnbWVudC5sb29wIC0gaW5kaWNhdGVzIHRoYXQgdGhlIHNlZ21lbnQgaXMgYSBsb29wXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5tb3ZlIC0gbW92ZSB0byBzdGFydGluZyBwb2ludCAodnMgbGluZSB0byBpdClcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLnJldmVyc2UgLSBwYXRoIHRoZSBzZWdtZW50IGZyb20gZW5kIHRvIHN0YXJ0XG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnN0YXJ0IC0gbGltaXQgc2VnbWVudCB0byBwb2ludHMgc3RhcnRpbmcgZnJvbSBgc3RhcnRgIGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmVuZCAtIGxpbWl0IHNlZ21lbnQgdG8gcG9pbnRzIGVuZGluZyBhdCBgc3RhcnRgICsgYGNvdW50YCBpbmRleFxuICovXG5mdW5jdGlvbiBmYXN0UGF0aFNlZ21lbnQoY3R4LCBsaW5lLCBzZWdtZW50LCBwYXJhbXMpIHtcbiAgY29uc3QgcG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IHtjb3VudCwgc3RhcnQsIGlsZW59ID0gcGF0aFZhcnMocG9pbnRzLCBzZWdtZW50LCBwYXJhbXMpO1xuICBjb25zdCB7bW92ZSA9IHRydWUsIHJldmVyc2V9ID0gcGFyYW1zIHx8IHt9O1xuICBsZXQgYXZnWCA9IDA7XG4gIGxldCBjb3VudFggPSAwO1xuICBsZXQgaSwgcG9pbnQsIHByZXZYLCBtaW5ZLCBtYXhZLCBsYXN0WTtcblxuICBjb25zdCBwb2ludEluZGV4ID0gKGluZGV4KSA9PiAoc3RhcnQgKyAocmV2ZXJzZSA/IGlsZW4gLSBpbmRleCA6IGluZGV4KSkgJSBjb3VudDtcbiAgY29uc3QgZHJhd1ggPSAoKSA9PiB7XG4gICAgaWYgKG1pblkgIT09IG1heFkpIHtcbiAgICAgIC8vIERyYXcgbGluZSB0byBtYXhZIGFuZCBtaW5ZLCB1c2luZyB0aGUgYXZlcmFnZSB4LWNvb3JkaW5hdGVcbiAgICAgIGN0eC5saW5lVG8oYXZnWCwgbWF4WSk7XG4gICAgICBjdHgubGluZVRvKGF2Z1gsIG1pblkpO1xuICAgICAgLy8gTGluZSB0byB5LXZhbHVlIG9mIGxhc3QgcG9pbnQgaW4gZ3JvdXAuIFNvIHRoZSBsaW5lIGNvbnRpbnVlc1xuICAgICAgLy8gZnJvbSBjb3JyZWN0IHBvc2l0aW9uLiBOb3QgdXNpbmcgbW92ZSwgdG8gaGF2ZSBzb2xpZCBwYXRoLlxuICAgICAgY3R4LmxpbmVUbyhhdmdYLCBsYXN0WSk7XG4gICAgfVxuICB9O1xuXG4gIGlmIChtb3ZlKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbcG9pbnRJbmRleCgwKV07XG4gICAgY3R4Lm1vdmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPD0gaWxlbjsgKytpKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbcG9pbnRJbmRleChpKV07XG5cbiAgICBpZiAocG9pbnQuc2tpcCkge1xuICAgICAgLy8gSWYgdGhlcmUgaXMgYSBza2lwcGVkIHBvaW50IGluc2lkZSBhIHNlZ21lbnQsIHNwYW5HYXBzIG11c3QgYmUgdHJ1ZVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgeCA9IHBvaW50Lng7XG4gICAgY29uc3QgeSA9IHBvaW50Lnk7XG4gICAgY29uc3QgdHJ1bmNYID0geCB8IDA7IC8vIHRydW5jYXRlZCB4LWNvb3JkaW5hdGVcblxuICAgIGlmICh0cnVuY1ggPT09IHByZXZYKSB7XG4gICAgICAvLyBEZXRlcm1pbmUgYG1pbllgIC8gYG1heFlgIGFuZCBgYXZnWGAgd2hpbGUgd2Ugc3RheSB3aXRoaW4gc2FtZSB4LXBvc2l0aW9uXG4gICAgICBpZiAoeSA8IG1pblkpIHtcbiAgICAgICAgbWluWSA9IHk7XG4gICAgICB9IGVsc2UgaWYgKHkgPiBtYXhZKSB7XG4gICAgICAgIG1heFkgPSB5O1xuICAgICAgfVxuICAgICAgLy8gRm9yIGZpcnN0IHBvaW50IGluIGdyb3VwLCBjb3VudFggaXMgYDBgLCBzbyBhdmVyYWdlIHdpbGwgYmUgYHhgIC8gMS5cbiAgICAgIGF2Z1ggPSAoY291bnRYICogYXZnWCArIHgpIC8gKytjb3VudFg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRyYXdYKCk7XG4gICAgICAvLyBEcmF3IGxpbmUgdG8gbmV4dCB4LXBvc2l0aW9uLCB1c2luZyB0aGUgZmlyc3QgKG9yIG9ubHkpXG4gICAgICAvLyB5LXZhbHVlIGluIHRoYXQgZ3JvdXBcbiAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG5cbiAgICAgIHByZXZYID0gdHJ1bmNYO1xuICAgICAgY291bnRYID0gMDtcbiAgICAgIG1pblkgPSBtYXhZID0geTtcbiAgICB9XG4gICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgbGFzdCB5LXZhbHVlIGluIGdyb3VwXG4gICAgbGFzdFkgPSB5O1xuICB9XG4gIGRyYXdYKCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZSAtIHRoZSBsaW5lXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfZ2V0U2VnbWVudE1ldGhvZChsaW5lKSB7XG4gIGNvbnN0IG9wdHMgPSBsaW5lLm9wdGlvbnM7XG4gIGNvbnN0IGJvcmRlckRhc2ggPSBvcHRzLmJvcmRlckRhc2ggJiYgb3B0cy5ib3JkZXJEYXNoLmxlbmd0aDtcbiAgY29uc3QgdXNlRmFzdFBhdGggPSAhbGluZS5fZGVjaW1hdGVkICYmICFsaW5lLl9sb29wICYmICFvcHRzLnRlbnNpb24gJiYgb3B0cy5jdWJpY0ludGVycG9sYXRpb25Nb2RlICE9PSAnbW9ub3RvbmUnICYmICFvcHRzLnN0ZXBwZWQgJiYgIWJvcmRlckRhc2g7XG4gIHJldHVybiB1c2VGYXN0UGF0aCA/IGZhc3RQYXRoU2VnbWVudCA6IHBhdGhTZWdtZW50O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9nZXRJbnRlcnBvbGF0aW9uTWV0aG9kKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuc3RlcHBlZCkge1xuICAgIHJldHVybiBfc3RlcHBlZEludGVycG9sYXRpb247XG4gIH1cblxuICBpZiAob3B0aW9ucy50ZW5zaW9uIHx8IG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xuICAgIHJldHVybiBfYmV6aWVySW50ZXJwb2xhdGlvbjtcbiAgfVxuXG4gIHJldHVybiBfcG9pbnRJbkxpbmU7XG59XG5cbmZ1bmN0aW9uIHN0cm9rZVBhdGhXaXRoQ2FjaGUoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpIHtcbiAgbGV0IHBhdGggPSBsaW5lLl9wYXRoO1xuICBpZiAoIXBhdGgpIHtcbiAgICBwYXRoID0gbGluZS5fcGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgICBpZiAobGluZS5wYXRoKHBhdGgsIHN0YXJ0LCBjb3VudCkpIHtcbiAgICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gICAgfVxuICB9XG4gIHNldFN0eWxlKGN0eCwgbGluZS5vcHRpb25zKTtcbiAgY3R4LnN0cm9rZShwYXRoKTtcbn1cblxuZnVuY3Rpb24gc3Ryb2tlUGF0aERpcmVjdChjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCkge1xuICBjb25zdCB7c2VnbWVudHMsIG9wdGlvbnN9ID0gbGluZTtcbiAgY29uc3Qgc2VnbWVudE1ldGhvZCA9IF9nZXRTZWdtZW50TWV0aG9kKGxpbmUpO1xuXG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgIHNldFN0eWxlKGN0eCwgb3B0aW9ucywgc2VnbWVudC5zdHlsZSk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGlmIChzZWdtZW50TWV0aG9kKGN0eCwgbGluZSwgc2VnbWVudCwge3N0YXJ0LCBlbmQ6IHN0YXJ0ICsgY291bnQgLSAxfSkpIHtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5cbmNvbnN0IHVzZVBhdGgyRCA9IHR5cGVvZiBQYXRoMkQgPT09ICdmdW5jdGlvbic7XG5cbmZ1bmN0aW9uIGRyYXcoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpIHtcbiAgaWYgKHVzZVBhdGgyRCAmJiAhbGluZS5vcHRpb25zLnNlZ21lbnQpIHtcbiAgICBzdHJva2VQYXRoV2l0aENhY2hlKGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KTtcbiAgfSBlbHNlIHtcbiAgICBzdHJva2VQYXRoRGlyZWN0KGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5lRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuXG4gIHN0YXRpYyBpZCA9ICdsaW5lJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBib3JkZXJDYXBTdHlsZTogJ2J1dHQnLFxuICAgIGJvcmRlckRhc2g6IFtdLFxuICAgIGJvcmRlckRhc2hPZmZzZXQ6IDAsXG4gICAgYm9yZGVySm9pblN0eWxlOiAnbWl0ZXInLFxuICAgIGJvcmRlcldpZHRoOiAzLFxuICAgIGNhcEJlemllclBvaW50czogdHJ1ZSxcbiAgICBjdWJpY0ludGVycG9sYXRpb25Nb2RlOiAnZGVmYXVsdCcsXG4gICAgZmlsbDogZmFsc2UsXG4gICAgc3BhbkdhcHM6IGZhbHNlLFxuICAgIHN0ZXBwZWQ6IGZhbHNlLFxuICAgIHRlbnNpb246IDAsXG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdFJvdXRlcyA9IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InLFxuICAgIGJvcmRlckNvbG9yOiAnYm9yZGVyQ29sb3InXG4gIH07XG5cblxuICBzdGF0aWMgZGVzY3JpcHRvcnMgPSB7XG4gICAgX3NjcmlwdGFibGU6IHRydWUsXG4gICAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdib3JkZXJEYXNoJyAmJiBuYW1lICE9PSAnZmlsbCcsXG4gIH07XG5cblxuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5hbmltYXRlZCA9IHRydWU7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2NoYXJ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2xvb3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZnVsbExvb3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcGF0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wb2ludHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc2VnbWVudHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZGVjaW1hdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcG9pbnRzVXBkYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2RhdGFzZXRJbmRleCA9IHVuZGVmaW5lZDtcblxuICAgIGlmIChjZmcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVDb250cm9sUG9pbnRzKGNoYXJ0QXJlYSwgaW5kZXhBeGlzKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoKG9wdGlvbnMudGVuc2lvbiB8fCBvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpICYmICFvcHRpb25zLnN0ZXBwZWQgJiYgIXRoaXMuX3BvaW50c1VwZGF0ZWQpIHtcbiAgICAgIGNvbnN0IGxvb3AgPSBvcHRpb25zLnNwYW5HYXBzID8gdGhpcy5fbG9vcCA6IHRoaXMuX2Z1bGxMb29wO1xuICAgICAgX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHModGhpcy5fcG9pbnRzLCBvcHRpb25zLCBjaGFydEFyZWEsIGxvb3AsIGluZGV4QXhpcyk7XG4gICAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBzZXQgcG9pbnRzKHBvaW50cykge1xuICAgIHRoaXMuX3BvaW50cyA9IHBvaW50cztcbiAgICBkZWxldGUgdGhpcy5fc2VnbWVudHM7XG4gICAgZGVsZXRlIHRoaXMuX3BhdGg7XG4gICAgdGhpcy5fcG9pbnRzVXBkYXRlZCA9IGZhbHNlO1xuICB9XG5cbiAgZ2V0IHBvaW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9pbnRzO1xuICB9XG5cbiAgZ2V0IHNlZ21lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWdtZW50cyB8fCAodGhpcy5fc2VnbWVudHMgPSBfY29tcHV0ZVNlZ21lbnRzKHRoaXMsIHRoaXMub3B0aW9ucy5zZWdtZW50KSk7XG4gIH1cblxuICAvKipcblx0ICogRmlyc3Qgbm9uLXNraXBwZWQgcG9pbnQgb24gdGhpcyBsaW5lXG5cdCAqIEByZXR1cm5zIHtQb2ludEVsZW1lbnR8dW5kZWZpbmVkfVxuXHQgKi9cbiAgZmlyc3QoKSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgIHJldHVybiBzZWdtZW50cy5sZW5ndGggJiYgcG9pbnRzW3NlZ21lbnRzWzBdLnN0YXJ0XTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBMYXN0IG5vbi1za2lwcGVkIHBvaW50IG9uIHRoaXMgbGluZVxuXHQgKiBAcmV0dXJucyB7UG9pbnRFbGVtZW50fHVuZGVmaW5lZH1cblx0ICovXG4gIGxhc3QoKSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgIGNvbnN0IGNvdW50ID0gc2VnbWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBjb3VudCAmJiBwb2ludHNbc2VnbWVudHNbY291bnQgLSAxXS5lbmRdO1xuICB9XG5cbiAgLyoqXG5cdCAqIEludGVycG9sYXRlIGEgcG9pbnQgaW4gdGhpcyBsaW5lIGF0IHRoZSBzYW1lIHZhbHVlIG9uIGBwcm9wZXJ0eWAgYXNcblx0ICogdGhlIHJlZmVyZW5jZSBgcG9pbnRgIHByb3ZpZGVkXG5cdCAqIEBwYXJhbSB7UG9pbnRFbGVtZW50fSBwb2ludCAtIHRoZSByZWZlcmVuY2UgcG9pbnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IC0gdGhlIHByb3BlcnR5IHRvIG1hdGNoIG9uXG5cdCAqIEByZXR1cm5zIHtQb2ludEVsZW1lbnR8dW5kZWZpbmVkfVxuXHQgKi9cbiAgaW50ZXJwb2xhdGUocG9pbnQsIHByb3BlcnR5KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB2YWx1ZSA9IHBvaW50W3Byb3BlcnR5XTtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICBjb25zdCBzZWdtZW50cyA9IF9ib3VuZFNlZ21lbnRzKHRoaXMsIHtwcm9wZXJ0eSwgc3RhcnQ6IHZhbHVlLCBlbmQ6IHZhbHVlfSk7XG5cbiAgICBpZiAoIXNlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IF9pbnRlcnBvbGF0ZSA9IF9nZXRJbnRlcnBvbGF0aW9uTWV0aG9kKG9wdGlvbnMpO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IHtzdGFydCwgZW5kfSA9IHNlZ21lbnRzW2ldO1xuICAgICAgY29uc3QgcDEgPSBwb2ludHNbc3RhcnRdO1xuICAgICAgY29uc3QgcDIgPSBwb2ludHNbZW5kXTtcbiAgICAgIGlmIChwMSA9PT0gcDIpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gocDEpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHQgPSBNYXRoLmFicygodmFsdWUgLSBwMVtwcm9wZXJ0eV0pIC8gKHAyW3Byb3BlcnR5XSAtIHAxW3Byb3BlcnR5XSkpO1xuICAgICAgY29uc3QgaW50ZXJwb2xhdGVkID0gX2ludGVycG9sYXRlKHAxLCBwMiwgdCwgb3B0aW9ucy5zdGVwcGVkKTtcbiAgICAgIGludGVycG9sYXRlZFtwcm9wZXJ0eV0gPSBwb2ludFtwcm9wZXJ0eV07XG4gICAgICByZXN1bHQucHVzaChpbnRlcnBvbGF0ZWQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PT0gMSA/IHJlc3VsdFswXSA6IHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBcHBlbmQgYSBzZWdtZW50IG9mIHRoaXMgbGluZSB0byBjdXJyZW50IHBhdGguXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICogQHBhcmFtIHtvYmplY3R9IHNlZ21lbnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnQuc3RhcnQgLSBzdGFydCBpbmRleCBvZiB0aGUgc2VnbWVudCwgcmVmZXJyaW5nIHRoZSBwb2ludHMgYXJyYXlcbiBcdCAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LmVuZCAtIGVuZCBpbmRleCBvZiB0aGUgc2VnbWVudCwgcmVmZXJyaW5nIHRoZSBwb2ludHMgYXJyYXlcbiBcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VnbWVudC5sb29wIC0gaW5kaWNhdGVzIHRoYXQgdGhlIHNlZ21lbnQgaXMgYSBsb29wXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcblx0ICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMubW92ZSAtIG1vdmUgdG8gc3RhcnRpbmcgcG9pbnQgKHZzIGxpbmUgdG8gaXQpXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLnJldmVyc2UgLSBwYXRoIHRoZSBzZWdtZW50IGZyb20gZW5kIHRvIHN0YXJ0XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuc3RhcnQgLSBsaW1pdCBzZWdtZW50IHRvIHBvaW50cyBzdGFydGluZyBmcm9tIGBzdGFydGAgaW5kZXhcblx0ICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5lbmQgLSBsaW1pdCBzZWdtZW50IHRvIHBvaW50cyBlbmRpbmcgYXQgYHN0YXJ0YCArIGBjb3VudGAgaW5kZXhcblx0ICogQHJldHVybnMge3VuZGVmaW5lZHxib29sZWFufSAtIHRydWUgaWYgdGhlIHNlZ21lbnQgaXMgYSBmdWxsIGxvb3AgKHBhdGggc2hvdWxkIGJlIGNsb3NlZClcblx0ICovXG4gIHBhdGhTZWdtZW50KGN0eCwgc2VnbWVudCwgcGFyYW1zKSB7XG4gICAgY29uc3Qgc2VnbWVudE1ldGhvZCA9IF9nZXRTZWdtZW50TWV0aG9kKHRoaXMpO1xuICAgIHJldHVybiBzZWdtZW50TWV0aG9kKGN0eCwgdGhpcywgc2VnbWVudCwgcGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBcHBlbmQgYWxsIHNlZ21lbnRzIG9mIHRoaXMgbGluZSB0byBjdXJyZW50IHBhdGguXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfFBhdGgyRH0gY3R4XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRdXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbY291bnRdXG5cdCAqIEByZXR1cm5zIHt1bmRlZmluZWR8Ym9vbGVhbn0gLSB0cnVlIGlmIGxpbmUgaXMgYSBmdWxsIGxvb3AgKHBhdGggc2hvdWxkIGJlIGNsb3NlZClcblx0ICovXG4gIHBhdGgoY3R4LCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgY29uc3Qgc2VnbWVudE1ldGhvZCA9IF9nZXRTZWdtZW50TWV0aG9kKHRoaXMpO1xuICAgIGxldCBsb29wID0gdGhpcy5fbG9vcDtcblxuICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgICBjb3VudCA9IGNvdW50IHx8ICh0aGlzLnBvaW50cy5sZW5ndGggLSBzdGFydCk7XG5cbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICAgIGxvb3AgJj0gc2VnbWVudE1ldGhvZChjdHgsIHRoaXMsIHNlZ21lbnQsIHtzdGFydCwgZW5kOiBzdGFydCArIGNvdW50IC0gMX0pO1xuICAgIH1cbiAgICByZXR1cm4gISFsb29wO1xuICB9XG5cbiAgLyoqXG5cdCAqIERyYXdcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuXHQgKiBAcGFyYW0ge29iamVjdH0gY2hhcnRBcmVhXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRdXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbY291bnRdXG5cdCAqL1xuICBkcmF3KGN0eCwgY2hhcnRBcmVhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzIHx8IFtdO1xuXG4gICAgaWYgKHBvaW50cy5sZW5ndGggJiYgb3B0aW9ucy5ib3JkZXJXaWR0aCkge1xuICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgZHJhdyhjdHgsIHRoaXMsIHN0YXJ0LCBjb3VudCk7XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYW5pbWF0ZWQpIHtcbiAgICAgIC8vIFdoZW4gbGluZSBpcyBhbmltYXRlZCwgdGhlIGNvbnRyb2wgcG9pbnRzIGFuZCBwYXRoIGFyZSBub3QgY2FjaGVkLlxuICAgICAgdGhpcy5fcG9pbnRzVXBkYXRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fcGF0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQgRWxlbWVudCBmcm9tICcuLi9jb3JlL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQge2RyYXdQb2ludCwgX2lzUG9pbnRJbkFyZWF9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHR5cGUge1xuICBDYXJ0ZXNpYW5QYXJzZWREYXRhLFxuICBDaGFydEFyZWEsXG4gIFBvaW50LFxuICBQb2ludEhvdmVyT3B0aW9ucyxcbiAgUG9pbnRPcHRpb25zLFxufSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5cbmZ1bmN0aW9uIGluUmFuZ2UoZWw6IFBvaW50RWxlbWVudCwgcG9zOiBudW1iZXIsIGF4aXM6ICd4JyB8ICd5JywgdXNlRmluYWxQb3NpdGlvbj86IGJvb2xlYW4pIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGVsLm9wdGlvbnM7XG4gIGNvbnN0IHtbYXhpc106IHZhbHVlfSA9IGVsLmdldFByb3BzKFtheGlzXSwgdXNlRmluYWxQb3NpdGlvbik7XG5cbiAgcmV0dXJuIChNYXRoLmFicyhwb3MgLSB2YWx1ZSkgPCBvcHRpb25zLnJhZGl1cyArIG9wdGlvbnMuaGl0UmFkaXVzKTtcbn1cblxuZXhwb3J0IHR5cGUgUG9pbnRQcm9wcyA9IFBvaW50XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvaW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ8UG9pbnRQcm9wcywgUG9pbnRPcHRpb25zICYgUG9pbnRIb3Zlck9wdGlvbnM+IHtcblxuICBzdGF0aWMgaWQgPSAncG9pbnQnO1xuXG4gIHBhcnNlZDogQ2FydGVzaWFuUGFyc2VkRGF0YTtcbiAgc2tpcD86IGJvb2xlYW47XG4gIHN0b3A/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGJvcmRlcldpZHRoOiAxLFxuICAgIGhpdFJhZGl1czogMSxcbiAgICBob3ZlckJvcmRlcldpZHRoOiAxLFxuICAgIGhvdmVyUmFkaXVzOiA0LFxuICAgIHBvaW50U3R5bGU6ICdjaXJjbGUnLFxuICAgIHJhZGl1czogMyxcbiAgICByb3RhdGlvbjogMFxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJyxcbiAgICBib3JkZXJDb2xvcjogJ2JvcmRlckNvbG9yJ1xuICB9O1xuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYXJzZWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5za2lwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc3RvcCA9IHVuZGVmaW5lZDtcblxuICAgIGlmIChjZmcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICB9XG4gIH1cblxuICBpblJhbmdlKG1vdXNlWDogbnVtYmVyLCBtb3VzZVk6IG51bWJlciwgdXNlRmluYWxQb3NpdGlvbj86IGJvb2xlYW4pIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHt4LCB5fSA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgcmV0dXJuICgoTWF0aC5wb3cobW91c2VYIC0geCwgMikgKyBNYXRoLnBvdyhtb3VzZVkgLSB5LCAyKSkgPCBNYXRoLnBvdyhvcHRpb25zLmhpdFJhZGl1cyArIG9wdGlvbnMucmFkaXVzLCAyKSk7XG4gIH1cblxuICBpblhSYW5nZShtb3VzZVg6IG51bWJlciwgdXNlRmluYWxQb3NpdGlvbj86IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBtb3VzZVgsICd4JywgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cblxuICBpbllSYW5nZShtb3VzZVk6IG51bWJlciwgdXNlRmluYWxQb3NpdGlvbj86IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBtb3VzZVksICd5JywgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cblxuICBnZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uPzogYm9vbGVhbikge1xuICAgIGNvbnN0IHt4LCB5fSA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgcmV0dXJuIHt4LCB5fTtcbiAgfVxuXG4gIHNpemUob3B0aW9ucz86IFBhcnRpYWw8UG9pbnRPcHRpb25zICYgUG9pbnRIb3Zlck9wdGlvbnM+KSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgIGxldCByYWRpdXMgPSBvcHRpb25zLnJhZGl1cyB8fCAwO1xuICAgIHJhZGl1cyA9IE1hdGgubWF4KHJhZGl1cywgcmFkaXVzICYmIG9wdGlvbnMuaG92ZXJSYWRpdXMgfHwgMCk7XG4gICAgY29uc3QgYm9yZGVyV2lkdGggPSByYWRpdXMgJiYgb3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwO1xuICAgIHJldHVybiAocmFkaXVzICsgYm9yZGVyV2lkdGgpICogMjtcbiAgfVxuXG4gIGRyYXcoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGFyZWE6IENoYXJ0QXJlYSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBpZiAodGhpcy5za2lwIHx8IG9wdGlvbnMucmFkaXVzIDwgMC4xIHx8ICFfaXNQb2ludEluQXJlYSh0aGlzLCBhcmVhLCB0aGlzLnNpemUob3B0aW9ucykgLyAyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG4gICAgY3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgIGRyYXdQb2ludChjdHgsIG9wdGlvbnMsIHRoaXMueCwgdGhpcy55KTtcbiAgfVxuXG4gIGdldFJhbmdlKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgfHwge307XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBGYWxsYmFja3Mgc2hvdWxkIG5ldmVyIGJlIGhpdCBpbiBwcmFjdGljZVxuICAgIHJldHVybiBvcHRpb25zLnJhZGl1cyArIG9wdGlvbnMuaGl0UmFkaXVzO1xuICB9XG59XG4iLCAiaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi4vY29yZS9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IHtpc09iamVjdCwgX2lzQmV0d2VlbiwgX2xpbWl0VmFsdWV9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHthZGRSb3VuZGVkUmVjdFBhdGh9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHt0b1RSQkwsIHRvVFJCTENvcm5lcnN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLmpzJztcblxuLyoqIEB0eXBlZGVmIHt7IHg6IG51bWJlciwgeTogbnVtYmVyLCBiYXNlOiBudW1iZXIsIGhvcml6b250YWw6IGJvb2xlYW4sIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyIH19IEJhclByb3BzICovXG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgYm91bmRzIG9mIHRoZSBiYXIgcmVnYXJkbGVzcyBvZiB0aGUgb3JpZW50YXRpb25cbiAqIEBwYXJhbSB7QmFyRWxlbWVudH0gYmFyIHRoZSBiYXJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dXG4gKiBAcmV0dXJuIHtvYmplY3R9IGJvdW5kcyBvZiB0aGUgYmFyXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRCYXJCb3VuZHMoYmFyLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGNvbnN0IHt4LCB5LCBiYXNlLCB3aWR0aCwgaGVpZ2h0fSA9IC8qKiBAdHlwZSB7QmFyUHJvcHN9ICovIChiYXIuZ2V0UHJvcHMoWyd4JywgJ3knLCAnYmFzZScsICd3aWR0aCcsICdoZWlnaHQnXSwgdXNlRmluYWxQb3NpdGlvbikpO1xuXG4gIGxldCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIGhhbGY7XG5cbiAgaWYgKGJhci5ob3Jpem9udGFsKSB7XG4gICAgaGFsZiA9IGhlaWdodCAvIDI7XG4gICAgbGVmdCA9IE1hdGgubWluKHgsIGJhc2UpO1xuICAgIHJpZ2h0ID0gTWF0aC5tYXgoeCwgYmFzZSk7XG4gICAgdG9wID0geSAtIGhhbGY7XG4gICAgYm90dG9tID0geSArIGhhbGY7XG4gIH0gZWxzZSB7XG4gICAgaGFsZiA9IHdpZHRoIC8gMjtcbiAgICBsZWZ0ID0geCAtIGhhbGY7XG4gICAgcmlnaHQgPSB4ICsgaGFsZjtcbiAgICB0b3AgPSBNYXRoLm1pbih5LCBiYXNlKTtcbiAgICBib3R0b20gPSBNYXRoLm1heCh5LCBiYXNlKTtcbiAgfVxuXG4gIHJldHVybiB7bGVmdCwgdG9wLCByaWdodCwgYm90dG9tfTtcbn1cblxuZnVuY3Rpb24gc2tpcE9yTGltaXQoc2tpcCwgdmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBza2lwID8gMCA6IF9saW1pdFZhbHVlKHZhbHVlLCBtaW4sIG1heCk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQm9yZGVyV2lkdGgoYmFyLCBtYXhXLCBtYXhIKSB7XG4gIGNvbnN0IHZhbHVlID0gYmFyLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gIGNvbnN0IHNraXAgPSBiYXIuYm9yZGVyU2tpcHBlZDtcbiAgY29uc3QgbyA9IHRvVFJCTCh2YWx1ZSk7XG5cbiAgcmV0dXJuIHtcbiAgICB0OiBza2lwT3JMaW1pdChza2lwLnRvcCwgby50b3AsIDAsIG1heEgpLFxuICAgIHI6IHNraXBPckxpbWl0KHNraXAucmlnaHQsIG8ucmlnaHQsIDAsIG1heFcpLFxuICAgIGI6IHNraXBPckxpbWl0KHNraXAuYm90dG9tLCBvLmJvdHRvbSwgMCwgbWF4SCksXG4gICAgbDogc2tpcE9yTGltaXQoc2tpcC5sZWZ0LCBvLmxlZnQsIDAsIG1heFcpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlQm9yZGVyUmFkaXVzKGJhciwgbWF4VywgbWF4SCkge1xuICBjb25zdCB7ZW5hYmxlQm9yZGVyUmFkaXVzfSA9IGJhci5nZXRQcm9wcyhbJ2VuYWJsZUJvcmRlclJhZGl1cyddKTtcbiAgY29uc3QgdmFsdWUgPSBiYXIub3B0aW9ucy5ib3JkZXJSYWRpdXM7XG4gIGNvbnN0IG8gPSB0b1RSQkxDb3JuZXJzKHZhbHVlKTtcbiAgY29uc3QgbWF4UiA9IE1hdGgubWluKG1heFcsIG1heEgpO1xuICBjb25zdCBza2lwID0gYmFyLmJvcmRlclNraXBwZWQ7XG5cbiAgLy8gSWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdCwgYXNzdW1lIHRoZSB1c2VyIGtub3dzIHdoYXQgdGhleSBhcmUgZG9pbmdcbiAgLy8gYW5kIGFwcGx5IGFzIGRpcmVjdGVkLlxuICBjb25zdCBlbmFibGVCb3JkZXIgPSBlbmFibGVCb3JkZXJSYWRpdXMgfHwgaXNPYmplY3QodmFsdWUpO1xuXG4gIHJldHVybiB7XG4gICAgdG9wTGVmdDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLnRvcCB8fCBza2lwLmxlZnQsIG8udG9wTGVmdCwgMCwgbWF4UiksXG4gICAgdG9wUmlnaHQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC50b3AgfHwgc2tpcC5yaWdodCwgby50b3BSaWdodCwgMCwgbWF4UiksXG4gICAgYm90dG9tTGVmdDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLmJvdHRvbSB8fCBza2lwLmxlZnQsIG8uYm90dG9tTGVmdCwgMCwgbWF4UiksXG4gICAgYm90dG9tUmlnaHQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC5ib3R0b20gfHwgc2tpcC5yaWdodCwgby5ib3R0b21SaWdodCwgMCwgbWF4UilcbiAgfTtcbn1cblxuZnVuY3Rpb24gYm91bmRpbmdSZWN0cyhiYXIpIHtcbiAgY29uc3QgYm91bmRzID0gZ2V0QmFyQm91bmRzKGJhcik7XG4gIGNvbnN0IHdpZHRoID0gYm91bmRzLnJpZ2h0IC0gYm91bmRzLmxlZnQ7XG4gIGNvbnN0IGhlaWdodCA9IGJvdW5kcy5ib3R0b20gLSBib3VuZHMudG9wO1xuICBjb25zdCBib3JkZXIgPSBwYXJzZUJvcmRlcldpZHRoKGJhciwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcbiAgY29uc3QgcmFkaXVzID0gcGFyc2VCb3JkZXJSYWRpdXMoYmFyLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuXG4gIHJldHVybiB7XG4gICAgb3V0ZXI6IHtcbiAgICAgIHg6IGJvdW5kcy5sZWZ0LFxuICAgICAgeTogYm91bmRzLnRvcCxcbiAgICAgIHc6IHdpZHRoLFxuICAgICAgaDogaGVpZ2h0LFxuICAgICAgcmFkaXVzXG4gICAgfSxcbiAgICBpbm5lcjoge1xuICAgICAgeDogYm91bmRzLmxlZnQgKyBib3JkZXIubCxcbiAgICAgIHk6IGJvdW5kcy50b3AgKyBib3JkZXIudCxcbiAgICAgIHc6IHdpZHRoIC0gYm9yZGVyLmwgLSBib3JkZXIucixcbiAgICAgIGg6IGhlaWdodCAtIGJvcmRlci50IC0gYm9yZGVyLmIsXG4gICAgICByYWRpdXM6IHtcbiAgICAgICAgdG9wTGVmdDogTWF0aC5tYXgoMCwgcmFkaXVzLnRvcExlZnQgLSBNYXRoLm1heChib3JkZXIudCwgYm9yZGVyLmwpKSxcbiAgICAgICAgdG9wUmlnaHQ6IE1hdGgubWF4KDAsIHJhZGl1cy50b3BSaWdodCAtIE1hdGgubWF4KGJvcmRlci50LCBib3JkZXIucikpLFxuICAgICAgICBib3R0b21MZWZ0OiBNYXRoLm1heCgwLCByYWRpdXMuYm90dG9tTGVmdCAtIE1hdGgubWF4KGJvcmRlci5iLCBib3JkZXIubCkpLFxuICAgICAgICBib3R0b21SaWdodDogTWF0aC5tYXgoMCwgcmFkaXVzLmJvdHRvbVJpZ2h0IC0gTWF0aC5tYXgoYm9yZGVyLmIsIGJvcmRlci5yKSksXG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpblJhbmdlKGJhciwgeCwgeSwgdXNlRmluYWxQb3NpdGlvbikge1xuICBjb25zdCBza2lwWCA9IHggPT09IG51bGw7XG4gIGNvbnN0IHNraXBZID0geSA9PT0gbnVsbDtcbiAgY29uc3Qgc2tpcEJvdGggPSBza2lwWCAmJiBza2lwWTtcbiAgY29uc3QgYm91bmRzID0gYmFyICYmICFza2lwQm90aCAmJiBnZXRCYXJCb3VuZHMoYmFyLCB1c2VGaW5hbFBvc2l0aW9uKTtcblxuICByZXR1cm4gYm91bmRzXG5cdFx0JiYgKHNraXBYIHx8IF9pc0JldHdlZW4oeCwgYm91bmRzLmxlZnQsIGJvdW5kcy5yaWdodCkpXG5cdFx0JiYgKHNraXBZIHx8IF9pc0JldHdlZW4oeSwgYm91bmRzLnRvcCwgYm91bmRzLmJvdHRvbSkpO1xufVxuXG5mdW5jdGlvbiBoYXNSYWRpdXMocmFkaXVzKSB7XG4gIHJldHVybiByYWRpdXMudG9wTGVmdCB8fCByYWRpdXMudG9wUmlnaHQgfHwgcmFkaXVzLmJvdHRvbUxlZnQgfHwgcmFkaXVzLmJvdHRvbVJpZ2h0O1xufVxuXG4vKipcbiAqIEFkZCBhIHBhdGggb2YgYSByZWN0YW5nbGUgdG8gdGhlIGN1cnJlbnQgc3ViLXBhdGhcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dFxuICogQHBhcmFtIHsqfSByZWN0IEJvdW5kaW5nIHJlY3RcbiAqL1xuZnVuY3Rpb24gYWRkTm9ybWFsUmVjdFBhdGgoY3R4LCByZWN0KSB7XG4gIGN0eC5yZWN0KHJlY3QueCwgcmVjdC55LCByZWN0LncsIHJlY3QuaCk7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZWN0KHJlY3QsIGFtb3VudCwgcmVmUmVjdCA9IHt9KSB7XG4gIGNvbnN0IHggPSByZWN0LnggIT09IHJlZlJlY3QueCA/IC1hbW91bnQgOiAwO1xuICBjb25zdCB5ID0gcmVjdC55ICE9PSByZWZSZWN0LnkgPyAtYW1vdW50IDogMDtcbiAgY29uc3QgdyA9IChyZWN0LnggKyByZWN0LncgIT09IHJlZlJlY3QueCArIHJlZlJlY3QudyA/IGFtb3VudCA6IDApIC0geDtcbiAgY29uc3QgaCA9IChyZWN0LnkgKyByZWN0LmggIT09IHJlZlJlY3QueSArIHJlZlJlY3QuaCA/IGFtb3VudCA6IDApIC0geTtcbiAgcmV0dXJuIHtcbiAgICB4OiByZWN0LnggKyB4LFxuICAgIHk6IHJlY3QueSArIHksXG4gICAgdzogcmVjdC53ICsgdyxcbiAgICBoOiByZWN0LmggKyBoLFxuICAgIHJhZGl1czogcmVjdC5yYWRpdXNcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuXG4gIHN0YXRpYyBpZCA9ICdiYXInO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGJvcmRlclNraXBwZWQ6ICdzdGFydCcsXG4gICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgIGluZmxhdGVBbW91bnQ6ICdhdXRvJyxcbiAgICBwb2ludFN0eWxlOiB1bmRlZmluZWRcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0Um91dGVzID0ge1xuICAgIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXG4gICAgYm9yZGVyQ29sb3I6ICdib3JkZXJDb2xvcidcbiAgfTtcblxuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaG9yaXpvbnRhbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJhc2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmluZmxhdGVBbW91bnQgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoY2ZnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgfVxuICB9XG5cbiAgZHJhdyhjdHgpIHtcbiAgICBjb25zdCB7aW5mbGF0ZUFtb3VudCwgb3B0aW9uczoge2JvcmRlckNvbG9yLCBiYWNrZ3JvdW5kQ29sb3J9fSA9IHRoaXM7XG4gICAgY29uc3Qge2lubmVyLCBvdXRlcn0gPSBib3VuZGluZ1JlY3RzKHRoaXMpO1xuICAgIGNvbnN0IGFkZFJlY3RQYXRoID0gaGFzUmFkaXVzKG91dGVyLnJhZGl1cykgPyBhZGRSb3VuZGVkUmVjdFBhdGggOiBhZGROb3JtYWxSZWN0UGF0aDtcblxuICAgIGN0eC5zYXZlKCk7XG5cbiAgICBpZiAob3V0ZXIudyAhPT0gaW5uZXIudyB8fCBvdXRlci5oICE9PSBpbm5lci5oKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBhZGRSZWN0UGF0aChjdHgsIGluZmxhdGVSZWN0KG91dGVyLCBpbmZsYXRlQW1vdW50LCBpbm5lcikpO1xuICAgICAgY3R4LmNsaXAoKTtcbiAgICAgIGFkZFJlY3RQYXRoKGN0eCwgaW5mbGF0ZVJlY3QoaW5uZXIsIC1pbmZsYXRlQW1vdW50LCBvdXRlcikpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJvcmRlckNvbG9yO1xuICAgICAgY3R4LmZpbGwoJ2V2ZW5vZGQnKTtcbiAgICB9XG5cbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgYWRkUmVjdFBhdGgoY3R4LCBpbmZsYXRlUmVjdChpbm5lciwgaW5mbGF0ZUFtb3VudCkpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgY3R4LmZpbGwoKTtcblxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cblxuICBpblJhbmdlKG1vdXNlWCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbW91c2VYLCBtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG5cbiAgaW5YUmFuZ2UobW91c2VYLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbW91c2VYLCBudWxsLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuXG4gIGluWVJhbmdlKG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlKHRoaXMsIG51bGwsIG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cblxuICBnZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3Qge3gsIHksIGJhc2UsIGhvcml6b250YWx9ID0gLyoqIEB0eXBlIHtCYXJQcm9wc30gKi8gKHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knLCAnYmFzZScsICdob3Jpem9udGFsJ10sIHVzZUZpbmFsUG9zaXRpb24pKTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogaG9yaXpvbnRhbCA/ICh4ICsgYmFzZSkgLyAyIDogeCxcbiAgICAgIHk6IGhvcml6b250YWwgPyB5IDogKHkgKyBiYXNlKSAvIDJcbiAgICB9O1xuICB9XG5cbiAgZ2V0UmFuZ2UoYXhpcykge1xuICAgIHJldHVybiBheGlzID09PSAneCcgPyB0aGlzLndpZHRoIC8gMiA6IHRoaXMuaGVpZ2h0IC8gMjtcbiAgfVxufVxuIiwgImltcG9ydCB7RG91Z2hudXRDb250cm9sbGVyLCBQb2xhckFyZWFDb250cm9sbGVyfSBmcm9tICcuLi9pbmRleC5qcyc7XG5pbXBvcnQgdHlwZSB7Q2hhcnQsIENoYXJ0RGF0YXNldH0gZnJvbSAnLi4vdHlwZXMuanMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbG9yc1BsdWdpbk9wdGlvbnMge1xuICBlbmFibGVkPzogYm9vbGVhbjtcbiAgZm9yY2VPdmVycmlkZT86IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBDb2xvcnNEZXNjcmlwdG9yIHtcbiAgYmFja2dyb3VuZENvbG9yPzogdW5rbm93bjtcbiAgYm9yZGVyQ29sb3I/OiB1bmtub3duO1xufVxuXG5jb25zdCBCT1JERVJfQ09MT1JTID0gW1xuICAncmdiKDU0LCAxNjIsIDIzNSknLCAvLyBibHVlXG4gICdyZ2IoMjU1LCA5OSwgMTMyKScsIC8vIHJlZFxuICAncmdiKDI1NSwgMTU5LCA2NCknLCAvLyBvcmFuZ2VcbiAgJ3JnYigyNTUsIDIwNSwgODYpJywgLy8geWVsbG93XG4gICdyZ2IoNzUsIDE5MiwgMTkyKScsIC8vIGdyZWVuXG4gICdyZ2IoMTUzLCAxMDIsIDI1NSknLCAvLyBwdXJwbGVcbiAgJ3JnYigyMDEsIDIwMywgMjA3KScgLy8gZ3JleVxuXTtcblxuLy8gQm9yZGVyIGNvbG9ycyB3aXRoIDUwJSB0cmFuc3BhcmVuY3lcbmNvbnN0IEJBQ0tHUk9VTkRfQ09MT1JTID0gLyogI19fUFVSRV9fICovIEJPUkRFUl9DT0xPUlMubWFwKGNvbG9yID0+IGNvbG9yLnJlcGxhY2UoJ3JnYignLCAncmdiYSgnKS5yZXBsYWNlKCcpJywgJywgMC41KScpKTtcblxuZnVuY3Rpb24gZ2V0Qm9yZGVyQ29sb3IoaTogbnVtYmVyKSB7XG4gIHJldHVybiBCT1JERVJfQ09MT1JTW2kgJSBCT1JERVJfQ09MT1JTLmxlbmd0aF07XG59XG5cbmZ1bmN0aW9uIGdldEJhY2tncm91bmRDb2xvcihpOiBudW1iZXIpIHtcbiAgcmV0dXJuIEJBQ0tHUk9VTkRfQ09MT1JTW2kgJSBCQUNLR1JPVU5EX0NPTE9SUy5sZW5ndGhdO1xufVxuXG5mdW5jdGlvbiBjb2xvcml6ZURlZmF1bHREYXRhc2V0KGRhdGFzZXQ6IENoYXJ0RGF0YXNldCwgaTogbnVtYmVyKSB7XG4gIGRhdGFzZXQuYm9yZGVyQ29sb3IgPSBnZXRCb3JkZXJDb2xvcihpKTtcbiAgZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3IgPSBnZXRCYWNrZ3JvdW5kQ29sb3IoaSk7XG5cbiAgcmV0dXJuICsraTtcbn1cblxuZnVuY3Rpb24gY29sb3JpemVEb3VnaG51dERhdGFzZXQoZGF0YXNldDogQ2hhcnREYXRhc2V0LCBpOiBudW1iZXIpIHtcbiAgZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3IgPSBkYXRhc2V0LmRhdGEubWFwKCgpID0+IGdldEJvcmRlckNvbG9yKGkrKykpO1xuXG4gIHJldHVybiBpO1xufVxuXG5mdW5jdGlvbiBjb2xvcml6ZVBvbGFyQXJlYURhdGFzZXQoZGF0YXNldDogQ2hhcnREYXRhc2V0LCBpOiBudW1iZXIpIHtcbiAgZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3IgPSBkYXRhc2V0LmRhdGEubWFwKCgpID0+IGdldEJhY2tncm91bmRDb2xvcihpKyspKTtcblxuICByZXR1cm4gaTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29sb3JpemVyKGNoYXJ0OiBDaGFydCkge1xuICBsZXQgaSA9IDA7XG5cbiAgcmV0dXJuIChkYXRhc2V0OiBDaGFydERhdGFzZXQsIGRhdGFzZXRJbmRleDogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlcjtcblxuICAgIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgRG91Z2hudXRDb250cm9sbGVyKSB7XG4gICAgICBpID0gY29sb3JpemVEb3VnaG51dERhdGFzZXQoZGF0YXNldCwgaSk7XG4gICAgfSBlbHNlIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgUG9sYXJBcmVhQ29udHJvbGxlcikge1xuICAgICAgaSA9IGNvbG9yaXplUG9sYXJBcmVhRGF0YXNldChkYXRhc2V0LCBpKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRyb2xsZXIpIHtcbiAgICAgIGkgPSBjb2xvcml6ZURlZmF1bHREYXRhc2V0KGRhdGFzZXQsIGkpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnNDb2xvcnNEZWZpbml0aW9ucyhcbiAgZGVzY3JpcHRvcnM6IENvbG9yc0Rlc2NyaXB0b3JbXSB8IFJlY29yZDxzdHJpbmcsIENvbG9yc0Rlc2NyaXB0b3I+XG4pIHtcbiAgbGV0IGs6IG51bWJlciB8IHN0cmluZztcblxuICBmb3IgKGsgaW4gZGVzY3JpcHRvcnMpIHtcbiAgICBpZiAoZGVzY3JpcHRvcnNba10uYm9yZGVyQ29sb3IgfHwgZGVzY3JpcHRvcnNba10uYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zQ29sb3JzRGVmaW5pdGlvbihcbiAgZGVzY3JpcHRvcjogQ29sb3JzRGVzY3JpcHRvclxuKSB7XG4gIHJldHVybiBkZXNjcmlwdG9yICYmIChkZXNjcmlwdG9yLmJvcmRlckNvbG9yIHx8IGRlc2NyaXB0b3IuYmFja2dyb3VuZENvbG9yKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpZDogJ2NvbG9ycycsXG5cbiAgZGVmYXVsdHM6IHtcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGZvcmNlT3ZlcnJpZGU6IGZhbHNlXG4gIH0gYXMgQ29sb3JzUGx1Z2luT3B0aW9ucyxcblxuICBiZWZvcmVMYXlvdXQoY2hhcnQ6IENoYXJ0LCBfYXJncywgb3B0aW9uczogQ29sb3JzUGx1Z2luT3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5lbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgZGF0YToge2RhdGFzZXRzfSxcbiAgICAgIG9wdGlvbnM6IGNoYXJ0T3B0aW9uc1xuICAgIH0gPSBjaGFydC5jb25maWc7XG4gICAgY29uc3Qge2VsZW1lbnRzfSA9IGNoYXJ0T3B0aW9ucztcblxuICAgIGlmICghb3B0aW9ucy5mb3JjZU92ZXJyaWRlICYmIChjb250YWluc0NvbG9yc0RlZmluaXRpb25zKGRhdGFzZXRzKSB8fCBjb250YWluc0NvbG9yc0RlZmluaXRpb24oY2hhcnRPcHRpb25zKSB8fCAoZWxlbWVudHMgJiYgY29udGFpbnNDb2xvcnNEZWZpbml0aW9ucyhlbGVtZW50cykpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbG9yaXplciA9IGdldENvbG9yaXplcihjaGFydCk7XG5cbiAgICBkYXRhc2V0cy5mb3JFYWNoKGNvbG9yaXplcik7XG4gIH1cbn07XG4iLCAiaW1wb3J0IHtfbGltaXRWYWx1ZSwgX2xvb2t1cEJ5S2V5LCBpc051bGxPclVuZGVmLCByZXNvbHZlfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuZnVuY3Rpb24gbHR0YkRlY2ltYXRpb24oZGF0YSwgc3RhcnQsIGNvdW50LCBhdmFpbGFibGVXaWR0aCwgb3B0aW9ucykge1xuICAvKipcbiAgICogSW1wbGVtZW50YXRpb24gb2YgdGhlIExhcmdlc3QgVHJpYW5nbGUgVGhyZWUgQnVja2V0cyBhbGdvcml0aG0uXG4gICAqXG4gICAqIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gdGhlIG9yaWdpbmFsIGltcGxlbWVudGF0aW9uIGJ5IFN2ZWlubiBTdGVpbmFyc3NvblxuICAgKiBpbiBodHRwczovL2dpdGh1Yi5jb20vc3ZlaW5uLXN0ZWluYXJzc29uL2Zsb3QtZG93bnNhbXBsZS9ibG9iL21hc3Rlci9qcXVlcnkuZmxvdC5kb3duc2FtcGxlLmpzXG4gICAqXG4gICAqIFRoZSBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiBpcyBNSVQgbGljZW5zZWQuXG4gICAqL1xuICBjb25zdCBzYW1wbGVzID0gb3B0aW9ucy5zYW1wbGVzIHx8IGF2YWlsYWJsZVdpZHRoO1xuICAvLyBUaGVyZSBhcmUgbGVzcyBwb2ludHMgdGhhbiB0aGUgdGhyZXNob2xkLCByZXR1cm5pbmcgdGhlIHdob2xlIGFycmF5XG4gIGlmIChzYW1wbGVzID49IGNvdW50KSB7XG4gICAgcmV0dXJuIGRhdGEuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgY291bnQpO1xuICB9XG5cbiAgY29uc3QgZGVjaW1hdGVkID0gW107XG5cbiAgY29uc3QgYnVja2V0V2lkdGggPSAoY291bnQgLSAyKSAvIChzYW1wbGVzIC0gMik7XG4gIGxldCBzYW1wbGVkSW5kZXggPSAwO1xuICBjb25zdCBlbmRJbmRleCA9IHN0YXJ0ICsgY291bnQgLSAxO1xuICAvLyBTdGFydGluZyBmcm9tIG9mZnNldFxuICBsZXQgYSA9IHN0YXJ0O1xuICBsZXQgaSwgbWF4QXJlYVBvaW50LCBtYXhBcmVhLCBhcmVhLCBuZXh0QTtcblxuICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gZGF0YVthXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc2FtcGxlcyAtIDI7IGkrKykge1xuICAgIGxldCBhdmdYID0gMDtcbiAgICBsZXQgYXZnWSA9IDA7XG4gICAgbGV0IGo7XG5cbiAgICAvLyBBZGRpbmcgb2Zmc2V0XG4gICAgY29uc3QgYXZnUmFuZ2VTdGFydCA9IE1hdGguZmxvb3IoKGkgKyAxKSAqIGJ1Y2tldFdpZHRoKSArIDEgKyBzdGFydDtcbiAgICBjb25zdCBhdmdSYW5nZUVuZCA9IE1hdGgubWluKE1hdGguZmxvb3IoKGkgKyAyKSAqIGJ1Y2tldFdpZHRoKSArIDEsIGNvdW50KSArIHN0YXJ0O1xuICAgIGNvbnN0IGF2Z1JhbmdlTGVuZ3RoID0gYXZnUmFuZ2VFbmQgLSBhdmdSYW5nZVN0YXJ0O1xuXG4gICAgZm9yIChqID0gYXZnUmFuZ2VTdGFydDsgaiA8IGF2Z1JhbmdlRW5kOyBqKyspIHtcbiAgICAgIGF2Z1ggKz0gZGF0YVtqXS54O1xuICAgICAgYXZnWSArPSBkYXRhW2pdLnk7XG4gICAgfVxuXG4gICAgYXZnWCAvPSBhdmdSYW5nZUxlbmd0aDtcbiAgICBhdmdZIC89IGF2Z1JhbmdlTGVuZ3RoO1xuXG4gICAgLy8gQWRkaW5nIG9mZnNldFxuICAgIGNvbnN0IHJhbmdlT2ZmcyA9IE1hdGguZmxvb3IoaSAqIGJ1Y2tldFdpZHRoKSArIDEgKyBzdGFydDtcbiAgICBjb25zdCByYW5nZVRvID0gTWF0aC5taW4oTWF0aC5mbG9vcigoaSArIDEpICogYnVja2V0V2lkdGgpICsgMSwgY291bnQpICsgc3RhcnQ7XG4gICAgY29uc3Qge3g6IHBvaW50QXgsIHk6IHBvaW50QXl9ID0gZGF0YVthXTtcblxuICAgIC8vIE5vdGUgdGhhdCB0aGlzIGlzIGNoYW5nZWQgZnJvbSB0aGUgb3JpZ2luYWwgYWxnb3JpdGhtIHdoaWNoIGluaXRpYWxpemVzIHRoZXNlXG4gICAgLy8gdmFsdWVzIHRvIDEuIFRoZSByZWFzb24gZm9yIHRoaXMgY2hhbmdlIGlzIHRoYXQgaWYgdGhlIGFyZWEgaXMgc21hbGwsIG5leHRBXG4gICAgLy8gd291bGQgbmV2ZXIgYmUgc2V0IGFuZCB0aHVzIGEgY3Jhc2ggd291bGQgb2NjdXIgaW4gdGhlIG5leHQgbG9vcCBhcyBgYWAgd291bGQgYmVjb21lXG4gICAgLy8gYHVuZGVmaW5lZGAuIFNpbmNlIHRoZSBhcmVhIGlzIGFsd2F5cyBwb3NpdGl2ZSwgYnV0IGNvdWxkIGJlIDAgaW4gdGhlIGNhc2Ugb2YgYSBmbGF0IHRyYWNlLFxuICAgIC8vIGluaXRpYWxpemluZyB3aXRoIGEgbmVnYXRpdmUgbnVtYmVyIGlzIHRoZSBjb3JyZWN0IHNvbHV0aW9uLlxuICAgIG1heEFyZWEgPSBhcmVhID0gLTE7XG5cbiAgICBmb3IgKGogPSByYW5nZU9mZnM7IGogPCByYW5nZVRvOyBqKyspIHtcbiAgICAgIGFyZWEgPSAwLjUgKiBNYXRoLmFicyhcbiAgICAgICAgKHBvaW50QXggLSBhdmdYKSAqIChkYXRhW2pdLnkgLSBwb2ludEF5KSAtXG4gICAgICAgIChwb2ludEF4IC0gZGF0YVtqXS54KSAqIChhdmdZIC0gcG9pbnRBeSlcbiAgICAgICk7XG5cbiAgICAgIGlmIChhcmVhID4gbWF4QXJlYSkge1xuICAgICAgICBtYXhBcmVhID0gYXJlYTtcbiAgICAgICAgbWF4QXJlYVBvaW50ID0gZGF0YVtqXTtcbiAgICAgICAgbmV4dEEgPSBqO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRlY2ltYXRlZFtzYW1wbGVkSW5kZXgrK10gPSBtYXhBcmVhUG9pbnQ7XG4gICAgYSA9IG5leHRBO1xuICB9XG5cbiAgLy8gSW5jbHVkZSB0aGUgbGFzdCBwb2ludFxuICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gZGF0YVtlbmRJbmRleF07XG5cbiAgcmV0dXJuIGRlY2ltYXRlZDtcbn1cblxuZnVuY3Rpb24gbWluTWF4RGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoKSB7XG4gIGxldCBhdmdYID0gMDtcbiAgbGV0IGNvdW50WCA9IDA7XG4gIGxldCBpLCBwb2ludCwgeCwgeSwgcHJldlgsIG1pbkluZGV4LCBtYXhJbmRleCwgc3RhcnRJbmRleCwgbWluWSwgbWF4WTtcbiAgY29uc3QgZGVjaW1hdGVkID0gW107XG4gIGNvbnN0IGVuZEluZGV4ID0gc3RhcnQgKyBjb3VudCAtIDE7XG5cbiAgY29uc3QgeE1pbiA9IGRhdGFbc3RhcnRdLng7XG4gIGNvbnN0IHhNYXggPSBkYXRhW2VuZEluZGV4XS54O1xuICBjb25zdCBkeCA9IHhNYXggLSB4TWluO1xuXG4gIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgcG9pbnQgPSBkYXRhW2ldO1xuICAgIHggPSAocG9pbnQueCAtIHhNaW4pIC8gZHggKiBhdmFpbGFibGVXaWR0aDtcbiAgICB5ID0gcG9pbnQueTtcbiAgICBjb25zdCB0cnVuY1ggPSB4IHwgMDtcblxuICAgIGlmICh0cnVuY1ggPT09IHByZXZYKSB7XG4gICAgICAvLyBEZXRlcm1pbmUgYG1pbllgIC8gYG1heFlgIGFuZCBgYXZnWGAgd2hpbGUgd2Ugc3RheSB3aXRoaW4gc2FtZSB4LXBvc2l0aW9uXG4gICAgICBpZiAoeSA8IG1pblkpIHtcbiAgICAgICAgbWluWSA9IHk7XG4gICAgICAgIG1pbkluZGV4ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoeSA+IG1heFkpIHtcbiAgICAgICAgbWF4WSA9IHk7XG4gICAgICAgIG1heEluZGV4ID0gaTtcbiAgICAgIH1cbiAgICAgIC8vIEZvciBmaXJzdCBwb2ludCBpbiBncm91cCwgY291bnRYIGlzIGAwYCwgc28gYXZlcmFnZSB3aWxsIGJlIGB4YCAvIDEuXG4gICAgICAvLyBVc2UgcG9pbnQueCBoZXJlIGJlY2F1c2Ugd2UncmUgY29tcHV0aW5nIHRoZSBhdmVyYWdlIGRhdGEgYHhgIHZhbHVlXG4gICAgICBhdmdYID0gKGNvdW50WCAqIGF2Z1ggKyBwb2ludC54KSAvICsrY291bnRYO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQdXNoIHVwIHRvIDQgcG9pbnRzLCAzIGZvciB0aGUgbGFzdCBpbnRlcnZhbCBhbmQgdGhlIGZpcnN0IHBvaW50IGZvciB0aGlzIGludGVydmFsXG4gICAgICBjb25zdCBsYXN0SW5kZXggPSBpIC0gMTtcblxuICAgICAgaWYgKCFpc051bGxPclVuZGVmKG1pbkluZGV4KSAmJiAhaXNOdWxsT3JVbmRlZihtYXhJbmRleCkpIHtcbiAgICAgICAgLy8gVGhlIGludGVydmFsIGlzIGRlZmluZWQgYnkgNCBwb2ludHM6IHN0YXJ0LCBtaW4sIG1heCwgZW5kLlxuICAgICAgICAvLyBUaGUgc3RhcnRpbmcgcG9pbnQgaXMgYWxyZWFkeSBjb25zaWRlcmVkIGF0IHRoaXMgcG9pbnQsIHNvIHdlIG5lZWQgdG8gZGV0ZXJtaW5lIHdoaWNoXG4gICAgICAgIC8vIG9mIHRoZSBvdGhlciBwb2ludHMgdG8gYWRkLiBXZSBuZWVkIHRvIHNvcnQgdGhlc2UgcG9pbnRzIHRvIGVuc3VyZSB0aGUgZGVjaW1hdGVkIGRhdGFcbiAgICAgICAgLy8gaXMgc3RpbGwgc29ydGVkIGFuZCB0aGVuIGVuc3VyZSB0aGVyZSBhcmUgbm8gZHVwbGljYXRlcy5cbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlSW5kZXgxID0gTWF0aC5taW4obWluSW5kZXgsIG1heEluZGV4KTtcbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlSW5kZXgyID0gTWF0aC5tYXgobWluSW5kZXgsIG1heEluZGV4KTtcblxuICAgICAgICBpZiAoaW50ZXJtZWRpYXRlSW5kZXgxICE9PSBzdGFydEluZGV4ICYmIGludGVybWVkaWF0ZUluZGV4MSAhPT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgZGVjaW1hdGVkLnB1c2goe1xuICAgICAgICAgICAgLi4uZGF0YVtpbnRlcm1lZGlhdGVJbmRleDFdLFxuICAgICAgICAgICAgeDogYXZnWCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJtZWRpYXRlSW5kZXgyICE9PSBzdGFydEluZGV4ICYmIGludGVybWVkaWF0ZUluZGV4MiAhPT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgZGVjaW1hdGVkLnB1c2goe1xuICAgICAgICAgICAgLi4uZGF0YVtpbnRlcm1lZGlhdGVJbmRleDJdLFxuICAgICAgICAgICAgeDogYXZnWFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGxhc3RJbmRleCA9PT0gc3RhcnRJbmRleCB3aWxsIG9jY3VyIHdoZW4gYSByYW5nZSBoYXMgb25seSAxIHBvaW50IHdoaWNoIGNvdWxkXG4gICAgICAvLyBoYXBwZW4gd2l0aCB2ZXJ5IHVuZXZlbiBkYXRhXG4gICAgICBpZiAoaSA+IDAgJiYgbGFzdEluZGV4ICE9PSBzdGFydEluZGV4KSB7XG4gICAgICAgIC8vIExhc3QgcG9pbnQgaW4gdGhlIHByZXZpb3VzIGludGVydmFsXG4gICAgICAgIGRlY2ltYXRlZC5wdXNoKGRhdGFbbGFzdEluZGV4XSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFN0YXJ0IG9mIHRoZSBuZXcgaW50ZXJ2YWxcbiAgICAgIGRlY2ltYXRlZC5wdXNoKHBvaW50KTtcbiAgICAgIHByZXZYID0gdHJ1bmNYO1xuICAgICAgY291bnRYID0gMDtcbiAgICAgIG1pblkgPSBtYXhZID0geTtcbiAgICAgIG1pbkluZGV4ID0gbWF4SW5kZXggPSBzdGFydEluZGV4ID0gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVjaW1hdGVkO1xufVxuXG5mdW5jdGlvbiBjbGVhbkRlY2ltYXRlZERhdGFzZXQoZGF0YXNldCkge1xuICBpZiAoZGF0YXNldC5fZGVjaW1hdGVkKSB7XG4gICAgY29uc3QgZGF0YSA9IGRhdGFzZXQuX2RhdGE7XG4gICAgZGVsZXRlIGRhdGFzZXQuX2RlY2ltYXRlZDtcbiAgICBkZWxldGUgZGF0YXNldC5fZGF0YTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGF0YXNldCwgJ2RhdGEnLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZGF0YSxcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhbkRlY2ltYXRlZERhdGEoY2hhcnQpIHtcbiAgY2hhcnQuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKChkYXRhc2V0KSA9PiB7XG4gICAgY2xlYW5EZWNpbWF0ZWREYXRhc2V0KGRhdGFzZXQpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50c1NpbXBsaWZpZWQobWV0YSwgcG9pbnRzKSB7XG4gIGNvbnN0IHBvaW50Q291bnQgPSBwb2ludHMubGVuZ3RoO1xuXG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBjb3VudDtcblxuICBjb25zdCB7aVNjYWxlfSA9IG1ldGE7XG4gIGNvbnN0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSBpU2NhbGUuZ2V0VXNlckJvdW5kcygpO1xuXG4gIGlmIChtaW5EZWZpbmVkKSB7XG4gICAgc3RhcnQgPSBfbGltaXRWYWx1ZShfbG9va3VwQnlLZXkocG9pbnRzLCBpU2NhbGUuYXhpcywgbWluKS5sbywgMCwgcG9pbnRDb3VudCAtIDEpO1xuICB9XG4gIGlmIChtYXhEZWZpbmVkKSB7XG4gICAgY291bnQgPSBfbGltaXRWYWx1ZShfbG9va3VwQnlLZXkocG9pbnRzLCBpU2NhbGUuYXhpcywgbWF4KS5oaSArIDEsIHN0YXJ0LCBwb2ludENvdW50KSAtIHN0YXJ0O1xuICB9IGVsc2Uge1xuICAgIGNvdW50ID0gcG9pbnRDb3VudCAtIHN0YXJ0O1xuICB9XG5cbiAgcmV0dXJuIHtzdGFydCwgY291bnR9O1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlkOiAnZGVjaW1hdGlvbicsXG5cbiAgZGVmYXVsdHM6IHtcbiAgICBhbGdvcml0aG06ICdtaW4tbWF4JyxcbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgfSxcblxuICBiZWZvcmVFbGVtZW50c1VwZGF0ZTogKGNoYXJ0LCBhcmdzLCBvcHRpb25zKSA9PiB7XG4gICAgaWYgKCFvcHRpb25zLmVuYWJsZWQpIHtcbiAgICAgIC8vIFRoZSBkZWNpbWF0aW9uIHBsdWdpbiBtYXkgaGF2ZSBiZWVuIHByZXZpb3VzbHkgZW5hYmxlZC4gTmVlZCB0byByZW1vdmUgb2xkIGBkYXRhc2V0Ll9kYXRhYCBoYW5kbGVyc1xuICAgICAgY2xlYW5EZWNpbWF0ZWREYXRhKGNoYXJ0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBBc3N1bWUgdGhlIGVudGlyZSBjaGFydCBpcyBhdmFpbGFibGUgdG8gc2hvdyBhIGZldyBtb3JlIHBvaW50cyB0aGFuIG5lZWRlZFxuICAgIGNvbnN0IGF2YWlsYWJsZVdpZHRoID0gY2hhcnQud2lkdGg7XG5cbiAgICBjaGFydC5kYXRhLmRhdGFzZXRzLmZvckVhY2goKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkgPT4ge1xuICAgICAgY29uc3Qge19kYXRhLCBpbmRleEF4aXN9ID0gZGF0YXNldDtcbiAgICAgIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgICAgY29uc3QgZGF0YSA9IF9kYXRhIHx8IGRhdGFzZXQuZGF0YTtcblxuICAgICAgaWYgKHJlc29sdmUoW2luZGV4QXhpcywgY2hhcnQub3B0aW9ucy5pbmRleEF4aXNdKSA9PT0gJ3knKSB7XG4gICAgICAgIC8vIERlY2ltYXRpb24gaXMgb25seSBzdXBwb3J0ZWQgZm9yIGxpbmVzIHRoYXQgaGF2ZSBhbiBYIGluZGV4QXhpc1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghbWV0YS5jb250cm9sbGVyLnN1cHBvcnRzRGVjaW1hdGlvbikge1xuICAgICAgICAvLyBPbmx5IGxpbmUgZGF0YXNldHMgYXJlIHN1cHBvcnRlZFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHhBeGlzID0gY2hhcnQuc2NhbGVzW21ldGEueEF4aXNJRF07XG4gICAgICBpZiAoeEF4aXMudHlwZSAhPT0gJ2xpbmVhcicgJiYgeEF4aXMudHlwZSAhPT0gJ3RpbWUnKSB7XG4gICAgICAgIC8vIE9ubHkgbGluZWFyIGludGVycG9sYXRpb24gaXMgc3VwcG9ydGVkXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoYXJ0Lm9wdGlvbnMucGFyc2luZykge1xuICAgICAgICAvLyBQbHVnaW4gb25seSBzdXBwb3J0cyBkYXRhIHRoYXQgZG9lcyBub3QgbmVlZCBwYXJzaW5nXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IHtzdGFydCwgY291bnR9ID0gZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50c1NpbXBsaWZpZWQobWV0YSwgZGF0YSk7XG4gICAgICBjb25zdCB0aHJlc2hvbGQgPSBvcHRpb25zLnRocmVzaG9sZCB8fCA0ICogYXZhaWxhYmxlV2lkdGg7XG4gICAgICBpZiAoY291bnQgPD0gdGhyZXNob2xkKSB7XG4gICAgICAgIC8vIE5vIGRlY2ltYXRpb24gaXMgcmVxdWlyZWQgdW50aWwgd2UgYXJlIGFib3ZlIHRoaXMgdGhyZXNob2xkXG4gICAgICAgIGNsZWFuRGVjaW1hdGVkRGF0YXNldChkYXRhc2V0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZihfZGF0YSkpIHtcbiAgICAgICAgLy8gRmlyc3QgdGltZSB3ZSBhcmUgc2VlaW5nIHRoaXMgZGF0YXNldFxuICAgICAgICAvLyBXZSBvdmVycmlkZSB0aGUgJ2RhdGEnIHByb3BlcnR5IHdpdGggYSBzZXR0ZXIgdGhhdCBzdG9yZXMgdGhlXG4gICAgICAgIC8vIHJhdyBkYXRhIGluIF9kYXRhLCBidXQgcmVhZHMgdGhlIGRlY2ltYXRlZCBkYXRhIGZyb20gX2RlY2ltYXRlZFxuICAgICAgICBkYXRhc2V0Ll9kYXRhID0gZGF0YTtcbiAgICAgICAgZGVsZXRlIGRhdGFzZXQuZGF0YTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRhdGFzZXQsICdkYXRhJywge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVjaW1hdGVkO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB0aGlzLl9kYXRhID0gZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBQb2ludCB0aGUgY2hhcnQgdG8gdGhlIGRlY2ltYXRlZCBkYXRhXG4gICAgICBsZXQgZGVjaW1hdGVkO1xuICAgICAgc3dpdGNoIChvcHRpb25zLmFsZ29yaXRobSkge1xuICAgICAgY2FzZSAnbHR0Yic6XG4gICAgICAgIGRlY2ltYXRlZCA9IGx0dGJEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgsIG9wdGlvbnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21pbi1tYXgnOlxuICAgICAgICBkZWNpbWF0ZWQgPSBtaW5NYXhEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGVjaW1hdGlvbiBhbGdvcml0aG0gJyR7b3B0aW9ucy5hbGdvcml0aG19J2ApO1xuICAgICAgfVxuXG4gICAgICBkYXRhc2V0Ll9kZWNpbWF0ZWQgPSBkZWNpbWF0ZWQ7XG4gICAgfSk7XG4gIH0sXG5cbiAgZGVzdHJveShjaGFydCkge1xuICAgIGNsZWFuRGVjaW1hdGVkRGF0YShjaGFydCk7XG4gIH1cbn07XG4iLCAiaW1wb3J0IHtfYm91bmRTZWdtZW50LCBfYm91bmRTZWdtZW50cywgX25vcm1hbGl6ZUFuZ2xlfSBmcm9tICcuLi8uLi9oZWxwZXJzL2luZGV4LmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIF9zZWdtZW50cyhsaW5lLCB0YXJnZXQsIHByb3BlcnR5KSB7XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgY29uc3QgcG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IHRwb2ludHMgPSB0YXJnZXQucG9pbnRzO1xuICBjb25zdCBwYXJ0cyA9IFtdO1xuXG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgIGxldCB7c3RhcnQsIGVuZH0gPSBzZWdtZW50O1xuICAgIGVuZCA9IF9maW5kU2VnbWVudEVuZChzdGFydCwgZW5kLCBwb2ludHMpO1xuXG4gICAgY29uc3QgYm91bmRzID0gX2dldEJvdW5kcyhwcm9wZXJ0eSwgcG9pbnRzW3N0YXJ0XSwgcG9pbnRzW2VuZF0sIHNlZ21lbnQubG9vcCk7XG5cbiAgICBpZiAoIXRhcmdldC5zZWdtZW50cykge1xuICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBib3VuZGFyeSBub3Qgc3VwcG9ydGluZyBgc2VnbWVudHNgIChzaW1wbGVBcmMpXG4gICAgICAvLyBCb3VuZHMgYXJlIHByb3ZpZGVkIGFzIGB0YXJnZXRgIGZvciBwYXJ0aWFsIGNpcmNsZSwgb3IgdW5kZWZpbmVkIGZvciBmdWxsIGNpcmNsZVxuICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgIHNvdXJjZTogc2VnbWVudCxcbiAgICAgICAgdGFyZ2V0OiBib3VuZHMsXG4gICAgICAgIHN0YXJ0OiBwb2ludHNbc3RhcnRdLFxuICAgICAgICBlbmQ6IHBvaW50c1tlbmRdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIEdldCBhbGwgc2VnbWVudHMgZnJvbSBgdGFyZ2V0YCB0aGF0IGludGVyc2VjdCB0aGUgYm91bmRzIG9mIGN1cnJlbnQgc2VnbWVudCBvZiBgbGluZWBcbiAgICBjb25zdCB0YXJnZXRTZWdtZW50cyA9IF9ib3VuZFNlZ21lbnRzKHRhcmdldCwgYm91bmRzKTtcblxuICAgIGZvciAoY29uc3QgdGd0IG9mIHRhcmdldFNlZ21lbnRzKSB7XG4gICAgICBjb25zdCBzdWJCb3VuZHMgPSBfZ2V0Qm91bmRzKHByb3BlcnR5LCB0cG9pbnRzW3RndC5zdGFydF0sIHRwb2ludHNbdGd0LmVuZF0sIHRndC5sb29wKTtcbiAgICAgIGNvbnN0IGZpbGxTb3VyY2VzID0gX2JvdW5kU2VnbWVudChzZWdtZW50LCBwb2ludHMsIHN1YkJvdW5kcyk7XG5cbiAgICAgIGZvciAoY29uc3QgZmlsbFNvdXJjZSBvZiBmaWxsU291cmNlcykge1xuICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICBzb3VyY2U6IGZpbGxTb3VyY2UsXG4gICAgICAgICAgdGFyZ2V0OiB0Z3QsXG4gICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgIFtwcm9wZXJ0eV06IF9nZXRFZGdlKGJvdW5kcywgc3ViQm91bmRzLCAnc3RhcnQnLCBNYXRoLm1heClcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVuZDoge1xuICAgICAgICAgICAgW3Byb3BlcnR5XTogX2dldEVkZ2UoYm91bmRzLCBzdWJCb3VuZHMsICdlbmQnLCBNYXRoLm1pbilcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGFydHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0Qm91bmRzKHByb3BlcnR5LCBmaXJzdCwgbGFzdCwgbG9vcCkge1xuICBpZiAobG9vcCkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgc3RhcnQgPSBmaXJzdFtwcm9wZXJ0eV07XG4gIGxldCBlbmQgPSBsYXN0W3Byb3BlcnR5XTtcblxuICBpZiAocHJvcGVydHkgPT09ICdhbmdsZScpIHtcbiAgICBzdGFydCA9IF9ub3JtYWxpemVBbmdsZShzdGFydCk7XG4gICAgZW5kID0gX25vcm1hbGl6ZUFuZ2xlKGVuZCk7XG4gIH1cbiAgcmV0dXJuIHtwcm9wZXJ0eSwgc3RhcnQsIGVuZH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfcG9pbnRzRnJvbVNlZ21lbnRzKGJvdW5kYXJ5LCBsaW5lKSB7XG4gIGNvbnN0IHt4ID0gbnVsbCwgeSA9IG51bGx9ID0gYm91bmRhcnkgfHwge307XG4gIGNvbnN0IGxpbmVQb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3QgcG9pbnRzID0gW107XG4gIGxpbmUuc2VnbWVudHMuZm9yRWFjaCgoe3N0YXJ0LCBlbmR9KSA9PiB7XG4gICAgZW5kID0gX2ZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIGxpbmVQb2ludHMpO1xuICAgIGNvbnN0IGZpcnN0ID0gbGluZVBvaW50c1tzdGFydF07XG4gICAgY29uc3QgbGFzdCA9IGxpbmVQb2ludHNbZW5kXTtcbiAgICBpZiAoeSAhPT0gbnVsbCkge1xuICAgICAgcG9pbnRzLnB1c2goe3g6IGZpcnN0LngsIHl9KTtcbiAgICAgIHBvaW50cy5wdXNoKHt4OiBsYXN0LngsIHl9KTtcbiAgICB9IGVsc2UgaWYgKHggIT09IG51bGwpIHtcbiAgICAgIHBvaW50cy5wdXNoKHt4LCB5OiBmaXJzdC55fSk7XG4gICAgICBwb2ludHMucHVzaCh7eCwgeTogbGFzdC55fSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHBvaW50cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9maW5kU2VnbWVudEVuZChzdGFydCwgZW5kLCBwb2ludHMpIHtcbiAgZm9yICg7ZW5kID4gc3RhcnQ7IGVuZC0tKSB7XG4gICAgY29uc3QgcG9pbnQgPSBwb2ludHNbZW5kXTtcbiAgICBpZiAoIWlzTmFOKHBvaW50LngpICYmICFpc05hTihwb2ludC55KSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbmQ7XG59XG5cbmZ1bmN0aW9uIF9nZXRFZGdlKGEsIGIsIHByb3AsIGZuKSB7XG4gIGlmIChhICYmIGIpIHtcbiAgICByZXR1cm4gZm4oYVtwcm9wXSwgYltwcm9wXSk7XG4gIH1cbiAgcmV0dXJuIGEgPyBhW3Byb3BdIDogYiA/IGJbcHJvcF0gOiAwO1xufVxuIiwgIi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2NvcmUvY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vY29yZS9jb3JlLnNjYWxlLmpzJykuZGVmYXVsdCB9IFNjYWxlXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vZWxlbWVudHMvZWxlbWVudC5wb2ludC5qcycpLmRlZmF1bHQgfSBQb2ludEVsZW1lbnRcbiAqL1xuXG5pbXBvcnQge0xpbmVFbGVtZW50fSBmcm9tICcuLi8uLi9lbGVtZW50cy9pbmRleC5qcyc7XG5pbXBvcnQge2lzQXJyYXl9IGZyb20gJy4uLy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtfcG9pbnRzRnJvbVNlZ21lbnRzfSBmcm9tICcuL2ZpbGxlci5zZWdtZW50LmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge1BvaW50RWxlbWVudFtdIHwgeyB4OiBudW1iZXI7IHk6IG51bWJlcjsgfX0gYm91bmRhcnlcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmVcbiAqIEByZXR1cm4ge0xpbmVFbGVtZW50P31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9jcmVhdGVCb3VuZGFyeUxpbmUoYm91bmRhcnksIGxpbmUpIHtcbiAgbGV0IHBvaW50cyA9IFtdO1xuICBsZXQgX2xvb3AgPSBmYWxzZTtcblxuICBpZiAoaXNBcnJheShib3VuZGFyeSkpIHtcbiAgICBfbG9vcCA9IHRydWU7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHBvaW50cyA9IGJvdW5kYXJ5O1xuICB9IGVsc2Uge1xuICAgIHBvaW50cyA9IF9wb2ludHNGcm9tU2VnbWVudHMoYm91bmRhcnksIGxpbmUpO1xuICB9XG5cbiAgcmV0dXJuIHBvaW50cy5sZW5ndGggPyBuZXcgTGluZUVsZW1lbnQoe1xuICAgIHBvaW50cyxcbiAgICBvcHRpb25zOiB7dGVuc2lvbjogMH0sXG4gICAgX2xvb3AsXG4gICAgX2Z1bGxMb29wOiBfbG9vcFxuICB9KSA6IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfc2hvdWxkQXBwbHlGaWxsKHNvdXJjZSkge1xuICByZXR1cm4gc291cmNlICYmIHNvdXJjZS5maWxsICE9PSBmYWxzZTtcbn1cbiIsICJpbXBvcnQge2lzT2JqZWN0LCBpc0Zpbml0ZSwgdmFsdWVPckRlZmF1bHR9IGZyb20gJy4uLy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vY29yZS9jb3JlLnNjYWxlLmpzJykuZGVmYXVsdCB9IFNjYWxlXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vZWxlbWVudHMvZWxlbWVudC5saW5lLmpzJykuZGVmYXVsdCB9IExpbmVFbGVtZW50XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vdHlwZXMvaW5kZXguanMnKS5GaWxsVGFyZ2V0IH0gRmlsbFRhcmdldFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL3R5cGVzL2luZGV4LmpzJykuQ29tcGxleEZpbGxUYXJnZXQgfSBDb21wbGV4RmlsbFRhcmdldFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBfcmVzb2x2ZVRhcmdldChzb3VyY2VzLCBpbmRleCwgcHJvcGFnYXRlKSB7XG4gIGNvbnN0IHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICBsZXQgZmlsbCA9IHNvdXJjZS5maWxsO1xuICBjb25zdCB2aXNpdGVkID0gW2luZGV4XTtcbiAgbGV0IHRhcmdldDtcblxuICBpZiAoIXByb3BhZ2F0ZSkge1xuICAgIHJldHVybiBmaWxsO1xuICB9XG5cbiAgd2hpbGUgKGZpbGwgIT09IGZhbHNlICYmIHZpc2l0ZWQuaW5kZXhPZihmaWxsKSA9PT0gLTEpIHtcbiAgICBpZiAoIWlzRmluaXRlKGZpbGwpKSB7XG4gICAgICByZXR1cm4gZmlsbDtcbiAgICB9XG5cbiAgICB0YXJnZXQgPSBzb3VyY2VzW2ZpbGxdO1xuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldC52aXNpYmxlKSB7XG4gICAgICByZXR1cm4gZmlsbDtcbiAgICB9XG5cbiAgICB2aXNpdGVkLnB1c2goZmlsbCk7XG4gICAgZmlsbCA9IHRhcmdldC5maWxsO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZGVjb2RlRmlsbChsaW5lLCBpbmRleCwgY291bnQpIHtcbiAgLyoqIEB0eXBlIHtzdHJpbmcgfCB7dmFsdWU6IG51bWJlcn19ICovXG4gIGNvbnN0IGZpbGwgPSBwYXJzZUZpbGxPcHRpb24obGluZSk7XG5cbiAgaWYgKGlzT2JqZWN0KGZpbGwpKSB7XG4gICAgcmV0dXJuIGlzTmFOKGZpbGwudmFsdWUpID8gZmFsc2UgOiBmaWxsO1xuICB9XG5cbiAgbGV0IHRhcmdldCA9IHBhcnNlRmxvYXQoZmlsbCk7XG5cbiAgaWYgKGlzRmluaXRlKHRhcmdldCkgJiYgTWF0aC5mbG9vcih0YXJnZXQpID09PSB0YXJnZXQpIHtcbiAgICByZXR1cm4gZGVjb2RlVGFyZ2V0SW5kZXgoZmlsbFswXSwgaW5kZXgsIHRhcmdldCwgY291bnQpO1xuICB9XG5cbiAgcmV0dXJuIFsnb3JpZ2luJywgJ3N0YXJ0JywgJ2VuZCcsICdzdGFjaycsICdzaGFwZSddLmluZGV4T2YoZmlsbCkgPj0gMCAmJiBmaWxsO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVUYXJnZXRJbmRleChmaXJzdENoLCBpbmRleCwgdGFyZ2V0LCBjb3VudCkge1xuICBpZiAoZmlyc3RDaCA9PT0gJy0nIHx8IGZpcnN0Q2ggPT09ICcrJykge1xuICAgIHRhcmdldCA9IGluZGV4ICsgdGFyZ2V0O1xuICB9XG5cbiAgaWYgKHRhcmdldCA9PT0gaW5kZXggfHwgdGFyZ2V0IDwgMCB8fCB0YXJnZXQgPj0gY291bnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RmlsbFRhcmdldCB8IENvbXBsZXhGaWxsVGFyZ2V0fSBmaWxsXG4gKiBAcGFyYW0ge1NjYWxlfSBzY2FsZVxuICogQHJldHVybnMge251bWJlciB8IG51bGx9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0VGFyZ2V0UGl4ZWwoZmlsbCwgc2NhbGUpIHtcbiAgbGV0IHBpeGVsID0gbnVsbDtcbiAgaWYgKGZpbGwgPT09ICdzdGFydCcpIHtcbiAgICBwaXhlbCA9IHNjYWxlLmJvdHRvbTtcbiAgfSBlbHNlIGlmIChmaWxsID09PSAnZW5kJykge1xuICAgIHBpeGVsID0gc2NhbGUudG9wO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGZpbGwpKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHBpeGVsID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShmaWxsLnZhbHVlKTtcbiAgfSBlbHNlIGlmIChzY2FsZS5nZXRCYXNlUGl4ZWwpIHtcbiAgICBwaXhlbCA9IHNjYWxlLmdldEJhc2VQaXhlbCgpO1xuICB9XG4gIHJldHVybiBwaXhlbDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZpbGxUYXJnZXQgfCBDb21wbGV4RmlsbFRhcmdldH0gZmlsbFxuICogQHBhcmFtIHtTY2FsZX0gc2NhbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFZhbHVlXG4gKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2dldFRhcmdldFZhbHVlKGZpbGwsIHNjYWxlLCBzdGFydFZhbHVlKSB7XG4gIGxldCB2YWx1ZTtcblxuICBpZiAoZmlsbCA9PT0gJ3N0YXJ0Jykge1xuICAgIHZhbHVlID0gc3RhcnRWYWx1ZTtcbiAgfSBlbHNlIGlmIChmaWxsID09PSAnZW5kJykge1xuICAgIHZhbHVlID0gc2NhbGUub3B0aW9ucy5yZXZlcnNlID8gc2NhbGUubWluIDogc2NhbGUubWF4O1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGZpbGwpKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHZhbHVlID0gZmlsbC52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IHNjYWxlLmdldEJhc2VWYWx1ZSgpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRmlsbE9wdGlvbihsaW5lKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBsaW5lLm9wdGlvbnM7XG4gIGNvbnN0IGZpbGxPcHRpb24gPSBvcHRpb25zLmZpbGw7XG4gIGxldCBmaWxsID0gdmFsdWVPckRlZmF1bHQoZmlsbE9wdGlvbiAmJiBmaWxsT3B0aW9uLnRhcmdldCwgZmlsbE9wdGlvbik7XG5cbiAgaWYgKGZpbGwgPT09IHVuZGVmaW5lZCkge1xuICAgIGZpbGwgPSAhIW9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICB9XG5cbiAgaWYgKGZpbGwgPT09IGZhbHNlIHx8IGZpbGwgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoZmlsbCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiAnb3JpZ2luJztcbiAgfVxuICByZXR1cm4gZmlsbDtcbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9jb3JlL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2NvcmUvY29yZS5zY2FsZS5qcycpLmRlZmF1bHQgfSBTY2FsZVxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2VsZW1lbnRzL2VsZW1lbnQucG9pbnQuanMnKS5kZWZhdWx0IH0gUG9pbnRFbGVtZW50XG4gKi9cblxuaW1wb3J0IHtMaW5lRWxlbWVudH0gZnJvbSAnLi4vLi4vZWxlbWVudHMvaW5kZXguanMnO1xuaW1wb3J0IHtfaXNCZXR3ZWVufSBmcm9tICcuLi8uLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7X2NyZWF0ZUJvdW5kYXJ5TGluZX0gZnJvbSAnLi9maWxsZXIuaGVscGVyLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge3sgY2hhcnQ6IENoYXJ0OyBzY2FsZTogU2NhbGU7IGluZGV4OiBudW1iZXI7IGxpbmU6IExpbmVFbGVtZW50OyB9fSBzb3VyY2VcbiAqIEByZXR1cm4ge0xpbmVFbGVtZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2J1aWxkU3RhY2tMaW5lKHNvdXJjZSkge1xuICBjb25zdCB7c2NhbGUsIGluZGV4LCBsaW5lfSA9IHNvdXJjZTtcbiAgY29uc3QgcG9pbnRzID0gW107XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgY29uc3Qgc291cmNlUG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IGxpbmVzQmVsb3cgPSBnZXRMaW5lc0JlbG93KHNjYWxlLCBpbmRleCk7XG4gIGxpbmVzQmVsb3cucHVzaChfY3JlYXRlQm91bmRhcnlMaW5lKHt4OiBudWxsLCB5OiBzY2FsZS5ib3R0b219LCBsaW5lKSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICBmb3IgKGxldCBqID0gc2VnbWVudC5zdGFydDsgaiA8PSBzZWdtZW50LmVuZDsgaisrKSB7XG4gICAgICBhZGRQb2ludHNCZWxvdyhwb2ludHMsIHNvdXJjZVBvaW50c1tqXSwgbGluZXNCZWxvdyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgTGluZUVsZW1lbnQoe3BvaW50cywgb3B0aW9uczoge319KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NjYWxlfSBzY2FsZVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcmV0dXJuIHtMaW5lRWxlbWVudFtdfVxuICovXG5mdW5jdGlvbiBnZXRMaW5lc0JlbG93KHNjYWxlLCBpbmRleCkge1xuICBjb25zdCBiZWxvdyA9IFtdO1xuICBjb25zdCBtZXRhcyA9IHNjYWxlLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCdsaW5lJyk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXRhcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG1ldGEgPSBtZXRhc1tpXTtcbiAgICBpZiAobWV0YS5pbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoIW1ldGEuaGlkZGVuKSB7XG4gICAgICBiZWxvdy51bnNoaWZ0KG1ldGEuZGF0YXNldCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBiZWxvdztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1BvaW50RWxlbWVudFtdfSBwb2ludHNcbiAqIEBwYXJhbSB7UG9pbnRFbGVtZW50fSBzb3VyY2VQb2ludFxuICogQHBhcmFtIHtMaW5lRWxlbWVudFtdfSBsaW5lc0JlbG93XG4gKi9cbmZ1bmN0aW9uIGFkZFBvaW50c0JlbG93KHBvaW50cywgc291cmNlUG9pbnQsIGxpbmVzQmVsb3cpIHtcbiAgY29uc3QgcG9zdHBvbmVkID0gW107XG4gIGZvciAobGV0IGogPSAwOyBqIDwgbGluZXNCZWxvdy5sZW5ndGg7IGorKykge1xuICAgIGNvbnN0IGxpbmUgPSBsaW5lc0JlbG93W2pdO1xuICAgIGNvbnN0IHtmaXJzdCwgbGFzdCwgcG9pbnR9ID0gZmluZFBvaW50KGxpbmUsIHNvdXJjZVBvaW50LCAneCcpO1xuXG4gICAgaWYgKCFwb2ludCB8fCAoZmlyc3QgJiYgbGFzdCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoZmlyc3QpIHtcbiAgICAgIC8vIEZpcnN0IHBvaW50IG9mIGFuIHNlZ21lbnQgLT4gbmVlZCB0byBhZGQgYW5vdGhlciBwb2ludCBiZWZvcmUgdGhpcyxcbiAgICAgIC8vIGZyb20gbmV4dCBsaW5lIGJlbG93LlxuICAgICAgcG9zdHBvbmVkLnVuc2hpZnQocG9pbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludHMucHVzaChwb2ludCk7XG4gICAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgLy8gSW4gdGhlIG1pZGRsZSBvZiBhbiBzZWdtZW50LCBubyBuZWVkIHRvIGFkZCBtb3JlIHBvaW50cy5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBvaW50cy5wdXNoKC4uLnBvc3Rwb25lZCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICogQHBhcmFtIHtQb2ludEVsZW1lbnR9IHNvdXJjZVBvaW50XG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAqIEByZXR1cm5zIHt7cG9pbnQ/OiBQb2ludEVsZW1lbnQsIGZpcnN0PzogYm9vbGVhbiwgbGFzdD86IGJvb2xlYW59fVxuICovXG5mdW5jdGlvbiBmaW5kUG9pbnQobGluZSwgc291cmNlUG9pbnQsIHByb3BlcnR5KSB7XG4gIGNvbnN0IHBvaW50ID0gbGluZS5pbnRlcnBvbGF0ZShzb3VyY2VQb2ludCwgcHJvcGVydHkpO1xuICBpZiAoIXBvaW50KSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgY29uc3QgcG9pbnRWYWx1ZSA9IHBvaW50W3Byb3BlcnR5XTtcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuICBjb25zdCBsaW5lUG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGxldCBmaXJzdCA9IGZhbHNlO1xuICBsZXQgbGFzdCA9IGZhbHNlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgIGNvbnN0IGZpcnN0VmFsdWUgPSBsaW5lUG9pbnRzW3NlZ21lbnQuc3RhcnRdW3Byb3BlcnR5XTtcbiAgICBjb25zdCBsYXN0VmFsdWUgPSBsaW5lUG9pbnRzW3NlZ21lbnQuZW5kXVtwcm9wZXJ0eV07XG4gICAgaWYgKF9pc0JldHdlZW4ocG9pbnRWYWx1ZSwgZmlyc3RWYWx1ZSwgbGFzdFZhbHVlKSkge1xuICAgICAgZmlyc3QgPSBwb2ludFZhbHVlID09PSBmaXJzdFZhbHVlO1xuICAgICAgbGFzdCA9IHBvaW50VmFsdWUgPT09IGxhc3RWYWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge2ZpcnN0LCBsYXN0LCBwb2ludH07XG59XG4iLCAiaW1wb3J0IHtUQVV9IGZyb20gJy4uLy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG4vLyBUT0RPOiB1c2UgZWxlbWVudHMuQXJjRWxlbWVudCBpbnN0ZWFkXG5leHBvcnQgY2xhc3Mgc2ltcGxlQXJjIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHRoaXMueCA9IG9wdHMueDtcbiAgICB0aGlzLnkgPSBvcHRzLnk7XG4gICAgdGhpcy5yYWRpdXMgPSBvcHRzLnJhZGl1cztcbiAgfVxuXG4gIHBhdGhTZWdtZW50KGN0eCwgYm91bmRzLCBvcHRzKSB7XG4gICAgY29uc3Qge3gsIHksIHJhZGl1c30gPSB0aGlzO1xuICAgIGJvdW5kcyA9IGJvdW5kcyB8fCB7c3RhcnQ6IDAsIGVuZDogVEFVfTtcbiAgICBjdHguYXJjKHgsIHksIHJhZGl1cywgYm91bmRzLmVuZCwgYm91bmRzLnN0YXJ0LCB0cnVlKTtcbiAgICByZXR1cm4gIW9wdHMuYm91bmRzO1xuICB9XG5cbiAgaW50ZXJwb2xhdGUocG9pbnQpIHtcbiAgICBjb25zdCB7eCwgeSwgcmFkaXVzfSA9IHRoaXM7XG4gICAgY29uc3QgYW5nbGUgPSBwb2ludC5hbmdsZTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCArIE1hdGguY29zKGFuZ2xlKSAqIHJhZGl1cyxcbiAgICAgIHk6IHkgKyBNYXRoLnNpbihhbmdsZSkgKiByYWRpdXMsXG4gICAgICBhbmdsZVxuICAgIH07XG4gIH1cbn1cbiIsICJpbXBvcnQge2lzRmluaXRlfSBmcm9tICcuLi8uLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7X2NyZWF0ZUJvdW5kYXJ5TGluZX0gZnJvbSAnLi9maWxsZXIuaGVscGVyLmpzJztcbmltcG9ydCB7X2dldFRhcmdldFBpeGVsLCBfZ2V0VGFyZ2V0VmFsdWV9IGZyb20gJy4vZmlsbGVyLm9wdGlvbnMuanMnO1xuaW1wb3J0IHtfYnVpbGRTdGFja0xpbmV9IGZyb20gJy4vZmlsbGVyLnRhcmdldC5zdGFjay5qcyc7XG5pbXBvcnQge3NpbXBsZUFyY30gZnJvbSAnLi9zaW1wbGVBcmMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9jb3JlL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2NvcmUvY29yZS5zY2FsZS5qcycpLmRlZmF1bHQgfSBTY2FsZVxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2VsZW1lbnRzL2VsZW1lbnQucG9pbnQuanMnKS5kZWZhdWx0IH0gUG9pbnRFbGVtZW50XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIF9nZXRUYXJnZXQoc291cmNlKSB7XG4gIGNvbnN0IHtjaGFydCwgZmlsbCwgbGluZX0gPSBzb3VyY2U7XG5cbiAgaWYgKGlzRmluaXRlKGZpbGwpKSB7XG4gICAgcmV0dXJuIGdldExpbmVCeUluZGV4KGNoYXJ0LCBmaWxsKTtcbiAgfVxuXG4gIGlmIChmaWxsID09PSAnc3RhY2snKSB7XG4gICAgcmV0dXJuIF9idWlsZFN0YWNrTGluZShzb3VyY2UpO1xuICB9XG5cbiAgaWYgKGZpbGwgPT09ICdzaGFwZScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IGJvdW5kYXJ5ID0gY29tcHV0ZUJvdW5kYXJ5KHNvdXJjZSk7XG5cbiAgaWYgKGJvdW5kYXJ5IGluc3RhbmNlb2Ygc2ltcGxlQXJjKSB7XG4gICAgcmV0dXJuIGJvdW5kYXJ5O1xuICB9XG5cbiAgcmV0dXJuIF9jcmVhdGVCb3VuZGFyeUxpbmUoYm91bmRhcnksIGxpbmUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqL1xuZnVuY3Rpb24gZ2V0TGluZUJ5SW5kZXgoY2hhcnQsIGluZGV4KSB7XG4gIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpbmRleCk7XG4gIGNvbnN0IHZpc2libGUgPSBtZXRhICYmIGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaW5kZXgpO1xuICByZXR1cm4gdmlzaWJsZSA/IG1ldGEuZGF0YXNldCA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVCb3VuZGFyeShzb3VyY2UpIHtcbiAgY29uc3Qgc2NhbGUgPSBzb3VyY2Uuc2NhbGUgfHwge307XG5cbiAgaWYgKHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSkge1xuICAgIHJldHVybiBjb21wdXRlQ2lyY3VsYXJCb3VuZGFyeShzb3VyY2UpO1xuICB9XG4gIHJldHVybiBjb21wdXRlTGluZWFyQm91bmRhcnkoc291cmNlKTtcbn1cblxuXG5mdW5jdGlvbiBjb21wdXRlTGluZWFyQm91bmRhcnkoc291cmNlKSB7XG4gIGNvbnN0IHtzY2FsZSA9IHt9LCBmaWxsfSA9IHNvdXJjZTtcbiAgY29uc3QgcGl4ZWwgPSBfZ2V0VGFyZ2V0UGl4ZWwoZmlsbCwgc2NhbGUpO1xuXG4gIGlmIChpc0Zpbml0ZShwaXhlbCkpIHtcbiAgICBjb25zdCBob3Jpem9udGFsID0gc2NhbGUuaXNIb3Jpem9udGFsKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogaG9yaXpvbnRhbCA/IHBpeGVsIDogbnVsbCxcbiAgICAgIHk6IGhvcml6b250YWwgPyBudWxsIDogcGl4ZWxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVDaXJjdWxhckJvdW5kYXJ5KHNvdXJjZSkge1xuICBjb25zdCB7c2NhbGUsIGZpbGx9ID0gc291cmNlO1xuICBjb25zdCBvcHRpb25zID0gc2NhbGUub3B0aW9ucztcbiAgY29uc3QgbGVuZ3RoID0gc2NhbGUuZ2V0TGFiZWxzKCkubGVuZ3RoO1xuICBjb25zdCBzdGFydCA9IG9wdGlvbnMucmV2ZXJzZSA/IHNjYWxlLm1heCA6IHNjYWxlLm1pbjtcbiAgY29uc3QgdmFsdWUgPSBfZ2V0VGFyZ2V0VmFsdWUoZmlsbCwgc2NhbGUsIHN0YXJ0KTtcbiAgY29uc3QgdGFyZ2V0ID0gW107XG5cbiAgaWYgKG9wdGlvbnMuZ3JpZC5jaXJjdWxhcikge1xuICAgIGNvbnN0IGNlbnRlciA9IHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSgwLCBzdGFydCk7XG4gICAgcmV0dXJuIG5ldyBzaW1wbGVBcmMoe1xuICAgICAgeDogY2VudGVyLngsXG4gICAgICB5OiBjZW50ZXIueSxcbiAgICAgIHJhZGl1czogc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpXG4gICAgfSk7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdGFyZ2V0LnB1c2goc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGksIHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuIiwgImltcG9ydCB7Y2xpcEFyZWEsIHVuY2xpcEFyZWF9IGZyb20gJy4uLy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtfZmluZFNlZ21lbnRFbmQsIF9nZXRCb3VuZHMsIF9zZWdtZW50c30gZnJvbSAnLi9maWxsZXIuc2VnbWVudC5qcyc7XG5pbXBvcnQge19nZXRUYXJnZXR9IGZyb20gJy4vZmlsbGVyLnRhcmdldC5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBfZHJhd2ZpbGwoY3R4LCBzb3VyY2UsIGFyZWEpIHtcbiAgY29uc3QgdGFyZ2V0ID0gX2dldFRhcmdldChzb3VyY2UpO1xuICBjb25zdCB7bGluZSwgc2NhbGUsIGF4aXN9ID0gc291cmNlO1xuICBjb25zdCBsaW5lT3B0cyA9IGxpbmUub3B0aW9ucztcbiAgY29uc3QgZmlsbE9wdGlvbiA9IGxpbmVPcHRzLmZpbGw7XG4gIGNvbnN0IGNvbG9yID0gbGluZU9wdHMuYmFja2dyb3VuZENvbG9yO1xuICBjb25zdCB7YWJvdmUgPSBjb2xvciwgYmVsb3cgPSBjb2xvcn0gPSBmaWxsT3B0aW9uIHx8IHt9O1xuICBpZiAodGFyZ2V0ICYmIGxpbmUucG9pbnRzLmxlbmd0aCkge1xuICAgIGNsaXBBcmVhKGN0eCwgYXJlYSk7XG4gICAgZG9GaWxsKGN0eCwge2xpbmUsIHRhcmdldCwgYWJvdmUsIGJlbG93LCBhcmVhLCBzY2FsZSwgYXhpc30pO1xuICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkb0ZpbGwoY3R4LCBjZmcpIHtcbiAgY29uc3Qge2xpbmUsIHRhcmdldCwgYWJvdmUsIGJlbG93LCBhcmVhLCBzY2FsZX0gPSBjZmc7XG4gIGNvbnN0IHByb3BlcnR5ID0gbGluZS5fbG9vcCA/ICdhbmdsZScgOiBjZmcuYXhpcztcblxuICBjdHguc2F2ZSgpO1xuXG4gIGlmIChwcm9wZXJ0eSA9PT0gJ3gnICYmIGJlbG93ICE9PSBhYm92ZSkge1xuICAgIGNsaXBWZXJ0aWNhbChjdHgsIHRhcmdldCwgYXJlYS50b3ApO1xuICAgIGZpbGwoY3R4LCB7bGluZSwgdGFyZ2V0LCBjb2xvcjogYWJvdmUsIHNjYWxlLCBwcm9wZXJ0eX0pO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjbGlwVmVydGljYWwoY3R4LCB0YXJnZXQsIGFyZWEuYm90dG9tKTtcbiAgfVxuICBmaWxsKGN0eCwge2xpbmUsIHRhcmdldCwgY29sb3I6IGJlbG93LCBzY2FsZSwgcHJvcGVydHl9KTtcblxuICBjdHgucmVzdG9yZSgpO1xufVxuXG5mdW5jdGlvbiBjbGlwVmVydGljYWwoY3R4LCB0YXJnZXQsIGNsaXBZKSB7XG4gIGNvbnN0IHtzZWdtZW50cywgcG9pbnRzfSA9IHRhcmdldDtcbiAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgbGV0IGxpbmVMb29wID0gZmFsc2U7XG5cbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBjb25zdCB7c3RhcnQsIGVuZH0gPSBzZWdtZW50O1xuICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBwb2ludHNbc3RhcnRdO1xuICAgIGNvbnN0IGxhc3RQb2ludCA9IHBvaW50c1tfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgcG9pbnRzKV07XG4gICAgaWYgKGZpcnN0KSB7XG4gICAgICBjdHgubW92ZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcbiAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5saW5lVG8oZmlyc3RQb2ludC54LCBjbGlwWSk7XG4gICAgICBjdHgubGluZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcbiAgICB9XG4gICAgbGluZUxvb3AgPSAhIXRhcmdldC5wYXRoU2VnbWVudChjdHgsIHNlZ21lbnQsIHttb3ZlOiBsaW5lTG9vcH0pO1xuICAgIGlmIChsaW5lTG9vcCkge1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHgubGluZVRvKGxhc3RQb2ludC54LCBjbGlwWSk7XG4gICAgfVxuICB9XG5cbiAgY3R4LmxpbmVUbyh0YXJnZXQuZmlyc3QoKS54LCBjbGlwWSk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LmNsaXAoKTtcbn1cblxuZnVuY3Rpb24gZmlsbChjdHgsIGNmZykge1xuICBjb25zdCB7bGluZSwgdGFyZ2V0LCBwcm9wZXJ0eSwgY29sb3IsIHNjYWxlfSA9IGNmZztcbiAgY29uc3Qgc2VnbWVudHMgPSBfc2VnbWVudHMobGluZSwgdGFyZ2V0LCBwcm9wZXJ0eSk7XG5cbiAgZm9yIChjb25zdCB7c291cmNlOiBzcmMsIHRhcmdldDogdGd0LCBzdGFydCwgZW5kfSBvZiBzZWdtZW50cykge1xuICAgIGNvbnN0IHtzdHlsZToge2JhY2tncm91bmRDb2xvciA9IGNvbG9yfSA9IHt9fSA9IHNyYztcbiAgICBjb25zdCBub3RTaGFwZSA9IHRhcmdldCAhPT0gdHJ1ZTtcblxuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcblxuICAgIGNsaXBCb3VuZHMoY3R4LCBzY2FsZSwgbm90U2hhcGUgJiYgX2dldEJvdW5kcyhwcm9wZXJ0eSwgc3RhcnQsIGVuZCkpO1xuXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgY29uc3QgbGluZUxvb3AgPSAhIWxpbmUucGF0aFNlZ21lbnQoY3R4LCBzcmMpO1xuXG4gICAgbGV0IGxvb3A7XG4gICAgaWYgKG5vdFNoYXBlKSB7XG4gICAgICBpZiAobGluZUxvb3ApIHtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJwb2xhdGVkTGluZVRvKGN0eCwgdGFyZ2V0LCBlbmQsIHByb3BlcnR5KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGFyZ2V0TG9vcCA9ICEhdGFyZ2V0LnBhdGhTZWdtZW50KGN0eCwgdGd0LCB7bW92ZTogbGluZUxvb3AsIHJldmVyc2U6IHRydWV9KTtcbiAgICAgIGxvb3AgPSBsaW5lTG9vcCAmJiB0YXJnZXRMb29wO1xuICAgICAgaWYgKCFsb29wKSB7XG4gICAgICAgIGludGVycG9sYXRlZExpbmVUbyhjdHgsIHRhcmdldCwgc3RhcnQsIHByb3BlcnR5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4LmZpbGwobG9vcCA/ICdldmVub2RkJyA6ICdub256ZXJvJyk7XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNsaXBCb3VuZHMoY3R4LCBzY2FsZSwgYm91bmRzKSB7XG4gIGNvbnN0IHt0b3AsIGJvdHRvbX0gPSBzY2FsZS5jaGFydC5jaGFydEFyZWE7XG4gIGNvbnN0IHtwcm9wZXJ0eSwgc3RhcnQsIGVuZH0gPSBib3VuZHMgfHwge307XG4gIGlmIChwcm9wZXJ0eSA9PT0gJ3gnKSB7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5yZWN0KHN0YXJ0LCB0b3AsIGVuZCAtIHN0YXJ0LCBib3R0b20gLSB0b3ApO1xuICAgIGN0eC5jbGlwKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW50ZXJwb2xhdGVkTGluZVRvKGN0eCwgdGFyZ2V0LCBwb2ludCwgcHJvcGVydHkpIHtcbiAgY29uc3QgaW50ZXJwb2xhdGVkUG9pbnQgPSB0YXJnZXQuaW50ZXJwb2xhdGUocG9pbnQsIHByb3BlcnR5KTtcbiAgaWYgKGludGVycG9sYXRlZFBvaW50KSB7XG4gICAgY3R4LmxpbmVUbyhpbnRlcnBvbGF0ZWRQb2ludC54LCBpbnRlcnBvbGF0ZWRQb2ludC55KTtcbiAgfVxufVxuXG4iLCAiLyoqXG4gKiBQbHVnaW4gYmFzZWQgb24gZGlzY3Vzc2lvbiBmcm9tIHRoZSBmb2xsb3dpbmcgQ2hhcnQuanMgaXNzdWVzOlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjM4MCNpc3N1ZWNvbW1lbnQtMjc5OTYxNTY5XG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yNDQwI2lzc3VlY29tbWVudC0yNTY0NjE4OTdcbiAqL1xuXG5pbXBvcnQgTGluZUVsZW1lbnQgZnJvbSAnLi4vLi4vZWxlbWVudHMvZWxlbWVudC5saW5lLmpzJztcbmltcG9ydCB7X2RyYXdmaWxsfSBmcm9tICcuL2ZpbGxlci5kcmF3aW5nLmpzJztcbmltcG9ydCB7X3Nob3VsZEFwcGx5RmlsbH0gZnJvbSAnLi9maWxsZXIuaGVscGVyLmpzJztcbmltcG9ydCB7X2RlY29kZUZpbGwsIF9yZXNvbHZlVGFyZ2V0fSBmcm9tICcuL2ZpbGxlci5vcHRpb25zLmpzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBpZDogJ2ZpbGxlcicsXG5cbiAgYWZ0ZXJEYXRhc2V0c1VwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjb3VudCA9IChjaGFydC5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGg7XG4gICAgY29uc3Qgc291cmNlcyA9IFtdO1xuICAgIGxldCBtZXRhLCBpLCBsaW5lLCBzb3VyY2U7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgbGluZSA9IG1ldGEuZGF0YXNldDtcbiAgICAgIHNvdXJjZSA9IG51bGw7XG5cbiAgICAgIGlmIChsaW5lICYmIGxpbmUub3B0aW9ucyAmJiBsaW5lIGluc3RhbmNlb2YgTGluZUVsZW1lbnQpIHtcbiAgICAgICAgc291cmNlID0ge1xuICAgICAgICAgIHZpc2libGU6IGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSksXG4gICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgZmlsbDogX2RlY29kZUZpbGwobGluZSwgaSwgY291bnQpLFxuICAgICAgICAgIGNoYXJ0LFxuICAgICAgICAgIGF4aXM6IG1ldGEuY29udHJvbGxlci5vcHRpb25zLmluZGV4QXhpcyxcbiAgICAgICAgICBzY2FsZTogbWV0YS52U2NhbGUsXG4gICAgICAgICAgbGluZSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbWV0YS4kZmlsbGVyID0gc291cmNlO1xuICAgICAgc291cmNlcy5wdXNoKHNvdXJjZSk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIHNvdXJjZSA9IHNvdXJjZXNbaV07XG4gICAgICBpZiAoIXNvdXJjZSB8fCBzb3VyY2UuZmlsbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHNvdXJjZS5maWxsID0gX3Jlc29sdmVUYXJnZXQoc291cmNlcywgaSwgb3B0aW9ucy5wcm9wYWdhdGUpO1xuICAgIH1cbiAgfSxcblxuICBiZWZvcmVEcmF3KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IGRyYXcgPSBvcHRpb25zLmRyYXdUaW1lID09PSAnYmVmb3JlRHJhdyc7XG4gICAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgY29uc3QgYXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICBmb3IgKGxldCBpID0gbWV0YXNldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IG1ldGFzZXRzW2ldLiRmaWxsZXI7XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc291cmNlLmxpbmUudXBkYXRlQ29udHJvbFBvaW50cyhhcmVhLCBzb3VyY2UuYXhpcyk7XG4gICAgICBpZiAoZHJhdyAmJiBzb3VyY2UuZmlsbCkge1xuICAgICAgICBfZHJhd2ZpbGwoY2hhcnQuY3R4LCBzb3VyY2UsIGFyZWEpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBiZWZvcmVEYXRhc2V0c0RyYXcoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuZHJhd1RpbWUgIT09ICdiZWZvcmVEYXRhc2V0c0RyYXcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgZm9yIChsZXQgaSA9IG1ldGFzZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBtZXRhc2V0c1tpXS4kZmlsbGVyO1xuXG4gICAgICBpZiAoX3Nob3VsZEFwcGx5RmlsbChzb3VyY2UpKSB7XG4gICAgICAgIF9kcmF3ZmlsbChjaGFydC5jdHgsIHNvdXJjZSwgY2hhcnQuY2hhcnRBcmVhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgYmVmb3JlRGF0YXNldERyYXcoY2hhcnQsIGFyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBhcmdzLm1ldGEuJGZpbGxlcjtcblxuICAgIGlmICghX3Nob3VsZEFwcGx5RmlsbChzb3VyY2UpIHx8IG9wdGlvbnMuZHJhd1RpbWUgIT09ICdiZWZvcmVEYXRhc2V0RHJhdycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBfZHJhd2ZpbGwoY2hhcnQuY3R4LCBzb3VyY2UsIGNoYXJ0LmNoYXJ0QXJlYSk7XG4gIH0sXG5cbiAgZGVmYXVsdHM6IHtcbiAgICBwcm9wYWdhdGU6IHRydWUsXG4gICAgZHJhd1RpbWU6ICdiZWZvcmVEYXRhc2V0RHJhdydcbiAgfVxufTtcbiIsICJpbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi4vY29yZS9jb3JlLmRlZmF1bHRzLmpzJztcbmltcG9ydCBFbGVtZW50IGZyb20gJy4uL2NvcmUvY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCBsYXlvdXRzIGZyb20gJy4uL2NvcmUvY29yZS5sYXlvdXRzLmpzJztcbmltcG9ydCB7YWRkUm91bmRlZFJlY3RQYXRoLCBkcmF3UG9pbnRMZWdlbmQsIHJlbmRlclRleHR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHtcbiAgX2lzQmV0d2VlbixcbiAgY2FsbGJhY2sgYXMgY2FsbCxcbiAgY2xpcEFyZWEsXG4gIGdldFJ0bEFkYXB0ZXIsXG4gIG92ZXJyaWRlVGV4dERpcmVjdGlvbixcbiAgcmVzdG9yZVRleHREaXJlY3Rpb24sXG4gIHRvRm9udCxcbiAgdG9QYWRkaW5nLFxuICB1bmNsaXBBcmVhLFxuICB2YWx1ZU9yRGVmYXVsdCxcbn0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge19hbGlnblN0YXJ0RW5kLCBfdGV4dFgsIF90b0xlZnRSaWdodENlbnRlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmV4dHJhcy5qcyc7XG5pbXBvcnQge3RvVFJCTENvcm5lcnN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5DaGFydEV2ZW50IH0gQ2hhcnRFdmVudFxuICovXG5cbmNvbnN0IGdldEJveFNpemUgPSAobGFiZWxPcHRzLCBmb250U2l6ZSkgPT4ge1xuICBsZXQge2JveEhlaWdodCA9IGZvbnRTaXplLCBib3hXaWR0aCA9IGZvbnRTaXplfSA9IGxhYmVsT3B0cztcblxuICBpZiAobGFiZWxPcHRzLnVzZVBvaW50U3R5bGUpIHtcbiAgICBib3hIZWlnaHQgPSBNYXRoLm1pbihib3hIZWlnaHQsIGZvbnRTaXplKTtcbiAgICBib3hXaWR0aCA9IGxhYmVsT3B0cy5wb2ludFN0eWxlV2lkdGggfHwgTWF0aC5taW4oYm94V2lkdGgsIGZvbnRTaXplKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYm94V2lkdGgsXG4gICAgYm94SGVpZ2h0LFxuICAgIGl0ZW1IZWlnaHQ6IE1hdGgubWF4KGZvbnRTaXplLCBib3hIZWlnaHQpXG4gIH07XG59O1xuXG5jb25zdCBpdGVtc0VxdWFsID0gKGEsIGIpID0+IGEgIT09IG51bGwgJiYgYiAhPT0gbnVsbCAmJiBhLmRhdGFzZXRJbmRleCA9PT0gYi5kYXRhc2V0SW5kZXggJiYgYS5pbmRleCA9PT0gYi5pbmRleDtcblxuZXhwb3J0IGNsYXNzIExlZ2VuZCBleHRlbmRzIEVsZW1lbnQge1xuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3sgY3R4OiBhbnk7IG9wdGlvbnM6IGFueTsgY2hhcnQ6IGFueTsgfX0gY29uZmlnXG5cdCAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fYWRkZWQgPSBmYWxzZTtcblxuICAgIC8vIENvbnRhaW5zIGhpdCBib3hlcyBmb3IgZWFjaCBkYXRhc2V0IChpbiBkYXRhc2V0IG9yZGVyKVxuICAgIHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcblxuICAgIC8qKlxuIFx0XHQgKiBAcHJpdmF0ZVxuIFx0XHQgKi9cbiAgICB0aGlzLl9ob3ZlcmVkSXRlbSA9IG51bGw7XG5cbiAgICAvLyBBcmUgd2UgaW4gZG91Z2hudXQgbW9kZSB3aGljaCBoYXMgYSBkaWZmZXJlbnQgZGF0YSB0eXBlXG4gICAgdGhpcy5kb3VnaG51dE1vZGUgPSBmYWxzZTtcblxuICAgIHRoaXMuY2hhcnQgPSBjb25maWcuY2hhcnQ7XG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG4gICAgdGhpcy5jdHggPSBjb25maWcuY3R4O1xuICAgIHRoaXMubGVnZW5kSXRlbXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jb2x1bW5TaXplcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxpbmVXaWR0aHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXhIZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXhXaWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRvcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvdHRvbSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxlZnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX21hcmdpbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZ1bGxTaXplID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdXBkYXRlKG1heFdpZHRoLCBtYXhIZWlnaHQsIG1hcmdpbnMpIHtcbiAgICB0aGlzLm1heFdpZHRoID0gbWF4V2lkdGg7XG4gICAgdGhpcy5tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XG4gICAgdGhpcy5fbWFyZ2lucyA9IG1hcmdpbnM7XG5cbiAgICB0aGlzLnNldERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLmJ1aWxkTGFiZWxzKCk7XG4gICAgdGhpcy5maXQoKTtcbiAgfVxuXG4gIHNldERpbWVuc2lvbnMoKSB7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLm1heFdpZHRoO1xuICAgICAgdGhpcy5sZWZ0ID0gdGhpcy5fbWFyZ2lucy5sZWZ0O1xuICAgICAgdGhpcy5yaWdodCA9IHRoaXMud2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQ7XG4gICAgICB0aGlzLnRvcCA9IHRoaXMuX21hcmdpbnMudG9wO1xuICAgICAgdGhpcy5ib3R0b20gPSB0aGlzLmhlaWdodDtcbiAgICB9XG4gIH1cblxuICBidWlsZExhYmVscygpIHtcbiAgICBjb25zdCBsYWJlbE9wdHMgPSB0aGlzLm9wdGlvbnMubGFiZWxzIHx8IHt9O1xuICAgIGxldCBsZWdlbmRJdGVtcyA9IGNhbGwobGFiZWxPcHRzLmdlbmVyYXRlTGFiZWxzLCBbdGhpcy5jaGFydF0sIHRoaXMpIHx8IFtdO1xuXG4gICAgaWYgKGxhYmVsT3B0cy5maWx0ZXIpIHtcbiAgICAgIGxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXMuZmlsdGVyKChpdGVtKSA9PiBsYWJlbE9wdHMuZmlsdGVyKGl0ZW0sIHRoaXMuY2hhcnQuZGF0YSkpO1xuICAgIH1cblxuICAgIGlmIChsYWJlbE9wdHMuc29ydCkge1xuICAgICAgbGVnZW5kSXRlbXMgPSBsZWdlbmRJdGVtcy5zb3J0KChhLCBiKSA9PiBsYWJlbE9wdHMuc29ydChhLCBiLCB0aGlzLmNoYXJ0LmRhdGEpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIGxlZ2VuZEl0ZW1zLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICB0aGlzLmxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXM7XG4gIH1cblxuICBmaXQoKSB7XG4gICAgY29uc3Qge29wdGlvbnMsIGN0eH0gPSB0aGlzO1xuXG4gICAgLy8gVGhlIGxlZ2VuZCBtYXkgbm90IGJlIGRpc3BsYXllZCBmb3IgYSB2YXJpZXR5IG9mIHJlYXNvbnMgaW5jbHVkaW5nXG4gICAgLy8gdGhlIGZhY3QgdGhhdCB0aGUgZGVmYXVsdHMgZ290IHNldCB0byBgZmFsc2VgLlxuICAgIC8vIFdoZW4gdGhlIGxlZ2VuZCBpcyBub3QgZGlzcGxheWVkLCB0aGVyZSBhcmUgbm8gZ3VhcmFudGVlcyB0aGF0IHRoZSBvcHRpb25zXG4gICAgLy8gYXJlIGNvcnJlY3RseSBmb3JtYXR0ZWQgc28gd2UgbmVlZCB0byBiYWlsIG91dCBhcyBlYXJseSBhcyBwb3NzaWJsZS5cbiAgICBpZiAoIW9wdGlvbnMuZGlzcGxheSkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBsYWJlbE9wdHMgPSBvcHRpb25zLmxhYmVscztcbiAgICBjb25zdCBsYWJlbEZvbnQgPSB0b0ZvbnQobGFiZWxPcHRzLmZvbnQpO1xuICAgIGNvbnN0IGZvbnRTaXplID0gbGFiZWxGb250LnNpemU7XG4gICAgY29uc3QgdGl0bGVIZWlnaHQgPSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKTtcbiAgICBjb25zdCB7Ym94V2lkdGgsIGl0ZW1IZWlnaHR9ID0gZ2V0Qm94U2l6ZShsYWJlbE9wdHMsIGZvbnRTaXplKTtcblxuICAgIGxldCB3aWR0aCwgaGVpZ2h0O1xuXG4gICAgY3R4LmZvbnQgPSBsYWJlbEZvbnQuc3RyaW5nO1xuXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHdpZHRoID0gdGhpcy5tYXhXaWR0aDsgLy8gZmlsbCBhbGwgdGhlIHdpZHRoXG4gICAgICBoZWlnaHQgPSB0aGlzLl9maXRSb3dzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpICsgMTA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlaWdodCA9IHRoaXMubWF4SGVpZ2h0OyAvLyBmaWxsIGFsbCB0aGUgaGVpZ2h0XG4gICAgICB3aWR0aCA9IHRoaXMuX2ZpdENvbHModGl0bGVIZWlnaHQsIGxhYmVsRm9udCwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpICsgMTA7XG4gICAgfVxuXG4gICAgdGhpcy53aWR0aCA9IE1hdGgubWluKHdpZHRoLCBvcHRpb25zLm1heFdpZHRoIHx8IHRoaXMubWF4V2lkdGgpO1xuICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5taW4oaGVpZ2h0LCBvcHRpb25zLm1heEhlaWdodCB8fCB0aGlzLm1heEhlaWdodCk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9maXRSb3dzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpIHtcbiAgICBjb25zdCB7Y3R4LCBtYXhXaWR0aCwgb3B0aW9uczoge2xhYmVsczoge3BhZGRpbmd9fX0gPSB0aGlzO1xuICAgIGNvbnN0IGhpdGJveGVzID0gdGhpcy5sZWdlbmRIaXRCb3hlcyA9IFtdO1xuICAgIC8vIFdpZHRoIG9mIGVhY2ggbGluZSBvZiBsZWdlbmQgYm94ZXMuIExhYmVscyB3cmFwIG9udG8gbXVsdGlwbGUgbGluZXMgd2hlbiB0aGVyZSBhcmUgdG9vIG1hbnkgdG8gZml0IG9uIG9uZVxuICAgIGNvbnN0IGxpbmVXaWR0aHMgPSB0aGlzLmxpbmVXaWR0aHMgPSBbMF07XG4gICAgY29uc3QgbGluZUhlaWdodCA9IGl0ZW1IZWlnaHQgKyBwYWRkaW5nO1xuICAgIGxldCB0b3RhbEhlaWdodCA9IHRpdGxlSGVpZ2h0O1xuXG4gICAgY3R4LnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cbiAgICBsZXQgcm93ID0gLTE7XG4gICAgbGV0IHRvcCA9IC1saW5lSGVpZ2h0O1xuICAgIHRoaXMubGVnZW5kSXRlbXMuZm9yRWFjaCgobGVnZW5kSXRlbSwgaSkgPT4ge1xuICAgICAgY29uc3QgaXRlbVdpZHRoID0gYm94V2lkdGggKyAoZm9udFNpemUgLyAyKSArIGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuXG4gICAgICBpZiAoaSA9PT0gMCB8fCBsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gMV0gKyBpdGVtV2lkdGggKyAyICogcGFkZGluZyA+IG1heFdpZHRoKSB7XG4gICAgICAgIHRvdGFsSGVpZ2h0ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgIGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAoaSA+IDAgPyAwIDogMSldID0gMDtcbiAgICAgICAgdG9wICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgIHJvdysrO1xuICAgICAgfVxuXG4gICAgICBoaXRib3hlc1tpXSA9IHtsZWZ0OiAwLCB0b3AsIHJvdywgd2lkdGg6IGl0ZW1XaWR0aCwgaGVpZ2h0OiBpdGVtSGVpZ2h0fTtcblxuICAgICAgbGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIDFdICs9IGl0ZW1XaWR0aCArIHBhZGRpbmc7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdG90YWxIZWlnaHQ7XG4gIH1cblxuICBfZml0Q29scyh0aXRsZUhlaWdodCwgbGFiZWxGb250LCBib3hXaWR0aCwgX2l0ZW1IZWlnaHQpIHtcbiAgICBjb25zdCB7Y3R4LCBtYXhIZWlnaHQsIG9wdGlvbnM6IHtsYWJlbHM6IHtwYWRkaW5nfX19ID0gdGhpcztcbiAgICBjb25zdCBoaXRib3hlcyA9IHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcbiAgICBjb25zdCBjb2x1bW5TaXplcyA9IHRoaXMuY29sdW1uU2l6ZXMgPSBbXTtcbiAgICBjb25zdCBoZWlnaHRMaW1pdCA9IG1heEhlaWdodCAtIHRpdGxlSGVpZ2h0O1xuXG4gICAgbGV0IHRvdGFsV2lkdGggPSBwYWRkaW5nO1xuICAgIGxldCBjdXJyZW50Q29sV2lkdGggPSAwO1xuICAgIGxldCBjdXJyZW50Q29sSGVpZ2h0ID0gMDtcblxuICAgIGxldCBsZWZ0ID0gMDtcbiAgICBsZXQgY29sID0gMDtcblxuICAgIHRoaXMubGVnZW5kSXRlbXMuZm9yRWFjaCgobGVnZW5kSXRlbSwgaSkgPT4ge1xuICAgICAgY29uc3Qge2l0ZW1XaWR0aCwgaXRlbUhlaWdodH0gPSBjYWxjdWxhdGVJdGVtU2l6ZShib3hXaWR0aCwgbGFiZWxGb250LCBjdHgsIGxlZ2VuZEl0ZW0sIF9pdGVtSGVpZ2h0KTtcblxuICAgICAgLy8gSWYgdG9vIHRhbGwsIGdvIHRvIG5ldyBjb2x1bW5cbiAgICAgIGlmIChpID4gMCAmJiBjdXJyZW50Q29sSGVpZ2h0ICsgaXRlbUhlaWdodCArIDIgKiBwYWRkaW5nID4gaGVpZ2h0TGltaXQpIHtcbiAgICAgICAgdG90YWxXaWR0aCArPSBjdXJyZW50Q29sV2lkdGggKyBwYWRkaW5nO1xuICAgICAgICBjb2x1bW5TaXplcy5wdXNoKHt3aWR0aDogY3VycmVudENvbFdpZHRoLCBoZWlnaHQ6IGN1cnJlbnRDb2xIZWlnaHR9KTsgLy8gcHJldmlvdXMgY29sdW1uIHNpemVcbiAgICAgICAgbGVmdCArPSBjdXJyZW50Q29sV2lkdGggKyBwYWRkaW5nO1xuICAgICAgICBjb2wrKztcbiAgICAgICAgY3VycmVudENvbFdpZHRoID0gY3VycmVudENvbEhlaWdodCA9IDA7XG4gICAgICB9XG5cbiAgICAgIC8vIFN0b3JlIHRoZSBoaXRib3ggd2lkdGggYW5kIGhlaWdodCBoZXJlLiBGaW5hbCBwb3NpdGlvbiB3aWxsIGJlIHVwZGF0ZWQgaW4gYGRyYXdgXG4gICAgICBoaXRib3hlc1tpXSA9IHtsZWZ0LCB0b3A6IGN1cnJlbnRDb2xIZWlnaHQsIGNvbCwgd2lkdGg6IGl0ZW1XaWR0aCwgaGVpZ2h0OiBpdGVtSGVpZ2h0fTtcblxuICAgICAgLy8gR2V0IG1heCB3aWR0aFxuICAgICAgY3VycmVudENvbFdpZHRoID0gTWF0aC5tYXgoY3VycmVudENvbFdpZHRoLCBpdGVtV2lkdGgpO1xuICAgICAgY3VycmVudENvbEhlaWdodCArPSBpdGVtSGVpZ2h0ICsgcGFkZGluZztcbiAgICB9KTtcblxuICAgIHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoO1xuICAgIGNvbHVtblNpemVzLnB1c2goe3dpZHRoOiBjdXJyZW50Q29sV2lkdGgsIGhlaWdodDogY3VycmVudENvbEhlaWdodH0pOyAvLyBwcmV2aW91cyBjb2x1bW4gc2l6ZVxuXG4gICAgcmV0dXJuIHRvdGFsV2lkdGg7XG4gIH1cblxuICBhZGp1c3RIaXRCb3hlcygpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgY29uc3Qge2xlZ2VuZEhpdEJveGVzOiBoaXRib3hlcywgb3B0aW9uczoge2FsaWduLCBsYWJlbHM6IHtwYWRkaW5nfSwgcnRsfX0gPSB0aGlzO1xuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIocnRsLCB0aGlzLmxlZnQsIHRoaXMud2lkdGgpO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBsZXQgcm93ID0gMDtcbiAgICAgIGxldCBsZWZ0ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMubGVmdCArIHBhZGRpbmcsIHRoaXMucmlnaHQgLSB0aGlzLmxpbmVXaWR0aHNbcm93XSk7XG4gICAgICBmb3IgKGNvbnN0IGhpdGJveCBvZiBoaXRib3hlcykge1xuICAgICAgICBpZiAocm93ICE9PSBoaXRib3gucm93KSB7XG4gICAgICAgICAgcm93ID0gaGl0Ym94LnJvdztcbiAgICAgICAgICBsZWZ0ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMubGVmdCArIHBhZGRpbmcsIHRoaXMucmlnaHQgLSB0aGlzLmxpbmVXaWR0aHNbcm93XSk7XG4gICAgICAgIH1cbiAgICAgICAgaGl0Ym94LnRvcCArPSB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZztcbiAgICAgICAgaGl0Ym94LmxlZnQgPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxIZWxwZXIueChsZWZ0KSwgaGl0Ym94LndpZHRoKTtcbiAgICAgICAgbGVmdCArPSBoaXRib3gud2lkdGggKyBwYWRkaW5nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgY29sID0gMDtcbiAgICAgIGxldCB0b3AgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gdGhpcy5jb2x1bW5TaXplc1tjb2xdLmhlaWdodCk7XG4gICAgICBmb3IgKGNvbnN0IGhpdGJveCBvZiBoaXRib3hlcykge1xuICAgICAgICBpZiAoaGl0Ym94LmNvbCAhPT0gY29sKSB7XG4gICAgICAgICAgY29sID0gaGl0Ym94LmNvbDtcbiAgICAgICAgICB0b3AgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gdGhpcy5jb2x1bW5TaXplc1tjb2xdLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgaGl0Ym94LnRvcCA9IHRvcDtcbiAgICAgICAgaGl0Ym94LmxlZnQgKz0gdGhpcy5sZWZ0ICsgcGFkZGluZztcbiAgICAgICAgaGl0Ym94LmxlZnQgPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxIZWxwZXIueChoaXRib3gubGVmdCksIGhpdGJveC53aWR0aCk7XG4gICAgICAgIHRvcCArPSBoaXRib3guaGVpZ2h0ICsgcGFkZGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpc0hvcml6b250YWwoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ3RvcCcgfHwgdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAnYm90dG9tJztcbiAgfVxuXG4gIGRyYXcoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICAgIGNsaXBBcmVhKGN0eCwgdGhpcyk7XG5cbiAgICAgIHRoaXMuX2RyYXcoKTtcblxuICAgICAgdW5jbGlwQXJlYShjdHgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2RyYXcoKSB7XG4gICAgY29uc3Qge29wdGlvbnM6IG9wdHMsIGNvbHVtblNpemVzLCBsaW5lV2lkdGhzLCBjdHh9ID0gdGhpcztcbiAgICBjb25zdCB7YWxpZ24sIGxhYmVsczogbGFiZWxPcHRzfSA9IG9wdHM7XG4gICAgY29uc3QgZGVmYXVsdENvbG9yID0gZGVmYXVsdHMuY29sb3I7XG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRzLnJ0bCwgdGhpcy5sZWZ0LCB0aGlzLndpZHRoKTtcbiAgICBjb25zdCBsYWJlbEZvbnQgPSB0b0ZvbnQobGFiZWxPcHRzLmZvbnQpO1xuICAgIGNvbnN0IHtwYWRkaW5nfSA9IGxhYmVsT3B0cztcbiAgICBjb25zdCBmb250U2l6ZSA9IGxhYmVsRm9udC5zaXplO1xuICAgIGNvbnN0IGhhbGZGb250U2l6ZSA9IGZvbnRTaXplIC8gMjtcbiAgICBsZXQgY3Vyc29yO1xuXG4gICAgdGhpcy5kcmF3VGl0bGUoKTtcblxuICAgIC8vIENhbnZhcyBzZXR1cFxuICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKCdsZWZ0Jyk7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGN0eC5saW5lV2lkdGggPSAwLjU7XG4gICAgY3R4LmZvbnQgPSBsYWJlbEZvbnQuc3RyaW5nO1xuXG4gICAgY29uc3Qge2JveFdpZHRoLCBib3hIZWlnaHQsIGl0ZW1IZWlnaHR9ID0gZ2V0Qm94U2l6ZShsYWJlbE9wdHMsIGZvbnRTaXplKTtcblxuICAgIC8vIGN1cnJlbnQgcG9zaXRpb25cbiAgICBjb25zdCBkcmF3TGVnZW5kQm94ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSkge1xuICAgICAgaWYgKGlzTmFOKGJveFdpZHRoKSB8fCBib3hXaWR0aCA8PSAwIHx8IGlzTmFOKGJveEhlaWdodCkgfHwgYm94SGVpZ2h0IDwgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB0aGUgY3R4IGZvciB0aGUgYm94XG4gICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICBjb25zdCBsaW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVXaWR0aCwgMSk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5maWxsU3R5bGUsIGRlZmF1bHRDb2xvcik7XG4gICAgICBjdHgubGluZUNhcCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZUNhcCwgJ2J1dHQnKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZURhc2hPZmZzZXQsIDApO1xuICAgICAgY3R4LmxpbmVKb2luID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lSm9pbiwgJ21pdGVyJyk7XG4gICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5zdHJva2VTdHlsZSwgZGVmYXVsdENvbG9yKTtcblxuICAgICAgY3R4LnNldExpbmVEYXNoKHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZURhc2gsIFtdKSk7XG5cbiAgICAgIGlmIChsYWJlbE9wdHMudXNlUG9pbnRTdHlsZSkge1xuICAgICAgICAvLyBSZWNhbGN1bGF0ZSB4IGFuZCB5IGZvciBkcmF3UG9pbnQoKSBiZWNhdXNlIGl0cyBleHBlY3RpbmdcbiAgICAgICAgLy8geCBhbmQgeSB0byBiZSBjZW50ZXIgb2YgZmlndXJlIChpbnN0ZWFkIG9mIHRvcCBsZWZ0KVxuICAgICAgICBjb25zdCBkcmF3T3B0aW9ucyA9IHtcbiAgICAgICAgICByYWRpdXM6IGJveEhlaWdodCAqIE1hdGguU1FSVDIgLyAyLFxuICAgICAgICAgIHBvaW50U3R5bGU6IGxlZ2VuZEl0ZW0ucG9pbnRTdHlsZSxcbiAgICAgICAgICByb3RhdGlvbjogbGVnZW5kSXRlbS5yb3RhdGlvbixcbiAgICAgICAgICBib3JkZXJXaWR0aDogbGluZVdpZHRoXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNlbnRlclggPSBydGxIZWxwZXIueFBsdXMoeCwgYm94V2lkdGggLyAyKTtcbiAgICAgICAgY29uc3QgY2VudGVyWSA9IHkgKyBoYWxmRm9udFNpemU7XG5cbiAgICAgICAgLy8gRHJhdyBwb2ludFN0eWxlIGFzIGxlZ2VuZCBzeW1ib2xcbiAgICAgICAgZHJhd1BvaW50TGVnZW5kKGN0eCwgZHJhd09wdGlvbnMsIGNlbnRlclgsIGNlbnRlclksIGxhYmVsT3B0cy5wb2ludFN0eWxlV2lkdGggJiYgYm94V2lkdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRHJhdyBib3ggYXMgbGVnZW5kIHN5bWJvbFxuICAgICAgICAvLyBBZGp1c3QgcG9zaXRpb24gd2hlbiBib3hIZWlnaHQgPCBmb250U2l6ZSAod2FudCBpdCBjZW50ZXJlZClcbiAgICAgICAgY29uc3QgeUJveFRvcCA9IHkgKyBNYXRoLm1heCgoZm9udFNpemUgLSBib3hIZWlnaHQpIC8gMiwgMCk7XG4gICAgICAgIGNvbnN0IHhCb3hMZWZ0ID0gcnRsSGVscGVyLmxlZnRGb3JMdHIoeCwgYm94V2lkdGgpO1xuICAgICAgICBjb25zdCBib3JkZXJSYWRpdXMgPSB0b1RSQkxDb3JuZXJzKGxlZ2VuZEl0ZW0uYm9yZGVyUmFkaXVzKTtcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgaWYgKE9iamVjdC52YWx1ZXMoYm9yZGVyUmFkaXVzKS5zb21lKHYgPT4gdiAhPT0gMCkpIHtcbiAgICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgICAgICB4OiB4Qm94TGVmdCxcbiAgICAgICAgICAgIHk6IHlCb3hUb3AsXG4gICAgICAgICAgICB3OiBib3hXaWR0aCxcbiAgICAgICAgICAgIGg6IGJveEhlaWdodCxcbiAgICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eC5yZWN0KHhCb3hMZWZ0LCB5Qm94VG9wLCBib3hXaWR0aCwgYm94SGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGlmIChsaW5lV2lkdGggIT09IDApIHtcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgZmlsbFRleHQgPSBmdW5jdGlvbih4LCB5LCBsZWdlbmRJdGVtKSB7XG4gICAgICByZW5kZXJUZXh0KGN0eCwgbGVnZW5kSXRlbS50ZXh0LCB4LCB5ICsgKGl0ZW1IZWlnaHQgLyAyKSwgbGFiZWxGb250LCB7XG4gICAgICAgIHN0cmlrZXRocm91Z2g6IGxlZ2VuZEl0ZW0uaGlkZGVuLFxuICAgICAgICB0ZXh0QWxpZ246IHJ0bEhlbHBlci50ZXh0QWxpZ24obGVnZW5kSXRlbS50ZXh0QWxpZ24pXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gSG9yaXpvbnRhbFxuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgdGl0bGVIZWlnaHQgPSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKTtcbiAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICBjdXJzb3IgPSB7XG4gICAgICAgIHg6IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gbGluZVdpZHRoc1swXSksXG4gICAgICAgIHk6IHRoaXMudG9wICsgcGFkZGluZyArIHRpdGxlSGVpZ2h0LFxuICAgICAgICBsaW5lOiAwXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJzb3IgPSB7XG4gICAgICAgIHg6IHRoaXMubGVmdCArIHBhZGRpbmcsXG4gICAgICAgIHk6IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSBjb2x1bW5TaXplc1swXS5oZWlnaHQpLFxuICAgICAgICBsaW5lOiAwXG4gICAgICB9O1xuICAgIH1cblxuICAgIG92ZXJyaWRlVGV4dERpcmVjdGlvbih0aGlzLmN0eCwgb3B0cy50ZXh0RGlyZWN0aW9uKTtcblxuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBpdGVtSGVpZ2h0ICsgcGFkZGluZztcbiAgICB0aGlzLmxlZ2VuZEl0ZW1zLmZvckVhY2goKGxlZ2VuZEl0ZW0sIGkpID0+IHtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxlZ2VuZEl0ZW0uZm9udENvbG9yOyAvLyBmb3Igc3RyaWtldGhyb3VnaCBlZmZlY3RcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBsZWdlbmRJdGVtLmZvbnRDb2xvcjsgLy8gcmVuZGVyIGluIGNvcnJlY3QgY29sb3VyXG5cbiAgICAgIGNvbnN0IHRleHRXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuICAgICAgY29uc3QgdGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbihsZWdlbmRJdGVtLnRleHRBbGlnbiB8fCAobGVnZW5kSXRlbS50ZXh0QWxpZ24gPSBsYWJlbE9wdHMudGV4dEFsaWduKSk7XG4gICAgICBjb25zdCB3aWR0aCA9IGJveFdpZHRoICsgaGFsZkZvbnRTaXplICsgdGV4dFdpZHRoO1xuICAgICAgbGV0IHggPSBjdXJzb3IueDtcbiAgICAgIGxldCB5ID0gY3Vyc29yLnk7XG5cbiAgICAgIHJ0bEhlbHBlci5zZXRXaWR0aCh0aGlzLndpZHRoKTtcblxuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICBpZiAoaSA+IDAgJiYgeCArIHdpZHRoICsgcGFkZGluZyA+IHRoaXMucmlnaHQpIHtcbiAgICAgICAgICB5ID0gY3Vyc29yLnkgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICBjdXJzb3IubGluZSsrO1xuICAgICAgICAgIHggPSBjdXJzb3IueCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gbGluZVdpZHRoc1tjdXJzb3IubGluZV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGkgPiAwICYmIHkgKyBsaW5lSGVpZ2h0ID4gdGhpcy5ib3R0b20pIHtcbiAgICAgICAgeCA9IGN1cnNvci54ID0geCArIGNvbHVtblNpemVzW2N1cnNvci5saW5lXS53aWR0aCArIHBhZGRpbmc7XG4gICAgICAgIGN1cnNvci5saW5lKys7XG4gICAgICAgIHkgPSBjdXJzb3IueSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSBjb2x1bW5TaXplc1tjdXJzb3IubGluZV0uaGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVhbFggPSBydGxIZWxwZXIueCh4KTtcblxuICAgICAgZHJhd0xlZ2VuZEJveChyZWFsWCwgeSwgbGVnZW5kSXRlbSk7XG5cbiAgICAgIHggPSBfdGV4dFgodGV4dEFsaWduLCB4ICsgYm94V2lkdGggKyBoYWxmRm9udFNpemUsIGlzSG9yaXpvbnRhbCA/IHggKyB3aWR0aCA6IHRoaXMucmlnaHQsIG9wdHMucnRsKTtcblxuICAgICAgLy8gRmlsbCB0aGUgYWN0dWFsIGxhYmVsXG4gICAgICBmaWxsVGV4dChydGxIZWxwZXIueCh4KSwgeSwgbGVnZW5kSXRlbSk7XG5cbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgY3Vyc29yLnggKz0gd2lkdGggKyBwYWRkaW5nO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGVnZW5kSXRlbS50ZXh0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBmb250TGluZUhlaWdodCA9IGxhYmVsRm9udC5saW5lSGVpZ2h0O1xuICAgICAgICBjdXJzb3IueSArPSBjYWxjdWxhdGVMZWdlbmRJdGVtSGVpZ2h0KGxlZ2VuZEl0ZW0sIGZvbnRMaW5lSGVpZ2h0KSArIHBhZGRpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJzb3IueSArPSBsaW5lSGVpZ2h0O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVzdG9yZVRleHREaXJlY3Rpb24odGhpcy5jdHgsIG9wdHMudGV4dERpcmVjdGlvbik7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd1RpdGxlKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGl0bGVPcHRzID0gb3B0cy50aXRsZTtcbiAgICBjb25zdCB0aXRsZUZvbnQgPSB0b0ZvbnQodGl0bGVPcHRzLmZvbnQpO1xuICAgIGNvbnN0IHRpdGxlUGFkZGluZyA9IHRvUGFkZGluZyh0aXRsZU9wdHMucGFkZGluZyk7XG5cbiAgICBpZiAoIXRpdGxlT3B0cy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRzLnJ0bCwgdGhpcy5sZWZ0LCB0aGlzLndpZHRoKTtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRpdGxlT3B0cy5wb3NpdGlvbjtcbiAgICBjb25zdCBoYWxmRm9udFNpemUgPSB0aXRsZUZvbnQuc2l6ZSAvIDI7XG4gICAgY29uc3QgdG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemUgPSB0aXRsZVBhZGRpbmcudG9wICsgaGFsZkZvbnRTaXplO1xuICAgIGxldCB5O1xuXG4gICAgLy8gVGhlc2UgZGVmYXVsdHMgYXJlIHVzZWQgd2hlbiB0aGUgbGVnZW5kIGlzIHZlcnRpY2FsLlxuICAgIC8vIFdoZW4gaG9yaXpvbnRhbCwgdGhleSBhcmUgY29tcHV0ZWQgYmVsb3cuXG4gICAgbGV0IGxlZnQgPSB0aGlzLmxlZnQ7XG4gICAgbGV0IG1heFdpZHRoID0gdGhpcy53aWR0aDtcblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAvLyBNb3ZlIGxlZnQgLyByaWdodCBzbyB0aGF0IHRoZSB0aXRsZSBpcyBhYm92ZSB0aGUgbGVnZW5kIGxpbmVzXG4gICAgICBtYXhXaWR0aCA9IE1hdGgubWF4KC4uLnRoaXMubGluZVdpZHRocyk7XG4gICAgICB5ID0gdGhpcy50b3AgKyB0b3BQYWRkaW5nUGx1c0hhbGZGb250U2l6ZTtcbiAgICAgIGxlZnQgPSBfYWxpZ25TdGFydEVuZChvcHRzLmFsaWduLCBsZWZ0LCB0aGlzLnJpZ2h0IC0gbWF4V2lkdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNb3ZlIGRvd24gc28gdGhhdCB0aGUgdGl0bGUgaXMgYWJvdmUgdGhlIGxlZ2VuZCBzdGFjayBpbiBldmVyeSBhbGlnbm1lbnRcbiAgICAgIGNvbnN0IG1heEhlaWdodCA9IHRoaXMuY29sdW1uU2l6ZXMucmVkdWNlKChhY2MsIHNpemUpID0+IE1hdGgubWF4KGFjYywgc2l6ZS5oZWlnaHQpLCAwKTtcbiAgICAgIHkgPSB0b3BQYWRkaW5nUGx1c0hhbGZGb250U2l6ZSArIF9hbGlnblN0YXJ0RW5kKG9wdHMuYWxpZ24sIHRoaXMudG9wLCB0aGlzLmJvdHRvbSAtIG1heEhlaWdodCAtIG9wdHMubGFiZWxzLnBhZGRpbmcgLSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKSk7XG4gICAgfVxuXG4gICAgLy8gTm93IHRoYXQgd2Uga25vdyB0aGUgbGVmdCBlZGdlIG9mIHRoZSBpbm5lciBsZWdlbmQgYm94LCBjb21wdXRlIHRoZSBjb3JyZWN0XG4gICAgLy8gWCBjb29yZGluYXRlIGZyb20gdGhlIHRpdGxlIGFsaWdubWVudFxuICAgIGNvbnN0IHggPSBfYWxpZ25TdGFydEVuZChwb3NpdGlvbiwgbGVmdCwgbGVmdCArIG1heFdpZHRoKTtcblxuICAgIC8vIENhbnZhcyBzZXR1cFxuICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKF90b0xlZnRSaWdodENlbnRlcihwb3NpdGlvbikpO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aXRsZU9wdHMuY29sb3I7XG4gICAgY3R4LmZpbGxTdHlsZSA9IHRpdGxlT3B0cy5jb2xvcjtcbiAgICBjdHguZm9udCA9IHRpdGxlRm9udC5zdHJpbmc7XG5cbiAgICByZW5kZXJUZXh0KGN0eCwgdGl0bGVPcHRzLnRleHQsIHgsIHksIHRpdGxlRm9udCk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jb21wdXRlVGl0bGVIZWlnaHQoKSB7XG4gICAgY29uc3QgdGl0bGVPcHRzID0gdGhpcy5vcHRpb25zLnRpdGxlO1xuICAgIGNvbnN0IHRpdGxlRm9udCA9IHRvRm9udCh0aXRsZU9wdHMuZm9udCk7XG4gICAgY29uc3QgdGl0bGVQYWRkaW5nID0gdG9QYWRkaW5nKHRpdGxlT3B0cy5wYWRkaW5nKTtcbiAgICByZXR1cm4gdGl0bGVPcHRzLmRpc3BsYXkgPyB0aXRsZUZvbnQubGluZUhlaWdodCArIHRpdGxlUGFkZGluZy5oZWlnaHQgOiAwO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0TGVnZW5kSXRlbUF0KHgsIHkpIHtcbiAgICBsZXQgaSwgaGl0Qm94LCBsaDtcblxuICAgIGlmIChfaXNCZXR3ZWVuKHgsIHRoaXMubGVmdCwgdGhpcy5yaWdodClcbiAgICAgICYmIF9pc0JldHdlZW4oeSwgdGhpcy50b3AsIHRoaXMuYm90dG9tKSkge1xuICAgICAgLy8gU2VlIGlmIHdlIGFyZSB0b3VjaGluZyBvbmUgb2YgdGhlIGRhdGFzZXQgYm94ZXNcbiAgICAgIGxoID0gdGhpcy5sZWdlbmRIaXRCb3hlcztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsaC5sZW5ndGg7ICsraSkge1xuICAgICAgICBoaXRCb3ggPSBsaFtpXTtcblxuICAgICAgICBpZiAoX2lzQmV0d2Vlbih4LCBoaXRCb3gubGVmdCwgaGl0Qm94LmxlZnQgKyBoaXRCb3gud2lkdGgpXG4gICAgICAgICAgJiYgX2lzQmV0d2Vlbih5LCBoaXRCb3gudG9wLCBoaXRCb3gudG9wICsgaGl0Qm94LmhlaWdodCkpIHtcbiAgICAgICAgICAvLyBUb3VjaGluZyBhbiBlbGVtZW50XG4gICAgICAgICAgcmV0dXJuIHRoaXMubGVnZW5kSXRlbXNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBIYW5kbGUgYW4gZXZlbnRcblx0ICogQHBhcmFtIHtDaGFydEV2ZW50fSBlIC0gVGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKi9cbiAgaGFuZGxlRXZlbnQoZSkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKCFpc0xpc3RlbmVkKGUudHlwZSwgb3B0cykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGFydCBldmVudCBhbHJlYWR5IGhhcyByZWxhdGl2ZSBwb3NpdGlvbiBpbiBpdFxuICAgIGNvbnN0IGhvdmVyZWRJdGVtID0gdGhpcy5fZ2V0TGVnZW5kSXRlbUF0KGUueCwgZS55KTtcblxuICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZW1vdmUnIHx8IGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgICAgY29uc3QgcHJldmlvdXMgPSB0aGlzLl9ob3ZlcmVkSXRlbTtcbiAgICAgIGNvbnN0IHNhbWVJdGVtID0gaXRlbXNFcXVhbChwcmV2aW91cywgaG92ZXJlZEl0ZW0pO1xuICAgICAgaWYgKHByZXZpb3VzICYmICFzYW1lSXRlbSkge1xuICAgICAgICBjYWxsKG9wdHMub25MZWF2ZSwgW2UsIHByZXZpb3VzLCB0aGlzXSwgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2hvdmVyZWRJdGVtID0gaG92ZXJlZEl0ZW07XG5cbiAgICAgIGlmIChob3ZlcmVkSXRlbSAmJiAhc2FtZUl0ZW0pIHtcbiAgICAgICAgY2FsbChvcHRzLm9uSG92ZXIsIFtlLCBob3ZlcmVkSXRlbSwgdGhpc10sIHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaG92ZXJlZEl0ZW0pIHtcbiAgICAgIGNhbGwob3B0cy5vbkNsaWNrLCBbZSwgaG92ZXJlZEl0ZW0sIHRoaXNdLCB0aGlzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlSXRlbVNpemUoYm94V2lkdGgsIGxhYmVsRm9udCwgY3R4LCBsZWdlbmRJdGVtLCBfaXRlbUhlaWdodCkge1xuICBjb25zdCBpdGVtV2lkdGggPSBjYWxjdWxhdGVJdGVtV2lkdGgobGVnZW5kSXRlbSwgYm94V2lkdGgsIGxhYmVsRm9udCwgY3R4KTtcbiAgY29uc3QgaXRlbUhlaWdodCA9IGNhbGN1bGF0ZUl0ZW1IZWlnaHQoX2l0ZW1IZWlnaHQsIGxlZ2VuZEl0ZW0sIGxhYmVsRm9udC5saW5lSGVpZ2h0KTtcbiAgcmV0dXJuIHtpdGVtV2lkdGgsIGl0ZW1IZWlnaHR9O1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVJdGVtV2lkdGgobGVnZW5kSXRlbSwgYm94V2lkdGgsIGxhYmVsRm9udCwgY3R4KSB7XG4gIGxldCBsZWdlbmRJdGVtVGV4dCA9IGxlZ2VuZEl0ZW0udGV4dDtcbiAgaWYgKGxlZ2VuZEl0ZW1UZXh0ICYmIHR5cGVvZiBsZWdlbmRJdGVtVGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICBsZWdlbmRJdGVtVGV4dCA9IGxlZ2VuZEl0ZW1UZXh0LnJlZHVjZSgoYSwgYikgPT4gYS5sZW5ndGggPiBiLmxlbmd0aCA/IGEgOiBiKTtcbiAgfVxuICByZXR1cm4gYm94V2lkdGggKyAobGFiZWxGb250LnNpemUgLyAyKSArIGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtVGV4dCkud2lkdGg7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUl0ZW1IZWlnaHQoX2l0ZW1IZWlnaHQsIGxlZ2VuZEl0ZW0sIGZvbnRMaW5lSGVpZ2h0KSB7XG4gIGxldCBpdGVtSGVpZ2h0ID0gX2l0ZW1IZWlnaHQ7XG4gIGlmICh0eXBlb2YgbGVnZW5kSXRlbS50ZXh0ICE9PSAnc3RyaW5nJykge1xuICAgIGl0ZW1IZWlnaHQgPSBjYWxjdWxhdGVMZWdlbmRJdGVtSGVpZ2h0KGxlZ2VuZEl0ZW0sIGZvbnRMaW5lSGVpZ2h0KTtcbiAgfVxuICByZXR1cm4gaXRlbUhlaWdodDtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlTGVnZW5kSXRlbUhlaWdodChsZWdlbmRJdGVtLCBmb250TGluZUhlaWdodCkge1xuICBjb25zdCBsYWJlbEhlaWdodCA9IGxlZ2VuZEl0ZW0udGV4dCA/IGxlZ2VuZEl0ZW0udGV4dC5sZW5ndGggOiAwO1xuICByZXR1cm4gZm9udExpbmVIZWlnaHQgKiBsYWJlbEhlaWdodDtcbn1cblxuZnVuY3Rpb24gaXNMaXN0ZW5lZCh0eXBlLCBvcHRzKSB7XG4gIGlmICgodHlwZSA9PT0gJ21vdXNlbW92ZScgfHwgdHlwZSA9PT0gJ21vdXNlb3V0JykgJiYgKG9wdHMub25Ib3ZlciB8fCBvcHRzLm9uTGVhdmUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKG9wdHMub25DbGljayAmJiAodHlwZSA9PT0gJ2NsaWNrJyB8fCB0eXBlID09PSAnbW91c2V1cCcpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlkOiAnbGVnZW5kJyxcblxuICAvKipcblx0ICogRm9yIHRlc3RzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZWxlbWVudDogTGVnZW5kLFxuXG4gIHN0YXJ0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZCA9IG5ldyBMZWdlbmQoe2N0eDogY2hhcnQuY3R4LCBvcHRpb25zLCBjaGFydH0pO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCBsZWdlbmQsIG9wdGlvbnMpO1xuICAgIGxheW91dHMuYWRkQm94KGNoYXJ0LCBsZWdlbmQpO1xuICB9LFxuXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBsYXlvdXRzLnJlbW92ZUJveChjaGFydCwgY2hhcnQubGVnZW5kKTtcbiAgICBkZWxldGUgY2hhcnQubGVnZW5kO1xuICB9LFxuXG4gIC8vIER1cmluZyB0aGUgYmVmb3JlVXBkYXRlIHN0ZXAsIHRoZSBsYXlvdXQgY29uZmlndXJhdGlvbiBuZWVkcyB0byBydW5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgaWYgdGhlIGxlZ2VuZCBwb3NpdGlvbiBjaGFuZ2VzICh2aWEgYW4gb3B0aW9uIHVwZGF0ZSlcbiAgLy8gdGhlIGxheW91dCBzeXN0ZW0gcmVzcGVjdHMgdGhlIGNoYW5nZS4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy83NTI3XG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsZWdlbmQgPSBjaGFydC5sZWdlbmQ7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIGxlZ2VuZCwgb3B0aW9ucyk7XG4gICAgbGVnZW5kLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuXG4gIC8vIFRoZSBsYWJlbHMgbmVlZCB0byBiZSBidWlsdCBhZnRlciBkYXRhc2V0cyBhcmUgdXBkYXRlZCB0byBlbnN1cmUgdGhhdCBjb2xvcnNcbiAgLy8gYW5kIG90aGVyIHN0eWxpbmcgYXJlIGNvcnJlY3QuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNjk2OFxuICBhZnRlclVwZGF0ZShjaGFydCkge1xuICAgIGNvbnN0IGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZDtcbiAgICBsZWdlbmQuYnVpbGRMYWJlbHMoKTtcbiAgICBsZWdlbmQuYWRqdXN0SGl0Qm94ZXMoKTtcbiAgfSxcblxuXG4gIGFmdGVyRXZlbnQoY2hhcnQsIGFyZ3MpIHtcbiAgICBpZiAoIWFyZ3MucmVwbGF5KSB7XG4gICAgICBjaGFydC5sZWdlbmQuaGFuZGxlRXZlbnQoYXJncy5ldmVudCk7XG4gICAgfVxuICB9LFxuXG4gIGRlZmF1bHRzOiB7XG4gICAgZGlzcGxheTogdHJ1ZSxcbiAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgYWxpZ246ICdjZW50ZXInLFxuICAgIGZ1bGxTaXplOiB0cnVlLFxuICAgIHJldmVyc2U6IGZhbHNlLFxuICAgIHdlaWdodDogMTAwMCxcblxuICAgIC8vIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGhhbmRsZVxuICAgIG9uQ2xpY2soZSwgbGVnZW5kSXRlbSwgbGVnZW5kKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGxlZ2VuZEl0ZW0uZGF0YXNldEluZGV4O1xuICAgICAgY29uc3QgY2kgPSBsZWdlbmQuY2hhcnQ7XG4gICAgICBpZiAoY2kuaXNEYXRhc2V0VmlzaWJsZShpbmRleCkpIHtcbiAgICAgICAgY2kuaGlkZShpbmRleCk7XG4gICAgICAgIGxlZ2VuZEl0ZW0uaGlkZGVuID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNpLnNob3coaW5kZXgpO1xuICAgICAgICBsZWdlbmRJdGVtLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBvbkhvdmVyOiBudWxsLFxuICAgIG9uTGVhdmU6IG51bGwsXG5cbiAgICBsYWJlbHM6IHtcbiAgICAgIGNvbG9yOiAoY3R4KSA9PiBjdHguY2hhcnQub3B0aW9ucy5jb2xvcixcbiAgICAgIGJveFdpZHRoOiA0MCxcbiAgICAgIHBhZGRpbmc6IDEwLFxuICAgICAgLy8gR2VuZXJhdGVzIGxhYmVscyBzaG93biBpbiB0aGUgbGVnZW5kXG4gICAgICAvLyBWYWxpZCBwcm9wZXJ0aWVzIHRvIHJldHVybjpcbiAgICAgIC8vIHRleHQgOiB0ZXh0IHRvIGRpc3BsYXlcbiAgICAgIC8vIGZpbGxTdHlsZSA6IGZpbGwgb2YgY29sb3VyZWQgYm94XG4gICAgICAvLyBzdHJva2VTdHlsZTogc3Ryb2tlIG9mIGNvbG91cmVkIGJveFxuICAgICAgLy8gaGlkZGVuIDogaWYgdGhpcyBsZWdlbmQgaXRlbSByZWZlcnMgdG8gYSBoaWRkZW4gaXRlbVxuICAgICAgLy8gbGluZUNhcCA6IGNhcCBzdHlsZSBmb3IgbGluZVxuICAgICAgLy8gbGluZURhc2hcbiAgICAgIC8vIGxpbmVEYXNoT2Zmc2V0IDpcbiAgICAgIC8vIGxpbmVKb2luIDpcbiAgICAgIC8vIGxpbmVXaWR0aCA6XG4gICAgICBnZW5lcmF0ZUxhYmVscyhjaGFydCkge1xuICAgICAgICBjb25zdCBkYXRhc2V0cyA9IGNoYXJ0LmRhdGEuZGF0YXNldHM7XG4gICAgICAgIGNvbnN0IHtsYWJlbHM6IHt1c2VQb2ludFN0eWxlLCBwb2ludFN0eWxlLCB0ZXh0QWxpZ24sIGNvbG9yLCB1c2VCb3JkZXJSYWRpdXMsIGJvcmRlclJhZGl1c319ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XG5cbiAgICAgICAgcmV0dXJuIGNoYXJ0Ll9nZXRTb3J0ZWREYXRhc2V0TWV0YXMoKS5tYXAoKG1ldGEpID0+IHtcbiAgICAgICAgICBjb25zdCBzdHlsZSA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZSh1c2VQb2ludFN0eWxlID8gMCA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgY29uc3QgYm9yZGVyV2lkdGggPSB0b1BhZGRpbmcoc3R5bGUuYm9yZGVyV2lkdGgpO1xuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IGRhdGFzZXRzW21ldGEuaW5kZXhdLmxhYmVsLFxuICAgICAgICAgICAgZmlsbFN0eWxlOiBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBmb250Q29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgaGlkZGVuOiAhbWV0YS52aXNpYmxlLFxuICAgICAgICAgICAgbGluZUNhcDogc3R5bGUuYm9yZGVyQ2FwU3R5bGUsXG4gICAgICAgICAgICBsaW5lRGFzaDogc3R5bGUuYm9yZGVyRGFzaCxcbiAgICAgICAgICAgIGxpbmVEYXNoT2Zmc2V0OiBzdHlsZS5ib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgICAgICAgbGluZUpvaW46IHN0eWxlLmJvcmRlckpvaW5TdHlsZSxcbiAgICAgICAgICAgIGxpbmVXaWR0aDogKGJvcmRlcldpZHRoLndpZHRoICsgYm9yZGVyV2lkdGguaGVpZ2h0KSAvIDQsXG4gICAgICAgICAgICBzdHJva2VTdHlsZTogc3R5bGUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICBwb2ludFN0eWxlOiBwb2ludFN0eWxlIHx8IHN0eWxlLnBvaW50U3R5bGUsXG4gICAgICAgICAgICByb3RhdGlvbjogc3R5bGUucm90YXRpb24sXG4gICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbiB8fCBzdHlsZS50ZXh0QWxpZ24sXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IHVzZUJvcmRlclJhZGl1cyAmJiAoYm9yZGVyUmFkaXVzIHx8IHN0eWxlLmJvcmRlclJhZGl1cyksXG5cbiAgICAgICAgICAgIC8vIEJlbG93IGlzIGV4dHJhIGRhdGEgdXNlZCBmb3IgdG9nZ2xpbmcgdGhlIGRhdGFzZXRzXG4gICAgICAgICAgICBkYXRhc2V0SW5kZXg6IG1ldGEuaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdGl0bGU6IHtcbiAgICAgIGNvbG9yOiAoY3R4KSA9PiBjdHguY2hhcnQub3B0aW9ucy5jb2xvcixcbiAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgcG9zaXRpb246ICdjZW50ZXInLFxuICAgICAgdGV4dDogJycsXG4gICAgfVxuICB9LFxuXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiAhbmFtZS5zdGFydHNXaXRoKCdvbicpLFxuICAgIGxhYmVsczoge1xuICAgICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiAhWydnZW5lcmF0ZUxhYmVscycsICdmaWx0ZXInLCAnc29ydCddLmluY2x1ZGVzKG5hbWUpLFxuICAgIH1cbiAgfSxcbn07XG4iLCAiaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi4vY29yZS9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IGxheW91dHMgZnJvbSAnLi4vY29yZS9jb3JlLmxheW91dHMuanMnO1xuaW1wb3J0IHtQSSwgaXNBcnJheSwgdG9QYWRkaW5nLCB0b0ZvbnR9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtfdG9MZWZ0UmlnaHRDZW50ZXIsIF9hbGlnblN0YXJ0RW5kfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLmpzJztcbmltcG9ydCB7cmVuZGVyVGV4dH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNhbnZhcy5qcyc7XG5cbmV4cG9ydCBjbGFzcyBUaXRsZSBleHRlbmRzIEVsZW1lbnQge1xuICAvKipcblx0ICogQHBhcmFtIHt7IGN0eDogYW55OyBvcHRpb25zOiBhbnk7IGNoYXJ0OiBhbnk7IH19IGNvbmZpZ1xuXHQgKi9cbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuY2hhcnQgPSBjb25maWcuY2hhcnQ7XG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG4gICAgdGhpcy5jdHggPSBjb25maWcuY3R4O1xuICAgIHRoaXMuX3BhZGRpbmcgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2VpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZnVsbFNpemUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICB1cGRhdGUobWF4V2lkdGgsIG1heEhlaWdodCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICB0aGlzLmxlZnQgPSAwO1xuICAgIHRoaXMudG9wID0gMDtcblxuICAgIGlmICghb3B0cy5kaXNwbGF5KSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSB0aGlzLnJpZ2h0ID0gdGhpcy5ib3R0b20gPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMud2lkdGggPSB0aGlzLnJpZ2h0ID0gbWF4V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLmJvdHRvbSA9IG1heEhlaWdodDtcblxuICAgIGNvbnN0IGxpbmVDb3VudCA9IGlzQXJyYXkob3B0cy50ZXh0KSA/IG9wdHMudGV4dC5sZW5ndGggOiAxO1xuICAgIHRoaXMuX3BhZGRpbmcgPSB0b1BhZGRpbmcob3B0cy5wYWRkaW5nKTtcbiAgICBjb25zdCB0ZXh0U2l6ZSA9IGxpbmVDb3VudCAqIHRvRm9udChvcHRzLmZvbnQpLmxpbmVIZWlnaHQgKyB0aGlzLl9wYWRkaW5nLmhlaWdodDtcblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aGlzLmhlaWdodCA9IHRleHRTaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndpZHRoID0gdGV4dFNpemU7XG4gICAgfVxuICB9XG5cbiAgaXNIb3Jpem9udGFsKCkge1xuICAgIGNvbnN0IHBvcyA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcbiAgICByZXR1cm4gcG9zID09PSAndG9wJyB8fCBwb3MgPT09ICdib3R0b20nO1xuICB9XG5cbiAgX2RyYXdBcmdzKG9mZnNldCkge1xuICAgIGNvbnN0IHt0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQsIG9wdGlvbnN9ID0gdGhpcztcbiAgICBjb25zdCBhbGlnbiA9IG9wdGlvbnMuYWxpZ247XG4gICAgbGV0IHJvdGF0aW9uID0gMDtcbiAgICBsZXQgbWF4V2lkdGgsIHRpdGxlWCwgdGl0bGVZO1xuXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRpdGxlWCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBsZWZ0LCByaWdodCk7XG4gICAgICB0aXRsZVkgPSB0b3AgKyBvZmZzZXQ7XG4gICAgICBtYXhXaWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICB0aXRsZVggPSBsZWZ0ICsgb2Zmc2V0O1xuICAgICAgICB0aXRsZVkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgYm90dG9tLCB0b3ApO1xuICAgICAgICByb3RhdGlvbiA9IFBJICogLTAuNTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpdGxlWCA9IHJpZ2h0IC0gb2Zmc2V0O1xuICAgICAgICB0aXRsZVkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdG9wLCBib3R0b20pO1xuICAgICAgICByb3RhdGlvbiA9IFBJICogMC41O1xuICAgICAgfVxuICAgICAgbWF4V2lkdGggPSBib3R0b20gLSB0b3A7XG4gICAgfVxuICAgIHJldHVybiB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn07XG4gIH1cblxuICBkcmF3KCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBpZiAoIW9wdHMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGZvbnRPcHRzID0gdG9Gb250KG9wdHMuZm9udCk7XG4gICAgY29uc3QgbGluZUhlaWdodCA9IGZvbnRPcHRzLmxpbmVIZWlnaHQ7XG4gICAgY29uc3Qgb2Zmc2V0ID0gbGluZUhlaWdodCAvIDIgKyB0aGlzLl9wYWRkaW5nLnRvcDtcbiAgICBjb25zdCB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn0gPSB0aGlzLl9kcmF3QXJncyhvZmZzZXQpO1xuXG4gICAgcmVuZGVyVGV4dChjdHgsIG9wdHMudGV4dCwgMCwgMCwgZm9udE9wdHMsIHtcbiAgICAgIGNvbG9yOiBvcHRzLmNvbG9yLFxuICAgICAgbWF4V2lkdGgsXG4gICAgICByb3RhdGlvbixcbiAgICAgIHRleHRBbGlnbjogX3RvTGVmdFJpZ2h0Q2VudGVyKG9wdHMuYWxpZ24pLFxuICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICAgIHRyYW5zbGF0aW9uOiBbdGl0bGVYLCB0aXRsZVldLFxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRpdGxlKGNoYXJ0LCB0aXRsZU9wdHMpIHtcbiAgY29uc3QgdGl0bGUgPSBuZXcgVGl0bGUoe1xuICAgIGN0eDogY2hhcnQuY3R4LFxuICAgIG9wdGlvbnM6IHRpdGxlT3B0cyxcbiAgICBjaGFydFxuICB9KTtcblxuICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIHRpdGxlT3B0cyk7XG4gIGxheW91dHMuYWRkQm94KGNoYXJ0LCB0aXRsZSk7XG4gIGNoYXJ0LnRpdGxlQmxvY2sgPSB0aXRsZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpZDogJ3RpdGxlJyxcblxuICAvKipcblx0ICogRm9yIHRlc3RzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZWxlbWVudDogVGl0bGUsXG5cbiAgc3RhcnQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY3JlYXRlVGl0bGUoY2hhcnQsIG9wdGlvbnMpO1xuICB9LFxuXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBjb25zdCB0aXRsZUJsb2NrID0gY2hhcnQudGl0bGVCbG9jaztcbiAgICBsYXlvdXRzLnJlbW92ZUJveChjaGFydCwgdGl0bGVCbG9jayk7XG4gICAgZGVsZXRlIGNoYXJ0LnRpdGxlQmxvY2s7XG4gIH0sXG5cbiAgYmVmb3JlVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gY2hhcnQudGl0bGVCbG9jaztcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIG9wdGlvbnMpO1xuICAgIHRpdGxlLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuXG4gIGRlZmF1bHRzOiB7XG4gICAgYWxpZ246ICdjZW50ZXInLFxuICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgIGZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ2JvbGQnLFxuICAgIH0sXG4gICAgZnVsbFNpemU6IHRydWUsXG4gICAgcGFkZGluZzogMTAsXG4gICAgcG9zaXRpb246ICd0b3AnLFxuICAgIHRleHQ6ICcnLFxuICAgIHdlaWdodDogMjAwMCAgICAgICAgIC8vIGJ5IGRlZmF1bHQgZ3JlYXRlciB0aGFuIGxlZ2VuZCAoMTAwMCkgdG8gYmUgYWJvdmVcbiAgfSxcblxuICBkZWZhdWx0Um91dGVzOiB7XG4gICAgY29sb3I6ICdjb2xvcidcbiAgfSxcblxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiB0cnVlLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICB9LFxufTtcbiIsICJpbXBvcnQge1RpdGxlfSBmcm9tICcuL3BsdWdpbi50aXRsZS5qcyc7XG5pbXBvcnQgbGF5b3V0cyBmcm9tICcuLi9jb3JlL2NvcmUubGF5b3V0cy5qcyc7XG5cbmNvbnN0IG1hcCA9IG5ldyBXZWFrTWFwKCk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaWQ6ICdzdWJ0aXRsZScsXG5cbiAgc3RhcnQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGl0bGUgPSBuZXcgVGl0bGUoe1xuICAgICAgY3R4OiBjaGFydC5jdHgsXG4gICAgICBvcHRpb25zLFxuICAgICAgY2hhcnRcbiAgICB9KTtcblxuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgb3B0aW9ucyk7XG4gICAgbGF5b3V0cy5hZGRCb3goY2hhcnQsIHRpdGxlKTtcbiAgICBtYXAuc2V0KGNoYXJ0LCB0aXRsZSk7XG4gIH0sXG5cbiAgc3RvcChjaGFydCkge1xuICAgIGxheW91dHMucmVtb3ZlQm94KGNoYXJ0LCBtYXAuZ2V0KGNoYXJ0KSk7XG4gICAgbWFwLmRlbGV0ZShjaGFydCk7XG4gIH0sXG5cbiAgYmVmb3JlVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gbWFwLmdldChjaGFydCk7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCBvcHRpb25zKTtcbiAgICB0aXRsZS5vcHRpb25zID0gb3B0aW9ucztcbiAgfSxcblxuICBkZWZhdWx0czoge1xuICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICBmb250OiB7XG4gICAgICB3ZWlnaHQ6ICdub3JtYWwnLFxuICAgIH0sXG4gICAgZnVsbFNpemU6IHRydWUsXG4gICAgcGFkZGluZzogMCxcbiAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgdGV4dDogJycsXG4gICAgd2VpZ2h0OiAxNTAwICAgICAgICAgLy8gYnkgZGVmYXVsdCBncmVhdGVyIHRoYW4gbGVnZW5kICgxMDAwKSBhbmQgc21hbGxlciB0aGFuIHRpdGxlICgyMDAwKVxuICB9LFxuXG4gIGRlZmF1bHRSb3V0ZXM6IHtcbiAgICBjb2xvcjogJ2NvbG9yJ1xuICB9LFxuXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IHRydWUsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gIH0sXG59O1xuIiwgImltcG9ydCBBbmltYXRpb25zIGZyb20gJy4uL2NvcmUvY29yZS5hbmltYXRpb25zLmpzJztcbmltcG9ydCBFbGVtZW50IGZyb20gJy4uL2NvcmUvY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCB7YWRkUm91bmRlZFJlY3RQYXRofSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB7ZWFjaCwgbm9vcCwgaXNOdWxsT3JVbmRlZiwgaXNBcnJheSwgX2VsZW1lbnRzRXF1YWwsIGlzT2JqZWN0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge3RvRm9udCwgdG9QYWRkaW5nLCB0b1RSQkxDb3JuZXJzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5pbXBvcnQge2dldFJ0bEFkYXB0ZXIsIG92ZXJyaWRlVGV4dERpcmVjdGlvbiwgcmVzdG9yZVRleHREaXJlY3Rpb259IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5ydGwuanMnO1xuaW1wb3J0IHtkaXN0YW5jZUJldHdlZW5Qb2ludHMsIF9saW1pdFZhbHVlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge2NyZWF0ZUNvbnRleHQsIGRyYXdQb2ludH0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3BsYXRmb3JtL3BsYXRmb3JtLmJhc2UuanMnKS5DaGFydCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5DaGFydEV2ZW50IH0gQ2hhcnRFdmVudFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQWN0aXZlRWxlbWVudCB9IEFjdGl2ZUVsZW1lbnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9jb3JlL2NvcmUuaW50ZXJhY3Rpb24uanMnKS5JbnRlcmFjdGlvbkl0ZW0gfSBJbnRlcmFjdGlvbkl0ZW1cbiAqL1xuXG5jb25zdCBwb3NpdGlvbmVycyA9IHtcbiAgLyoqXG5cdCAqIEF2ZXJhZ2UgbW9kZSBwbGFjZXMgdGhlIHRvb2x0aXAgYXQgdGhlIGF2ZXJhZ2UgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnRzIHNob3duXG5cdCAqL1xuICBhdmVyYWdlKGl0ZW1zKSB7XG4gICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgaSwgbGVuO1xuICAgIGxldCB4U2V0ID0gbmV3IFNldCgpO1xuICAgIGxldCB5ID0gMDtcbiAgICBsZXQgY291bnQgPSAwO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IGVsID0gaXRlbXNbaV0uZWxlbWVudDtcbiAgICAgIGlmIChlbCAmJiBlbC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGNvbnN0IHBvcyA9IGVsLnRvb2x0aXBQb3NpdGlvbigpO1xuICAgICAgICB4U2V0LmFkZChwb3MueCk7XG4gICAgICAgIHkgKz0gcG9zLnk7XG4gICAgICAgICsrY291bnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgeEF2ZXJhZ2UgPSBbLi4ueFNldF0ucmVkdWNlKChhLCBiKSA9PiBhICsgYikgLyB4U2V0LnNpemU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogeEF2ZXJhZ2UsXG4gICAgICB5OiB5IC8gY291bnRcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuXHQgKiBHZXRzIHRoZSB0b29sdGlwIHBvc2l0aW9uIG5lYXJlc3Qgb2YgdGhlIGl0ZW0gbmVhcmVzdCB0byB0aGUgZXZlbnQgcG9zaXRpb25cblx0ICovXG4gIG5lYXJlc3QoaXRlbXMsIGV2ZW50UG9zaXRpb24pIHtcbiAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCB4ID0gZXZlbnRQb3NpdGlvbi54O1xuICAgIGxldCB5ID0gZXZlbnRQb3NpdGlvbi55O1xuICAgIGxldCBtaW5EaXN0YW5jZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgaSwgbGVuLCBuZWFyZXN0RWxlbWVudDtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb25zdCBlbCA9IGl0ZW1zW2ldLmVsZW1lbnQ7XG4gICAgICBpZiAoZWwgJiYgZWwuaGFzVmFsdWUoKSkge1xuICAgICAgICBjb25zdCBjZW50ZXIgPSBlbC5nZXRDZW50ZXJQb2ludCgpO1xuICAgICAgICBjb25zdCBkID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKGV2ZW50UG9zaXRpb24sIGNlbnRlcik7XG5cbiAgICAgICAgaWYgKGQgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgICAgIG1pbkRpc3RhbmNlID0gZDtcbiAgICAgICAgICBuZWFyZXN0RWxlbWVudCA9IGVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5lYXJlc3RFbGVtZW50KSB7XG4gICAgICBjb25zdCB0cCA9IG5lYXJlc3RFbGVtZW50LnRvb2x0aXBQb3NpdGlvbigpO1xuICAgICAgeCA9IHRwLng7XG4gICAgICB5ID0gdHAueTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9O1xuICB9XG59O1xuXG4vLyBIZWxwZXIgdG8gcHVzaCBvciBjb25jYXQgYmFzZWQgb24gaWYgdGhlIDJuZCBwYXJhbWV0ZXIgaXMgYW4gYXJyYXkgb3Igbm90XG5mdW5jdGlvbiBwdXNoT3JDb25jYXQoYmFzZSwgdG9QdXNoKSB7XG4gIGlmICh0b1B1c2gpIHtcbiAgICBpZiAoaXNBcnJheSh0b1B1c2gpKSB7XG4gICAgICAvLyBiYXNlID0gYmFzZS5jb25jYXQodG9QdXNoKTtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGJhc2UsIHRvUHVzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2UucHVzaCh0b1B1c2gpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBiYXNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYXJyYXkgb2Ygc3RyaW5ncyBzcGxpdCBieSBuZXdsaW5lXG4gKiBAcGFyYW0geyp9IHN0ciAtIFRoZSB2YWx1ZSB0byBzcGxpdCBieSBuZXdsaW5lLlxuICogQHJldHVybnMge3N0cmluZ3xzdHJpbmdbXX0gdmFsdWUgaWYgbmV3bGluZSBwcmVzZW50IC0gUmV0dXJuZWQgZnJvbSBTdHJpbmcgc3BsaXQoKSBtZXRob2RcbiAqIEBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBzcGxpdE5ld2xpbmVzKHN0cikge1xuICBpZiAoKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnIHx8IHN0ciBpbnN0YW5jZW9mIFN0cmluZykgJiYgc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICByZXR1cm4gc3RyLnNwbGl0KCdcXG4nKTtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuXG5cbi8qKlxuICogUHJpdmF0ZSBoZWxwZXIgdG8gY3JlYXRlIGEgdG9vbHRpcCBpdGVtIG1vZGVsXG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuICogQHBhcmFtIHtBY3RpdmVFbGVtZW50fSBpdGVtIC0ge2VsZW1lbnQsIGluZGV4LCBkYXRhc2V0SW5kZXh9IHRvIGNyZWF0ZSB0aGUgdG9vbHRpcCBpdGVtIGZvclxuICogQHJldHVybiBuZXcgdG9vbHRpcCBpdGVtXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXBJdGVtKGNoYXJ0LCBpdGVtKSB7XG4gIGNvbnN0IHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSA9IGl0ZW07XG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXI7XG4gIGNvbnN0IHtsYWJlbCwgdmFsdWV9ID0gY29udHJvbGxlci5nZXRMYWJlbEFuZFZhbHVlKGluZGV4KTtcblxuICByZXR1cm4ge1xuICAgIGNoYXJ0LFxuICAgIGxhYmVsLFxuICAgIHBhcnNlZDogY29udHJvbGxlci5nZXRQYXJzZWQoaW5kZXgpLFxuICAgIHJhdzogY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdLFxuICAgIGZvcm1hdHRlZFZhbHVlOiB2YWx1ZSxcbiAgICBkYXRhc2V0OiBjb250cm9sbGVyLmdldERhdGFzZXQoKSxcbiAgICBkYXRhSW5kZXg6IGluZGV4LFxuICAgIGRhdGFzZXRJbmRleCxcbiAgICBlbGVtZW50XG4gIH07XG59XG5cbi8qKlxuICogR2V0IHRoZSBzaXplIG9mIHRoZSB0b29sdGlwXG4gKi9cbmZ1bmN0aW9uIGdldFRvb2x0aXBTaXplKHRvb2x0aXAsIG9wdGlvbnMpIHtcbiAgY29uc3QgY3R4ID0gdG9vbHRpcC5jaGFydC5jdHg7XG4gIGNvbnN0IHtib2R5LCBmb290ZXIsIHRpdGxlfSA9IHRvb2x0aXA7XG4gIGNvbnN0IHtib3hXaWR0aCwgYm94SGVpZ2h0fSA9IG9wdGlvbnM7XG4gIGNvbnN0IGJvZHlGb250ID0gdG9Gb250KG9wdGlvbnMuYm9keUZvbnQpO1xuICBjb25zdCB0aXRsZUZvbnQgPSB0b0ZvbnQob3B0aW9ucy50aXRsZUZvbnQpO1xuICBjb25zdCBmb290ZXJGb250ID0gdG9Gb250KG9wdGlvbnMuZm9vdGVyRm9udCk7XG4gIGNvbnN0IHRpdGxlTGluZUNvdW50ID0gdGl0bGUubGVuZ3RoO1xuICBjb25zdCBmb290ZXJMaW5lQ291bnQgPSBmb290ZXIubGVuZ3RoO1xuICBjb25zdCBib2R5TGluZUl0ZW1Db3VudCA9IGJvZHkubGVuZ3RoO1xuXG4gIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcbiAgbGV0IGhlaWdodCA9IHBhZGRpbmcuaGVpZ2h0O1xuICBsZXQgd2lkdGggPSAwO1xuXG4gIC8vIENvdW50IG9mIGFsbCBsaW5lcyBpbiB0aGUgYm9keVxuICBsZXQgY29tYmluZWRCb2R5TGVuZ3RoID0gYm9keS5yZWR1Y2UoKGNvdW50LCBib2R5SXRlbSkgPT4gY291bnQgKyBib2R5SXRlbS5iZWZvcmUubGVuZ3RoICsgYm9keUl0ZW0ubGluZXMubGVuZ3RoICsgYm9keUl0ZW0uYWZ0ZXIubGVuZ3RoLCAwKTtcbiAgY29tYmluZWRCb2R5TGVuZ3RoICs9IHRvb2x0aXAuYmVmb3JlQm9keS5sZW5ndGggKyB0b29sdGlwLmFmdGVyQm9keS5sZW5ndGg7XG5cbiAgaWYgKHRpdGxlTGluZUNvdW50KSB7XG4gICAgaGVpZ2h0ICs9IHRpdGxlTGluZUNvdW50ICogdGl0bGVGb250LmxpbmVIZWlnaHRcblx0XHRcdCsgKHRpdGxlTGluZUNvdW50IC0gMSkgKiBvcHRpb25zLnRpdGxlU3BhY2luZ1xuXHRcdFx0KyBvcHRpb25zLnRpdGxlTWFyZ2luQm90dG9tO1xuICB9XG4gIGlmIChjb21iaW5lZEJvZHlMZW5ndGgpIHtcbiAgICAvLyBCb2R5IGxpbmVzIG1heSBpbmNsdWRlIHNvbWUgZXh0cmEgaGVpZ2h0IGRlcGVuZGluZyBvbiBib3hIZWlnaHRcbiAgICBjb25zdCBib2R5TGluZUhlaWdodCA9IG9wdGlvbnMuZGlzcGxheUNvbG9ycyA/IE1hdGgubWF4KGJveEhlaWdodCwgYm9keUZvbnQubGluZUhlaWdodCkgOiBib2R5Rm9udC5saW5lSGVpZ2h0O1xuICAgIGhlaWdodCArPSBib2R5TGluZUl0ZW1Db3VudCAqIGJvZHlMaW5lSGVpZ2h0XG5cdFx0XHQrIChjb21iaW5lZEJvZHlMZW5ndGggLSBib2R5TGluZUl0ZW1Db3VudCkgKiBib2R5Rm9udC5saW5lSGVpZ2h0XG5cdFx0XHQrIChjb21iaW5lZEJvZHlMZW5ndGggLSAxKSAqIG9wdGlvbnMuYm9keVNwYWNpbmc7XG4gIH1cbiAgaWYgKGZvb3RlckxpbmVDb3VudCkge1xuICAgIGhlaWdodCArPSBvcHRpb25zLmZvb3Rlck1hcmdpblRvcFxuXHRcdFx0KyBmb290ZXJMaW5lQ291bnQgKiBmb290ZXJGb250LmxpbmVIZWlnaHRcblx0XHRcdCsgKGZvb3RlckxpbmVDb3VudCAtIDEpICogb3B0aW9ucy5mb290ZXJTcGFjaW5nO1xuICB9XG5cbiAgLy8gVGl0bGUgd2lkdGhcbiAgbGV0IHdpZHRoUGFkZGluZyA9IDA7XG4gIGNvbnN0IG1heExpbmVXaWR0aCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICB3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCBjdHgubWVhc3VyZVRleHQobGluZSkud2lkdGggKyB3aWR0aFBhZGRpbmcpO1xuICB9O1xuXG4gIGN0eC5zYXZlKCk7XG5cbiAgY3R4LmZvbnQgPSB0aXRsZUZvbnQuc3RyaW5nO1xuICBlYWNoKHRvb2x0aXAudGl0bGUsIG1heExpbmVXaWR0aCk7XG5cbiAgLy8gQm9keSB3aWR0aFxuICBjdHguZm9udCA9IGJvZHlGb250LnN0cmluZztcbiAgZWFjaCh0b29sdGlwLmJlZm9yZUJvZHkuY29uY2F0KHRvb2x0aXAuYWZ0ZXJCb2R5KSwgbWF4TGluZVdpZHRoKTtcblxuICAvLyBCb2R5IGxpbmVzIG1heSBpbmNsdWRlIHNvbWUgZXh0cmEgd2lkdGggZHVlIHRvIHRoZSBjb2xvciBib3hcbiAgd2lkdGhQYWRkaW5nID0gb3B0aW9ucy5kaXNwbGF5Q29sb3JzID8gKGJveFdpZHRoICsgMiArIG9wdGlvbnMuYm94UGFkZGluZykgOiAwO1xuICBlYWNoKGJvZHksIChib2R5SXRlbSkgPT4ge1xuICAgIGVhY2goYm9keUl0ZW0uYmVmb3JlLCBtYXhMaW5lV2lkdGgpO1xuICAgIGVhY2goYm9keUl0ZW0ubGluZXMsIG1heExpbmVXaWR0aCk7XG4gICAgZWFjaChib2R5SXRlbS5hZnRlciwgbWF4TGluZVdpZHRoKTtcbiAgfSk7XG5cbiAgLy8gUmVzZXQgYmFjayB0byAwXG4gIHdpZHRoUGFkZGluZyA9IDA7XG5cbiAgLy8gRm9vdGVyIHdpZHRoXG4gIGN0eC5mb250ID0gZm9vdGVyRm9udC5zdHJpbmc7XG4gIGVhY2godG9vbHRpcC5mb290ZXIsIG1heExpbmVXaWR0aCk7XG5cbiAgY3R4LnJlc3RvcmUoKTtcblxuICAvLyBBZGQgcGFkZGluZ1xuICB3aWR0aCArPSBwYWRkaW5nLndpZHRoO1xuXG4gIHJldHVybiB7d2lkdGgsIGhlaWdodH07XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZVlBbGlnbihjaGFydCwgc2l6ZSkge1xuICBjb25zdCB7eSwgaGVpZ2h0fSA9IHNpemU7XG5cbiAgaWYgKHkgPCBoZWlnaHQgLyAyKSB7XG4gICAgcmV0dXJuICd0b3AnO1xuICB9IGVsc2UgaWYgKHkgPiAoY2hhcnQuaGVpZ2h0IC0gaGVpZ2h0IC8gMikpIHtcbiAgICByZXR1cm4gJ2JvdHRvbSc7XG4gIH1cbiAgcmV0dXJuICdjZW50ZXInO1xufVxuXG5mdW5jdGlvbiBkb2VzTm90Rml0V2l0aEFsaWduKHhBbGlnbiwgY2hhcnQsIG9wdGlvbnMsIHNpemUpIHtcbiAgY29uc3Qge3gsIHdpZHRofSA9IHNpemU7XG4gIGNvbnN0IGNhcmV0ID0gb3B0aW9ucy5jYXJldFNpemUgKyBvcHRpb25zLmNhcmV0UGFkZGluZztcbiAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnICYmIHggKyB3aWR0aCArIGNhcmV0ID4gY2hhcnQud2lkdGgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh4QWxpZ24gPT09ICdyaWdodCcgJiYgeCAtIHdpZHRoIC0gY2FyZXQgPCAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5lWEFsaWduKGNoYXJ0LCBvcHRpb25zLCBzaXplLCB5QWxpZ24pIHtcbiAgY29uc3Qge3gsIHdpZHRofSA9IHNpemU7XG4gIGNvbnN0IHt3aWR0aDogY2hhcnRXaWR0aCwgY2hhcnRBcmVhOiB7bGVmdCwgcmlnaHR9fSA9IGNoYXJ0O1xuICBsZXQgeEFsaWduID0gJ2NlbnRlcic7XG5cbiAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4QWxpZ24gPSB4IDw9IChsZWZ0ICsgcmlnaHQpIC8gMiA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gIH0gZWxzZSBpZiAoeCA8PSB3aWR0aCAvIDIpIHtcbiAgICB4QWxpZ24gPSAnbGVmdCc7XG4gIH0gZWxzZSBpZiAoeCA+PSBjaGFydFdpZHRoIC0gd2lkdGggLyAyKSB7XG4gICAgeEFsaWduID0gJ3JpZ2h0JztcbiAgfVxuXG4gIGlmIChkb2VzTm90Rml0V2l0aEFsaWduKHhBbGlnbiwgY2hhcnQsIG9wdGlvbnMsIHNpemUpKSB7XG4gICAgeEFsaWduID0gJ2NlbnRlcic7XG4gIH1cblxuICByZXR1cm4geEFsaWduO1xufVxuXG4vKipcbiAqIEhlbHBlciB0byBnZXQgdGhlIGFsaWdubWVudCBvZiBhIHRvb2x0aXAgZ2l2ZW4gdGhlIHNpemVcbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lQWxpZ25tZW50KGNoYXJ0LCBvcHRpb25zLCBzaXplKSB7XG4gIGNvbnN0IHlBbGlnbiA9IHNpemUueUFsaWduIHx8IG9wdGlvbnMueUFsaWduIHx8IGRldGVybWluZVlBbGlnbihjaGFydCwgc2l6ZSk7XG5cbiAgcmV0dXJuIHtcbiAgICB4QWxpZ246IHNpemUueEFsaWduIHx8IG9wdGlvbnMueEFsaWduIHx8IGRldGVybWluZVhBbGlnbihjaGFydCwgb3B0aW9ucywgc2l6ZSwgeUFsaWduKSxcbiAgICB5QWxpZ25cbiAgfTtcbn1cblxuZnVuY3Rpb24gYWxpZ25YKHNpemUsIHhBbGlnbikge1xuICBsZXQge3gsIHdpZHRofSA9IHNpemU7XG4gIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB4IC09IHdpZHRoO1xuICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4IC09ICh3aWR0aCAvIDIpO1xuICB9XG4gIHJldHVybiB4O1xufVxuXG5mdW5jdGlvbiBhbGlnblkoc2l6ZSwgeUFsaWduLCBwYWRkaW5nQW5kU2l6ZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gIGxldCB7eSwgaGVpZ2h0fSA9IHNpemU7XG4gIGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG4gICAgeSArPSBwYWRkaW5nQW5kU2l6ZTtcbiAgfSBlbHNlIGlmICh5QWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgeSAtPSBoZWlnaHQgKyBwYWRkaW5nQW5kU2l6ZTtcbiAgfSBlbHNlIHtcbiAgICB5IC09IChoZWlnaHQgLyAyKTtcbiAgfVxuICByZXR1cm4geTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IHRoZSBsb2NhdGlvbiBhIHRvb2x0aXAgbmVlZHMgdG8gYmUgcGxhY2VkIGF0IGdpdmVuIHRoZSBpbml0aWFsIHBvc2l0aW9uICh2aWEgdGhlIHZtKSBhbmQgdGhlIHNpemUgYW5kIGFsaWdubWVudFxuICovXG5mdW5jdGlvbiBnZXRCYWNrZ3JvdW5kUG9pbnQob3B0aW9ucywgc2l6ZSwgYWxpZ25tZW50LCBjaGFydCkge1xuICBjb25zdCB7Y2FyZXRTaXplLCBjYXJldFBhZGRpbmcsIGNvcm5lclJhZGl1c30gPSBvcHRpb25zO1xuICBjb25zdCB7eEFsaWduLCB5QWxpZ259ID0gYWxpZ25tZW50O1xuICBjb25zdCBwYWRkaW5nQW5kU2l6ZSA9IGNhcmV0U2l6ZSArIGNhcmV0UGFkZGluZztcbiAgY29uc3Qge3RvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodH0gPSB0b1RSQkxDb3JuZXJzKGNvcm5lclJhZGl1cyk7XG5cbiAgbGV0IHggPSBhbGlnblgoc2l6ZSwgeEFsaWduKTtcbiAgY29uc3QgeSA9IGFsaWduWShzaXplLCB5QWxpZ24sIHBhZGRpbmdBbmRTaXplKTtcblxuICBpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuICAgIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgeCArPSBwYWRkaW5nQW5kU2l6ZTtcbiAgICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgeCAtPSBwYWRkaW5nQW5kU2l6ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICB4IC09IE1hdGgubWF4KHRvcExlZnQsIGJvdHRvbUxlZnQpICsgY2FyZXRTaXplO1xuICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHggKz0gTWF0aC5tYXgodG9wUmlnaHQsIGJvdHRvbVJpZ2h0KSArIGNhcmV0U2l6ZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogX2xpbWl0VmFsdWUoeCwgMCwgY2hhcnQud2lkdGggLSBzaXplLndpZHRoKSxcbiAgICB5OiBfbGltaXRWYWx1ZSh5LCAwLCBjaGFydC5oZWlnaHQgLSBzaXplLmhlaWdodClcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0QWxpZ25lZFgodG9vbHRpcCwgYWxpZ24sIG9wdGlvbnMpIHtcbiAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuXG4gIHJldHVybiBhbGlnbiA9PT0gJ2NlbnRlcidcbiAgICA/IHRvb2x0aXAueCArIHRvb2x0aXAud2lkdGggLyAyXG4gICAgOiBhbGlnbiA9PT0gJ3JpZ2h0J1xuICAgICAgPyB0b29sdGlwLnggKyB0b29sdGlwLndpZHRoIC0gcGFkZGluZy5yaWdodFxuICAgICAgOiB0b29sdGlwLnggKyBwYWRkaW5nLmxlZnQ7XG59XG5cbi8qKlxuICogSGVscGVyIHRvIGJ1aWxkIGJlZm9yZSBhbmQgYWZ0ZXIgYm9keSBsaW5lc1xuICovXG5mdW5jdGlvbiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhjYWxsYmFjaykge1xuICByZXR1cm4gcHVzaE9yQ29uY2F0KFtdLCBzcGxpdE5ld2xpbmVzKGNhbGxiYWNrKSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXBDb250ZXh0KHBhcmVudCwgdG9vbHRpcCwgdG9vbHRpcEl0ZW1zKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIHRvb2x0aXAsXG4gICAgdG9vbHRpcEl0ZW1zLFxuICAgIHR5cGU6ICd0b29sdGlwJ1xuICB9KTtcbn1cblxuZnVuY3Rpb24gb3ZlcnJpZGVDYWxsYmFja3MoY2FsbGJhY2tzLCBjb250ZXh0KSB7XG4gIGNvbnN0IG92ZXJyaWRlID0gY29udGV4dCAmJiBjb250ZXh0LmRhdGFzZXQgJiYgY29udGV4dC5kYXRhc2V0LnRvb2x0aXAgJiYgY29udGV4dC5kYXRhc2V0LnRvb2x0aXAuY2FsbGJhY2tzO1xuICByZXR1cm4gb3ZlcnJpZGUgPyBjYWxsYmFja3Mub3ZlcnJpZGUob3ZlcnJpZGUpIDogY2FsbGJhY2tzO1xufVxuXG5jb25zdCBkZWZhdWx0Q2FsbGJhY2tzID0ge1xuICAvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtcywgZGF0YSlcbiAgYmVmb3JlVGl0bGU6IG5vb3AsXG4gIHRpdGxlKHRvb2x0aXBJdGVtcykge1xuICAgIGlmICh0b29sdGlwSXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgaXRlbSA9IHRvb2x0aXBJdGVtc1swXTtcbiAgICAgIGNvbnN0IGxhYmVscyA9IGl0ZW0uY2hhcnQuZGF0YS5sYWJlbHM7XG4gICAgICBjb25zdCBsYWJlbENvdW50ID0gbGFiZWxzID8gbGFiZWxzLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0aGlzICYmIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubW9kZSA9PT0gJ2RhdGFzZXQnKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmRhdGFzZXQubGFiZWwgfHwgJyc7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW0ubGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0ubGFiZWw7XG4gICAgICB9IGVsc2UgaWYgKGxhYmVsQ291bnQgPiAwICYmIGl0ZW0uZGF0YUluZGV4IDwgbGFiZWxDb3VudCkge1xuICAgICAgICByZXR1cm4gbGFiZWxzW2l0ZW0uZGF0YUluZGV4XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH0sXG4gIGFmdGVyVGl0bGU6IG5vb3AsXG5cbiAgLy8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG4gIGJlZm9yZUJvZHk6IG5vb3AsXG5cbiAgLy8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcbiAgYmVmb3JlTGFiZWw6IG5vb3AsXG4gIGxhYmVsKHRvb2x0aXBJdGVtKSB7XG4gICAgaWYgKHRoaXMgJiYgdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5tb2RlID09PSAnZGF0YXNldCcpIHtcbiAgICAgIHJldHVybiB0b29sdGlwSXRlbS5sYWJlbCArICc6ICcgKyB0b29sdGlwSXRlbS5mb3JtYXR0ZWRWYWx1ZSB8fCB0b29sdGlwSXRlbS5mb3JtYXR0ZWRWYWx1ZTtcbiAgICB9XG5cbiAgICBsZXQgbGFiZWwgPSB0b29sdGlwSXRlbS5kYXRhc2V0LmxhYmVsIHx8ICcnO1xuXG4gICAgaWYgKGxhYmVsKSB7XG4gICAgICBsYWJlbCArPSAnOiAnO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHRvb2x0aXBJdGVtLmZvcm1hdHRlZFZhbHVlO1xuICAgIGlmICghaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgIGxhYmVsICs9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbGFiZWw7XG4gIH0sXG4gIGxhYmVsQ29sb3IodG9vbHRpcEl0ZW0pIHtcbiAgICBjb25zdCBtZXRhID0gdG9vbHRpcEl0ZW0uY2hhcnQuZ2V0RGF0YXNldE1ldGEodG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4KTtcbiAgICBjb25zdCBvcHRpb25zID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKHRvb2x0aXBJdGVtLmRhdGFJbmRleCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcbiAgICAgIGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxuICAgICAgYm9yZGVyRGFzaDogb3B0aW9ucy5ib3JkZXJEYXNoLFxuICAgICAgYm9yZGVyRGFzaE9mZnNldDogb3B0aW9ucy5ib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgIH07XG4gIH0sXG4gIGxhYmVsVGV4dENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYm9keUNvbG9yO1xuICB9LFxuICBsYWJlbFBvaW50U3R5bGUodG9vbHRpcEl0ZW0pIHtcbiAgICBjb25zdCBtZXRhID0gdG9vbHRpcEl0ZW0uY2hhcnQuZ2V0RGF0YXNldE1ldGEodG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4KTtcbiAgICBjb25zdCBvcHRpb25zID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKHRvb2x0aXBJdGVtLmRhdGFJbmRleCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvaW50U3R5bGU6IG9wdGlvbnMucG9pbnRTdHlsZSxcbiAgICAgIHJvdGF0aW9uOiBvcHRpb25zLnJvdGF0aW9uLFxuICAgIH07XG4gIH0sXG4gIGFmdGVyTGFiZWw6IG5vb3AsXG5cbiAgLy8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG4gIGFmdGVyQm9keTogbm9vcCxcblxuICAvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtcywgZGF0YSlcbiAgYmVmb3JlRm9vdGVyOiBub29wLFxuICBmb290ZXI6IG5vb3AsXG4gIGFmdGVyRm9vdGVyOiBub29wXG59O1xuXG4vKipcbiAqIEludm9rZSBjYWxsYmFjayBmcm9tIG9iamVjdCB3aXRoIGNvbnRleHQgYW5kIGFyZ3VtZW50cy5cbiAqIElmIGNhbGxiYWNrIHJldHVybnMgYHVuZGVmaW5lZGAsIHRoZW4gd2lsbCBiZSBpbnZva2VkIGRlZmF1bHQgY2FsbGJhY2suXG4gKiBAcGFyYW0ge1JlY29yZDxrZXlvZiB0eXBlb2YgZGVmYXVsdENhbGxiYWNrcywgRnVuY3Rpb24+fSBjYWxsYmFja3NcbiAqIEBwYXJhbSB7a2V5b2YgdHlwZW9mIGRlZmF1bHRDYWxsYmFja3N9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gY3R4XG4gKiBAcGFyYW0geyp9IGFyZ1xuICogQHJldHVybnMge2FueX1cbiAqL1xuZnVuY3Rpb24gaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soY2FsbGJhY2tzLCBuYW1lLCBjdHgsIGFyZykge1xuICBjb25zdCByZXN1bHQgPSBjYWxsYmFja3NbbmFtZV0uY2FsbChjdHgsIGFyZyk7XG5cbiAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRDYWxsYmFja3NbbmFtZV0uY2FsbChjdHgsIGFyZyk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgY2xhc3MgVG9vbHRpcCBleHRlbmRzIEVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAbmFtZXNwYWNlIENoYXJ0LlRvb2x0aXAucG9zaXRpb25lcnNcbiAgICovXG4gIHN0YXRpYyBwb3NpdGlvbmVycyA9IHBvc2l0aW9uZXJzO1xuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLm9wYWNpdHkgPSAwO1xuICAgIHRoaXMuX2FjdGl2ZSA9IFtdO1xuICAgIHRoaXMuX2V2ZW50UG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc2l6ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9jYWNoZWRBbmltYXRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3Rvb2x0aXBJdGVtcyA9IFtdO1xuICAgIHRoaXMuJGFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNoYXJ0ID0gY29uZmlnLmNoYXJ0O1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xuICAgIHRoaXMuZGF0YVBvaW50cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRpdGxlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYmVmb3JlQm9keSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvZHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5hZnRlckJvZHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mb290ZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy54QWxpZ24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy55QWxpZ24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy54ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2FyZXRYID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2FyZXRZID0gdW5kZWZpbmVkO1xuICAgIC8vIFRPRE86IFY0LCBtYWtlIHRoaXMgcHJpdmF0ZSwgcmVuYW1lIHRvIGBfbGFiZWxTdHlsZXNgLCBhbmQgY29tYmluZSB3aXRoIGBsYWJlbFBvaW50U3R5bGVzYFxuICAgIC8vIGFuZCBgbGFiZWxUZXh0Q29sb3JzYCB0byBjcmVhdGUgYSBzaW5nbGUgdmFyaWFibGVcbiAgICB0aGlzLmxhYmVsQ29sb3JzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGFiZWxQb2ludFN0eWxlcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxhYmVsVGV4dENvbG9ycyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGluaXRpYWxpemUob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5fY2FjaGVkQW5pbWF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVzb2x2ZUFuaW1hdGlvbnMoKSB7XG4gICAgY29uc3QgY2FjaGVkID0gdGhpcy5fY2FjaGVkQW5pbWF0aW9ucztcblxuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3Qgb3B0cyA9IG9wdGlvbnMuZW5hYmxlZCAmJiBjaGFydC5vcHRpb25zLmFuaW1hdGlvbiAmJiBvcHRpb25zLmFuaW1hdGlvbnM7XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IG5ldyBBbmltYXRpb25zKHRoaXMuY2hhcnQsIG9wdHMpO1xuICAgIGlmIChvcHRzLl9jYWNoZWFibGUpIHtcbiAgICAgIHRoaXMuX2NhY2hlZEFuaW1hdGlvbnMgPSBPYmplY3QuZnJlZXplKGFuaW1hdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBhbmltYXRpb25zO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQgfHxcblx0XHRcdCh0aGlzLiRjb250ZXh0ID0gY3JlYXRlVG9vbHRpcENvbnRleHQodGhpcy5jaGFydC5nZXRDb250ZXh0KCksIHRoaXMsIHRoaXMuX3Rvb2x0aXBJdGVtcykpO1xuICB9XG5cbiAgZ2V0VGl0bGUoY29udGV4dCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHtjYWxsYmFja3N9ID0gb3B0aW9ucztcblxuICAgIGNvbnN0IGJlZm9yZVRpdGxlID0gaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soY2FsbGJhY2tzLCAnYmVmb3JlVGl0bGUnLCB0aGlzLCBjb250ZXh0KTtcbiAgICBjb25zdCB0aXRsZSA9IGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKGNhbGxiYWNrcywgJ3RpdGxlJywgdGhpcywgY29udGV4dCk7XG4gICAgY29uc3QgYWZ0ZXJUaXRsZSA9IGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKGNhbGxiYWNrcywgJ2FmdGVyVGl0bGUnLCB0aGlzLCBjb250ZXh0KTtcblxuICAgIGxldCBsaW5lcyA9IFtdO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGJlZm9yZVRpdGxlKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXModGl0bGUpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhhZnRlclRpdGxlKSk7XG5cbiAgICByZXR1cm4gbGluZXM7XG4gIH1cblxuICBnZXRCZWZvcmVCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucykge1xuICAgIHJldHVybiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhcbiAgICAgIGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKG9wdGlvbnMuY2FsbGJhY2tzLCAnYmVmb3JlQm9keScsIHRoaXMsIHRvb2x0aXBJdGVtcylcbiAgICApO1xuICB9XG5cbiAgZ2V0Qm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Y2FsbGJhY2tzfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYm9keUl0ZW1zID0gW107XG5cbiAgICBlYWNoKHRvb2x0aXBJdGVtcywgKGNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IGJvZHlJdGVtID0ge1xuICAgICAgICBiZWZvcmU6IFtdLFxuICAgICAgICBsaW5lczogW10sXG4gICAgICAgIGFmdGVyOiBbXVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNjb3BlZCA9IG92ZXJyaWRlQ2FsbGJhY2tzKGNhbGxiYWNrcywgY29udGV4dCk7XG4gICAgICBwdXNoT3JDb25jYXQoYm9keUl0ZW0uYmVmb3JlLCBzcGxpdE5ld2xpbmVzKGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKHNjb3BlZCwgJ2JlZm9yZUxhYmVsJywgdGhpcywgY29udGV4dCkpKTtcbiAgICAgIHB1c2hPckNvbmNhdChib2R5SXRlbS5saW5lcywgaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soc2NvcGVkLCAnbGFiZWwnLCB0aGlzLCBjb250ZXh0KSk7XG4gICAgICBwdXNoT3JDb25jYXQoYm9keUl0ZW0uYWZ0ZXIsIHNwbGl0TmV3bGluZXMoaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soc2NvcGVkLCAnYWZ0ZXJMYWJlbCcsIHRoaXMsIGNvbnRleHQpKSk7XG5cbiAgICAgIGJvZHlJdGVtcy5wdXNoKGJvZHlJdGVtKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBib2R5SXRlbXM7XG4gIH1cblxuICBnZXRBZnRlckJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKFxuICAgICAgaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2sob3B0aW9ucy5jYWxsYmFja3MsICdhZnRlckJvZHknLCB0aGlzLCB0b29sdGlwSXRlbXMpXG4gICAgKTtcbiAgfVxuXG4gIC8vIEdldCB0aGUgZm9vdGVyIGFuZCBiZWZvcmVGb290ZXIgYW5kIGFmdGVyRm9vdGVyIGxpbmVzXG4gIGdldEZvb3Rlcih0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Y2FsbGJhY2tzfSA9IG9wdGlvbnM7XG5cbiAgICBjb25zdCBiZWZvcmVGb290ZXIgPSBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhjYWxsYmFja3MsICdiZWZvcmVGb290ZXInLCB0aGlzLCB0b29sdGlwSXRlbXMpO1xuICAgIGNvbnN0IGZvb3RlciA9IGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKGNhbGxiYWNrcywgJ2Zvb3RlcicsIHRoaXMsIHRvb2x0aXBJdGVtcyk7XG4gICAgY29uc3QgYWZ0ZXJGb290ZXIgPSBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhjYWxsYmFja3MsICdhZnRlckZvb3RlcicsIHRoaXMsIHRvb2x0aXBJdGVtcyk7XG5cbiAgICBsZXQgbGluZXMgPSBbXTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhiZWZvcmVGb290ZXIpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhmb290ZXIpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhhZnRlckZvb3RlcikpO1xuXG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY3JlYXRlSXRlbXMob3B0aW9ucykge1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5jaGFydC5kYXRhO1xuICAgIGNvbnN0IGxhYmVsQ29sb3JzID0gW107XG4gICAgY29uc3QgbGFiZWxQb2ludFN0eWxlcyA9IFtdO1xuICAgIGNvbnN0IGxhYmVsVGV4dENvbG9ycyA9IFtdO1xuICAgIGxldCB0b29sdGlwSXRlbXMgPSBbXTtcbiAgICBsZXQgaSwgbGVuO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gYWN0aXZlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0b29sdGlwSXRlbXMucHVzaChjcmVhdGVUb29sdGlwSXRlbSh0aGlzLmNoYXJ0LCBhY3RpdmVbaV0pKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdXNlciBwcm92aWRlZCBhIGZpbHRlciBmdW5jdGlvbiwgdXNlIGl0IHRvIG1vZGlmeSB0aGUgdG9vbHRpcCBpdGVtc1xuICAgIGlmIChvcHRpb25zLmZpbHRlcikge1xuICAgICAgdG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zLmZpbHRlcigoZWxlbWVudCwgaW5kZXgsIGFycmF5KSA9PiBvcHRpb25zLmZpbHRlcihlbGVtZW50LCBpbmRleCwgYXJyYXksIGRhdGEpKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdXNlciBwcm92aWRlZCBhIHNvcnRpbmcgZnVuY3Rpb24sIHVzZSBpdCB0byBtb2RpZnkgdGhlIHRvb2x0aXAgaXRlbXNcbiAgICBpZiAob3B0aW9ucy5pdGVtU29ydCkge1xuICAgICAgdG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zLnNvcnQoKGEsIGIpID0+IG9wdGlvbnMuaXRlbVNvcnQoYSwgYiwgZGF0YSkpO1xuICAgIH1cblxuICAgIC8vIERldGVybWluZSBjb2xvcnMgZm9yIGJveGVzXG4gICAgZWFjaCh0b29sdGlwSXRlbXMsIChjb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBzY29wZWQgPSBvdmVycmlkZUNhbGxiYWNrcyhvcHRpb25zLmNhbGxiYWNrcywgY29udGV4dCk7XG4gICAgICBsYWJlbENvbG9ycy5wdXNoKGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKHNjb3BlZCwgJ2xhYmVsQ29sb3InLCB0aGlzLCBjb250ZXh0KSk7XG4gICAgICBsYWJlbFBvaW50U3R5bGVzLnB1c2goaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soc2NvcGVkLCAnbGFiZWxQb2ludFN0eWxlJywgdGhpcywgY29udGV4dCkpO1xuICAgICAgbGFiZWxUZXh0Q29sb3JzLnB1c2goaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soc2NvcGVkLCAnbGFiZWxUZXh0Q29sb3InLCB0aGlzLCBjb250ZXh0KSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmxhYmVsQ29sb3JzID0gbGFiZWxDb2xvcnM7XG4gICAgdGhpcy5sYWJlbFBvaW50U3R5bGVzID0gbGFiZWxQb2ludFN0eWxlcztcbiAgICB0aGlzLmxhYmVsVGV4dENvbG9ycyA9IGxhYmVsVGV4dENvbG9ycztcbiAgICB0aGlzLmRhdGFQb2ludHMgPSB0b29sdGlwSXRlbXM7XG4gICAgcmV0dXJuIHRvb2x0aXBJdGVtcztcbiAgfVxuXG4gIHVwZGF0ZShjaGFuZ2VkLCByZXBsYXkpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcbiAgICBsZXQgcHJvcGVydGllcztcbiAgICBsZXQgdG9vbHRpcEl0ZW1zID0gW107XG5cbiAgICBpZiAoIWFjdGl2ZS5sZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLm9wYWNpdHkgIT09IDApIHtcbiAgICAgICAgcHJvcGVydGllcyA9IHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0aW9ucy5wb3NpdGlvbl0uY2FsbCh0aGlzLCBhY3RpdmUsIHRoaXMuX2V2ZW50UG9zaXRpb24pO1xuICAgICAgdG9vbHRpcEl0ZW1zID0gdGhpcy5fY3JlYXRlSXRlbXMob3B0aW9ucyk7XG5cbiAgICAgIHRoaXMudGl0bGUgPSB0aGlzLmdldFRpdGxlKHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLmJlZm9yZUJvZHkgPSB0aGlzLmdldEJlZm9yZUJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuYm9keSA9IHRoaXMuZ2V0Qm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5hZnRlckJvZHkgPSB0aGlzLmdldEFmdGVyQm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5mb290ZXIgPSB0aGlzLmdldEZvb3Rlcih0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuXG4gICAgICBjb25zdCBzaXplID0gdGhpcy5fc2l6ZSA9IGdldFRvb2x0aXBTaXplKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgY29uc3QgcG9zaXRpb25BbmRTaXplID0gT2JqZWN0LmFzc2lnbih7fSwgcG9zaXRpb24sIHNpemUpO1xuICAgICAgY29uc3QgYWxpZ25tZW50ID0gZGV0ZXJtaW5lQWxpZ25tZW50KHRoaXMuY2hhcnQsIG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSk7XG4gICAgICBjb25zdCBiYWNrZ3JvdW5kUG9pbnQgPSBnZXRCYWNrZ3JvdW5kUG9pbnQob3B0aW9ucywgcG9zaXRpb25BbmRTaXplLCBhbGlnbm1lbnQsIHRoaXMuY2hhcnQpO1xuXG4gICAgICB0aGlzLnhBbGlnbiA9IGFsaWdubWVudC54QWxpZ247XG4gICAgICB0aGlzLnlBbGlnbiA9IGFsaWdubWVudC55QWxpZ247XG5cbiAgICAgIHByb3BlcnRpZXMgPSB7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIHg6IGJhY2tncm91bmRQb2ludC54LFxuICAgICAgICB5OiBiYWNrZ3JvdW5kUG9pbnQueSxcbiAgICAgICAgd2lkdGg6IHNpemUud2lkdGgsXG4gICAgICAgIGhlaWdodDogc2l6ZS5oZWlnaHQsXG4gICAgICAgIGNhcmV0WDogcG9zaXRpb24ueCxcbiAgICAgICAgY2FyZXRZOiBwb3NpdGlvbi55XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMuX3Rvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcztcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKCkudXBkYXRlKHRoaXMsIHByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIGlmIChjaGFuZ2VkICYmIG9wdGlvbnMuZXh0ZXJuYWwpIHtcbiAgICAgIG9wdGlvbnMuZXh0ZXJuYWwuY2FsbCh0aGlzLCB7Y2hhcnQ6IHRoaXMuY2hhcnQsIHRvb2x0aXA6IHRoaXMsIHJlcGxheX0pO1xuICAgIH1cbiAgfVxuXG4gIGRyYXdDYXJldCh0b29sdGlwUG9pbnQsIGN0eCwgc2l6ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGNhcmV0UG9zaXRpb24gPSB0aGlzLmdldENhcmV0UG9zaXRpb24odG9vbHRpcFBvaW50LCBzaXplLCBvcHRpb25zKTtcblxuICAgIGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MSwgY2FyZXRQb3NpdGlvbi55MSk7XG4gICAgY3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngyLCBjYXJldFBvc2l0aW9uLnkyKTtcbiAgICBjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDMsIGNhcmV0UG9zaXRpb24ueTMpO1xuICB9XG5cbiAgZ2V0Q2FyZXRQb3NpdGlvbih0b29sdGlwUG9pbnQsIHNpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7eEFsaWduLCB5QWxpZ259ID0gdGhpcztcbiAgICBjb25zdCB7Y2FyZXRTaXplLCBjb3JuZXJSYWRpdXN9ID0gb3B0aW9ucztcbiAgICBjb25zdCB7dG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0fSA9IHRvVFJCTENvcm5lcnMoY29ybmVyUmFkaXVzKTtcbiAgICBjb25zdCB7eDogcHRYLCB5OiBwdFl9ID0gdG9vbHRpcFBvaW50O1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHNpemU7XG4gICAgbGV0IHgxLCB4MiwgeDMsIHkxLCB5MiwgeTM7XG5cbiAgICBpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgeTIgPSBwdFkgKyAoaGVpZ2h0IC8gMik7XG5cbiAgICAgIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICB4MSA9IHB0WDtcbiAgICAgICAgeDIgPSB4MSAtIGNhcmV0U2l6ZTtcblxuICAgICAgICAvLyBMZWZ0IGRyYXdzIGJvdHRvbSAtPiB0b3AsIHRoaXMgeTEgaXMgb24gdGhlIGJvdHRvbVxuICAgICAgICB5MSA9IHkyICsgY2FyZXRTaXplO1xuICAgICAgICB5MyA9IHkyIC0gY2FyZXRTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDEgPSBwdFggKyB3aWR0aDtcbiAgICAgICAgeDIgPSB4MSArIGNhcmV0U2l6ZTtcblxuICAgICAgICAvLyBSaWdodCBkcmF3cyB0b3AgLT4gYm90dG9tLCB0aHVzIHkxIGlzIG9uIHRoZSB0b3BcbiAgICAgICAgeTEgPSB5MiAtIGNhcmV0U2l6ZTtcbiAgICAgICAgeTMgPSB5MiArIGNhcmV0U2l6ZTtcbiAgICAgIH1cblxuICAgICAgeDMgPSB4MTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHgyID0gcHRYICsgTWF0aC5tYXgodG9wTGVmdCwgYm90dG9tTGVmdCkgKyAoY2FyZXRTaXplKTtcbiAgICAgIH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIHgyID0gcHRYICsgd2lkdGggLSBNYXRoLm1heCh0b3BSaWdodCwgYm90dG9tUmlnaHQpIC0gY2FyZXRTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDIgPSB0aGlzLmNhcmV0WDtcbiAgICAgIH1cblxuICAgICAgaWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgeTEgPSBwdFk7XG4gICAgICAgIHkyID0geTEgLSBjYXJldFNpemU7XG5cbiAgICAgICAgLy8gVG9wIGRyYXdzIGxlZnQgLT4gcmlnaHQsIHRodXMgeDEgaXMgb24gdGhlIGxlZnRcbiAgICAgICAgeDEgPSB4MiAtIGNhcmV0U2l6ZTtcbiAgICAgICAgeDMgPSB4MiArIGNhcmV0U2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkxID0gcHRZICsgaGVpZ2h0O1xuICAgICAgICB5MiA9IHkxICsgY2FyZXRTaXplO1xuXG4gICAgICAgIC8vIEJvdHRvbSBkcmF3cyByaWdodCAtPiBsZWZ0LCB0aHVzIHgxIGlzIG9uIHRoZSByaWdodFxuICAgICAgICB4MSA9IHgyICsgY2FyZXRTaXplO1xuICAgICAgICB4MyA9IHgyIC0gY2FyZXRTaXplO1xuICAgICAgfVxuICAgICAgeTMgPSB5MTtcbiAgICB9XG4gICAgcmV0dXJuIHt4MSwgeDIsIHgzLCB5MSwgeTIsIHkzfTtcbiAgfVxuXG4gIGRyYXdUaXRsZShwdCwgY3R4LCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGl0bGUgPSB0aGlzLnRpdGxlO1xuICAgIGNvbnN0IGxlbmd0aCA9IHRpdGxlLmxlbmd0aDtcbiAgICBsZXQgdGl0bGVGb250LCB0aXRsZVNwYWNpbmcsIGk7XG5cbiAgICBpZiAobGVuZ3RoKSB7XG4gICAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdGlvbnMucnRsLCB0aGlzLngsIHRoaXMud2lkdGgpO1xuXG4gICAgICBwdC54ID0gZ2V0QWxpZ25lZFgodGhpcywgb3B0aW9ucy50aXRsZUFsaWduLCBvcHRpb25zKTtcblxuICAgICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24ob3B0aW9ucy50aXRsZUFsaWduKTtcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuICAgICAgdGl0bGVGb250ID0gdG9Gb250KG9wdGlvbnMudGl0bGVGb250KTtcbiAgICAgIHRpdGxlU3BhY2luZyA9IG9wdGlvbnMudGl0bGVTcGFjaW5nO1xuXG4gICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy50aXRsZUNvbG9yO1xuICAgICAgY3R4LmZvbnQgPSB0aXRsZUZvbnQuc3RyaW5nO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3R4LmZpbGxUZXh0KHRpdGxlW2ldLCBydGxIZWxwZXIueChwdC54KSwgcHQueSArIHRpdGxlRm9udC5saW5lSGVpZ2h0IC8gMik7XG4gICAgICAgIHB0LnkgKz0gdGl0bGVGb250LmxpbmVIZWlnaHQgKyB0aXRsZVNwYWNpbmc7IC8vIExpbmUgSGVpZ2h0IGFuZCBzcGFjaW5nXG5cbiAgICAgICAgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICBwdC55ICs9IG9wdGlvbnMudGl0bGVNYXJnaW5Cb3R0b20gLSB0aXRsZVNwYWNpbmc7IC8vIElmIExhc3QsIGFkZCBtYXJnaW4sIHJlbW92ZSBzcGFjaW5nXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kcmF3Q29sb3JCb3goY3R4LCBwdCwgaSwgcnRsSGVscGVyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGFiZWxDb2xvciA9IHRoaXMubGFiZWxDb2xvcnNbaV07XG4gICAgY29uc3QgbGFiZWxQb2ludFN0eWxlID0gdGhpcy5sYWJlbFBvaW50U3R5bGVzW2ldO1xuICAgIGNvbnN0IHtib3hIZWlnaHQsIGJveFdpZHRofSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYm9keUZvbnQgPSB0b0ZvbnQob3B0aW9ucy5ib2R5Rm9udCk7XG4gICAgY29uc3QgY29sb3JYID0gZ2V0QWxpZ25lZFgodGhpcywgJ2xlZnQnLCBvcHRpb25zKTtcbiAgICBjb25zdCBydGxDb2xvclggPSBydGxIZWxwZXIueChjb2xvclgpO1xuICAgIGNvbnN0IHlPZmZTZXQgPSBib3hIZWlnaHQgPCBib2R5Rm9udC5saW5lSGVpZ2h0ID8gKGJvZHlGb250LmxpbmVIZWlnaHQgLSBib3hIZWlnaHQpIC8gMiA6IDA7XG4gICAgY29uc3QgY29sb3JZID0gcHQueSArIHlPZmZTZXQ7XG5cbiAgICBpZiAob3B0aW9ucy51c2VQb2ludFN0eWxlKSB7XG4gICAgICBjb25zdCBkcmF3T3B0aW9ucyA9IHtcbiAgICAgICAgcmFkaXVzOiBNYXRoLm1pbihib3hXaWR0aCwgYm94SGVpZ2h0KSAvIDIsIC8vIGZpdCB0aGUgY2lyY2xlIGluIHRoZSBib3hcbiAgICAgICAgcG9pbnRTdHlsZTogbGFiZWxQb2ludFN0eWxlLnBvaW50U3R5bGUsXG4gICAgICAgIHJvdGF0aW9uOiBsYWJlbFBvaW50U3R5bGUucm90YXRpb24sXG4gICAgICAgIGJvcmRlcldpZHRoOiAxXG4gICAgICB9O1xuICAgICAgLy8gUmVjYWxjdWxhdGUgeCBhbmQgeSBmb3IgZHJhd1BvaW50KCkgYmVjYXVzZSBpdHMgZXhwZWN0aW5nXG4gICAgICAvLyB4IGFuZCB5IHRvIGJlIGNlbnRlciBvZiBmaWd1cmUgKGluc3RlYWQgb2YgdG9wIGxlZnQpXG4gICAgICBjb25zdCBjZW50ZXJYID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsQ29sb3JYLCBib3hXaWR0aCkgKyBib3hXaWR0aCAvIDI7XG4gICAgICBjb25zdCBjZW50ZXJZID0gY29sb3JZICsgYm94SGVpZ2h0IC8gMjtcblxuICAgICAgLy8gRmlsbCB0aGUgcG9pbnQgd2l0aCB3aGl0ZSBzbyB0aGF0IGNvbG91cnMgbWVyZ2UgbmljZWx5IGlmIHRoZSBvcGFjaXR5IGlzIDwgMVxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5tdWx0aUtleUJhY2tncm91bmQ7XG4gICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5tdWx0aUtleUJhY2tncm91bmQ7XG4gICAgICBkcmF3UG9pbnQoY3R4LCBkcmF3T3B0aW9ucywgY2VudGVyWCwgY2VudGVyWSk7XG5cbiAgICAgIC8vIERyYXcgdGhlIHBvaW50XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsYWJlbENvbG9yLmJvcmRlckNvbG9yO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3IuYmFja2dyb3VuZENvbG9yO1xuICAgICAgZHJhd1BvaW50KGN0eCwgZHJhd09wdGlvbnMsIGNlbnRlclgsIGNlbnRlclkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCb3JkZXJcbiAgICAgIGN0eC5saW5lV2lkdGggPSBpc09iamVjdChsYWJlbENvbG9yLmJvcmRlcldpZHRoKSA/IE1hdGgubWF4KC4uLk9iamVjdC52YWx1ZXMobGFiZWxDb2xvci5ib3JkZXJXaWR0aCkpIDogKGxhYmVsQ29sb3IuYm9yZGVyV2lkdGggfHwgMSk7IC8vIFRPRE8sIHY0IHJlbW92ZSBmYWxsYmFja1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbGFiZWxDb2xvci5ib3JkZXJDb2xvcjtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChsYWJlbENvbG9yLmJvcmRlckRhc2ggfHwgW10pO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gbGFiZWxDb2xvci5ib3JkZXJEYXNoT2Zmc2V0IHx8IDA7XG5cbiAgICAgIC8vIEZpbGwgYSB3aGl0ZSByZWN0IHNvIHRoYXQgY29sb3VycyBtZXJnZSBuaWNlbHkgaWYgdGhlIG9wYWNpdHkgaXMgPCAxXG4gICAgICBjb25zdCBvdXRlclggPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxDb2xvclgsIGJveFdpZHRoKTtcbiAgICAgIGNvbnN0IGlubmVyWCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bEhlbHBlci54UGx1cyhydGxDb2xvclgsIDEpLCBib3hXaWR0aCAtIDIpO1xuICAgICAgY29uc3QgYm9yZGVyUmFkaXVzID0gdG9UUkJMQ29ybmVycyhsYWJlbENvbG9yLmJvcmRlclJhZGl1cyk7XG5cbiAgICAgIGlmIChPYmplY3QudmFsdWVzKGJvcmRlclJhZGl1cykuc29tZSh2ID0+IHYgIT09IDApKSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgICAgeDogb3V0ZXJYLFxuICAgICAgICAgIHk6IGNvbG9yWSxcbiAgICAgICAgICB3OiBib3hXaWR0aCxcbiAgICAgICAgICBoOiBib3hIZWlnaHQsXG4gICAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICAgIH0pO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgLy8gSW5uZXIgc3F1YXJlXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBsYWJlbENvbG9yLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgICAgeDogaW5uZXJYLFxuICAgICAgICAgIHk6IGNvbG9yWSArIDEsXG4gICAgICAgICAgdzogYm94V2lkdGggLSAyLFxuICAgICAgICAgIGg6IGJveEhlaWdodCAtIDIsXG4gICAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICAgIH0pO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm9ybWFsIHJlY3RcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgICBjdHguZmlsbFJlY3Qob3V0ZXJYLCBjb2xvclksIGJveFdpZHRoLCBib3hIZWlnaHQpO1xuICAgICAgICBjdHguc3Ryb2tlUmVjdChvdXRlclgsIGNvbG9yWSwgYm94V2lkdGgsIGJveEhlaWdodCk7XG4gICAgICAgIC8vIElubmVyIHNxdWFyZVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gbGFiZWxDb2xvci5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGN0eC5maWxsUmVjdChpbm5lclgsIGNvbG9yWSArIDEsIGJveFdpZHRoIC0gMiwgYm94SGVpZ2h0IC0gMik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVzdG9yZSBmaWxsU3R5bGVcbiAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5sYWJlbFRleHRDb2xvcnNbaV07XG4gIH1cblxuICBkcmF3Qm9keShwdCwgY3R4LCBvcHRpb25zKSB7XG4gICAgY29uc3Qge2JvZHl9ID0gdGhpcztcbiAgICBjb25zdCB7Ym9keVNwYWNpbmcsIGJvZHlBbGlnbiwgZGlzcGxheUNvbG9ycywgYm94SGVpZ2h0LCBib3hXaWR0aCwgYm94UGFkZGluZ30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJvZHlGb250ID0gdG9Gb250KG9wdGlvbnMuYm9keUZvbnQpO1xuICAgIGxldCBib2R5TGluZUhlaWdodCA9IGJvZHlGb250LmxpbmVIZWlnaHQ7XG4gICAgbGV0IHhMaW5lUGFkZGluZyA9IDA7XG5cbiAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdGlvbnMucnRsLCB0aGlzLngsIHRoaXMud2lkdGgpO1xuXG4gICAgY29uc3QgZmlsbExpbmVPZlRleHQgPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgICBjdHguZmlsbFRleHQobGluZSwgcnRsSGVscGVyLngocHQueCArIHhMaW5lUGFkZGluZyksIHB0LnkgKyBib2R5TGluZUhlaWdodCAvIDIpO1xuICAgICAgcHQueSArPSBib2R5TGluZUhlaWdodCArIGJvZHlTcGFjaW5nO1xuICAgIH07XG5cbiAgICBjb25zdCBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24oYm9keUFsaWduKTtcbiAgICBsZXQgYm9keUl0ZW0sIHRleHRDb2xvciwgbGluZXMsIGksIGosIGlsZW4sIGpsZW47XG5cbiAgICBjdHgudGV4dEFsaWduID0gYm9keUFsaWduO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBjdHguZm9udCA9IGJvZHlGb250LnN0cmluZztcblxuICAgIHB0LnggPSBnZXRBbGlnbmVkWCh0aGlzLCBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiwgb3B0aW9ucyk7XG5cbiAgICAvLyBCZWZvcmUgYm9keSBsaW5lc1xuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJvZHlDb2xvcjtcbiAgICBlYWNoKHRoaXMuYmVmb3JlQm9keSwgZmlsbExpbmVPZlRleHQpO1xuXG4gICAgeExpbmVQYWRkaW5nID0gZGlzcGxheUNvbG9ycyAmJiBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiAhPT0gJ3JpZ2h0J1xuICAgICAgPyBib2R5QWxpZ24gPT09ICdjZW50ZXInID8gKGJveFdpZHRoIC8gMiArIGJveFBhZGRpbmcpIDogKGJveFdpZHRoICsgMiArIGJveFBhZGRpbmcpXG4gICAgICA6IDA7XG5cbiAgICAvLyBEcmF3IGJvZHkgbGluZXMgbm93XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGJvZHkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBib2R5SXRlbSA9IGJvZHlbaV07XG4gICAgICB0ZXh0Q29sb3IgPSB0aGlzLmxhYmVsVGV4dENvbG9yc1tpXTtcblxuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRleHRDb2xvcjtcbiAgICAgIGVhY2goYm9keUl0ZW0uYmVmb3JlLCBmaWxsTGluZU9mVGV4dCk7XG5cbiAgICAgIGxpbmVzID0gYm9keUl0ZW0ubGluZXM7XG4gICAgICAvLyBEcmF3IExlZ2VuZC1saWtlIGJveGVzIGlmIG5lZWRlZFxuICAgICAgaWYgKGRpc3BsYXlDb2xvcnMgJiYgbGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX2RyYXdDb2xvckJveChjdHgsIHB0LCBpLCBydGxIZWxwZXIsIG9wdGlvbnMpO1xuICAgICAgICBib2R5TGluZUhlaWdodCA9IE1hdGgubWF4KGJvZHlGb250LmxpbmVIZWlnaHQsIGJveEhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSBsaW5lcy5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcbiAgICAgICAgZmlsbExpbmVPZlRleHQobGluZXNbal0pO1xuICAgICAgICAvLyBSZXNldCBmb3IgYW55IGxpbmVzIHRoYXQgZG9uJ3QgaW5jbHVkZSBjb2xvcmJveFxuICAgICAgICBib2R5TGluZUhlaWdodCA9IGJvZHlGb250LmxpbmVIZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIGVhY2goYm9keUl0ZW0uYWZ0ZXIsIGZpbGxMaW5lT2ZUZXh0KTtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBiYWNrIHRvIDAgZm9yIGFmdGVyIGJvZHlcbiAgICB4TGluZVBhZGRpbmcgPSAwO1xuICAgIGJvZHlMaW5lSGVpZ2h0ID0gYm9keUZvbnQubGluZUhlaWdodDtcblxuICAgIC8vIEFmdGVyIGJvZHkgbGluZXNcbiAgICBlYWNoKHRoaXMuYWZ0ZXJCb2R5LCBmaWxsTGluZU9mVGV4dCk7XG4gICAgcHQueSAtPSBib2R5U3BhY2luZzsgLy8gUmVtb3ZlIGxhc3QgYm9keSBzcGFjaW5nXG4gIH1cblxuICBkcmF3Rm9vdGVyKHB0LCBjdHgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBmb290ZXIgPSB0aGlzLmZvb3RlcjtcbiAgICBjb25zdCBsZW5ndGggPSBmb290ZXIubGVuZ3RoO1xuICAgIGxldCBmb290ZXJGb250LCBpO1xuXG4gICAgaWYgKGxlbmd0aCkge1xuICAgICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRpb25zLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKTtcblxuICAgICAgcHQueCA9IGdldEFsaWduZWRYKHRoaXMsIG9wdGlvbnMuZm9vdGVyQWxpZ24sIG9wdGlvbnMpO1xuICAgICAgcHQueSArPSBvcHRpb25zLmZvb3Rlck1hcmdpblRvcDtcblxuICAgICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24ob3B0aW9ucy5mb290ZXJBbGlnbik7XG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cbiAgICAgIGZvb3RlckZvbnQgPSB0b0ZvbnQob3B0aW9ucy5mb290ZXJGb250KTtcblxuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuZm9vdGVyQ29sb3I7XG4gICAgICBjdHguZm9udCA9IGZvb3RlckZvbnQuc3RyaW5nO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3R4LmZpbGxUZXh0KGZvb3RlcltpXSwgcnRsSGVscGVyLngocHQueCksIHB0LnkgKyBmb290ZXJGb250LmxpbmVIZWlnaHQgLyAyKTtcbiAgICAgICAgcHQueSArPSBmb290ZXJGb250LmxpbmVIZWlnaHQgKyBvcHRpb25zLmZvb3RlclNwYWNpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZHJhd0JhY2tncm91bmQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7eEFsaWduLCB5QWxpZ259ID0gdGhpcztcbiAgICBjb25zdCB7eCwgeX0gPSBwdDtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0b29sdGlwU2l6ZTtcbiAgICBjb25zdCB7dG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0fSA9IHRvVFJCTENvcm5lcnMob3B0aW9ucy5jb3JuZXJSYWRpdXMpO1xuXG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG4gICAgY3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMuYm9yZGVyV2lkdGg7XG5cbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyh4ICsgdG9wTGVmdCwgeSk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4ICsgd2lkdGggLSB0b3BSaWdodCwgeSk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyB0b3BSaWdodCk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicgJiYgeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gYm90dG9tUmlnaHQpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gYm90dG9tUmlnaHQsIHkgKyBoZWlnaHQpO1xuICAgIGlmICh5QWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCArIGJvdHRvbUxlZnQsIHkgKyBoZWlnaHQpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSBib3R0b21MZWZ0KTtcbiAgICBpZiAoeUFsaWduID09PSAnY2VudGVyJyAmJiB4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHgsIHkgKyB0b3BMZWZ0KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgdG9wTGVmdCwgeSk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgY3R4LmZpbGwoKTtcblxuICAgIGlmIChvcHRpb25zLmJvcmRlcldpZHRoID4gMCkge1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBVcGRhdGUgeC95IGFuaW1hdGlvbiB0YXJnZXRzIHdoZW4gX2FjdGl2ZSBlbGVtZW50cyBhcmUgYW5pbWF0aW5nIHRvb1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZUFuaW1hdGlvblRhcmdldChvcHRpb25zKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGFuaW1zID0gdGhpcy4kYW5pbWF0aW9ucztcbiAgICBjb25zdCBhbmltWCA9IGFuaW1zICYmIGFuaW1zLng7XG4gICAgY29uc3QgYW5pbVkgPSBhbmltcyAmJiBhbmltcy55O1xuICAgIGlmIChhbmltWCB8fCBhbmltWSkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbmVyc1tvcHRpb25zLnBvc2l0aW9uXS5jYWxsKHRoaXMsIHRoaXMuX2FjdGl2ZSwgdGhpcy5fZXZlbnRQb3NpdGlvbik7XG4gICAgICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpemUgPSB0aGlzLl9zaXplID0gZ2V0VG9vbHRpcFNpemUodGhpcywgb3B0aW9ucyk7XG4gICAgICBjb25zdCBwb3NpdGlvbkFuZFNpemUgPSBPYmplY3QuYXNzaWduKHt9LCBwb3NpdGlvbiwgdGhpcy5fc2l6ZSk7XG4gICAgICBjb25zdCBhbGlnbm1lbnQgPSBkZXRlcm1pbmVBbGlnbm1lbnQoY2hhcnQsIG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSk7XG4gICAgICBjb25zdCBwb2ludCA9IGdldEJhY2tncm91bmRQb2ludChvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUsIGFsaWdubWVudCwgY2hhcnQpO1xuICAgICAgaWYgKGFuaW1YLl90byAhPT0gcG9pbnQueCB8fCBhbmltWS5fdG8gIT09IHBvaW50LnkpIHtcbiAgICAgICAgdGhpcy54QWxpZ24gPSBhbGlnbm1lbnQueEFsaWduO1xuICAgICAgICB0aGlzLnlBbGlnbiA9IGFsaWdubWVudC55QWxpZ247XG4gICAgICAgIHRoaXMud2lkdGggPSBzaXplLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICAgICAgICB0aGlzLmNhcmV0WCA9IHBvc2l0aW9uLng7XG4gICAgICAgIHRoaXMuY2FyZXRZID0gcG9zaXRpb24ueTtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoKS51cGRhdGUodGhpcywgcG9pbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgdGhlIHRvb2x0aXAgd2lsbCBkcmF3IGFueXRoaW5nXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB0b29sdGlwIHdpbGwgcmVuZGVyXG4gICAqL1xuICBfd2lsbFJlbmRlcigpIHtcbiAgICByZXR1cm4gISF0aGlzLm9wYWNpdHk7XG4gIH1cblxuICBkcmF3KGN0eCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgbGV0IG9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG5cbiAgICBpZiAoIW9wYWNpdHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVBbmltYXRpb25UYXJnZXQob3B0aW9ucyk7XG5cbiAgICBjb25zdCB0b29sdGlwU2l6ZSA9IHtcbiAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgIH07XG4gICAgY29uc3QgcHQgPSB7XG4gICAgICB4OiB0aGlzLngsXG4gICAgICB5OiB0aGlzLnlcbiAgICB9O1xuXG4gICAgLy8gSUUxMS9FZGdlIGRvZXMgbm90IGxpa2UgdmVyeSBzbWFsbCBvcGFjaXRpZXMsIHNvIHNuYXAgdG8gMFxuICAgIG9wYWNpdHkgPSBNYXRoLmFicyhvcGFjaXR5KSA8IDFlLTMgPyAwIDogb3BhY2l0eTtcblxuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcblxuICAgIC8vIFRydXRoeS9mYWxzZXkgdmFsdWUgZm9yIGVtcHR5IHRvb2x0aXBcbiAgICBjb25zdCBoYXNUb29sdGlwQ29udGVudCA9IHRoaXMudGl0bGUubGVuZ3RoIHx8IHRoaXMuYmVmb3JlQm9keS5sZW5ndGggfHwgdGhpcy5ib2R5Lmxlbmd0aCB8fCB0aGlzLmFmdGVyQm9keS5sZW5ndGggfHwgdGhpcy5mb290ZXIubGVuZ3RoO1xuXG4gICAgaWYgKG9wdGlvbnMuZW5hYmxlZCAmJiBoYXNUb29sdGlwQ29udGVudCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XG5cbiAgICAgIC8vIERyYXcgQmFja2dyb3VuZFxuICAgICAgdGhpcy5kcmF3QmFja2dyb3VuZChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG5cbiAgICAgIG92ZXJyaWRlVGV4dERpcmVjdGlvbihjdHgsIG9wdGlvbnMudGV4dERpcmVjdGlvbik7XG5cbiAgICAgIHB0LnkgKz0gcGFkZGluZy50b3A7XG5cbiAgICAgIC8vIFRpdGxlc1xuICAgICAgdGhpcy5kcmF3VGl0bGUocHQsIGN0eCwgb3B0aW9ucyk7XG5cbiAgICAgIC8vIEJvZHlcbiAgICAgIHRoaXMuZHJhd0JvZHkocHQsIGN0eCwgb3B0aW9ucyk7XG5cbiAgICAgIC8vIEZvb3RlclxuICAgICAgdGhpcy5kcmF3Rm9vdGVyKHB0LCBjdHgsIG9wdGlvbnMpO1xuXG4gICAgICByZXN0b3JlVGV4dERpcmVjdGlvbihjdHgsIG9wdGlvbnMudGV4dERpcmVjdGlvbik7XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEdldCBhY3RpdmUgZWxlbWVudHMgaW4gdGhlIHRvb2x0aXBcblx0ICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiBlbGVtZW50cyB0aGF0IGFyZSBhY3RpdmUgaW4gdGhlIHRvb2x0aXBcblx0ICovXG4gIGdldEFjdGl2ZUVsZW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmUgfHwgW107XG4gIH1cblxuICAvKipcblx0ICogU2V0IGFjdGl2ZSBlbGVtZW50cyBpbiB0aGUgdG9vbHRpcFxuXHQgKiBAcGFyYW0ge2FycmF5fSBhY3RpdmVFbGVtZW50cyBBcnJheSBvZiBhY3RpdmUgZGF0YXNldEluZGV4L2luZGV4IHBhaXJzLlxuXHQgKiBAcGFyYW0ge29iamVjdH0gZXZlbnRQb3NpdGlvbiBTeW50aGV0aWMgZXZlbnQgcG9zaXRpb24gdXNlZCBpbiBwb3NpdGlvbmluZ1xuXHQgKi9cbiAgc2V0QWN0aXZlRWxlbWVudHMoYWN0aXZlRWxlbWVudHMsIGV2ZW50UG9zaXRpb24pIHtcbiAgICBjb25zdCBsYXN0QWN0aXZlID0gdGhpcy5fYWN0aXZlO1xuICAgIGNvbnN0IGFjdGl2ZSA9IGFjdGl2ZUVsZW1lbnRzLm1hcCgoe2RhdGFzZXRJbmRleCwgaW5kZXh9KSA9PiB7XG4gICAgICBjb25zdCBtZXRhID0gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXG4gICAgICBpZiAoIW1ldGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBhIGRhdGFzZXQgYXQgaW5kZXggJyArIGRhdGFzZXRJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGFzZXRJbmRleCxcbiAgICAgICAgZWxlbWVudDogbWV0YS5kYXRhW2luZGV4XSxcbiAgICAgICAgaW5kZXgsXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IGNoYW5nZWQgPSAhX2VsZW1lbnRzRXF1YWwobGFzdEFjdGl2ZSwgYWN0aXZlKTtcbiAgICBjb25zdCBwb3NpdGlvbkNoYW5nZWQgPSB0aGlzLl9wb3NpdGlvbkNoYW5nZWQoYWN0aXZlLCBldmVudFBvc2l0aW9uKTtcblxuICAgIGlmIChjaGFuZ2VkIHx8IHBvc2l0aW9uQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gYWN0aXZlO1xuICAgICAgdGhpcy5fZXZlbnRQb3NpdGlvbiA9IGV2ZW50UG9zaXRpb247XG4gICAgICB0aGlzLl9pZ25vcmVSZXBsYXlFdmVudHMgPSB0cnVlO1xuICAgICAgdGhpcy51cGRhdGUodHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEhhbmRsZSBhbiBldmVudFxuXHQgKiBAcGFyYW0ge0NoYXJ0RXZlbnR9IGUgLSBUaGUgZXZlbnQgdG8gaGFuZGxlXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlcGxheV0gLSBUaGlzIGlzIGEgcmVwbGF5ZWQgZXZlbnQgKGZyb20gdXBkYXRlKVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbkNoYXJ0QXJlYV0gLSBUaGUgZXZlbnQgaXMgaW5zaWRlIGNoYXJ0QXJlYVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdG9vbHRpcCBjaGFuZ2VkXG5cdCAqL1xuICBoYW5kbGVFdmVudChlLCByZXBsYXksIGluQ2hhcnRBcmVhID0gdHJ1ZSkge1xuICAgIGlmIChyZXBsYXkgJiYgdGhpcy5faWdub3JlUmVwbGF5RXZlbnRzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX2lnbm9yZVJlcGxheUV2ZW50cyA9IGZhbHNlO1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBsYXN0QWN0aXZlID0gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2dldEFjdGl2ZUVsZW1lbnRzKGUsIGxhc3RBY3RpdmUsIHJlcGxheSwgaW5DaGFydEFyZWEpO1xuXG4gICAgLy8gV2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgaXRlbXMgc2hvd24sIGJ1dCB0aGUgdG9vbHRpcCBwb3NpdGlvbiBpcyBuZWFyZXN0IG1vZGVcbiAgICAvLyBhbiB1cGRhdGUgbWF5IG5lZWQgdG8gYmUgbWFkZSBiZWNhdXNlIG91ciBwb3NpdGlvbiBtYXkgaGF2ZSBjaGFuZ2VkIGV2ZW4gdGhvdWdoXG4gICAgLy8gdGhlIGl0ZW1zIGFyZSB0aGUgc2FtZSBhcyBiZWZvcmUuXG4gICAgY29uc3QgcG9zaXRpb25DaGFuZ2VkID0gdGhpcy5fcG9zaXRpb25DaGFuZ2VkKGFjdGl2ZSwgZSk7XG5cbiAgICAvLyBSZW1lbWJlciBMYXN0IEFjdGl2ZXNcbiAgICBjb25zdCBjaGFuZ2VkID0gcmVwbGF5IHx8ICFfZWxlbWVudHNFcXVhbChhY3RpdmUsIGxhc3RBY3RpdmUpIHx8IHBvc2l0aW9uQ2hhbmdlZDtcblxuICAgIC8vIE9ubHkgaGFuZGxlIHRhcmdldCBldmVudCBvbiB0b29sdGlwIGNoYW5nZVxuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG5cbiAgICAgIGlmIChvcHRpb25zLmVuYWJsZWQgfHwgb3B0aW9ucy5leHRlcm5hbCkge1xuICAgICAgICB0aGlzLl9ldmVudFBvc2l0aW9uID0ge1xuICAgICAgICAgIHg6IGUueCxcbiAgICAgICAgICB5OiBlLnlcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnVwZGF0ZSh0cnVlLCByZXBsYXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEhlbHBlciBmb3IgZGV0ZXJtaW5pbmcgdGhlIGFjdGl2ZSBlbGVtZW50cyBmb3IgZXZlbnRcblx0ICogQHBhcmFtIHtDaGFydEV2ZW50fSBlIC0gVGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKiBAcGFyYW0ge0ludGVyYWN0aW9uSXRlbVtdfSBsYXN0QWN0aXZlIC0gUHJldmlvdXNseSBhY3RpdmUgZWxlbWVudHNcblx0ICogQHBhcmFtIHtib29sZWFufSBbcmVwbGF5XSAtIFRoaXMgaXMgYSByZXBsYXllZCBldmVudCAoZnJvbSB1cGRhdGUpXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luQ2hhcnRBcmVhXSAtIFRoZSBldmVudCBpcyBpbnNpZGUgY2hhcnRBcmVhXG5cdCAqIEByZXR1cm5zIHtJbnRlcmFjdGlvbkl0ZW1bXX0gLSBBY3RpdmUgZWxlbWVudHNcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCByZXBsYXksIGluQ2hhcnRBcmVhKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBpZiAoIWluQ2hhcnRBcmVhKSB7XG4gICAgICAvLyBMZXQgdXNlciBjb250cm9sIHRoZSBhY3RpdmUgZWxlbWVudHMgb3V0c2lkZSBjaGFydEFyZWEuIEVnLiB1c2luZyBMZWdlbmQuXG4gICAgICAvLyBCdXQgbWFrZSBzdXJlIHRoYXQgYWN0aXZlIGVsZW1lbnRzIGFyZSBzdGlsbCB2YWxpZC5cbiAgICAgIHJldHVybiBsYXN0QWN0aXZlLmZpbHRlcihpID0+XG4gICAgICAgIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tpLmRhdGFzZXRJbmRleF0gJiZcbiAgICAgICAgdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YShpLmRhdGFzZXRJbmRleCkuY29udHJvbGxlci5nZXRQYXJzZWQoaS5pbmRleCkgIT09IHVuZGVmaW5lZFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIEFjdGl2ZSBFbGVtZW50cyBmb3IgdG9vbHRpcHNcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmNoYXJ0LmdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgb3B0aW9ucy5tb2RlLCBvcHRpb25zLCByZXBsYXkpO1xuXG4gICAgaWYgKG9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgYWN0aXZlLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWN0aXZlO1xuICB9XG5cbiAgLyoqXG5cdCAqIERldGVybWluZSBpZiB0aGUgYWN0aXZlIGVsZW1lbnRzICsgZXZlbnQgY29tYmluYXRpb24gY2hhbmdlcyB0aGVcblx0ICogdG9vbHRpcCBwb3NpdGlvblxuXHQgKiBAcGFyYW0ge2FycmF5fSBhY3RpdmUgLSBBY3RpdmUgZWxlbWVudHNcblx0ICogQHBhcmFtIHtDaGFydEV2ZW50fSBlIC0gRXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhlIHBvc2l0aW9uIGNoYW5nZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcG9zaXRpb24gaGFzIGNoYW5nZWRcblx0ICovXG4gIF9wb3NpdGlvbkNoYW5nZWQoYWN0aXZlLCBlKSB7XG4gICAgY29uc3Qge2NhcmV0WCwgY2FyZXRZLCBvcHRpb25zfSA9IHRoaXM7XG4gICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbmVyc1tvcHRpb25zLnBvc2l0aW9uXS5jYWxsKHRoaXMsIGFjdGl2ZSwgZSk7XG4gICAgcmV0dXJuIHBvc2l0aW9uICE9PSBmYWxzZSAmJiAoY2FyZXRYICE9PSBwb3NpdGlvbi54IHx8IGNhcmV0WSAhPT0gcG9zaXRpb24ueSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpZDogJ3Rvb2x0aXAnLFxuICBfZWxlbWVudDogVG9vbHRpcCxcbiAgcG9zaXRpb25lcnMsXG5cbiAgYWZ0ZXJJbml0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBjaGFydC50b29sdGlwID0gbmV3IFRvb2x0aXAoe2NoYXJ0LCBvcHRpb25zfSk7XG4gICAgfVxuICB9LFxuXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAoY2hhcnQudG9vbHRpcCkge1xuICAgICAgY2hhcnQudG9vbHRpcC5pbml0aWFsaXplKG9wdGlvbnMpO1xuICAgIH1cbiAgfSxcblxuICByZXNldChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAoY2hhcnQudG9vbHRpcCkge1xuICAgICAgY2hhcnQudG9vbHRpcC5pbml0aWFsaXplKG9wdGlvbnMpO1xuICAgIH1cbiAgfSxcblxuICBhZnRlckRyYXcoY2hhcnQpIHtcbiAgICBjb25zdCB0b29sdGlwID0gY2hhcnQudG9vbHRpcDtcblxuICAgIGlmICh0b29sdGlwICYmIHRvb2x0aXAuX3dpbGxSZW5kZXIoKSkge1xuICAgICAgY29uc3QgYXJncyA9IHtcbiAgICAgICAgdG9vbHRpcFxuICAgICAgfTtcblxuICAgICAgaWYgKGNoYXJ0Lm5vdGlmeVBsdWdpbnMoJ2JlZm9yZVRvb2x0aXBEcmF3Jywgey4uLmFyZ3MsIGNhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0b29sdGlwLmRyYXcoY2hhcnQuY3R4KTtcblxuICAgICAgY2hhcnQubm90aWZ5UGx1Z2lucygnYWZ0ZXJUb29sdGlwRHJhdycsIGFyZ3MpO1xuICAgIH1cbiAgfSxcblxuICBhZnRlckV2ZW50KGNoYXJ0LCBhcmdzKSB7XG4gICAgaWYgKGNoYXJ0LnRvb2x0aXApIHtcbiAgICAgIC8vIElmIHRoZSBldmVudCBpcyByZXBsYXllZCBmcm9tIGB1cGRhdGVgLCB3ZSBzaG91bGQgZXZhbHVhdGUgd2l0aCB0aGUgZmluYWwgcG9zaXRpb25zLlxuICAgICAgY29uc3QgdXNlRmluYWxQb3NpdGlvbiA9IGFyZ3MucmVwbGF5O1xuICAgICAgaWYgKGNoYXJ0LnRvb2x0aXAuaGFuZGxlRXZlbnQoYXJncy5ldmVudCwgdXNlRmluYWxQb3NpdGlvbiwgYXJncy5pbkNoYXJ0QXJlYSkpIHtcbiAgICAgICAgLy8gbm90aWZ5IGNoYXJ0IGFib3V0IHRoZSBjaGFuZ2UsIHNvIGl0IHdpbGwgcmVuZGVyXG4gICAgICAgIGFyZ3MuY2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGRlZmF1bHRzOiB7XG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBleHRlcm5hbDogbnVsbCxcbiAgICBwb3NpdGlvbjogJ2F2ZXJhZ2UnLFxuICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMC44KScsXG4gICAgdGl0bGVDb2xvcjogJyNmZmYnLFxuICAgIHRpdGxlRm9udDoge1xuICAgICAgd2VpZ2h0OiAnYm9sZCcsXG4gICAgfSxcbiAgICB0aXRsZVNwYWNpbmc6IDIsXG4gICAgdGl0bGVNYXJnaW5Cb3R0b206IDYsXG4gICAgdGl0bGVBbGlnbjogJ2xlZnQnLFxuICAgIGJvZHlDb2xvcjogJyNmZmYnLFxuICAgIGJvZHlTcGFjaW5nOiAyLFxuICAgIGJvZHlGb250OiB7XG4gICAgfSxcbiAgICBib2R5QWxpZ246ICdsZWZ0JyxcbiAgICBmb290ZXJDb2xvcjogJyNmZmYnLFxuICAgIGZvb3RlclNwYWNpbmc6IDIsXG4gICAgZm9vdGVyTWFyZ2luVG9wOiA2LFxuICAgIGZvb3RlckZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ2JvbGQnLFxuICAgIH0sXG4gICAgZm9vdGVyQWxpZ246ICdsZWZ0JyxcbiAgICBwYWRkaW5nOiA2LFxuICAgIGNhcmV0UGFkZGluZzogMixcbiAgICBjYXJldFNpemU6IDUsXG4gICAgY29ybmVyUmFkaXVzOiA2LFxuICAgIGJveEhlaWdodDogKGN0eCwgb3B0cykgPT4gb3B0cy5ib2R5Rm9udC5zaXplLFxuICAgIGJveFdpZHRoOiAoY3R4LCBvcHRzKSA9PiBvcHRzLmJvZHlGb250LnNpemUsXG4gICAgbXVsdGlLZXlCYWNrZ3JvdW5kOiAnI2ZmZicsXG4gICAgZGlzcGxheUNvbG9yczogdHJ1ZSxcbiAgICBib3hQYWRkaW5nOiAwLFxuICAgIGJvcmRlckNvbG9yOiAncmdiYSgwLDAsMCwwKScsXG4gICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBkdXJhdGlvbjogNDAwLFxuICAgICAgZWFzaW5nOiAnZWFzZU91dFF1YXJ0JyxcbiAgICB9LFxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ3dpZHRoJywgJ2hlaWdodCcsICdjYXJldFgnLCAnY2FyZXRZJ10sXG4gICAgICB9LFxuICAgICAgb3BhY2l0eToge1xuICAgICAgICBlYXNpbmc6ICdsaW5lYXInLFxuICAgICAgICBkdXJhdGlvbjogMjAwXG4gICAgICB9XG4gICAgfSxcbiAgICBjYWxsYmFja3M6IGRlZmF1bHRDYWxsYmFja3NcbiAgfSxcblxuICBkZWZhdWx0Um91dGVzOiB7XG4gICAgYm9keUZvbnQ6ICdmb250JyxcbiAgICBmb290ZXJGb250OiAnZm9udCcsXG4gICAgdGl0bGVGb250OiAnZm9udCdcbiAgfSxcblxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2ZpbHRlcicgJiYgbmFtZSAhPT0gJ2l0ZW1Tb3J0JyAmJiBuYW1lICE9PSAnZXh0ZXJuYWwnLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICAgIGNhbGxiYWNrczoge1xuICAgICAgX3NjcmlwdGFibGU6IGZhbHNlLFxuICAgICAgX2luZGV4YWJsZTogZmFsc2UsXG4gICAgfSxcbiAgICBhbmltYXRpb246IHtcbiAgICAgIF9mYWxsYmFjazogZmFsc2VcbiAgICB9LFxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIF9mYWxsYmFjazogJ2FuaW1hdGlvbidcbiAgICB9XG4gIH0sXG5cbiAgLy8gUmVzb2x2ZSBhZGRpdGlvbmFsbHkgZnJvbSBgaW50ZXJhY3Rpb25gIG9wdGlvbnMgYW5kIGRlZmF1bHRzLlxuICBhZGRpdGlvbmFsT3B0aW9uU2NvcGVzOiBbJ2ludGVyYWN0aW9uJ11cbn07XG4iLCAiaW1wb3J0IFNjYWxlIGZyb20gJy4uL2NvcmUvY29yZS5zY2FsZS5qcyc7XG5pbXBvcnQge2lzTnVsbE9yVW5kZWYsIHZhbHVlT3JEZWZhdWx0LCBfbGltaXRWYWx1ZX0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbmNvbnN0IGFkZElmU3RyaW5nID0gKGxhYmVscywgcmF3LCBpbmRleCwgYWRkZWRMYWJlbHMpID0+IHtcbiAgaWYgKHR5cGVvZiByYXcgPT09ICdzdHJpbmcnKSB7XG4gICAgaW5kZXggPSBsYWJlbHMucHVzaChyYXcpIC0gMTtcbiAgICBhZGRlZExhYmVscy51bnNoaWZ0KHtpbmRleCwgbGFiZWw6IHJhd30pO1xuICB9IGVsc2UgaWYgKGlzTmFOKHJhdykpIHtcbiAgICBpbmRleCA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIGluZGV4O1xufTtcblxuZnVuY3Rpb24gZmluZE9yQWRkTGFiZWwobGFiZWxzLCByYXcsIGluZGV4LCBhZGRlZExhYmVscykge1xuICBjb25zdCBmaXJzdCA9IGxhYmVscy5pbmRleE9mKHJhdyk7XG4gIGlmIChmaXJzdCA9PT0gLTEpIHtcbiAgICByZXR1cm4gYWRkSWZTdHJpbmcobGFiZWxzLCByYXcsIGluZGV4LCBhZGRlZExhYmVscyk7XG4gIH1cbiAgY29uc3QgbGFzdCA9IGxhYmVscy5sYXN0SW5kZXhPZihyYXcpO1xuICByZXR1cm4gZmlyc3QgIT09IGxhc3QgPyBpbmRleCA6IGZpcnN0O1xufVxuXG5jb25zdCB2YWxpZEluZGV4ID0gKGluZGV4LCBtYXgpID0+IGluZGV4ID09PSBudWxsID8gbnVsbCA6IF9saW1pdFZhbHVlKE1hdGgucm91bmQoaW5kZXgpLCAwLCBtYXgpO1xuXG5mdW5jdGlvbiBfZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuXG4gIGlmICh2YWx1ZSA+PSAwICYmIHZhbHVlIDwgbGFiZWxzLmxlbmd0aCkge1xuICAgIHJldHVybiBsYWJlbHNbdmFsdWVdO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2F0ZWdvcnlTY2FsZSBleHRlbmRzIFNjYWxlIHtcblxuICBzdGF0aWMgaWQgPSAnY2F0ZWdvcnknO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIHRpY2tzOiB7XG4gICAgICBjYWxsYmFjazogX2dldExhYmVsRm9yVmFsdWVcbiAgICB9XG4gIH07XG5cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoY2ZnKTtcblxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IDA7XG4gICAgdGhpcy5fYWRkZWRMYWJlbHMgPSBbXTtcbiAgfVxuXG4gIGluaXQoc2NhbGVPcHRpb25zKSB7XG4gICAgY29uc3QgYWRkZWQgPSB0aGlzLl9hZGRlZExhYmVscztcbiAgICBpZiAoYWRkZWQubGVuZ3RoKSB7XG4gICAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgICAgZm9yIChjb25zdCB7aW5kZXgsIGxhYmVsfSBvZiBhZGRlZCkge1xuICAgICAgICBpZiAobGFiZWxzW2luZGV4XSA9PT0gbGFiZWwpIHtcbiAgICAgICAgICBsYWJlbHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fYWRkZWRMYWJlbHMgPSBbXTtcbiAgICB9XG4gICAgc3VwZXIuaW5pdChzY2FsZU9wdGlvbnMpO1xuICB9XG5cbiAgcGFyc2UocmF3LCBpbmRleCkge1xuICAgIGlmIChpc051bGxPclVuZGVmKHJhdykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgIGluZGV4ID0gaXNGaW5pdGUoaW5kZXgpICYmIGxhYmVsc1tpbmRleF0gPT09IHJhdyA/IGluZGV4XG4gICAgICA6IGZpbmRPckFkZExhYmVsKGxhYmVscywgcmF3LCB2YWx1ZU9yRGVmYXVsdChpbmRleCwgcmF3KSwgdGhpcy5fYWRkZWRMYWJlbHMpO1xuICAgIHJldHVybiB2YWxpZEluZGV4KGluZGV4LCBsYWJlbHMubGVuZ3RoIC0gMSk7XG4gIH1cblxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHttaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGxldCB7bWluLCBtYXh9ID0gdGhpcy5nZXRNaW5NYXgodHJ1ZSk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmJvdW5kcyA9PT0gJ3RpY2tzJykge1xuICAgICAgaWYgKCFtaW5EZWZpbmVkKSB7XG4gICAgICAgIG1pbiA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoIW1heERlZmluZWQpIHtcbiAgICAgICAgbWF4ID0gdGhpcy5nZXRMYWJlbHMoKS5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubWluID0gbWluO1xuICAgIHRoaXMubWF4ID0gbWF4O1xuICB9XG5cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCBtaW4gPSB0aGlzLm1pbjtcbiAgICBjb25zdCBtYXggPSB0aGlzLm1heDtcbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9wdGlvbnMub2Zmc2V0O1xuICAgIGNvbnN0IHRpY2tzID0gW107XG4gICAgbGV0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG5cbiAgICAvLyBJZiB3ZSBhcmUgdmlld2luZyBzb21lIHN1YnNldCBvZiBsYWJlbHMsIHNsaWNlIHRoZSBvcmlnaW5hbCBhcnJheVxuICAgIGxhYmVscyA9IChtaW4gPT09IDAgJiYgbWF4ID09PSBsYWJlbHMubGVuZ3RoIC0gMSkgPyBsYWJlbHMgOiBsYWJlbHMuc2xpY2UobWluLCBtYXggKyAxKTtcblxuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSBNYXRoLm1heChsYWJlbHMubGVuZ3RoIC0gKG9mZnNldCA/IDAgOiAxKSwgMSk7XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHRoaXMubWluIC0gKG9mZnNldCA/IDAuNSA6IDApO1xuXG4gICAgZm9yIChsZXQgdmFsdWUgPSBtaW47IHZhbHVlIDw9IG1heDsgdmFsdWUrKykge1xuICAgICAgdGlja3MucHVzaCh7dmFsdWV9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG5cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiBfZ2V0TGFiZWxGb3JWYWx1ZS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBjb25maWd1cmUoKSB7XG4gICAgc3VwZXIuY29uZmlndXJlKCk7XG5cbiAgICBpZiAoIXRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIC8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB2ZXJ0aWNhbCBjYXRlZ29yeSBzY2FsZSByZXZlcnNlIGlzIGludmVydGVkLlxuICAgICAgdGhpcy5fcmV2ZXJzZVBpeGVscyA9ICF0aGlzLl9yZXZlcnNlUGl4ZWxzO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVzZWQgdG8gZ2V0IGRhdGEgdmFsdWUgbG9jYXRpb25zLiBWYWx1ZSBjYW4gZWl0aGVyIGJlIGFuIGluZGV4IG9yIGEgbnVtZXJpY2FsIHZhbHVlXG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBOYU4gOiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCgodmFsdWUgLSB0aGlzLl9zdGFydFZhbHVlKSAvIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG5cbiAgLy8gTXVzdCBvdmVycmlkZSBiYXNlIGltcGxlbWVudGF0aW9uIGJlY2F1c2UgaXQgY2FsbHMgZ2V0UGl4ZWxGb3JWYWx1ZVxuICAvLyBhbmQgY2F0ZWdvcnkgc2NhbGUgY2FuIGhhdmUgZHVwbGljYXRlIHZhbHVlc1xuICBnZXRQaXhlbEZvclRpY2soaW5kZXgpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRpY2tzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRpY2tzW2luZGV4XS52YWx1ZSk7XG4gIH1cblxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodGhpcy5fc3RhcnRWYWx1ZSArIHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAqIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG5cbiAgZ2V0QmFzZVBpeGVsKCkge1xuICAgIHJldHVybiB0aGlzLmJvdHRvbTtcbiAgfVxufVxuIiwgImltcG9ydCB7aXNOdWxsT3JVbmRlZn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHthbG1vc3RFcXVhbHMsIGFsbW9zdFdob2xlLCBuaWNlTnVtLCBfZGVjaW1hbFBsYWNlcywgX3NldE1pbkFuZE1heEJ5S2V5LCBzaWduLCB0b1JhZGlhbnN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCBTY2FsZSBmcm9tICcuLi9jb3JlL2NvcmUuc2NhbGUuanMnO1xuaW1wb3J0IHtmb3JtYXROdW1iZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5pbnRsLmpzJztcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHNldCBvZiBsaW5lYXIgdGlja3MgZm9yIGFuIGF4aXNcbiAqIDEuIElmIGdlbmVyYXRpb25PcHRpb25zLm1pbiwgZ2VuZXJhdGlvbk9wdGlvbnMubWF4LCBhbmQgZ2VuZXJhdGlvbk9wdGlvbnMuc3RlcCBhcmUgZGVmaW5lZDpcbiAqICAgIGlmIChtYXggLSBtaW4pIC8gc3RlcCBpcyBhbiBpbnRlZ2VyLCB0aWNrcyBhcmUgZ2VuZXJhdGVkIGFzIFttaW4sIG1pbiArIHN0ZXAsIC4uLiwgbWF4XVxuICogICAgTm90ZSB0aGF0IHRoZSBnZW5lcmF0aW9uT3B0aW9ucy5tYXhDb3VudCBzZXR0aW5nIGlzIHJlc3BlY3RlZCBpbiB0aGlzIHNjZW5hcmlvXG4gKlxuICogMi4gSWYgZ2VuZXJhdGlvbk9wdGlvbnMubWluLCBnZW5lcmF0aW9uT3B0aW9ucy5tYXgsIGFuZCBnZW5lcmF0aW9uT3B0aW9ucy5jb3VudCBpcyBkZWZpbmVkXG4gKiAgICBzcGFjaW5nID0gKG1heCAtIG1pbikgLyBjb3VudFxuICogICAgVGlja3MgYXJlIGdlbmVyYXRlZCBhcyBbbWluLCBtaW4gKyBzcGFjaW5nLCAuLi4sIG1heF1cbiAqXG4gKiAzLiBJZiBnZW5lcmF0aW9uT3B0aW9ucy5jb3VudCBpcyBkZWZpbmVkXG4gKiAgICBzcGFjaW5nID0gKG5pY2VNYXggLSBuaWNlTWluKSAvIGNvdW50XG4gKlxuICogNC4gQ29tcHV0ZSBvcHRpbWFsIHNwYWNpbmcgb2YgdGlja3MgdXNpbmcgbmljZU51bSBhbGdvcml0aG1cbiAqXG4gKiBAcGFyYW0gZ2VuZXJhdGlvbk9wdGlvbnMgdGhlIG9wdGlvbnMgdXNlZCB0byBnZW5lcmF0ZSB0aGUgdGlja3NcbiAqIEBwYXJhbSBkYXRhUmFuZ2UgdGhlIHJhbmdlIG9mIHRoZSBkYXRhXG4gKiBAcmV0dXJucyB7b2JqZWN0W119IGFycmF5IG9mIHRpY2sgb2JqZWN0c1xuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVRpY2tzKGdlbmVyYXRpb25PcHRpb25zLCBkYXRhUmFuZ2UpIHtcbiAgY29uc3QgdGlja3MgPSBbXTtcbiAgLy8gVG8gZ2V0IGEgXCJuaWNlXCIgdmFsdWUgZm9yIHRoZSB0aWNrIHNwYWNpbmcsIHdlIHdpbGwgdXNlIHRoZSBhcHByb3ByaWF0ZWx5IG5hbWVkXG4gIC8vIFwibmljZSBudW1iZXJcIiBhbGdvcml0aG0uIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84NTA2ODgxL25pY2UtbGFiZWwtYWxnb3JpdGhtLWZvci1jaGFydHMtd2l0aC1taW5pbXVtLXRpY2tzXG4gIC8vIGZvciBkZXRhaWxzLlxuXG4gIGNvbnN0IE1JTl9TUEFDSU5HID0gMWUtMTQ7XG4gIGNvbnN0IHtib3VuZHMsIHN0ZXAsIG1pbiwgbWF4LCBwcmVjaXNpb24sIGNvdW50LCBtYXhUaWNrcywgbWF4RGlnaXRzLCBpbmNsdWRlQm91bmRzfSA9IGdlbmVyYXRpb25PcHRpb25zO1xuICBjb25zdCB1bml0ID0gc3RlcCB8fCAxO1xuICBjb25zdCBtYXhTcGFjZXMgPSBtYXhUaWNrcyAtIDE7XG4gIGNvbnN0IHttaW46IHJtaW4sIG1heDogcm1heH0gPSBkYXRhUmFuZ2U7XG4gIGNvbnN0IG1pbkRlZmluZWQgPSAhaXNOdWxsT3JVbmRlZihtaW4pO1xuICBjb25zdCBtYXhEZWZpbmVkID0gIWlzTnVsbE9yVW5kZWYobWF4KTtcbiAgY29uc3QgY291bnREZWZpbmVkID0gIWlzTnVsbE9yVW5kZWYoY291bnQpO1xuICBjb25zdCBtaW5TcGFjaW5nID0gKHJtYXggLSBybWluKSAvIChtYXhEaWdpdHMgKyAxKTtcbiAgbGV0IHNwYWNpbmcgPSBuaWNlTnVtKChybWF4IC0gcm1pbikgLyBtYXhTcGFjZXMgLyB1bml0KSAqIHVuaXQ7XG4gIGxldCBmYWN0b3IsIG5pY2VNaW4sIG5pY2VNYXgsIG51bVNwYWNlcztcblxuICAvLyBCZXlvbmQgTUlOX1NQQUNJTkcgZmxvYXRpbmcgcG9pbnQgbnVtYmVycyBiZWluZyB0byBsb3NlIHByZWNpc2lvblxuICAvLyBzdWNoIHRoYXQgd2UgY2FuJ3QgZG8gdGhlIG1hdGggbmVjZXNzYXJ5IHRvIGdlbmVyYXRlIHRpY2tzXG4gIGlmIChzcGFjaW5nIDwgTUlOX1NQQUNJTkcgJiYgIW1pbkRlZmluZWQgJiYgIW1heERlZmluZWQpIHtcbiAgICByZXR1cm4gW3t2YWx1ZTogcm1pbn0sIHt2YWx1ZTogcm1heH1dO1xuICB9XG5cbiAgbnVtU3BhY2VzID0gTWF0aC5jZWlsKHJtYXggLyBzcGFjaW5nKSAtIE1hdGguZmxvb3Iocm1pbiAvIHNwYWNpbmcpO1xuICBpZiAobnVtU3BhY2VzID4gbWF4U3BhY2VzKSB7XG4gICAgLy8gSWYgdGhlIGNhbGN1bGF0ZWQgbnVtIG9mIHNwYWNlcyBleGNlZWRzIG1heE51bVNwYWNlcywgcmVjYWxjdWxhdGUgaXRcbiAgICBzcGFjaW5nID0gbmljZU51bShudW1TcGFjZXMgKiBzcGFjaW5nIC8gbWF4U3BhY2VzIC8gdW5pdCkgKiB1bml0O1xuICB9XG5cbiAgaWYgKCFpc051bGxPclVuZGVmKHByZWNpc2lvbikpIHtcbiAgICAvLyBJZiB0aGUgdXNlciBzcGVjaWZpZWQgYSBwcmVjaXNpb24sIHJvdW5kIHRvIHRoYXQgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzXG4gICAgZmFjdG9yID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbik7XG4gICAgc3BhY2luZyA9IE1hdGguY2VpbChzcGFjaW5nICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgfVxuXG4gIGlmIChib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICBuaWNlTWluID0gTWF0aC5mbG9vcihybWluIC8gc3BhY2luZykgKiBzcGFjaW5nO1xuICAgIG5pY2VNYXggPSBNYXRoLmNlaWwocm1heCAvIHNwYWNpbmcpICogc3BhY2luZztcbiAgfSBlbHNlIHtcbiAgICBuaWNlTWluID0gcm1pbjtcbiAgICBuaWNlTWF4ID0gcm1heDtcbiAgfVxuXG4gIGlmIChtaW5EZWZpbmVkICYmIG1heERlZmluZWQgJiYgc3RlcCAmJiBhbG1vc3RXaG9sZSgobWF4IC0gbWluKSAvIHN0ZXAsIHNwYWNpbmcgLyAxMDAwKSkge1xuICAgIC8vIENhc2UgMTogSWYgbWluLCBtYXggYW5kIHN0ZXBTaXplIGFyZSBzZXQgYW5kIHRoZXkgbWFrZSBhbiBldmVubHkgc3BhY2VkIHNjYWxlIHVzZSBpdC5cbiAgICAvLyBzcGFjaW5nID0gc3RlcDtcbiAgICAvLyBudW1TcGFjZXMgPSAobWF4IC0gbWluKSAvIHNwYWNpbmc7XG4gICAgLy8gTm90ZSB0aGF0IHdlIHJvdW5kIGhlcmUgdG8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIGFsbW9zdFdob2xlIHRyYW5zbGF0ZWQgYW4gRlAgZXJyb3JcbiAgICBudW1TcGFjZXMgPSBNYXRoLnJvdW5kKE1hdGgubWluKChtYXggLSBtaW4pIC8gc3BhY2luZywgbWF4VGlja3MpKTtcbiAgICBzcGFjaW5nID0gKG1heCAtIG1pbikgLyBudW1TcGFjZXM7XG4gICAgbmljZU1pbiA9IG1pbjtcbiAgICBuaWNlTWF4ID0gbWF4O1xuICB9IGVsc2UgaWYgKGNvdW50RGVmaW5lZCkge1xuICAgIC8vIENhc2VzIDIgJiAzLCB3ZSBoYXZlIGEgY291bnQgc3BlY2lmaWVkLiBIYW5kbGUgb3B0aW9uYWwgdXNlciBkZWZpbmVkIGVkZ2VzIHRvIHRoZSByYW5nZS5cbiAgICAvLyBTb21ldGltZXMgdGhlc2UgYXJlIG5vLW9wcywgYnV0IGl0IG1ha2VzIHRoZSBjb2RlIGEgbG90IGNsZWFyZXJcbiAgICAvLyBhbmQgd2hlbiBhIHVzZXIgZGVmaW5lZCByYW5nZSBpcyBzcGVjaWZpZWQsIHdlIHdhbnQgdGhlIGNvcnJlY3QgdGlja3NcbiAgICBuaWNlTWluID0gbWluRGVmaW5lZCA/IG1pbiA6IG5pY2VNaW47XG4gICAgbmljZU1heCA9IG1heERlZmluZWQgPyBtYXggOiBuaWNlTWF4O1xuICAgIG51bVNwYWNlcyA9IGNvdW50IC0gMTtcbiAgICBzcGFjaW5nID0gKG5pY2VNYXggLSBuaWNlTWluKSAvIG51bVNwYWNlcztcbiAgfSBlbHNlIHtcbiAgICAvLyBDYXNlIDRcbiAgICBudW1TcGFjZXMgPSAobmljZU1heCAtIG5pY2VNaW4pIC8gc3BhY2luZztcblxuICAgIC8vIElmIHZlcnkgY2xvc2UgdG8gb3VyIHJvdW5kZWQgdmFsdWUsIHVzZSBpdC5cbiAgICBpZiAoYWxtb3N0RXF1YWxzKG51bVNwYWNlcywgTWF0aC5yb3VuZChudW1TcGFjZXMpLCBzcGFjaW5nIC8gMTAwMCkpIHtcbiAgICAgIG51bVNwYWNlcyA9IE1hdGgucm91bmQobnVtU3BhY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbnVtU3BhY2VzID0gTWF0aC5jZWlsKG51bVNwYWNlcyk7XG4gICAgfVxuICB9XG5cbiAgLy8gVGhlIHNwYWNpbmcgd2lsbCBoYXZlIGNoYW5nZWQgaW4gY2FzZXMgMSwgMiwgYW5kIDMgc28gdGhlIGZhY3RvciBjYW5ub3QgYmUgY29tcHV0ZWRcbiAgLy8gdW50aWwgdGhpcyBwb2ludFxuICBjb25zdCBkZWNpbWFsUGxhY2VzID0gTWF0aC5tYXgoXG4gICAgX2RlY2ltYWxQbGFjZXMoc3BhY2luZyksXG4gICAgX2RlY2ltYWxQbGFjZXMobmljZU1pbilcbiAgKTtcbiAgZmFjdG9yID0gTWF0aC5wb3coMTAsIGlzTnVsbE9yVW5kZWYocHJlY2lzaW9uKSA/IGRlY2ltYWxQbGFjZXMgOiBwcmVjaXNpb24pO1xuICBuaWNlTWluID0gTWF0aC5yb3VuZChuaWNlTWluICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgbmljZU1heCA9IE1hdGgucm91bmQobmljZU1heCAqIGZhY3RvcikgLyBmYWN0b3I7XG5cbiAgbGV0IGogPSAwO1xuICBpZiAobWluRGVmaW5lZCkge1xuICAgIGlmIChpbmNsdWRlQm91bmRzICYmIG5pY2VNaW4gIT09IG1pbikge1xuICAgICAgdGlja3MucHVzaCh7dmFsdWU6IG1pbn0pO1xuXG4gICAgICBpZiAobmljZU1pbiA8IG1pbikge1xuICAgICAgICBqKys7IC8vIFNraXAgbmljZU1pblxuICAgICAgfVxuICAgICAgLy8gSWYgdGhlIG5leHQgbmljZSB0aWNrIGlzIGNsb3NlIHRvIG1pbiwgc2tpcCBpdFxuICAgICAgaWYgKGFsbW9zdEVxdWFscyhNYXRoLnJvdW5kKChuaWNlTWluICsgaiAqIHNwYWNpbmcpICogZmFjdG9yKSAvIGZhY3RvciwgbWluLCByZWxhdGl2ZUxhYmVsU2l6ZShtaW4sIG1pblNwYWNpbmcsIGdlbmVyYXRpb25PcHRpb25zKSkpIHtcbiAgICAgICAgaisrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmljZU1pbiA8IG1pbikge1xuICAgICAgaisrO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBqIDwgbnVtU3BhY2VzOyArK2opIHtcbiAgICBjb25zdCB0aWNrVmFsdWUgPSBNYXRoLnJvdW5kKChuaWNlTWluICsgaiAqIHNwYWNpbmcpICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgICBpZiAobWF4RGVmaW5lZCAmJiB0aWNrVmFsdWUgPiBtYXgpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aWNrcy5wdXNoKHt2YWx1ZTogdGlja1ZhbHVlfSk7XG4gIH1cblxuICBpZiAobWF4RGVmaW5lZCAmJiBpbmNsdWRlQm91bmRzICYmIG5pY2VNYXggIT09IG1heCkge1xuICAgIC8vIElmIHRoZSBwcmV2aW91cyB0aWNrIGlzIHRvbyBjbG9zZSB0byBtYXgsIHJlcGxhY2UgaXQgd2l0aCBtYXgsIGVsc2UgYWRkIG1heFxuICAgIGlmICh0aWNrcy5sZW5ndGggJiYgYWxtb3N0RXF1YWxzKHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlLCBtYXgsIHJlbGF0aXZlTGFiZWxTaXplKG1heCwgbWluU3BhY2luZywgZ2VuZXJhdGlvbk9wdGlvbnMpKSkge1xuICAgICAgdGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWUgPSBtYXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBtYXh9KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIW1heERlZmluZWQgfHwgbmljZU1heCA9PT0gbWF4KSB7XG4gICAgdGlja3MucHVzaCh7dmFsdWU6IG5pY2VNYXh9KTtcbiAgfVxuXG4gIHJldHVybiB0aWNrcztcbn1cblxuZnVuY3Rpb24gcmVsYXRpdmVMYWJlbFNpemUodmFsdWUsIG1pblNwYWNpbmcsIHtob3Jpem9udGFsLCBtaW5Sb3RhdGlvbn0pIHtcbiAgY29uc3QgcmFkID0gdG9SYWRpYW5zKG1pblJvdGF0aW9uKTtcbiAgY29uc3QgcmF0aW8gPSAoaG9yaXpvbnRhbCA/IE1hdGguc2luKHJhZCkgOiBNYXRoLmNvcyhyYWQpKSB8fCAwLjAwMTtcbiAgY29uc3QgbGVuZ3RoID0gMC43NSAqIG1pblNwYWNpbmcgKiAoJycgKyB2YWx1ZSkubGVuZ3RoO1xuICByZXR1cm4gTWF0aC5taW4obWluU3BhY2luZyAvIHJhdGlvLCBsZW5ndGgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5lYXJTY2FsZUJhc2UgZXh0ZW5kcyBTY2FsZSB7XG5cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoY2ZnKTtcblxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuc3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5lbmQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLl9lbmRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gMDtcbiAgfVxuXG4gIHBhcnNlKHJhdywgaW5kZXgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIGlmIChpc051bGxPclVuZGVmKHJhdykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoKHR5cGVvZiByYXcgPT09ICdudW1iZXInIHx8IHJhdyBpbnN0YW5jZW9mIE51bWJlcikgJiYgIWlzRmluaXRlKCtyYXcpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gK3JhdztcbiAgfVxuXG4gIGhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKSB7XG4gICAgY29uc3Qge2JlZ2luQXRaZXJvfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7bWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBsZXQge21pbiwgbWF4fSA9IHRoaXM7XG5cbiAgICBjb25zdCBzZXRNaW4gPSB2ID0+IChtaW4gPSBtaW5EZWZpbmVkID8gbWluIDogdik7XG4gICAgY29uc3Qgc2V0TWF4ID0gdiA9PiAobWF4ID0gbWF4RGVmaW5lZCA/IG1heCA6IHYpO1xuXG4gICAgaWYgKGJlZ2luQXRaZXJvKSB7XG4gICAgICBjb25zdCBtaW5TaWduID0gc2lnbihtaW4pO1xuICAgICAgY29uc3QgbWF4U2lnbiA9IHNpZ24obWF4KTtcblxuICAgICAgaWYgKG1pblNpZ24gPCAwICYmIG1heFNpZ24gPCAwKSB7XG4gICAgICAgIHNldE1heCgwKTtcbiAgICAgIH0gZWxzZSBpZiAobWluU2lnbiA+IDAgJiYgbWF4U2lnbiA+IDApIHtcbiAgICAgICAgc2V0TWluKDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtaW4gPT09IG1heCkge1xuICAgICAgbGV0IG9mZnNldCA9IG1heCA9PT0gMCA/IDEgOiBNYXRoLmFicyhtYXggKiAwLjA1KTtcblxuICAgICAgc2V0TWF4KG1heCArIG9mZnNldCk7XG5cbiAgICAgIGlmICghYmVnaW5BdFplcm8pIHtcbiAgICAgICAgc2V0TWluKG1pbiAtIG9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubWluID0gbWluO1xuICAgIHRoaXMubWF4ID0gbWF4O1xuICB9XG5cbiAgZ2V0VGlja0xpbWl0KCkge1xuICAgIGNvbnN0IHRpY2tPcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICBsZXQge21heFRpY2tzTGltaXQsIHN0ZXBTaXplfSA9IHRpY2tPcHRzO1xuICAgIGxldCBtYXhUaWNrcztcblxuICAgIGlmIChzdGVwU2l6ZSkge1xuICAgICAgbWF4VGlja3MgPSBNYXRoLmNlaWwodGhpcy5tYXggLyBzdGVwU2l6ZSkgLSBNYXRoLmZsb29yKHRoaXMubWluIC8gc3RlcFNpemUpICsgMTtcbiAgICAgIGlmIChtYXhUaWNrcyA+IDEwMDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBzY2FsZXMuJHt0aGlzLmlkfS50aWNrcy5zdGVwU2l6ZTogJHtzdGVwU2l6ZX0gd291bGQgcmVzdWx0IGdlbmVyYXRpbmcgdXAgdG8gJHttYXhUaWNrc30gdGlja3MuIExpbWl0aW5nIHRvIDEwMDAuYCk7XG4gICAgICAgIG1heFRpY2tzID0gMTAwMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4VGlja3MgPSB0aGlzLmNvbXB1dGVUaWNrTGltaXQoKTtcbiAgICAgIG1heFRpY2tzTGltaXQgPSBtYXhUaWNrc0xpbWl0IHx8IDExO1xuICAgIH1cblxuICAgIGlmIChtYXhUaWNrc0xpbWl0KSB7XG4gICAgICBtYXhUaWNrcyA9IE1hdGgubWluKG1heFRpY2tzTGltaXQsIG1heFRpY2tzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWF4VGlja3M7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgY29tcHV0ZVRpY2tMaW1pdCgpIHtcbiAgICByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICB9XG5cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0cy50aWNrcztcblxuICAgIC8vIEZpZ3VyZSBvdXQgd2hhdCB0aGUgbWF4IG51bWJlciBvZiB0aWNrcyB3ZSBjYW4gc3VwcG9ydCBpdCBpcyBiYXNlZCBvbiB0aGUgc2l6ZSBvZlxuICAgIC8vIHRoZSBheGlzIGFyZWEuIEZvciBub3csIHdlIHNheSB0aGF0IHRoZSBtaW5pbXVtIHRpY2sgc3BhY2luZyBpbiBwaXhlbHMgbXVzdCBiZSA0MFxuICAgIC8vIFdlIGFsc28gbGltaXQgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpY2tzIHRvIDExIHdoaWNoIGdpdmVzIGEgbmljZSAxMCBzcXVhcmVzIG9uXG4gICAgLy8gdGhlIGdyYXBoLiBNYWtlIHN1cmUgd2UgYWx3YXlzIGhhdmUgYXQgbGVhc3QgMiB0aWNrc1xuICAgIGxldCBtYXhUaWNrcyA9IHRoaXMuZ2V0VGlja0xpbWl0KCk7XG4gICAgbWF4VGlja3MgPSBNYXRoLm1heCgyLCBtYXhUaWNrcyk7XG5cbiAgICBjb25zdCBudW1lcmljR2VuZXJhdG9yT3B0aW9ucyA9IHtcbiAgICAgIG1heFRpY2tzLFxuICAgICAgYm91bmRzOiBvcHRzLmJvdW5kcyxcbiAgICAgIG1pbjogb3B0cy5taW4sXG4gICAgICBtYXg6IG9wdHMubWF4LFxuICAgICAgcHJlY2lzaW9uOiB0aWNrT3B0cy5wcmVjaXNpb24sXG4gICAgICBzdGVwOiB0aWNrT3B0cy5zdGVwU2l6ZSxcbiAgICAgIGNvdW50OiB0aWNrT3B0cy5jb3VudCxcbiAgICAgIG1heERpZ2l0czogdGhpcy5fbWF4RGlnaXRzKCksXG4gICAgICBob3Jpem9udGFsOiB0aGlzLmlzSG9yaXpvbnRhbCgpLFxuICAgICAgbWluUm90YXRpb246IHRpY2tPcHRzLm1pblJvdGF0aW9uIHx8IDAsXG4gICAgICBpbmNsdWRlQm91bmRzOiB0aWNrT3B0cy5pbmNsdWRlQm91bmRzICE9PSBmYWxzZVxuICAgIH07XG4gICAgY29uc3QgZGF0YVJhbmdlID0gdGhpcy5fcmFuZ2UgfHwgdGhpcztcbiAgICBjb25zdCB0aWNrcyA9IGdlbmVyYXRlVGlja3MobnVtZXJpY0dlbmVyYXRvck9wdGlvbnMsIGRhdGFSYW5nZSk7XG5cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBuZWVkIHRvIHVwZGF0ZSBvdXIgbWF4IGFuZCBtaW4gZ2l2ZW4gdGhlIHRpY2sgdmFsdWVzLFxuICAgIC8vIHNpbmNlIHdlIHByb2JhYmx5IGhhdmUgZXhwYW5kZWQgdGhlIHJhbmdlIG9mIHRoZSBzY2FsZVxuICAgIGlmIChvcHRzLmJvdW5kcyA9PT0gJ3RpY2tzJykge1xuICAgICAgX3NldE1pbkFuZE1heEJ5S2V5KHRpY2tzLCB0aGlzLCAndmFsdWUnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5yZXZlcnNlKSB7XG4gICAgICB0aWNrcy5yZXZlcnNlKCk7XG5cbiAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm1heDtcbiAgICAgIHRoaXMuZW5kID0gdGhpcy5taW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm1pbjtcbiAgICAgIHRoaXMuZW5kID0gdGhpcy5tYXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgbGV0IHN0YXJ0ID0gdGhpcy5taW47XG4gICAgbGV0IGVuZCA9IHRoaXMubWF4O1xuXG4gICAgc3VwZXIuY29uZmlndXJlKCk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm9mZnNldCAmJiB0aWNrcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IChlbmQgLSBzdGFydCkgLyBNYXRoLm1heCh0aWNrcy5sZW5ndGggLSAxLCAxKSAvIDI7XG4gICAgICBzdGFydCAtPSBvZmZzZXQ7XG4gICAgICBlbmQgKz0gb2Zmc2V0O1xuICAgIH1cbiAgICB0aGlzLl9zdGFydFZhbHVlID0gc3RhcnQ7XG4gICAgdGhpcy5fZW5kVmFsdWUgPSBlbmQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IGVuZCAtIHN0YXJ0O1xuICB9XG5cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiBmb3JtYXROdW1iZXIodmFsdWUsIHRoaXMuY2hhcnQub3B0aW9ucy5sb2NhbGUsIHRoaXMub3B0aW9ucy50aWNrcy5mb3JtYXQpO1xuICB9XG59XG4iLCAiaW1wb3J0IHtpc0Zpbml0ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IExpbmVhclNjYWxlQmFzZSBmcm9tICcuL3NjYWxlLmxpbmVhcmJhc2UuanMnO1xuaW1wb3J0IFRpY2tzIGZyb20gJy4uL2NvcmUvY29yZS50aWNrcy5qcyc7XG5pbXBvcnQge3RvUmFkaWFuc30gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmVhclNjYWxlIGV4dGVuZHMgTGluZWFyU2NhbGVCYXNlIHtcblxuICBzdGF0aWMgaWQgPSAnbGluZWFyJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICB0aWNrczoge1xuICAgICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMubnVtZXJpY1xuICAgIH1cbiAgfTtcblxuXG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KHRydWUpO1xuXG4gICAgdGhpcy5taW4gPSBpc0Zpbml0ZShtaW4pID8gbWluIDogMDtcbiAgICB0aGlzLm1heCA9IGlzRmluaXRlKG1heCkgPyBtYXggOiAxO1xuXG4gICAgLy8gQ29tbW9uIGJhc2UgaW1wbGVtZW50YXRpb24gdG8gaGFuZGxlIG1pbiwgbWF4LCBiZWdpbkF0WmVyb1xuICAgIHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpY2tzIGJhc2VkIG9uIHRoZSBzY2FsZSBkaW1lbnNpb25cblx0ICogQHByb3RlY3RlZFxuIFx0ICovXG4gIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgY29uc3QgaG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgbGVuZ3RoID0gaG9yaXpvbnRhbCA/IHRoaXMud2lkdGggOiB0aGlzLmhlaWdodDtcbiAgICBjb25zdCBtaW5Sb3RhdGlvbiA9IHRvUmFkaWFucyh0aGlzLm9wdGlvbnMudGlja3MubWluUm90YXRpb24pO1xuICAgIGNvbnN0IHJhdGlvID0gKGhvcml6b250YWwgPyBNYXRoLnNpbihtaW5Sb3RhdGlvbikgOiBNYXRoLmNvcyhtaW5Sb3RhdGlvbikpIHx8IDAuMDAxO1xuICAgIGNvbnN0IHRpY2tGb250ID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucygwKTtcbiAgICByZXR1cm4gTWF0aC5jZWlsKGxlbmd0aCAvIE1hdGgubWluKDQwLCB0aWNrRm9udC5saW5lSGVpZ2h0IC8gcmF0aW8pKTtcbiAgfVxuXG4gIC8vIFV0aWxzXG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBOYU4gOiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCgodmFsdWUgLSB0aGlzLl9zdGFydFZhbHVlKSAvIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG5cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIHJldHVybiB0aGlzLl9zdGFydFZhbHVlICsgdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpICogdGhpcy5fdmFsdWVSYW5nZTtcbiAgfVxufVxuIiwgImltcG9ydCB7ZmluaXRlT3JEZWZhdWx0LCBpc0Zpbml0ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtmb3JtYXROdW1iZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5pbnRsLmpzJztcbmltcG9ydCB7X3NldE1pbkFuZE1heEJ5S2V5LCBsb2cxMH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IFNjYWxlIGZyb20gJy4uL2NvcmUvY29yZS5zY2FsZS5qcyc7XG5pbXBvcnQgTGluZWFyU2NhbGVCYXNlIGZyb20gJy4vc2NhbGUubGluZWFyYmFzZS5qcyc7XG5pbXBvcnQgVGlja3MgZnJvbSAnLi4vY29yZS9jb3JlLnRpY2tzLmpzJztcblxuY29uc3QgbG9nMTBGbG9vciA9IHYgPT4gTWF0aC5mbG9vcihsb2cxMCh2KSk7XG5jb25zdCBjaGFuZ2VFeHBvbmVudCA9ICh2LCBtKSA9PiBNYXRoLnBvdygxMCwgbG9nMTBGbG9vcih2KSArIG0pO1xuXG5mdW5jdGlvbiBpc01ham9yKHRpY2tWYWwpIHtcbiAgY29uc3QgcmVtYWluID0gdGlja1ZhbCAvIChNYXRoLnBvdygxMCwgbG9nMTBGbG9vcih0aWNrVmFsKSkpO1xuICByZXR1cm4gcmVtYWluID09PSAxO1xufVxuXG5mdW5jdGlvbiBzdGVwcyhtaW4sIG1heCwgcmFuZ2VFeHApIHtcbiAgY29uc3QgcmFuZ2VTdGVwID0gTWF0aC5wb3coMTAsIHJhbmdlRXhwKTtcbiAgY29uc3Qgc3RhcnQgPSBNYXRoLmZsb29yKG1pbiAvIHJhbmdlU3RlcCk7XG4gIGNvbnN0IGVuZCA9IE1hdGguY2VpbChtYXggLyByYW5nZVN0ZXApO1xuICByZXR1cm4gZW5kIC0gc3RhcnQ7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0RXhwKG1pbiwgbWF4KSB7XG4gIGNvbnN0IHJhbmdlID0gbWF4IC0gbWluO1xuICBsZXQgcmFuZ2VFeHAgPSBsb2cxMEZsb29yKHJhbmdlKTtcbiAgd2hpbGUgKHN0ZXBzKG1pbiwgbWF4LCByYW5nZUV4cCkgPiAxMCkge1xuICAgIHJhbmdlRXhwKys7XG4gIH1cbiAgd2hpbGUgKHN0ZXBzKG1pbiwgbWF4LCByYW5nZUV4cCkgPCAxMCkge1xuICAgIHJhbmdlRXhwLS07XG4gIH1cbiAgcmV0dXJuIE1hdGgubWluKHJhbmdlRXhwLCBsb2cxMEZsb29yKG1pbikpO1xufVxuXG5cbi8qKlxuICogR2VuZXJhdGUgYSBzZXQgb2YgbG9nYXJpdGhtaWMgdGlja3NcbiAqIEBwYXJhbSBnZW5lcmF0aW9uT3B0aW9ucyB0aGUgb3B0aW9ucyB1c2VkIHRvIGdlbmVyYXRlIHRoZSB0aWNrc1xuICogQHBhcmFtIGRhdGFSYW5nZSB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGFcbiAqIEByZXR1cm5zIHtvYmplY3RbXX0gYXJyYXkgb2YgdGljayBvYmplY3RzXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlVGlja3MoZ2VuZXJhdGlvbk9wdGlvbnMsIHttaW4sIG1heH0pIHtcbiAgbWluID0gZmluaXRlT3JEZWZhdWx0KGdlbmVyYXRpb25PcHRpb25zLm1pbiwgbWluKTtcbiAgY29uc3QgdGlja3MgPSBbXTtcbiAgY29uc3QgbWluRXhwID0gbG9nMTBGbG9vcihtaW4pO1xuICBsZXQgZXhwID0gc3RhcnRFeHAobWluLCBtYXgpO1xuICBsZXQgcHJlY2lzaW9uID0gZXhwIDwgMCA/IE1hdGgucG93KDEwLCBNYXRoLmFicyhleHApKSA6IDE7XG4gIGNvbnN0IHN0ZXBTaXplID0gTWF0aC5wb3coMTAsIGV4cCk7XG4gIGNvbnN0IGJhc2UgPSBtaW5FeHAgPiBleHAgPyBNYXRoLnBvdygxMCwgbWluRXhwKSA6IDA7XG4gIGNvbnN0IHN0YXJ0ID0gTWF0aC5yb3VuZCgobWluIC0gYmFzZSkgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuICBjb25zdCBvZmZzZXQgPSBNYXRoLmZsb29yKChtaW4gLSBiYXNlKSAvIHN0ZXBTaXplIC8gMTApICogc3RlcFNpemUgKiAxMDtcbiAgbGV0IHNpZ25pZmljYW5kID0gTWF0aC5mbG9vcigoc3RhcnQgLSBvZmZzZXQpIC8gTWF0aC5wb3coMTAsIGV4cCkpO1xuICBsZXQgdmFsdWUgPSBmaW5pdGVPckRlZmF1bHQoZ2VuZXJhdGlvbk9wdGlvbnMubWluLCBNYXRoLnJvdW5kKChiYXNlICsgb2Zmc2V0ICsgc2lnbmlmaWNhbmQgKiBNYXRoLnBvdygxMCwgZXhwKSkgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uKTtcbiAgd2hpbGUgKHZhbHVlIDwgbWF4KSB7XG4gICAgdGlja3MucHVzaCh7dmFsdWUsIG1ham9yOiBpc01ham9yKHZhbHVlKSwgc2lnbmlmaWNhbmR9KTtcbiAgICBpZiAoc2lnbmlmaWNhbmQgPj0gMTApIHtcbiAgICAgIHNpZ25pZmljYW5kID0gc2lnbmlmaWNhbmQgPCAxNSA/IDE1IDogMjA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpZ25pZmljYW5kKys7XG4gICAgfVxuICAgIGlmIChzaWduaWZpY2FuZCA+PSAyMCkge1xuICAgICAgZXhwKys7XG4gICAgICBzaWduaWZpY2FuZCA9IDI7XG4gICAgICBwcmVjaXNpb24gPSBleHAgPj0gMCA/IDEgOiBwcmVjaXNpb247XG4gICAgfVxuICAgIHZhbHVlID0gTWF0aC5yb3VuZCgoYmFzZSArIG9mZnNldCArIHNpZ25pZmljYW5kICogTWF0aC5wb3coMTAsIGV4cCkpICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcbiAgfVxuICBjb25zdCBsYXN0VGljayA9IGZpbml0ZU9yRGVmYXVsdChnZW5lcmF0aW9uT3B0aW9ucy5tYXgsIHZhbHVlKTtcbiAgdGlja3MucHVzaCh7dmFsdWU6IGxhc3RUaWNrLCBtYWpvcjogaXNNYWpvcihsYXN0VGljayksIHNpZ25pZmljYW5kfSk7XG5cbiAgcmV0dXJuIHRpY2tzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb2dhcml0aG1pY1NjYWxlIGV4dGVuZHMgU2NhbGUge1xuXG4gIHN0YXRpYyBpZCA9ICdsb2dhcml0aG1pYyc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgdGlja3M6IHtcbiAgICAgIGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLmxvZ2FyaXRobWljLFxuICAgICAgbWFqb3I6IHtcbiAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG5cbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnN0YXJ0ID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuZW5kID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IDA7XG4gIH1cblxuICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgY29uc3QgdmFsdWUgPSBMaW5lYXJTY2FsZUJhc2UucHJvdG90eXBlLnBhcnNlLmFwcGx5KHRoaXMsIFtyYXcsIGluZGV4XSk7XG4gICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICB0aGlzLl96ZXJvID0gdHJ1ZTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSkgJiYgdmFsdWUgPiAwID8gdmFsdWUgOiBudWxsO1xuICB9XG5cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcy5nZXRNaW5NYXgodHJ1ZSk7XG5cbiAgICB0aGlzLm1pbiA9IGlzRmluaXRlKG1pbikgPyBNYXRoLm1heCgwLCBtaW4pIDogbnVsbDtcbiAgICB0aGlzLm1heCA9IGlzRmluaXRlKG1heCkgPyBNYXRoLm1heCgwLCBtYXgpIDogbnVsbDtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuYmVnaW5BdFplcm8pIHtcbiAgICAgIHRoaXMuX3plcm8gPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGlmIGRhdGEgaGFzIGAwYCBpbiBpdCBvciBgYmVnaW5BdFplcm9gIGlzIHRydWUsIG1pbiAobm9uIHplcm8pIHZhbHVlIGlzIGF0IGJvdHRvbVxuICAgIC8vIG9mIHNjYWxlLCBhbmQgaXQgZG9lcyBub3QgZXF1YWwgc3VnZ2VzdGVkTWluLCBsb3dlciB0aGUgbWluIGJvdW5kIGJ5IG9uZSBleHAuXG4gICAgaWYgKHRoaXMuX3plcm8gJiYgdGhpcy5taW4gIT09IHRoaXMuX3N1Z2dlc3RlZE1pbiAmJiAhaXNGaW5pdGUodGhpcy5fdXNlck1pbikpIHtcbiAgICAgIHRoaXMubWluID0gbWluID09PSBjaGFuZ2VFeHBvbmVudCh0aGlzLm1pbiwgMCkgPyBjaGFuZ2VFeHBvbmVudCh0aGlzLm1pbiwgLTEpIDogY2hhbmdlRXhwb25lbnQodGhpcy5taW4sIDApO1xuICAgIH1cblxuICAgIHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuICB9XG5cbiAgaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpIHtcbiAgICBjb25zdCB7bWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBsZXQgbWluID0gdGhpcy5taW47XG4gICAgbGV0IG1heCA9IHRoaXMubWF4O1xuXG4gICAgY29uc3Qgc2V0TWluID0gdiA9PiAobWluID0gbWluRGVmaW5lZCA/IG1pbiA6IHYpO1xuICAgIGNvbnN0IHNldE1heCA9IHYgPT4gKG1heCA9IG1heERlZmluZWQgPyBtYXggOiB2KTtcblxuICAgIGlmIChtaW4gPT09IG1heCkge1xuICAgICAgaWYgKG1pbiA8PSAwKSB7IC8vIGluY2x1ZGVzIG51bGxcbiAgICAgICAgc2V0TWluKDEpO1xuICAgICAgICBzZXRNYXgoMTApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0TWluKGNoYW5nZUV4cG9uZW50KG1pbiwgLTEpKTtcbiAgICAgICAgc2V0TWF4KGNoYW5nZUV4cG9uZW50KG1heCwgKzEpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1pbiA8PSAwKSB7XG4gICAgICBzZXRNaW4oY2hhbmdlRXhwb25lbnQobWF4LCAtMSkpO1xuICAgIH1cbiAgICBpZiAobWF4IDw9IDApIHtcblxuICAgICAgc2V0TWF4KGNoYW5nZUV4cG9uZW50KG1pbiwgKzEpKTtcbiAgICB9XG5cbiAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICB0aGlzLm1heCA9IG1heDtcbiAgfVxuXG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcblxuICAgIGNvbnN0IGdlbmVyYXRpb25PcHRpb25zID0ge1xuICAgICAgbWluOiB0aGlzLl91c2VyTWluLFxuICAgICAgbWF4OiB0aGlzLl91c2VyTWF4XG4gICAgfTtcbiAgICBjb25zdCB0aWNrcyA9IGdlbmVyYXRlVGlja3MoZ2VuZXJhdGlvbk9wdGlvbnMsIHRoaXMpO1xuXG4gICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgbmVlZCB0byB1cGRhdGUgb3VyIG1heCBhbmQgbWluIGdpdmVuIHRoZSB0aWNrIHZhbHVlcyxcbiAgICAvLyBzaW5jZSB3ZSBwcm9iYWJseSBoYXZlIGV4cGFuZGVkIHRoZSByYW5nZSBvZiB0aGUgc2NhbGVcbiAgICBpZiAob3B0cy5ib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICAgIF9zZXRNaW5BbmRNYXhCeUtleSh0aWNrcywgdGhpcywgJ3ZhbHVlJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMucmV2ZXJzZSkge1xuICAgICAgdGlja3MucmV2ZXJzZSgpO1xuXG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5tYXg7XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWluO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5taW47XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWF4O1xuICAgIH1cblxuICAgIHJldHVybiB0aWNrcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICA/ICcwJ1xuICAgICAgOiBmb3JtYXROdW1iZXIodmFsdWUsIHRoaXMuY2hhcnQub3B0aW9ucy5sb2NhbGUsIHRoaXMub3B0aW9ucy50aWNrcy5mb3JtYXQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMubWluO1xuXG4gICAgc3VwZXIuY29uZmlndXJlKCk7XG5cbiAgICB0aGlzLl9zdGFydFZhbHVlID0gbG9nMTAoc3RhcnQpO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSBsb2cxMCh0aGlzLm1heCkgLSBsb2cxMChzdGFydCk7XG4gIH1cblxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IDApIHtcbiAgICAgIHZhbHVlID0gdGhpcy5taW47XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCBpc05hTih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCh2YWx1ZSA9PT0gdGhpcy5taW5cbiAgICAgID8gMFxuICAgICAgOiAobG9nMTAodmFsdWUpIC0gdGhpcy5fc3RhcnRWYWx1ZSkgLyB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuXG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBkZWNpbWFsID0gdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpO1xuICAgIHJldHVybiBNYXRoLnBvdygxMCwgdGhpcy5fc3RhcnRWYWx1ZSArIGRlY2ltYWwgKiB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxufVxuIiwgImltcG9ydCBkZWZhdWx0cyBmcm9tICcuLi9jb3JlL2NvcmUuZGVmYXVsdHMuanMnO1xuaW1wb3J0IHtfbG9uZ2VzdFRleHQsIGFkZFJvdW5kZWRSZWN0UGF0aCwgcmVuZGVyVGV4dCwgX2lzUG9pbnRJbkFyZWF9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHtIQUxGX1BJLCBUQVUsIHRvRGVncmVlcywgdG9SYWRpYW5zLCBfbm9ybWFsaXplQW5nbGUsIFBJfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQgTGluZWFyU2NhbGVCYXNlIGZyb20gJy4vc2NhbGUubGluZWFyYmFzZS5qcyc7XG5pbXBvcnQgVGlja3MgZnJvbSAnLi4vY29yZS9jb3JlLnRpY2tzLmpzJztcbmltcG9ydCB7dmFsdWVPckRlZmF1bHQsIGlzQXJyYXksIGlzRmluaXRlLCBjYWxsYmFjayBhcyBjYWxsQ2FsbGJhY2ssIGlzTnVsbE9yVW5kZWZ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7Y3JlYXRlQ29udGV4dCwgdG9Gb250LCB0b1BhZGRpbmcsIHRvVFJCTENvcm5lcnN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLmpzJztcblxuZnVuY3Rpb24gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KG9wdHMpIHtcbiAgY29uc3QgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuXG4gIGlmICh0aWNrT3B0cy5kaXNwbGF5ICYmIG9wdHMuZGlzcGxheSkge1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcodGlja09wdHMuYmFja2Ryb3BQYWRkaW5nKTtcbiAgICByZXR1cm4gdmFsdWVPckRlZmF1bHQodGlja09wdHMuZm9udCAmJiB0aWNrT3B0cy5mb250LnNpemUsIGRlZmF1bHRzLmZvbnQuc2l6ZSkgKyBwYWRkaW5nLmhlaWdodDtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gbWVhc3VyZUxhYmVsU2l6ZShjdHgsIGZvbnQsIGxhYmVsKSB7XG4gIGxhYmVsID0gaXNBcnJheShsYWJlbCkgPyBsYWJlbCA6IFtsYWJlbF07XG4gIHJldHVybiB7XG4gICAgdzogX2xvbmdlc3RUZXh0KGN0eCwgZm9udC5zdHJpbmcsIGxhYmVsKSxcbiAgICBoOiBsYWJlbC5sZW5ndGggKiBmb250LmxpbmVIZWlnaHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb3MsIHNpemUsIG1pbiwgbWF4KSB7XG4gIGlmIChhbmdsZSA9PT0gbWluIHx8IGFuZ2xlID09PSBtYXgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHBvcyAtIChzaXplIC8gMiksXG4gICAgICBlbmQ6IHBvcyArIChzaXplIC8gMilcbiAgICB9O1xuICB9IGVsc2UgaWYgKGFuZ2xlIDwgbWluIHx8IGFuZ2xlID4gbWF4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBwb3MgLSBzaXplLFxuICAgICAgZW5kOiBwb3NcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogcG9zLFxuICAgIGVuZDogcG9zICsgc2l6ZVxuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBmaXQgYSByYWRpYWwgbGluZWFyIHNjYWxlIHdpdGggcG9pbnQgbGFiZWxzXG4gKi9cbmZ1bmN0aW9uIGZpdFdpdGhQb2ludExhYmVscyhzY2FsZSkge1xuXG4gIC8vIFJpZ2h0LCB0aGlzIGlzIHJlYWxseSBjb25mdXNpbmcgYW5kIHRoZXJlIGlzIGEgbG90IG9mIG1hdGhzIGdvaW5nIG9uIGhlcmVcbiAgLy8gVGhlIGdpc3Qgb2YgdGhlIHByb2JsZW0gaXMgaGVyZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbm5uaWNrLzY5NmNjOWM1NWY0YjBiZWI4ZmU5XG4gIC8vXG4gIC8vIFJlYWN0aW9uOiBodHRwczovL2RsLmRyb3Bib3h1c2VyY29udGVudC5jb20vdS8zNDYwMTM2My90b29tdWNoc2NpZW5jZS5naWZcbiAgLy9cbiAgLy8gU29sdXRpb246XG4gIC8vXG4gIC8vIFdlIGFzc3VtZSB0aGUgcmFkaXVzIG9mIHRoZSBwb2x5Z29uIGlzIGhhbGYgdGhlIHNpemUgb2YgdGhlIGNhbnZhcyBhdCBmaXJzdFxuICAvLyBhdCBlYWNoIGluZGV4IHdlIGNoZWNrIGlmIHRoZSB0ZXh0IG92ZXJsYXBzLlxuICAvL1xuICAvLyBXaGVyZSBpdCBkb2VzLCB3ZSBzdG9yZSB0aGF0IGFuZ2xlIGFuZCB0aGF0IGluZGV4LlxuICAvL1xuICAvLyBBZnRlciBmaW5kaW5nIHRoZSBsYXJnZXN0IGluZGV4IGFuZCBhbmdsZSB3ZSBjYWxjdWxhdGUgaG93IG11Y2ggd2UgbmVlZCB0byByZW1vdmVcbiAgLy8gZnJvbSB0aGUgc2hhcGUgcmFkaXVzIHRvIG1vdmUgdGhlIHBvaW50IGlud2FyZHMgYnkgdGhhdCB4LlxuICAvL1xuICAvLyBXZSBhdmVyYWdlIHRoZSBsZWZ0IGFuZCByaWdodCBkaXN0YW5jZXMgdG8gZ2V0IHRoZSBtYXhpbXVtIHNoYXBlIHJhZGl1cyB0aGF0IGNhbiBmaXQgaW4gdGhlIGJveFxuICAvLyBhbG9uZyB3aXRoIGxhYmVscy5cbiAgLy9cbiAgLy8gT25jZSB3ZSBoYXZlIHRoYXQsIHdlIGNhbiBmaW5kIHRoZSBjZW50cmUgcG9pbnQgZm9yIHRoZSBjaGFydCwgYnkgdGFraW5nIHRoZSB4IHRleHQgcHJvdHJ1c2lvblxuICAvLyBvbiBlYWNoIHNpZGUsIHJlbW92aW5nIHRoYXQgZnJvbSB0aGUgc2l6ZSwgaGFsdmluZyBpdCBhbmQgYWRkaW5nIHRoZSBsZWZ0IHggcHJvdHJ1c2lvbiB3aWR0aC5cbiAgLy9cbiAgLy8gVGhpcyB3aWxsIG1lYW4gd2UgaGF2ZSBhIHNoYXBlIGZpdHRlZCB0byB0aGUgY2FudmFzLCBhcyBsYXJnZSBhcyBpdCBjYW4gYmUgd2l0aCB0aGUgbGFiZWxzXG4gIC8vIGFuZCBwb3NpdGlvbiBpdCBpbiB0aGUgbW9zdCBzcGFjZSBlZmZpY2llbnQgbWFubmVyXG4gIC8vXG4gIC8vIGh0dHBzOi8vZGwuZHJvcGJveHVzZXJjb250ZW50LmNvbS91LzM0NjAxMzYzL3llYWhzY2llbmNlLmdpZlxuXG4gIC8vIEdldCBtYXhpbXVtIHJhZGl1cyBvZiB0aGUgcG9seWdvbi4gRWl0aGVyIGhhbGYgdGhlIGhlaWdodCAobWludXMgdGhlIHRleHQgd2lkdGgpIG9yIGhhbGYgdGhlIHdpZHRoLlxuICAvLyBVc2UgdGhpcyB0byBjYWxjdWxhdGUgdGhlIG9mZnNldCArIGNoYW5nZS4gLSBNYWtlIHN1cmUgTC9SIHByb3RydXNpb24gaXMgYXQgbGVhc3QgMCB0byBzdG9wIGlzc3VlcyB3aXRoIGNlbnRyZSBwb2ludHNcbiAgY29uc3Qgb3JpZyA9IHtcbiAgICBsOiBzY2FsZS5sZWZ0ICsgc2NhbGUuX3BhZGRpbmcubGVmdCxcbiAgICByOiBzY2FsZS5yaWdodCAtIHNjYWxlLl9wYWRkaW5nLnJpZ2h0LFxuICAgIHQ6IHNjYWxlLnRvcCArIHNjYWxlLl9wYWRkaW5nLnRvcCxcbiAgICBiOiBzY2FsZS5ib3R0b20gLSBzY2FsZS5fcGFkZGluZy5ib3R0b21cbiAgfTtcbiAgY29uc3QgbGltaXRzID0gT2JqZWN0LmFzc2lnbih7fSwgb3JpZyk7XG4gIGNvbnN0IGxhYmVsU2l6ZXMgPSBbXTtcbiAgY29uc3QgcGFkZGluZyA9IFtdO1xuICBjb25zdCB2YWx1ZUNvdW50ID0gc2NhbGUuX3BvaW50TGFiZWxzLmxlbmd0aDtcbiAgY29uc3QgcG9pbnRMYWJlbE9wdHMgPSBzY2FsZS5vcHRpb25zLnBvaW50TGFiZWxzO1xuICBjb25zdCBhZGRpdGlvbmFsQW5nbGUgPSBwb2ludExhYmVsT3B0cy5jZW50ZXJQb2ludExhYmVscyA/IFBJIC8gdmFsdWVDb3VudCA6IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZUNvdW50OyBpKyspIHtcbiAgICBjb25zdCBvcHRzID0gcG9pbnRMYWJlbE9wdHMuc2V0Q29udGV4dChzY2FsZS5nZXRQb2ludExhYmVsQ29udGV4dChpKSk7XG4gICAgcGFkZGluZ1tpXSA9IG9wdHMucGFkZGluZztcbiAgICBjb25zdCBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCBzY2FsZS5kcmF3aW5nQXJlYSArIHBhZGRpbmdbaV0sIGFkZGl0aW9uYWxBbmdsZSk7XG4gICAgY29uc3QgcGxGb250ID0gdG9Gb250KG9wdHMuZm9udCk7XG4gICAgY29uc3QgdGV4dFNpemUgPSBtZWFzdXJlTGFiZWxTaXplKHNjYWxlLmN0eCwgcGxGb250LCBzY2FsZS5fcG9pbnRMYWJlbHNbaV0pO1xuICAgIGxhYmVsU2l6ZXNbaV0gPSB0ZXh0U2l6ZTtcblxuICAgIGNvbnN0IGFuZ2xlUmFkaWFucyA9IF9ub3JtYWxpemVBbmdsZShzY2FsZS5nZXRJbmRleEFuZ2xlKGkpICsgYWRkaXRpb25hbEFuZ2xlKTtcbiAgICBjb25zdCBhbmdsZSA9IE1hdGgucm91bmQodG9EZWdyZWVzKGFuZ2xlUmFkaWFucykpO1xuICAgIGNvbnN0IGhMaW1pdHMgPSBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvaW50UG9zaXRpb24ueCwgdGV4dFNpemUudywgMCwgMTgwKTtcbiAgICBjb25zdCB2TGltaXRzID0gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb2ludFBvc2l0aW9uLnksIHRleHRTaXplLmgsIDkwLCAyNzApO1xuICAgIHVwZGF0ZUxpbWl0cyhsaW1pdHMsIG9yaWcsIGFuZ2xlUmFkaWFucywgaExpbWl0cywgdkxpbWl0cyk7XG4gIH1cblxuICBzY2FsZS5zZXRDZW50ZXJQb2ludChcbiAgICBvcmlnLmwgLSBsaW1pdHMubCxcbiAgICBsaW1pdHMuciAtIG9yaWcucixcbiAgICBvcmlnLnQgLSBsaW1pdHMudCxcbiAgICBsaW1pdHMuYiAtIG9yaWcuYlxuICApO1xuXG4gIC8vIE5vdyB0aGF0IHRleHQgc2l6ZSBpcyBkZXRlcm1pbmVkLCBjb21wdXRlIHRoZSBmdWxsIHBvc2l0aW9uc1xuICBzY2FsZS5fcG9pbnRMYWJlbEl0ZW1zID0gYnVpbGRQb2ludExhYmVsSXRlbXMoc2NhbGUsIGxhYmVsU2l6ZXMsIHBhZGRpbmcpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVMaW1pdHMobGltaXRzLCBvcmlnLCBhbmdsZSwgaExpbWl0cywgdkxpbWl0cykge1xuICBjb25zdCBzaW4gPSBNYXRoLmFicyhNYXRoLnNpbihhbmdsZSkpO1xuICBjb25zdCBjb3MgPSBNYXRoLmFicyhNYXRoLmNvcyhhbmdsZSkpO1xuICBsZXQgeCA9IDA7XG4gIGxldCB5ID0gMDtcbiAgaWYgKGhMaW1pdHMuc3RhcnQgPCBvcmlnLmwpIHtcbiAgICB4ID0gKG9yaWcubCAtIGhMaW1pdHMuc3RhcnQpIC8gc2luO1xuICAgIGxpbWl0cy5sID0gTWF0aC5taW4obGltaXRzLmwsIG9yaWcubCAtIHgpO1xuICB9IGVsc2UgaWYgKGhMaW1pdHMuZW5kID4gb3JpZy5yKSB7XG4gICAgeCA9IChoTGltaXRzLmVuZCAtIG9yaWcucikgLyBzaW47XG4gICAgbGltaXRzLnIgPSBNYXRoLm1heChsaW1pdHMuciwgb3JpZy5yICsgeCk7XG4gIH1cbiAgaWYgKHZMaW1pdHMuc3RhcnQgPCBvcmlnLnQpIHtcbiAgICB5ID0gKG9yaWcudCAtIHZMaW1pdHMuc3RhcnQpIC8gY29zO1xuICAgIGxpbWl0cy50ID0gTWF0aC5taW4obGltaXRzLnQsIG9yaWcudCAtIHkpO1xuICB9IGVsc2UgaWYgKHZMaW1pdHMuZW5kID4gb3JpZy5iKSB7XG4gICAgeSA9ICh2TGltaXRzLmVuZCAtIG9yaWcuYikgLyBjb3M7XG4gICAgbGltaXRzLmIgPSBNYXRoLm1heChsaW1pdHMuYiwgb3JpZy5iICsgeSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlUG9pbnRMYWJlbEl0ZW0oc2NhbGUsIGluZGV4LCBpdGVtT3B0cykge1xuICBjb25zdCBvdXRlckRpc3RhbmNlID0gc2NhbGUuZHJhd2luZ0FyZWE7XG4gIGNvbnN0IHtleHRyYSwgYWRkaXRpb25hbEFuZ2xlLCBwYWRkaW5nLCBzaXplfSA9IGl0ZW1PcHRzO1xuICBjb25zdCBwb2ludExhYmVsUG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGluZGV4LCBvdXRlckRpc3RhbmNlICsgZXh0cmEgKyBwYWRkaW5nLCBhZGRpdGlvbmFsQW5nbGUpO1xuICBjb25zdCBhbmdsZSA9IE1hdGgucm91bmQodG9EZWdyZWVzKF9ub3JtYWxpemVBbmdsZShwb2ludExhYmVsUG9zaXRpb24uYW5nbGUgKyBIQUxGX1BJKSkpO1xuICBjb25zdCB5ID0geUZvckFuZ2xlKHBvaW50TGFiZWxQb3NpdGlvbi55LCBzaXplLmgsIGFuZ2xlKTtcbiAgY29uc3QgdGV4dEFsaWduID0gZ2V0VGV4dEFsaWduRm9yQW5nbGUoYW5nbGUpO1xuICBjb25zdCBsZWZ0ID0gbGVmdEZvclRleHRBbGlnbihwb2ludExhYmVsUG9zaXRpb24ueCwgc2l6ZS53LCB0ZXh0QWxpZ24pO1xuICByZXR1cm4ge1xuICAgIC8vIGlmIHRvIGRyYXcgb3Igb3ZlcmxhcHBlZFxuICAgIHZpc2libGU6IHRydWUsXG5cbiAgICAvLyBUZXh0IHBvc2l0aW9uXG4gICAgeDogcG9pbnRMYWJlbFBvc2l0aW9uLngsXG4gICAgeSxcblxuICAgIC8vIFRleHQgcmVuZGVyaW5nIGRhdGFcbiAgICB0ZXh0QWxpZ24sXG5cbiAgICAvLyBCb3VuZGluZyBib3hcbiAgICBsZWZ0LFxuICAgIHRvcDogeSxcbiAgICByaWdodDogbGVmdCArIHNpemUudyxcbiAgICBib3R0b206IHkgKyBzaXplLmhcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNOb3RPdmVybGFwcGVkKGl0ZW0sIGFyZWEpIHtcbiAgaWYgKCFhcmVhKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3Qge2xlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbX0gPSBpdGVtO1xuICBjb25zdCBhcGV4ZXNJbkFyZWEgPSBfaXNQb2ludEluQXJlYSh7eDogbGVmdCwgeTogdG9wfSwgYXJlYSkgfHwgX2lzUG9pbnRJbkFyZWEoe3g6IGxlZnQsIHk6IGJvdHRvbX0sIGFyZWEpIHx8XG4gICAgX2lzUG9pbnRJbkFyZWEoe3g6IHJpZ2h0LCB5OiB0b3B9LCBhcmVhKSB8fCBfaXNQb2ludEluQXJlYSh7eDogcmlnaHQsIHk6IGJvdHRvbX0sIGFyZWEpO1xuICByZXR1cm4gIWFwZXhlc0luQXJlYTtcbn1cblxuZnVuY3Rpb24gYnVpbGRQb2ludExhYmVsSXRlbXMoc2NhbGUsIGxhYmVsU2l6ZXMsIHBhZGRpbmcpIHtcbiAgY29uc3QgaXRlbXMgPSBbXTtcbiAgY29uc3QgdmFsdWVDb3VudCA9IHNjYWxlLl9wb2ludExhYmVscy5sZW5ndGg7XG4gIGNvbnN0IG9wdHMgPSBzY2FsZS5vcHRpb25zO1xuICBjb25zdCB7Y2VudGVyUG9pbnRMYWJlbHMsIGRpc3BsYXl9ID0gb3B0cy5wb2ludExhYmVscztcbiAgY29uc3QgaXRlbU9wdHMgPSB7XG4gICAgZXh0cmE6IGdldFRpY2tCYWNrZHJvcEhlaWdodChvcHRzKSAvIDIsXG4gICAgYWRkaXRpb25hbEFuZ2xlOiBjZW50ZXJQb2ludExhYmVscyA/IFBJIC8gdmFsdWVDb3VudCA6IDBcbiAgfTtcbiAgbGV0IGFyZWE7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZUNvdW50OyBpKyspIHtcbiAgICBpdGVtT3B0cy5wYWRkaW5nID0gcGFkZGluZ1tpXTtcbiAgICBpdGVtT3B0cy5zaXplID0gbGFiZWxTaXplc1tpXTtcblxuICAgIGNvbnN0IGl0ZW0gPSBjcmVhdGVQb2ludExhYmVsSXRlbShzY2FsZSwgaSwgaXRlbU9wdHMpO1xuICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgaWYgKGRpc3BsYXkgPT09ICdhdXRvJykge1xuICAgICAgaXRlbS52aXNpYmxlID0gaXNOb3RPdmVybGFwcGVkKGl0ZW0sIGFyZWEpO1xuICAgICAgaWYgKGl0ZW0udmlzaWJsZSkge1xuICAgICAgICBhcmVhID0gaXRlbTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGl0ZW1zO1xufVxuXG5mdW5jdGlvbiBnZXRUZXh0QWxpZ25Gb3JBbmdsZShhbmdsZSkge1xuICBpZiAoYW5nbGUgPT09IDAgfHwgYW5nbGUgPT09IDE4MCkge1xuICAgIHJldHVybiAnY2VudGVyJztcbiAgfSBlbHNlIGlmIChhbmdsZSA8IDE4MCkge1xuICAgIHJldHVybiAnbGVmdCc7XG4gIH1cblxuICByZXR1cm4gJ3JpZ2h0Jztcbn1cblxuZnVuY3Rpb24gbGVmdEZvclRleHRBbGlnbih4LCB3LCBhbGlnbikge1xuICBpZiAoYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB4IC09IHc7XG4gIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgeCAtPSAodyAvIDIpO1xuICB9XG4gIHJldHVybiB4O1xufVxuXG5mdW5jdGlvbiB5Rm9yQW5nbGUoeSwgaCwgYW5nbGUpIHtcbiAgaWYgKGFuZ2xlID09PSA5MCB8fCBhbmdsZSA9PT0gMjcwKSB7XG4gICAgeSAtPSAoaCAvIDIpO1xuICB9IGVsc2UgaWYgKGFuZ2xlID4gMjcwIHx8IGFuZ2xlIDwgOTApIHtcbiAgICB5IC09IGg7XG4gIH1cbiAgcmV0dXJuIHk7XG59XG5cbmZ1bmN0aW9uIGRyYXdQb2ludExhYmVsQm94KGN0eCwgb3B0cywgaXRlbSkge1xuICBjb25zdCB7bGVmdCwgdG9wLCByaWdodCwgYm90dG9tfSA9IGl0ZW07XG4gIGNvbnN0IHtiYWNrZHJvcENvbG9yfSA9IG9wdHM7XG5cbiAgaWYgKCFpc051bGxPclVuZGVmKGJhY2tkcm9wQ29sb3IpKSB7XG4gICAgY29uc3QgYm9yZGVyUmFkaXVzID0gdG9UUkJMQ29ybmVycyhvcHRzLmJvcmRlclJhZGl1cyk7XG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRzLmJhY2tkcm9wUGFkZGluZyk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tkcm9wQ29sb3I7XG5cbiAgICBjb25zdCBiYWNrZHJvcExlZnQgPSBsZWZ0IC0gcGFkZGluZy5sZWZ0O1xuICAgIGNvbnN0IGJhY2tkcm9wVG9wID0gdG9wIC0gcGFkZGluZy50b3A7XG4gICAgY29uc3QgYmFja2Ryb3BXaWR0aCA9IHJpZ2h0IC0gbGVmdCArIHBhZGRpbmcud2lkdGg7XG4gICAgY29uc3QgYmFja2Ryb3BIZWlnaHQgPSBib3R0b20gLSB0b3AgKyBwYWRkaW5nLmhlaWdodDtcblxuICAgIGlmIChPYmplY3QudmFsdWVzKGJvcmRlclJhZGl1cykuc29tZSh2ID0+IHYgIT09IDApKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgIHg6IGJhY2tkcm9wTGVmdCxcbiAgICAgICAgeTogYmFja2Ryb3BUb3AsXG4gICAgICAgIHc6IGJhY2tkcm9wV2lkdGgsXG4gICAgICAgIGg6IGJhY2tkcm9wSGVpZ2h0LFxuICAgICAgICByYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICAgIH0pO1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmZpbGxSZWN0KGJhY2tkcm9wTGVmdCwgYmFja2Ryb3BUb3AsIGJhY2tkcm9wV2lkdGgsIGJhY2tkcm9wSGVpZ2h0KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhd1BvaW50TGFiZWxzKHNjYWxlLCBsYWJlbENvdW50KSB7XG4gIGNvbnN0IHtjdHgsIG9wdGlvbnM6IHtwb2ludExhYmVsc319ID0gc2NhbGU7XG5cbiAgZm9yIChsZXQgaSA9IGxhYmVsQ291bnQgLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IGl0ZW0gPSBzY2FsZS5fcG9pbnRMYWJlbEl0ZW1zW2ldO1xuICAgIGlmICghaXRlbS52aXNpYmxlKSB7XG4gICAgICAvLyBvdmVybGFwcGluZ1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gcG9pbnRMYWJlbHMuc2V0Q29udGV4dChzY2FsZS5nZXRQb2ludExhYmVsQ29udGV4dChpKSk7XG4gICAgZHJhd1BvaW50TGFiZWxCb3goY3R4LCBvcHRzQXRJbmRleCwgaXRlbSk7XG4gICAgY29uc3QgcGxGb250ID0gdG9Gb250KG9wdHNBdEluZGV4LmZvbnQpO1xuICAgIGNvbnN0IHt4LCB5LCB0ZXh0QWxpZ259ID0gaXRlbTtcblxuICAgIHJlbmRlclRleHQoXG4gICAgICBjdHgsXG4gICAgICBzY2FsZS5fcG9pbnRMYWJlbHNbaV0sXG4gICAgICB4LFxuICAgICAgeSArIChwbEZvbnQubGluZUhlaWdodCAvIDIpLFxuICAgICAgcGxGb250LFxuICAgICAge1xuICAgICAgICBjb2xvcjogb3B0c0F0SW5kZXguY29sb3IsXG4gICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnXG4gICAgICB9XG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXRoUmFkaXVzTGluZShzY2FsZSwgcmFkaXVzLCBjaXJjdWxhciwgbGFiZWxDb3VudCkge1xuICBjb25zdCB7Y3R4fSA9IHNjYWxlO1xuICBpZiAoY2lyY3VsYXIpIHtcbiAgICAvLyBEcmF3IGNpcmN1bGFyIGFyY3MgYmV0d2VlbiB0aGUgcG9pbnRzXG4gICAgY3R4LmFyYyhzY2FsZS54Q2VudGVyLCBzY2FsZS55Q2VudGVyLCByYWRpdXMsIDAsIFRBVSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRHJhdyBzdHJhaWdodCBsaW5lcyBjb25uZWN0aW5nIGVhY2ggaW5kZXhcbiAgICBsZXQgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oMCwgcmFkaXVzKTtcbiAgICBjdHgubW92ZVRvKHBvaW50UG9zaXRpb24ueCwgcG9pbnRQb3NpdGlvbi55KTtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGFiZWxDb3VudDsgaSsrKSB7XG4gICAgICBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCByYWRpdXMpO1xuICAgICAgY3R4LmxpbmVUbyhwb2ludFBvc2l0aW9uLngsIHBvaW50UG9zaXRpb24ueSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdSYWRpdXNMaW5lKHNjYWxlLCBncmlkTGluZU9wdHMsIHJhZGl1cywgbGFiZWxDb3VudCwgYm9yZGVyT3B0cykge1xuICBjb25zdCBjdHggPSBzY2FsZS5jdHg7XG4gIGNvbnN0IGNpcmN1bGFyID0gZ3JpZExpbmVPcHRzLmNpcmN1bGFyO1xuXG4gIGNvbnN0IHtjb2xvciwgbGluZVdpZHRofSA9IGdyaWRMaW5lT3B0cztcblxuICBpZiAoKCFjaXJjdWxhciAmJiAhbGFiZWxDb3VudCkgfHwgIWNvbG9yIHx8ICFsaW5lV2lkdGggfHwgcmFkaXVzIDwgMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICBjdHguc2V0TGluZURhc2goYm9yZGVyT3B0cy5kYXNoKTtcbiAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gYm9yZGVyT3B0cy5kYXNoT2Zmc2V0O1xuXG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgcGF0aFJhZGl1c0xpbmUoc2NhbGUsIHJhZGl1cywgY2lyY3VsYXIsIGxhYmVsQ291bnQpO1xuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5zdHJva2UoKTtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUG9pbnRMYWJlbENvbnRleHQocGFyZW50LCBpbmRleCwgbGFiZWwpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgbGFiZWwsXG4gICAgaW5kZXgsXG4gICAgdHlwZTogJ3BvaW50TGFiZWwnXG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSYWRpYWxMaW5lYXJTY2FsZSBleHRlbmRzIExpbmVhclNjYWxlQmFzZSB7XG5cbiAgc3RhdGljIGlkID0gJ3JhZGlhbExpbmVhcic7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgZGlzcGxheTogdHJ1ZSxcblxuICAgIC8vIEJvb2xlYW4gLSBXaGV0aGVyIHRvIGFuaW1hdGUgc2NhbGluZyB0aGUgY2hhcnQgZnJvbSB0aGUgY2VudHJlXG4gICAgYW5pbWF0ZTogdHJ1ZSxcbiAgICBwb3NpdGlvbjogJ2NoYXJ0QXJlYScsXG5cbiAgICBhbmdsZUxpbmVzOiB7XG4gICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgbGluZVdpZHRoOiAxLFxuICAgICAgYm9yZGVyRGFzaDogW10sXG4gICAgICBib3JkZXJEYXNoT2Zmc2V0OiAwLjBcbiAgICB9LFxuXG4gICAgZ3JpZDoge1xuICAgICAgY2lyY3VsYXI6IGZhbHNlXG4gICAgfSxcblxuICAgIHN0YXJ0QW5nbGU6IDAsXG5cbiAgICAvLyBsYWJlbCBzZXR0aW5nc1xuICAgIHRpY2tzOiB7XG4gICAgICAvLyBCb29sZWFuIC0gU2hvdyBhIGJhY2tkcm9wIHRvIHRoZSBzY2FsZSBsYWJlbFxuICAgICAgc2hvd0xhYmVsQmFja2Ryb3A6IHRydWUsXG5cbiAgICAgIGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLm51bWVyaWNcbiAgICB9LFxuXG4gICAgcG9pbnRMYWJlbHM6IHtcbiAgICAgIGJhY2tkcm9wQ29sb3I6IHVuZGVmaW5lZCxcblxuICAgICAgLy8gTnVtYmVyIC0gVGhlIGJhY2tkcm9wIHBhZGRpbmcgYWJvdmUgJiBiZWxvdyB0aGUgbGFiZWwgaW4gcGl4ZWxzXG4gICAgICBiYWNrZHJvcFBhZGRpbmc6IDIsXG5cbiAgICAgIC8vIEJvb2xlYW4gLSBpZiB0cnVlLCBzaG93IHBvaW50IGxhYmVsc1xuICAgICAgZGlzcGxheTogdHJ1ZSxcblxuICAgICAgLy8gTnVtYmVyIC0gUG9pbnQgbGFiZWwgZm9udCBzaXplIGluIHBpeGVsc1xuICAgICAgZm9udDoge1xuICAgICAgICBzaXplOiAxMFxuICAgICAgfSxcblxuICAgICAgLy8gRnVuY3Rpb24gLSBVc2VkIHRvIGNvbnZlcnQgcG9pbnQgbGFiZWxzXG4gICAgICBjYWxsYmFjayhsYWJlbCkge1xuICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgICB9LFxuXG4gICAgICAvLyBOdW1iZXIgLSBBZGRpdGlvbmwgcGFkZGluZyBiZXR3ZWVuIHNjYWxlIGFuZCBwb2ludExhYmVsXG4gICAgICBwYWRkaW5nOiA1LFxuXG4gICAgICAvLyBCb29sZWFuIC0gaWYgdHJ1ZSwgY2VudGVyIHBvaW50IGxhYmVscyB0byBzbGljZXMgaW4gcG9sYXIgY2hhcnRcbiAgICAgIGNlbnRlclBvaW50TGFiZWxzOiBmYWxzZVxuICAgIH1cbiAgfTtcblxuICBzdGF0aWMgZGVmYXVsdFJvdXRlcyA9IHtcbiAgICAnYW5nbGVMaW5lcy5jb2xvcic6ICdib3JkZXJDb2xvcicsXG4gICAgJ3BvaW50TGFiZWxzLmNvbG9yJzogJ2NvbG9yJyxcbiAgICAndGlja3MuY29sb3InOiAnY29sb3InXG4gIH07XG5cbiAgc3RhdGljIGRlc2NyaXB0b3JzID0ge1xuICAgIGFuZ2xlTGluZXM6IHtcbiAgICAgIF9mYWxsYmFjazogJ2dyaWQnXG4gICAgfVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG5cbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnhDZW50ZXIgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy55Q2VudGVyID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuZHJhd2luZ0FyZWEgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtzdHJpbmdbXX0gKi9cbiAgICB0aGlzLl9wb2ludExhYmVscyA9IFtdO1xuICAgIHRoaXMuX3BvaW50TGFiZWxJdGVtcyA9IFtdO1xuICB9XG5cbiAgc2V0RGltZW5zaW9ucygpIHtcbiAgICAvLyBTZXQgdGhlIHVuY29uc3RyYWluZWQgZGltZW5zaW9uIGJlZm9yZSBsYWJlbCByb3RhdGlvblxuICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLl9wYWRkaW5nID0gdG9QYWRkaW5nKGdldFRpY2tCYWNrZHJvcEhlaWdodCh0aGlzLm9wdGlvbnMpIC8gMik7XG4gICAgY29uc3QgdyA9IHRoaXMud2lkdGggPSB0aGlzLm1heFdpZHRoIC0gcGFkZGluZy53aWR0aDtcbiAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQgPSB0aGlzLm1heEhlaWdodCAtIHBhZGRpbmcuaGVpZ2h0O1xuICAgIHRoaXMueENlbnRlciA9IE1hdGguZmxvb3IodGhpcy5sZWZ0ICsgdyAvIDIgKyBwYWRkaW5nLmxlZnQpO1xuICAgIHRoaXMueUNlbnRlciA9IE1hdGguZmxvb3IodGhpcy50b3AgKyBoIC8gMiArIHBhZGRpbmcudG9wKTtcbiAgICB0aGlzLmRyYXdpbmdBcmVhID0gTWF0aC5mbG9vcihNYXRoLm1pbih3LCBoKSAvIDIpO1xuICB9XG5cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcy5nZXRNaW5NYXgoZmFsc2UpO1xuXG4gICAgdGhpcy5taW4gPSBpc0Zpbml0ZShtaW4pICYmICFpc05hTihtaW4pID8gbWluIDogMDtcbiAgICB0aGlzLm1heCA9IGlzRmluaXRlKG1heCkgJiYgIWlzTmFOKG1heCkgPyBtYXggOiAwO1xuXG4gICAgLy8gQ29tbW9uIGJhc2UgaW1wbGVtZW50YXRpb24gdG8gaGFuZGxlIG1pbiwgbWF4LCBiZWdpbkF0WmVyb1xuICAgIHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpY2tzIGJhc2VkIG9uIHRoZSBzY2FsZSBkaW1lbnNpb25cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgY29tcHV0ZVRpY2tMaW1pdCgpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuZHJhd2luZ0FyZWEgLyBnZXRUaWNrQmFja2Ryb3BIZWlnaHQodGhpcy5vcHRpb25zKSk7XG4gIH1cblxuICBnZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpIHtcbiAgICBMaW5lYXJTY2FsZUJhc2UucHJvdG90eXBlLmdlbmVyYXRlVGlja0xhYmVscy5jYWxsKHRoaXMsIHRpY2tzKTtcblxuICAgIC8vIFBvaW50IGxhYmVsc1xuICAgIHRoaXMuX3BvaW50TGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKVxuICAgICAgLm1hcCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gY2FsbENhbGxiYWNrKHRoaXMub3B0aW9ucy5wb2ludExhYmVscy5jYWxsYmFjaywgW3ZhbHVlLCBpbmRleF0sIHRoaXMpO1xuICAgICAgICByZXR1cm4gbGFiZWwgfHwgbGFiZWwgPT09IDAgPyBsYWJlbCA6ICcnO1xuICAgICAgfSlcbiAgICAgIC5maWx0ZXIoKHYsIGkpID0+IHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkpO1xuICB9XG5cbiAgZml0KCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBpZiAob3B0cy5kaXNwbGF5ICYmIG9wdHMucG9pbnRMYWJlbHMuZGlzcGxheSkge1xuICAgICAgZml0V2l0aFBvaW50TGFiZWxzKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldENlbnRlclBvaW50KDAsIDAsIDAsIDApO1xuICAgIH1cbiAgfVxuXG4gIHNldENlbnRlclBvaW50KGxlZnRNb3ZlbWVudCwgcmlnaHRNb3ZlbWVudCwgdG9wTW92ZW1lbnQsIGJvdHRvbU1vdmVtZW50KSB7XG4gICAgdGhpcy54Q2VudGVyICs9IE1hdGguZmxvb3IoKGxlZnRNb3ZlbWVudCAtIHJpZ2h0TW92ZW1lbnQpIC8gMik7XG4gICAgdGhpcy55Q2VudGVyICs9IE1hdGguZmxvb3IoKHRvcE1vdmVtZW50IC0gYm90dG9tTW92ZW1lbnQpIC8gMik7XG4gICAgdGhpcy5kcmF3aW5nQXJlYSAtPSBNYXRoLm1pbih0aGlzLmRyYXdpbmdBcmVhIC8gMiwgTWF0aC5tYXgobGVmdE1vdmVtZW50LCByaWdodE1vdmVtZW50LCB0b3BNb3ZlbWVudCwgYm90dG9tTW92ZW1lbnQpKTtcbiAgfVxuXG4gIGdldEluZGV4QW5nbGUoaW5kZXgpIHtcbiAgICBjb25zdCBhbmdsZU11bHRpcGxpZXIgPSBUQVUgLyAodGhpcy5fcG9pbnRMYWJlbHMubGVuZ3RoIHx8IDEpO1xuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSB0aGlzLm9wdGlvbnMuc3RhcnRBbmdsZSB8fCAwO1xuXG4gICAgcmV0dXJuIF9ub3JtYWxpemVBbmdsZShpbmRleCAqIGFuZ2xlTXVsdGlwbGllciArIHRvUmFkaWFucyhzdGFydEFuZ2xlKSk7XG4gIH1cblxuICBnZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGlmIChpc051bGxPclVuZGVmKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG5cbiAgICAvLyBUYWtlIGludG8gYWNjb3VudCBoYWxmIGZvbnQgc2l6ZSArIHRoZSB5UGFkZGluZyBvZiB0aGUgdG9wIHZhbHVlXG4gICAgY29uc3Qgc2NhbGluZ0ZhY3RvciA9IHRoaXMuZHJhd2luZ0FyZWEgLyAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICByZXR1cm4gKHRoaXMubWF4IC0gdmFsdWUpICogc2NhbGluZ0ZhY3RvcjtcbiAgICB9XG4gICAgcmV0dXJuICh2YWx1ZSAtIHRoaXMubWluKSAqIHNjYWxpbmdGYWN0b3I7XG4gIH1cblxuICBnZXRWYWx1ZUZvckRpc3RhbmNlRnJvbUNlbnRlcihkaXN0YW5jZSkge1xuICAgIGlmIChpc051bGxPclVuZGVmKGRpc3RhbmNlKSkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG5cbiAgICBjb25zdCBzY2FsZWREaXN0YW5jZSA9IGRpc3RhbmNlIC8gKHRoaXMuZHJhd2luZ0FyZWEgLyAodGhpcy5tYXggLSB0aGlzLm1pbikpO1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMucmV2ZXJzZSA/IHRoaXMubWF4IC0gc2NhbGVkRGlzdGFuY2UgOiB0aGlzLm1pbiArIHNjYWxlZERpc3RhbmNlO1xuICB9XG5cbiAgZ2V0UG9pbnRMYWJlbENvbnRleHQoaW5kZXgpIHtcbiAgICBjb25zdCBwb2ludExhYmVscyA9IHRoaXMuX3BvaW50TGFiZWxzIHx8IFtdO1xuXG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCBwb2ludExhYmVscy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHBvaW50TGFiZWwgPSBwb2ludExhYmVsc1tpbmRleF07XG4gICAgICByZXR1cm4gY3JlYXRlUG9pbnRMYWJlbENvbnRleHQodGhpcy5nZXRDb250ZXh0KCksIGluZGV4LCBwb2ludExhYmVsKTtcbiAgICB9XG4gIH1cblxuICBnZXRQb2ludFBvc2l0aW9uKGluZGV4LCBkaXN0YW5jZUZyb21DZW50ZXIsIGFkZGl0aW9uYWxBbmdsZSA9IDApIHtcbiAgICBjb25zdCBhbmdsZSA9IHRoaXMuZ2V0SW5kZXhBbmdsZShpbmRleCkgLSBIQUxGX1BJICsgYWRkaXRpb25hbEFuZ2xlO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBNYXRoLmNvcyhhbmdsZSkgKiBkaXN0YW5jZUZyb21DZW50ZXIgKyB0aGlzLnhDZW50ZXIsXG4gICAgICB5OiBNYXRoLnNpbihhbmdsZSkgKiBkaXN0YW5jZUZyb21DZW50ZXIgKyB0aGlzLnlDZW50ZXIsXG4gICAgICBhbmdsZVxuICAgIH07XG4gIH1cblxuICBnZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaW5kZXgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnRQb3NpdGlvbihpbmRleCwgdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh2YWx1ZSkpO1xuICB9XG5cbiAgZ2V0QmFzZVBvc2l0aW9uKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGluZGV4IHx8IDAsIHRoaXMuZ2V0QmFzZVZhbHVlKCkpO1xuICB9XG5cbiAgZ2V0UG9pbnRMYWJlbFBvc2l0aW9uKGluZGV4KSB7XG4gICAgY29uc3Qge2xlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbX0gPSB0aGlzLl9wb2ludExhYmVsSXRlbXNbaW5kZXhdO1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0LFxuICAgICAgdG9wLFxuICAgICAgcmlnaHQsXG4gICAgICBib3R0b20sXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3QmFja2dyb3VuZCgpIHtcbiAgICBjb25zdCB7YmFja2dyb3VuZENvbG9yLCBncmlkOiB7Y2lyY3VsYXJ9fSA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBwYXRoUmFkaXVzTGluZSh0aGlzLCB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRoaXMuX2VuZFZhbHVlKSwgY2lyY3VsYXIsIHRoaXMuX3BvaW50TGFiZWxzLmxlbmd0aCk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdHcmlkKCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge2FuZ2xlTGluZXMsIGdyaWQsIGJvcmRlcn0gPSBvcHRzO1xuICAgIGNvbnN0IGxhYmVsQ291bnQgPSB0aGlzLl9wb2ludExhYmVscy5sZW5ndGg7XG5cbiAgICBsZXQgaSwgb2Zmc2V0LCBwb3NpdGlvbjtcblxuICAgIGlmIChvcHRzLnBvaW50TGFiZWxzLmRpc3BsYXkpIHtcbiAgICAgIGRyYXdQb2ludExhYmVscyh0aGlzLCBsYWJlbENvdW50KTtcbiAgICB9XG5cbiAgICBpZiAoZ3JpZC5kaXNwbGF5KSB7XG4gICAgICB0aGlzLnRpY2tzLmZvckVhY2goKHRpY2ssIGluZGV4KSA9PiB7XG4gICAgICAgIGlmIChpbmRleCAhPT0gMCB8fCAoaW5kZXggPT09IDAgJiYgdGhpcy5taW4gPCAwKSkge1xuICAgICAgICAgIG9mZnNldCA9IHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodGljay52YWx1ZSk7XG4gICAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0Q29udGV4dChpbmRleCk7XG4gICAgICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSBncmlkLnNldENvbnRleHQoY29udGV4dCk7XG4gICAgICAgICAgY29uc3Qgb3B0c0F0SW5kZXhCb3JkZXIgPSBib3JkZXIuc2V0Q29udGV4dChjb250ZXh0KTtcblxuICAgICAgICAgIGRyYXdSYWRpdXNMaW5lKHRoaXMsIG9wdHNBdEluZGV4LCBvZmZzZXQsIGxhYmVsQ291bnQsIG9wdHNBdEluZGV4Qm9yZGVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFuZ2xlTGluZXMuZGlzcGxheSkge1xuICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgZm9yIChpID0gbGFiZWxDb3VudCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gYW5nbGVMaW5lcy5zZXRDb250ZXh0KHRoaXMuZ2V0UG9pbnRMYWJlbENvbnRleHQoaSkpO1xuICAgICAgICBjb25zdCB7Y29sb3IsIGxpbmVXaWR0aH0gPSBvcHRzQXRJbmRleDtcblxuICAgICAgICBpZiAoIWxpbmVXaWR0aCB8fCAhY29sb3IpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuXG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaChvcHRzQXRJbmRleC5ib3JkZXJEYXNoKTtcbiAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gb3B0c0F0SW5kZXguYm9yZGVyRGFzaE9mZnNldDtcblxuICAgICAgICBvZmZzZXQgPSB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKG9wdHMudGlja3MucmV2ZXJzZSA/IHRoaXMubWluIDogdGhpcy5tYXgpO1xuICAgICAgICBwb3NpdGlvbiA9IHRoaXMuZ2V0UG9pbnRQb3NpdGlvbihpLCBvZmZzZXQpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8odGhpcy54Q2VudGVyLCB0aGlzLnlDZW50ZXIpO1xuICAgICAgICBjdHgubGluZVRvKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdCb3JkZXIoKSB7fVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3TGFiZWxzKCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuXG4gICAgaWYgKCF0aWNrT3B0cy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnRBbmdsZSA9IHRoaXMuZ2V0SW5kZXhBbmdsZSgwKTtcbiAgICBsZXQgb2Zmc2V0LCB3aWR0aDtcblxuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnRyYW5zbGF0ZSh0aGlzLnhDZW50ZXIsIHRoaXMueUNlbnRlcik7XG4gICAgY3R4LnJvdGF0ZShzdGFydEFuZ2xlKTtcbiAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXG4gICAgdGhpcy50aWNrcy5mb3JFYWNoKCh0aWNrLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKChpbmRleCA9PT0gMCAmJiB0aGlzLm1pbiA+PSAwKSAmJiAhb3B0cy5yZXZlcnNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSB0aWNrT3B0cy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpbmRleCkpO1xuICAgICAgY29uc3QgdGlja0ZvbnQgPSB0b0ZvbnQob3B0c0F0SW5kZXguZm9udCk7XG4gICAgICBvZmZzZXQgPSB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRoaXMudGlja3NbaW5kZXhdLnZhbHVlKTtcblxuICAgICAgaWYgKG9wdHNBdEluZGV4LnNob3dMYWJlbEJhY2tkcm9wKSB7XG4gICAgICAgIGN0eC5mb250ID0gdGlja0ZvbnQuc3RyaW5nO1xuICAgICAgICB3aWR0aCA9IGN0eC5tZWFzdXJlVGV4dCh0aWNrLmxhYmVsKS53aWR0aDtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdHNBdEluZGV4LmJhY2tkcm9wQ29sb3I7XG5cbiAgICAgICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRzQXRJbmRleC5iYWNrZHJvcFBhZGRpbmcpO1xuICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgLXdpZHRoIC8gMiAtIHBhZGRpbmcubGVmdCxcbiAgICAgICAgICAtb2Zmc2V0IC0gdGlja0ZvbnQuc2l6ZSAvIDIgLSBwYWRkaW5nLnRvcCxcbiAgICAgICAgICB3aWR0aCArIHBhZGRpbmcud2lkdGgsXG4gICAgICAgICAgdGlja0ZvbnQuc2l6ZSArIHBhZGRpbmcuaGVpZ2h0XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJlbmRlclRleHQoY3R4LCB0aWNrLmxhYmVsLCAwLCAtb2Zmc2V0LCB0aWNrRm9udCwge1xuICAgICAgICBjb2xvcjogb3B0c0F0SW5kZXguY29sb3IsXG4gICAgICAgIHN0cm9rZUNvbG9yOiBvcHRzQXRJbmRleC50ZXh0U3Ryb2tlQ29sb3IsXG4gICAgICAgIHN0cm9rZVdpZHRoOiBvcHRzQXRJbmRleC50ZXh0U3Ryb2tlV2lkdGgsXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd1RpdGxlKCkge31cbn1cbiIsICJpbXBvcnQgYWRhcHRlcnMgZnJvbSAnLi4vY29yZS9jb3JlLmFkYXB0ZXJzLmpzJztcbmltcG9ydCB7Y2FsbGJhY2sgYXMgY2FsbCwgaXNGaW5pdGUsIGlzTnVsbE9yVW5kZWYsIG1lcmdlSWYsIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge3RvUmFkaWFucywgaXNOdW1iZXIsIF9saW1pdFZhbHVlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQgU2NhbGUgZnJvbSAnLi4vY29yZS9jb3JlLnNjYWxlLmpzJztcbmltcG9ydCB7X2FycmF5VW5pcXVlLCBfZmlsdGVyQmV0d2VlbiwgX2xvb2t1cH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbGxlY3Rpb24uanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9jb3JlL2NvcmUuYWRhcHRlcnMuanMnKS5UaW1lVW5pdCB9IFVuaXRcbiAqIEB0eXBlZGVmIHt7Y29tbW9uOiBib29sZWFuLCBzaXplOiBudW1iZXIsIHN0ZXBzPzogbnVtYmVyfX0gSW50ZXJ2YWxcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9jb3JlL2NvcmUuYWRhcHRlcnMuanMnKS5EYXRlQWRhcHRlciB9IERhdGVBZGFwdGVyXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7T2JqZWN0PFVuaXQsIEludGVydmFsPn1cbiAqL1xuY29uc3QgSU5URVJWQUxTID0ge1xuICBtaWxsaXNlY29uZDoge2NvbW1vbjogdHJ1ZSwgc2l6ZTogMSwgc3RlcHM6IDEwMDB9LFxuICBzZWNvbmQ6IHtjb21tb246IHRydWUsIHNpemU6IDEwMDAsIHN0ZXBzOiA2MH0sXG4gIG1pbnV0ZToge2NvbW1vbjogdHJ1ZSwgc2l6ZTogNjAwMDAsIHN0ZXBzOiA2MH0sXG4gIGhvdXI6IHtjb21tb246IHRydWUsIHNpemU6IDM2MDAwMDAsIHN0ZXBzOiAyNH0sXG4gIGRheToge2NvbW1vbjogdHJ1ZSwgc2l6ZTogODY0MDAwMDAsIHN0ZXBzOiAzMH0sXG4gIHdlZWs6IHtjb21tb246IGZhbHNlLCBzaXplOiA2MDQ4MDAwMDAsIHN0ZXBzOiA0fSxcbiAgbW9udGg6IHtjb21tb246IHRydWUsIHNpemU6IDIuNjI4ZTksIHN0ZXBzOiAxMn0sXG4gIHF1YXJ0ZXI6IHtjb21tb246IGZhbHNlLCBzaXplOiA3Ljg4NGU5LCBzdGVwczogNH0sXG4gIHllYXI6IHtjb21tb246IHRydWUsIHNpemU6IDMuMTU0ZTEwfVxufTtcblxuLyoqXG4gKiBAdHlwZSB7VW5pdFtdfVxuICovXG5jb25zdCBVTklUUyA9IC8qKiBAdHlwZSBVbml0W10gKi8gLyogI19fUFVSRV9fICovIChPYmplY3Qua2V5cyhJTlRFUlZBTFMpKTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IGJcbiAqL1xuZnVuY3Rpb24gc29ydGVyKGEsIGIpIHtcbiAgcmV0dXJuIGEgLSBiO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGltZVNjYWxlfSBzY2FsZVxuICogQHBhcmFtIHsqfSBpbnB1dFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBwYXJzZShzY2FsZSwgaW5wdXQpIHtcbiAgaWYgKGlzTnVsbE9yVW5kZWYoaW5wdXQpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBhZGFwdGVyID0gc2NhbGUuX2FkYXB0ZXI7XG4gIGNvbnN0IHtwYXJzZXIsIHJvdW5kLCBpc29XZWVrZGF5fSA9IHNjYWxlLl9wYXJzZU9wdHM7XG4gIGxldCB2YWx1ZSA9IGlucHV0O1xuXG4gIGlmICh0eXBlb2YgcGFyc2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFsdWUgPSBwYXJzZXIodmFsdWUpO1xuICB9XG5cbiAgLy8gT25seSBwYXJzZSBpZiBpdCdzIG5vdCBhIHRpbWVzdGFtcCBhbHJlYWR5XG4gIGlmICghaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgdmFsdWUgPSB0eXBlb2YgcGFyc2VyID09PSAnc3RyaW5nJ1xuICAgICAgPyBhZGFwdGVyLnBhcnNlKHZhbHVlLCAvKiogQHR5cGUge1VuaXR9ICovIChwYXJzZXIpKVxuICAgICAgOiBhZGFwdGVyLnBhcnNlKHZhbHVlKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHJvdW5kKSB7XG4gICAgdmFsdWUgPSByb3VuZCA9PT0gJ3dlZWsnICYmIChpc051bWJlcihpc29XZWVrZGF5KSB8fCBpc29XZWVrZGF5ID09PSB0cnVlKVxuICAgICAgPyBhZGFwdGVyLnN0YXJ0T2YodmFsdWUsICdpc29XZWVrJywgaXNvV2Vla2RheSlcbiAgICAgIDogYWRhcHRlci5zdGFydE9mKHZhbHVlLCByb3VuZCk7XG4gIH1cblxuICByZXR1cm4gK3ZhbHVlO1xufVxuXG4vKipcbiAqIEZpZ3VyZXMgb3V0IHdoYXQgdW5pdCByZXN1bHRzIGluIGFuIGFwcHJvcHJpYXRlIG51bWJlciBvZiBhdXRvLWdlbmVyYXRlZCB0aWNrc1xuICogQHBhcmFtIHtVbml0fSBtaW5Vbml0XG4gKiBAcGFyYW0ge251bWJlcn0gbWluXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gKiBAcGFyYW0ge251bWJlcn0gY2FwYWNpdHlcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyhtaW5Vbml0LCBtaW4sIG1heCwgY2FwYWNpdHkpIHtcbiAgY29uc3QgaWxlbiA9IFVOSVRTLmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gVU5JVFMuaW5kZXhPZihtaW5Vbml0KTsgaSA8IGlsZW4gLSAxOyArK2kpIHtcbiAgICBjb25zdCBpbnRlcnZhbCA9IElOVEVSVkFMU1tVTklUU1tpXV07XG4gICAgY29uc3QgZmFjdG9yID0gaW50ZXJ2YWwuc3RlcHMgPyBpbnRlcnZhbC5zdGVwcyA6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuXG4gICAgaWYgKGludGVydmFsLmNvbW1vbiAmJiBNYXRoLmNlaWwoKG1heCAtIG1pbikgLyAoZmFjdG9yICogaW50ZXJ2YWwuc2l6ZSkpIDw9IGNhcGFjaXR5KSB7XG4gICAgICByZXR1cm4gVU5JVFNbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFVOSVRTW2lsZW4gLSAxXTtcbn1cblxuLyoqXG4gKiBGaWd1cmVzIG91dCB3aGF0IHVuaXQgdG8gZm9ybWF0IGEgc2V0IG9mIHRpY2tzIHdpdGhcbiAqIEBwYXJhbSB7VGltZVNjYWxlfSBzY2FsZVxuICogQHBhcmFtIHtudW1iZXJ9IG51bVRpY2tzXG4gKiBAcGFyYW0ge1VuaXR9IG1pblVuaXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAqIEByZXR1cm4ge1VuaXR9XG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nKHNjYWxlLCBudW1UaWNrcywgbWluVW5pdCwgbWluLCBtYXgpIHtcbiAgZm9yIChsZXQgaSA9IFVOSVRTLmxlbmd0aCAtIDE7IGkgPj0gVU5JVFMuaW5kZXhPZihtaW5Vbml0KTsgaS0tKSB7XG4gICAgY29uc3QgdW5pdCA9IFVOSVRTW2ldO1xuICAgIGlmIChJTlRFUlZBTFNbdW5pdF0uY29tbW9uICYmIHNjYWxlLl9hZGFwdGVyLmRpZmYobWF4LCBtaW4sIHVuaXQpID49IG51bVRpY2tzIC0gMSkge1xuICAgICAgcmV0dXJuIHVuaXQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFVOSVRTW21pblVuaXQgPyBVTklUUy5pbmRleE9mKG1pblVuaXQpIDogMF07XG59XG5cbi8qKlxuICogQHBhcmFtIHtVbml0fSB1bml0XG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZU1ham9yVW5pdCh1bml0KSB7XG4gIGZvciAobGV0IGkgPSBVTklUUy5pbmRleE9mKHVuaXQpICsgMSwgaWxlbiA9IFVOSVRTLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGlmIChJTlRFUlZBTFNbVU5JVFNbaV1dLmNvbW1vbikge1xuICAgICAgcmV0dXJuIFVOSVRTW2ldO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSB0aWNrc1xuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVcbiAqIEBwYXJhbSB7bnVtYmVyW119IFt0aW1lc3RhbXBzXSAtIGlmIGRlZmluZWQsIHNuYXAgdG8gdGhlc2UgdGltZXN0YW1wc1xuICovXG5mdW5jdGlvbiBhZGRUaWNrKHRpY2tzLCB0aW1lLCB0aW1lc3RhbXBzKSB7XG4gIGlmICghdGltZXN0YW1wcykge1xuICAgIHRpY2tzW3RpbWVdID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgIGNvbnN0IHtsbywgaGl9ID0gX2xvb2t1cCh0aW1lc3RhbXBzLCB0aW1lKTtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSB0aW1lc3RhbXBzW2xvXSA+PSB0aW1lID8gdGltZXN0YW1wc1tsb10gOiB0aW1lc3RhbXBzW2hpXTtcbiAgICB0aWNrc1t0aW1lc3RhbXBdID0gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VGltZVNjYWxlfSBzY2FsZVxuICogQHBhcmFtIHtvYmplY3RbXX0gdGlja3NcbiAqIEBwYXJhbSB7b2JqZWN0fSBtYXBcbiAqIEBwYXJhbSB7VW5pdH0gbWFqb3JVbml0XG4gKiBAcmV0dXJuIHtvYmplY3RbXX1cbiAqL1xuZnVuY3Rpb24gc2V0TWFqb3JUaWNrcyhzY2FsZSwgdGlja3MsIG1hcCwgbWFqb3JVbml0KSB7XG4gIGNvbnN0IGFkYXB0ZXIgPSBzY2FsZS5fYWRhcHRlcjtcbiAgY29uc3QgZmlyc3QgPSArYWRhcHRlci5zdGFydE9mKHRpY2tzWzBdLnZhbHVlLCBtYWpvclVuaXQpO1xuICBjb25zdCBsYXN0ID0gdGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWU7XG4gIGxldCBtYWpvciwgaW5kZXg7XG5cbiAgZm9yIChtYWpvciA9IGZpcnN0OyBtYWpvciA8PSBsYXN0OyBtYWpvciA9ICthZGFwdGVyLmFkZChtYWpvciwgMSwgbWFqb3JVbml0KSkge1xuICAgIGluZGV4ID0gbWFwW21ham9yXTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdGlja3NbaW5kZXhdLm1ham9yID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRpY2tzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGltZVNjYWxlfSBzY2FsZVxuICogQHBhcmFtIHtudW1iZXJbXX0gdmFsdWVzXG4gKiBAcGFyYW0ge1VuaXR8dW5kZWZpbmVkfSBbbWFqb3JVbml0XVxuICogQHJldHVybiB7b2JqZWN0W119XG4gKi9cbmZ1bmN0aW9uIHRpY2tzRnJvbVRpbWVzdGFtcHMoc2NhbGUsIHZhbHVlcywgbWFqb3JVbml0KSB7XG4gIGNvbnN0IHRpY2tzID0gW107XG4gIC8qKiBAdHlwZSB7T2JqZWN0PG51bWJlcixvYmplY3Q+fSAqL1xuICBjb25zdCBtYXAgPSB7fTtcbiAgY29uc3QgaWxlbiA9IHZhbHVlcy5sZW5ndGg7XG4gIGxldCBpLCB2YWx1ZTtcblxuICBmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgbWFwW3ZhbHVlXSA9IGk7XG5cbiAgICB0aWNrcy5wdXNoKHtcbiAgICAgIHZhbHVlLFxuICAgICAgbWFqb3I6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxuICAvLyBXZSBzZXQgdGhlIG1ham9yIHRpY2tzIHNlcGFyYXRlbHkgZnJvbSB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIGNhbGxpbmcgc3RhcnRPZiBmb3IgZXZlcnkgdGlja1xuICAvLyBpcyBleHBlbnNpdmUgd2hlbiB0aGVyZSBpcyBhIGxhcmdlIG51bWJlciBvZiB0aWNrc1xuICByZXR1cm4gKGlsZW4gPT09IDAgfHwgIW1ham9yVW5pdCkgPyB0aWNrcyA6IHNldE1ham9yVGlja3Moc2NhbGUsIHRpY2tzLCBtYXAsIG1ham9yVW5pdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbWVTY2FsZSBleHRlbmRzIFNjYWxlIHtcblxuICBzdGF0aWMgaWQgPSAndGltZSc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgLyoqXG4gICAgICogU2NhbGUgYm91bmRhcnkgc3RyYXRlZ3kgKGJ5cGFzc2VkIGJ5IG1pbi9tYXggdGltZSBvcHRpb25zKVxuICAgICAqIC0gYGRhdGFgOiBtYWtlIHN1cmUgZGF0YSBhcmUgZnVsbHkgdmlzaWJsZSwgdGlja3Mgb3V0c2lkZSBhcmUgcmVtb3ZlZFxuICAgICAqIC0gYHRpY2tzYDogbWFrZSBzdXJlIHRpY2tzIGFyZSBmdWxseSB2aXNpYmxlLCBkYXRhIG91dHNpZGUgYXJlIHRydW5jYXRlZFxuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvcHVsbC80NTU2XG4gICAgICogQHNpbmNlIDIuNy4wXG4gICAgICovXG4gICAgYm91bmRzOiAnZGF0YScsXG5cbiAgICBhZGFwdGVyczoge30sXG4gICAgdGltZToge1xuICAgICAgcGFyc2VyOiBmYWxzZSwgLy8gZmFsc2UgPT0gYSBwYXR0ZXJuIHN0cmluZyBmcm9tIG9yIGEgY3VzdG9tIGNhbGxiYWNrIHRoYXQgY29udmVydHMgaXRzIGFyZ3VtZW50IHRvIGEgdGltZXN0YW1wXG4gICAgICB1bml0OiBmYWxzZSwgLy8gZmFsc2UgPT0gYXV0b21hdGljIG9yIG92ZXJyaWRlIHdpdGggd2VlaywgbW9udGgsIHllYXIsIGV0Yy5cbiAgICAgIHJvdW5kOiBmYWxzZSwgLy8gbm9uZSwgb3Igb3ZlcnJpZGUgd2l0aCB3ZWVrLCBtb250aCwgeWVhciwgZXRjLlxuICAgICAgaXNvV2Vla2RheTogZmFsc2UsIC8vIG92ZXJyaWRlIHdlZWsgc3RhcnQgZGF5XG4gICAgICBtaW5Vbml0OiAnbWlsbGlzZWNvbmQnLFxuICAgICAgZGlzcGxheUZvcm1hdHM6IHt9XG4gICAgfSxcbiAgICB0aWNrczoge1xuICAgICAgLyoqXG4gICAgICAgKiBUaWNrcyBnZW5lcmF0aW9uIGlucHV0IHZhbHVlczpcbiAgICAgICAqIC0gJ2F1dG8nOiBnZW5lcmF0ZXMgXCJvcHRpbWFsXCIgdGlja3MgYmFzZWQgb24gc2NhbGUgc2l6ZSBhbmQgdGltZSBvcHRpb25zLlxuICAgICAgICogLSAnZGF0YSc6IGdlbmVyYXRlcyB0aWNrcyBmcm9tIGRhdGEgKGluY2x1ZGluZyBsYWJlbHMgZnJvbSBkYXRhIHt0fHh8eX0gb2JqZWN0cykuXG4gICAgICAgKiAtICdsYWJlbHMnOiBnZW5lcmF0ZXMgdGlja3MgZnJvbSB1c2VyIGdpdmVuIGBkYXRhLmxhYmVsc2AgdmFsdWVzIE9OTFkuXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDUwN1xuICAgICAgICogQHNpbmNlIDIuNy4wXG4gICAgICAgKi9cbiAgICAgIHNvdXJjZTogJ2F1dG8nLFxuXG4gICAgICBjYWxsYmFjazogZmFsc2UsXG5cbiAgICAgIG1ham9yOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcblx0ICovXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgLyoqIEB0eXBlIHt7ZGF0YTogbnVtYmVyW10sIGxhYmVsczogbnVtYmVyW10sIGFsbDogbnVtYmVyW119fSAqL1xuICAgIHRoaXMuX2NhY2hlID0ge1xuICAgICAgZGF0YTogW10sXG4gICAgICBsYWJlbHM6IFtdLFxuICAgICAgYWxsOiBbXVxuICAgIH07XG5cbiAgICAvKiogQHR5cGUge1VuaXR9ICovXG4gICAgdGhpcy5fdW5pdCA9ICdkYXknO1xuICAgIC8qKiBAdHlwZSB7VW5pdD19ICovXG4gICAgdGhpcy5fbWFqb3JVbml0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX29mZnNldHMgPSB7fTtcbiAgICB0aGlzLl9ub3JtYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5fcGFyc2VPcHRzID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaW5pdChzY2FsZU9wdHMsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHRpbWUgPSBzY2FsZU9wdHMudGltZSB8fCAoc2NhbGVPcHRzLnRpbWUgPSB7fSk7XG4gICAgLyoqIEB0eXBlIHtEYXRlQWRhcHRlcn0gKi9cbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlciA9IG5ldyBhZGFwdGVycy5fZGF0ZShzY2FsZU9wdHMuYWRhcHRlcnMuZGF0ZSk7XG5cbiAgICBhZGFwdGVyLmluaXQob3B0cyk7XG5cbiAgICAvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5OiBiZWZvcmUgaW50cm9kdWNpbmcgYWRhcHRlciwgYGRpc3BsYXlGb3JtYXRzYCB3YXNcbiAgICAvLyBzdXBwb3NlZCB0byBjb250YWluICphbGwqIHVuaXQvc3RyaW5nIHBhaXJzIGJ1dCB0aGlzIGNhbid0IGJlIHJlc29sdmVkXG4gICAgLy8gd2hlbiBsb2FkaW5nIHRoZSBzY2FsZSAoYWRhcHRlcnMgYXJlIGxvYWRlZCBhZnRlcndhcmQpLCBzbyBsZXQncyBwb3B1bGF0ZVxuICAgIC8vIG1pc3NpbmcgZm9ybWF0cyBvbiB1cGRhdGVcbiAgICBtZXJnZUlmKHRpbWUuZGlzcGxheUZvcm1hdHMsIGFkYXB0ZXIuZm9ybWF0cygpKTtcblxuICAgIHRoaXMuX3BhcnNlT3B0cyA9IHtcbiAgICAgIHBhcnNlcjogdGltZS5wYXJzZXIsXG4gICAgICByb3VuZDogdGltZS5yb3VuZCxcbiAgICAgIGlzb1dlZWtkYXk6IHRpbWUuaXNvV2Vla2RheVxuICAgIH07XG5cbiAgICBzdXBlci5pbml0KHNjYWxlT3B0cyk7XG5cbiAgICB0aGlzLl9ub3JtYWxpemVkID0gb3B0cy5ub3JtYWxpemVkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7Kn0gcmF3XG5cdCAqIEBwYXJhbSB7bnVtYmVyP30gW2luZGV4XVxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBwYXJzZShyYXcsIGluZGV4KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBpZiAocmF3ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2UodGhpcywgcmF3KTtcbiAgfVxuXG4gIGJlZm9yZUxheW91dCgpIHtcbiAgICBzdXBlci5iZWZvcmVMYXlvdXQoKTtcbiAgICB0aGlzLl9jYWNoZSA9IHtcbiAgICAgIGRhdGE6IFtdLFxuICAgICAgbGFiZWxzOiBbXSxcbiAgICAgIGFsbDogW11cbiAgICB9O1xuICB9XG5cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyO1xuICAgIGNvbnN0IHVuaXQgPSBvcHRpb25zLnRpbWUudW5pdCB8fCAnZGF5JztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgbGV0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcblxuICAgIC8qKlxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBib3VuZHNcblx0XHQgKi9cbiAgICBmdW5jdGlvbiBfYXBwbHlCb3VuZHMoYm91bmRzKSB7XG4gICAgICBpZiAoIW1pbkRlZmluZWQgJiYgIWlzTmFOKGJvdW5kcy5taW4pKSB7XG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgYm91bmRzLm1pbik7XG4gICAgICB9XG4gICAgICBpZiAoIW1heERlZmluZWQgJiYgIWlzTmFOKGJvdW5kcy5tYXgpKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgYm91bmRzLm1heCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgaGF2ZSB1c2VyIHByb3ZpZGVkIGBtaW5gIGFuZCBgbWF4YCBsYWJlbHMgLyBkYXRhIGJvdW5kcyBjYW4gYmUgaWdub3JlZFxuICAgIGlmICghbWluRGVmaW5lZCB8fCAhbWF4RGVmaW5lZCkge1xuICAgICAgLy8gTGFiZWxzIGFyZSBhbHdheXMgY29uc2lkZXJlZCwgd2hlbiB1c2VyIGRpZCBub3QgZm9yY2UgYm91bmRzXG4gICAgICBfYXBwbHlCb3VuZHModGhpcy5fZ2V0TGFiZWxCb3VuZHMoKSk7XG5cbiAgICAgIC8vIElmIGBib3VuZHNgIGlzIGAndGlja3MnYCBhbmQgYHRpY2tzLnNvdXJjZWAgaXMgYCdsYWJlbHMnYCxcbiAgICAgIC8vIGRhdGEgYm91bmRzIGFyZSBpZ25vcmVkIChhbmQgZG9uJ3QgbmVlZCB0byBiZSBkZXRlcm1pbmVkKVxuICAgICAgaWYgKG9wdGlvbnMuYm91bmRzICE9PSAndGlja3MnIHx8IG9wdGlvbnMudGlja3Muc291cmNlICE9PSAnbGFiZWxzJykge1xuICAgICAgICBfYXBwbHlCb3VuZHModGhpcy5nZXRNaW5NYXgoZmFsc2UpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtaW4gPSBpc0Zpbml0ZShtaW4pICYmICFpc05hTihtaW4pID8gbWluIDogK2FkYXB0ZXIuc3RhcnRPZihEYXRlLm5vdygpLCB1bml0KTtcbiAgICBtYXggPSBpc0Zpbml0ZShtYXgpICYmICFpc05hTihtYXgpID8gbWF4IDogK2FkYXB0ZXIuZW5kT2YoRGF0ZS5ub3coKSwgdW5pdCkgKyAxO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgbWF4IGlzIHN0cmljdGx5IGhpZ2hlciB0aGFuIG1pbiAocmVxdWlyZWQgYnkgdGhlIHRpbWVzZXJpZXMgbG9va3VwIHRhYmxlKVxuICAgIHRoaXMubWluID0gTWF0aC5taW4obWluLCBtYXggLSAxKTtcbiAgICB0aGlzLm1heCA9IE1hdGgubWF4KG1pbiArIDEsIG1heCk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRMYWJlbEJvdW5kcygpIHtcbiAgICBjb25zdCBhcnIgPSB0aGlzLmdldExhYmVsVGltZXN0YW1wcygpO1xuICAgIGxldCBtaW4gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IG1heCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcblxuICAgIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgICBtaW4gPSBhcnJbMF07XG4gICAgICBtYXggPSBhcnJbYXJyLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4ge21pbiwgbWF4fTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtvYmplY3RbXX1cblx0ICovXG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aW1lT3B0cyA9IG9wdGlvbnMudGltZTtcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdGlvbnMudGlja3M7XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IHRpY2tPcHRzLnNvdXJjZSA9PT0gJ2xhYmVscycgPyB0aGlzLmdldExhYmVsVGltZXN0YW1wcygpIDogdGhpcy5fZ2VuZXJhdGUoKTtcblxuICAgIGlmIChvcHRpb25zLmJvdW5kcyA9PT0gJ3RpY2tzJyAmJiB0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgdGhpcy5taW4gPSB0aGlzLl91c2VyTWluIHx8IHRpbWVzdGFtcHNbMF07XG4gICAgICB0aGlzLm1heCA9IHRoaXMuX3VzZXJNYXggfHwgdGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluO1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuXG4gICAgY29uc3QgdGlja3MgPSBfZmlsdGVyQmV0d2Vlbih0aW1lc3RhbXBzLCBtaW4sIG1heCk7XG5cbiAgICAvLyBQUklWQVRFXG4gICAgLy8gZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmcgcmVsaWVzIG9uIHRoZSBudW1iZXIgb2YgdGlja3Mgc28gd2UgZG9uJ3QgdXNlIGl0IHdoZW5cbiAgICAvLyBhdXRvU2tpcCBpcyBlbmFibGVkIGJlY2F1c2Ugd2UgZG9uJ3QgeWV0IGtub3cgd2hhdCB0aGUgZmluYWwgbnVtYmVyIG9mIHRpY2tzIHdpbGwgYmVcbiAgICB0aGlzLl91bml0ID0gdGltZU9wdHMudW5pdCB8fCAodGlja09wdHMuYXV0b1NraXBcbiAgICAgID8gZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyh0aW1lT3B0cy5taW5Vbml0LCB0aGlzLm1pbiwgdGhpcy5tYXgsIHRoaXMuX2dldExhYmVsQ2FwYWNpdHkobWluKSlcbiAgICAgIDogZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmcodGhpcywgdGlja3MubGVuZ3RoLCB0aW1lT3B0cy5taW5Vbml0LCB0aGlzLm1pbiwgdGhpcy5tYXgpKTtcbiAgICB0aGlzLl9tYWpvclVuaXQgPSAhdGlja09wdHMubWFqb3IuZW5hYmxlZCB8fCB0aGlzLl91bml0ID09PSAneWVhcicgPyB1bmRlZmluZWRcbiAgICAgIDogZGV0ZXJtaW5lTWFqb3JVbml0KHRoaXMuX3VuaXQpO1xuICAgIHRoaXMuaW5pdE9mZnNldHModGltZXN0YW1wcyk7XG5cbiAgICBpZiAob3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICB0aWNrcy5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRpY2tzRnJvbVRpbWVzdGFtcHModGhpcywgdGlja3MsIHRoaXMuX21ham9yVW5pdCk7XG4gIH1cblxuICBhZnRlckF1dG9Ta2lwKCkge1xuICAgIC8vIE9mZnNldHMgZm9yIGJhciBjaGFydHMgbmVlZCB0byBiZSBoYW5kbGVkIHdpdGggdGhlIGF1dG8gc2tpcHBlZFxuICAgIC8vIHRpY2tzLiBPbmNlIHRpY2tzIGhhdmUgYmVlbiBza2lwcGVkLCB3ZSByZS1jb21wdXRlIHRoZSBvZmZzZXRzLlxuICAgIGlmICh0aGlzLm9wdGlvbnMub2Zmc2V0QWZ0ZXJBdXRvc2tpcCkge1xuICAgICAgdGhpcy5pbml0T2Zmc2V0cyh0aGlzLnRpY2tzLm1hcCh0aWNrID0+ICt0aWNrLnZhbHVlKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIHN0YXJ0IGFuZCBlbmQgb2Zmc2V0cyBmcm9tIGVkZ2VzIGluIHRoZSBmb3JtIG9mIHtzdGFydCwgZW5kfVxuXHQgKiB3aGVyZSBlYWNoIHZhbHVlIGlzIGEgcmVsYXRpdmUgd2lkdGggdG8gdGhlIHNjYWxlIGFuZCByYW5nZXMgYmV0d2VlbiAwIGFuZCAxLlxuXHQgKiBUaGV5IGFkZCBleHRyYSBtYXJnaW5zIG9uIHRoZSBib3RoIHNpZGVzIGJ5IHNjYWxpbmcgZG93biB0aGUgb3JpZ2luYWwgc2NhbGUuXG5cdCAqIE9mZnNldHMgYXJlIGFkZGVkIHdoZW4gdGhlIGBvZmZzZXRgIG9wdGlvbiBpcyB0cnVlLlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSB0aW1lc3RhbXBzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGluaXRPZmZzZXRzKHRpbWVzdGFtcHMgPSBbXSkge1xuICAgIGxldCBzdGFydCA9IDA7XG4gICAgbGV0IGVuZCA9IDA7XG4gICAgbGV0IGZpcnN0LCBsYXN0O1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5vZmZzZXQgJiYgdGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIGZpcnN0ID0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1swXSk7XG4gICAgICBpZiAodGltZXN0YW1wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgc3RhcnQgPSAxIC0gZmlyc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydCA9ICh0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzWzFdKSAtIGZpcnN0KSAvIDI7XG4gICAgICB9XG4gICAgICBsYXN0ID0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdKTtcbiAgICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBlbmQgPSBsYXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gKGxhc3QgLSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMl0pKSAvIDI7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxpbWl0ID0gdGltZXN0YW1wcy5sZW5ndGggPCAzID8gMC41IDogMC4yNTtcbiAgICBzdGFydCA9IF9saW1pdFZhbHVlKHN0YXJ0LCAwLCBsaW1pdCk7XG4gICAgZW5kID0gX2xpbWl0VmFsdWUoZW5kLCAwLCBsaW1pdCk7XG5cbiAgICB0aGlzLl9vZmZzZXRzID0ge3N0YXJ0LCBlbmQsIGZhY3RvcjogMSAvIChzdGFydCArIDEgKyBlbmQpfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZW5lcmF0ZXMgYSBtYXhpbXVtIG9mIGBjYXBhY2l0eWAgdGltZXN0YW1wcyBiZXR3ZWVuIG1pbiBhbmQgbWF4LCByb3VuZGVkIHRvIHRoZVxuXHQgKiBgbWlub3JgIHVuaXQgdXNpbmcgdGhlIGdpdmVuIHNjYWxlIHRpbWUgYG9wdGlvbnNgLlxuXHQgKiBJbXBvcnRhbnQ6IHRoaXMgbWV0aG9kIGNhbiByZXR1cm4gdGlja3Mgb3V0c2lkZSB0aGUgbWluIGFuZCBtYXggcmFuZ2UsIGl0J3MgdGhlXG5cdCAqIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBjYWxsaW5nIGNvZGUgdG8gY2xhbXAgdmFsdWVzIGlmIG5lZWRlZC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgX2dlbmVyYXRlKCkge1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyO1xuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluO1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGltZU9wdHMgPSBvcHRpb25zLnRpbWU7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IG1pbm9yID0gdGltZU9wdHMudW5pdCB8fCBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKHRpbWVPcHRzLm1pblVuaXQsIG1pbiwgbWF4LCB0aGlzLl9nZXRMYWJlbENhcGFjaXR5KG1pbikpO1xuICAgIGNvbnN0IHN0ZXBTaXplID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy50aWNrcy5zdGVwU2l6ZSwgMSk7XG4gICAgY29uc3Qgd2Vla2RheSA9IG1pbm9yID09PSAnd2VlaycgPyB0aW1lT3B0cy5pc29XZWVrZGF5IDogZmFsc2U7XG4gICAgY29uc3QgaGFzV2Vla2RheSA9IGlzTnVtYmVyKHdlZWtkYXkpIHx8IHdlZWtkYXkgPT09IHRydWU7XG4gICAgY29uc3QgdGlja3MgPSB7fTtcbiAgICBsZXQgZmlyc3QgPSBtaW47XG4gICAgbGV0IHRpbWUsIGNvdW50O1xuXG4gICAgLy8gRm9yICd3ZWVrJyB1bml0LCBoYW5kbGUgdGhlIGZpcnN0IGRheSBvZiB3ZWVrIG9wdGlvblxuICAgIGlmIChoYXNXZWVrZGF5KSB7XG4gICAgICBmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YoZmlyc3QsICdpc29XZWVrJywgd2Vla2RheSk7XG4gICAgfVxuXG4gICAgLy8gQWxpZ24gZmlyc3QgdGlja3Mgb24gdW5pdFxuICAgIGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZihmaXJzdCwgaGFzV2Vla2RheSA/ICdkYXknIDogbWlub3IpO1xuXG4gICAgLy8gUHJldmVudCBicm93c2VyIGZyb20gZnJlZXppbmcgaW4gY2FzZSB1c2VyIG9wdGlvbnMgcmVxdWVzdCBtaWxsaW9ucyBvZiBtaWxsaXNlY29uZHNcbiAgICBpZiAoYWRhcHRlci5kaWZmKG1heCwgbWluLCBtaW5vcikgPiAxMDAwMDAgKiBzdGVwU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1pbiArICcgYW5kICcgKyBtYXggKyAnIGFyZSB0b28gZmFyIGFwYXJ0IHdpdGggc3RlcFNpemUgb2YgJyArIHN0ZXBTaXplICsgJyAnICsgbWlub3IpO1xuICAgIH1cblxuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSBvcHRpb25zLnRpY2tzLnNvdXJjZSA9PT0gJ2RhdGEnICYmIHRoaXMuZ2V0RGF0YVRpbWVzdGFtcHMoKTtcbiAgICBmb3IgKHRpbWUgPSBmaXJzdCwgY291bnQgPSAwOyB0aW1lIDwgbWF4OyB0aW1lID0gK2FkYXB0ZXIuYWRkKHRpbWUsIHN0ZXBTaXplLCBtaW5vciksIGNvdW50KyspIHtcbiAgICAgIGFkZFRpY2sodGlja3MsIHRpbWUsIHRpbWVzdGFtcHMpO1xuICAgIH1cblxuICAgIGlmICh0aW1lID09PSBtYXggfHwgb3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycgfHwgY291bnQgPT09IDEpIHtcbiAgICAgIGFkZFRpY2sodGlja3MsIHRpbWUsIHRpbWVzdGFtcHMpO1xuICAgIH1cblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGlja3MpLnNvcnQoc29ydGVyKS5tYXAoeCA9PiAreCk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlcjtcbiAgICBjb25zdCB0aW1lT3B0cyA9IHRoaXMub3B0aW9ucy50aW1lO1xuXG4gICAgaWYgKHRpbWVPcHRzLnRvb2x0aXBGb3JtYXQpIHtcbiAgICAgIHJldHVybiBhZGFwdGVyLmZvcm1hdCh2YWx1ZSwgdGltZU9wdHMudG9vbHRpcEZvcm1hdCk7XG4gICAgfVxuICAgIHJldHVybiBhZGFwdGVyLmZvcm1hdCh2YWx1ZSwgdGltZU9wdHMuZGlzcGxheUZvcm1hdHMuZGF0ZXRpbWUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuXHQgKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IGZvcm1hdFxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuICBmb3JtYXQodmFsdWUsIGZvcm1hdCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgZm9ybWF0cyA9IG9wdGlvbnMudGltZS5kaXNwbGF5Rm9ybWF0cztcbiAgICBjb25zdCB1bml0ID0gdGhpcy5fdW5pdDtcbiAgICBjb25zdCBmbXQgPSBmb3JtYXQgfHwgZm9ybWF0c1t1bml0XTtcbiAgICByZXR1cm4gdGhpcy5fYWRhcHRlci5mb3JtYXQodmFsdWUsIGZtdCk7XG4gIH1cblxuICAvKipcblx0ICogRnVuY3Rpb24gdG8gZm9ybWF0IGFuIGluZGl2aWR1YWwgdGljayBtYXJrXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuXHQgKiBAcGFyYW0ge29iamVjdFtdfSB0aWNrc1xuXHQgKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IFtmb3JtYXRdXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF90aWNrRm9ybWF0RnVuY3Rpb24odGltZSwgaW5kZXgsIHRpY2tzLCBmb3JtYXQpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGZvcm1hdHRlciA9IG9wdGlvbnMudGlja3MuY2FsbGJhY2s7XG5cbiAgICBpZiAoZm9ybWF0dGVyKSB7XG4gICAgICByZXR1cm4gY2FsbChmb3JtYXR0ZXIsIFt0aW1lLCBpbmRleCwgdGlja3NdLCB0aGlzKTtcbiAgICB9XG5cbiAgICBjb25zdCBmb3JtYXRzID0gb3B0aW9ucy50aW1lLmRpc3BsYXlGb3JtYXRzO1xuICAgIGNvbnN0IHVuaXQgPSB0aGlzLl91bml0O1xuICAgIGNvbnN0IG1ham9yVW5pdCA9IHRoaXMuX21ham9yVW5pdDtcbiAgICBjb25zdCBtaW5vckZvcm1hdCA9IHVuaXQgJiYgZm9ybWF0c1t1bml0XTtcbiAgICBjb25zdCBtYWpvckZvcm1hdCA9IG1ham9yVW5pdCAmJiBmb3JtYXRzW21ham9yVW5pdF07XG4gICAgY29uc3QgdGljayA9IHRpY2tzW2luZGV4XTtcbiAgICBjb25zdCBtYWpvciA9IG1ham9yVW5pdCAmJiBtYWpvckZvcm1hdCAmJiB0aWNrICYmIHRpY2subWFqb3I7XG5cbiAgICByZXR1cm4gdGhpcy5fYWRhcHRlci5mb3JtYXQodGltZSwgZm9ybWF0IHx8IChtYWpvciA/IG1ham9yRm9ybWF0IDogbWlub3JGb3JtYXQpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge29iamVjdFtdfSB0aWNrc1xuXHQgKi9cbiAgZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKSB7XG4gICAgbGV0IGksIGlsZW4sIHRpY2s7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aWNrID0gdGlja3NbaV07XG4gICAgICB0aWNrLmxhYmVsID0gdGhpcy5fdGlja0Zvcm1hdEZ1bmN0aW9uKHRpY2sudmFsdWUsIGksIHRpY2tzKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gTWlsbGlzZWNvbmRzIHNpbmNlIGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldERlY2ltYWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IE5hTiA6ICh2YWx1ZSAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBNaWxsaXNlY29uZHMgc2luY2UgZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQylcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLl9vZmZzZXRzO1xuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwoKG9mZnNldHMuc3RhcnQgKyBwb3MpICogb2Zmc2V0cy5mYWN0b3IpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuX29mZnNldHM7XG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpIC8gb2Zmc2V0cy5mYWN0b3IgLSBvZmZzZXRzLmVuZDtcbiAgICByZXR1cm4gdGhpcy5taW4gKyBwb3MgKiAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsXG5cdCAqIEByZXR1cm4ge3t3Om51bWJlciwgaDpudW1iZXJ9fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldExhYmVsU2l6ZShsYWJlbCkge1xuICAgIGNvbnN0IHRpY2tzT3B0cyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICBjb25zdCB0aWNrTGFiZWxXaWR0aCA9IHRoaXMuY3R4Lm1lYXN1cmVUZXh0KGxhYmVsKS53aWR0aDtcbiAgICBjb25zdCBhbmdsZSA9IHRvUmFkaWFucyh0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGlja3NPcHRzLm1heFJvdGF0aW9uIDogdGlja3NPcHRzLm1pblJvdGF0aW9uKTtcbiAgICBjb25zdCBjb3NSb3RhdGlvbiA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICBjb25zdCBzaW5Sb3RhdGlvbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICBjb25zdCB0aWNrRm9udFNpemUgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKDApLnNpemU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdzogKHRpY2tMYWJlbFdpZHRoICogY29zUm90YXRpb24pICsgKHRpY2tGb250U2l6ZSAqIHNpblJvdGF0aW9uKSxcbiAgICAgIGg6ICh0aWNrTGFiZWxXaWR0aCAqIHNpblJvdGF0aW9uKSArICh0aWNrRm9udFNpemUgKiBjb3NSb3RhdGlvbilcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBleGFtcGxlVGltZVxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0TGFiZWxDYXBhY2l0eShleGFtcGxlVGltZSkge1xuICAgIGNvbnN0IHRpbWVPcHRzID0gdGhpcy5vcHRpb25zLnRpbWU7XG4gICAgY29uc3QgZGlzcGxheUZvcm1hdHMgPSB0aW1lT3B0cy5kaXNwbGF5Rm9ybWF0cztcblxuICAgIC8vIHBpY2sgdGhlIGxvbmdlc3QgZm9ybWF0IChtaWxsaXNlY29uZHMpIGZvciBndWVzc3RpbWF0aW9uXG4gICAgY29uc3QgZm9ybWF0ID0gZGlzcGxheUZvcm1hdHNbdGltZU9wdHMudW5pdF0gfHwgZGlzcGxheUZvcm1hdHMubWlsbGlzZWNvbmQ7XG4gICAgY29uc3QgZXhhbXBsZUxhYmVsID0gdGhpcy5fdGlja0Zvcm1hdEZ1bmN0aW9uKGV4YW1wbGVUaW1lLCAwLCB0aWNrc0Zyb21UaW1lc3RhbXBzKHRoaXMsIFtleGFtcGxlVGltZV0sIHRoaXMuX21ham9yVW5pdCksIGZvcm1hdCk7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuX2dldExhYmVsU2l6ZShleGFtcGxlTGFiZWwpO1xuICAgIC8vIHN1YnRyYWN0IDEgLSBpZiBvZmZzZXQgdGhlbiB0aGVyZSdzIG9uZSBsZXNzIGxhYmVsIHRoYW4gdGlja1xuICAgIC8vIGlmIG5vdCBvZmZzZXQgdGhlbiBvbmUgaGFsZiBsYWJlbCBwYWRkaW5nIGlzIGFkZGVkIHRvIGVhY2ggZW5kIGxlYXZpbmcgcm9vbSBmb3Igb25lIGxlc3MgbGFiZWxcbiAgICBjb25zdCBjYXBhY2l0eSA9IE1hdGguZmxvb3IodGhpcy5pc0hvcml6b250YWwoKSA/IHRoaXMud2lkdGggLyBzaXplLncgOiB0aGlzLmhlaWdodCAvIHNpemUuaCkgLSAxO1xuICAgIHJldHVybiBjYXBhY2l0eSA+IDAgPyBjYXBhY2l0eSA6IDE7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0RGF0YVRpbWVzdGFtcHMoKSB7XG4gICAgbGV0IHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5kYXRhIHx8IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuXG4gICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICB9XG5cbiAgICBjb25zdCBtZXRhcyA9IHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKTtcblxuICAgIGlmICh0aGlzLl9ub3JtYWxpemVkICYmIG1ldGFzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuICh0aGlzLl9jYWNoZS5kYXRhID0gbWV0YXNbMF0uY29udHJvbGxlci5nZXRBbGxQYXJzZWRWYWx1ZXModGhpcykpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRpbWVzdGFtcHMgPSB0aW1lc3RhbXBzLmNvbmNhdChtZXRhc1tpXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyh0aGlzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICh0aGlzLl9jYWNoZS5kYXRhID0gdGhpcy5ub3JtYWxpemUodGltZXN0YW1wcykpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldExhYmVsVGltZXN0YW1wcygpIHtcbiAgICBjb25zdCB0aW1lc3RhbXBzID0gdGhpcy5fY2FjaGUubGFiZWxzIHx8IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuXG4gICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICB9XG5cbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBsYWJlbHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aW1lc3RhbXBzLnB1c2gocGFyc2UodGhpcywgbGFiZWxzW2ldKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICh0aGlzLl9jYWNoZS5sYWJlbHMgPSB0aGlzLl9ub3JtYWxpemVkID8gdGltZXN0YW1wcyA6IHRoaXMubm9ybWFsaXplKHRpbWVzdGFtcHMpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSB2YWx1ZXNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgbm9ybWFsaXplKHZhbHVlcykge1xuICAgIC8vIEl0IHNlZW1zIHRvIGJlIHNvbWV3aGF0IGZhc3RlciB0byBkbyBzb3J0aW5nIGZpcnN0XG4gICAgcmV0dXJuIF9hcnJheVVuaXF1ZSh2YWx1ZXMuc29ydChzb3J0ZXIpKTtcbiAgfVxufVxuIiwgImltcG9ydCBUaW1lU2NhbGUgZnJvbSAnLi9zY2FsZS50aW1lLmpzJztcbmltcG9ydCB7X2xvb2t1cEJ5S2V5fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29sbGVjdGlvbi5qcyc7XG5cbi8qKlxuICogTGluZWFybHkgaW50ZXJwb2xhdGVzIHRoZSBnaXZlbiBzb3VyY2UgYHZhbGAgdXNpbmcgdGhlIHRhYmxlLiBJZiB2YWx1ZSBpcyBvdXQgb2YgYm91bmRzLCB2YWx1ZXNcbiAqIGF0IGVkZ2VzIGFyZSB1c2VkIGZvciB0aGUgaW50ZXJwb2xhdGlvbi5cbiAqIEBwYXJhbSB7b2JqZWN0fSB0YWJsZVxuICogQHBhcmFtIHtudW1iZXJ9IHZhbFxuICogQHBhcmFtIHtib29sZWFufSBbcmV2ZXJzZV0gbG9va3VwIHRpbWUgYmFzZWQgb24gcG9zaXRpb24gaW5zdGVhZCBvZiB2aWNlIHZlcnNhXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGludGVycG9sYXRlKHRhYmxlLCB2YWwsIHJldmVyc2UpIHtcbiAgbGV0IGxvID0gMDtcbiAgbGV0IGhpID0gdGFibGUubGVuZ3RoIC0gMTtcbiAgbGV0IHByZXZTb3VyY2UsIG5leHRTb3VyY2UsIHByZXZUYXJnZXQsIG5leHRUYXJnZXQ7XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgaWYgKHZhbCA+PSB0YWJsZVtsb10ucG9zICYmIHZhbCA8PSB0YWJsZVtoaV0ucG9zKSB7XG4gICAgICAoe2xvLCBoaX0gPSBfbG9va3VwQnlLZXkodGFibGUsICdwb3MnLCB2YWwpKTtcbiAgICB9XG4gICAgKHtwb3M6IHByZXZTb3VyY2UsIHRpbWU6IHByZXZUYXJnZXR9ID0gdGFibGVbbG9dKTtcbiAgICAoe3BvczogbmV4dFNvdXJjZSwgdGltZTogbmV4dFRhcmdldH0gPSB0YWJsZVtoaV0pO1xuICB9IGVsc2Uge1xuICAgIGlmICh2YWwgPj0gdGFibGVbbG9dLnRpbWUgJiYgdmFsIDw9IHRhYmxlW2hpXS50aW1lKSB7XG4gICAgICAoe2xvLCBoaX0gPSBfbG9va3VwQnlLZXkodGFibGUsICd0aW1lJywgdmFsKSk7XG4gICAgfVxuICAgICh7dGltZTogcHJldlNvdXJjZSwgcG9zOiBwcmV2VGFyZ2V0fSA9IHRhYmxlW2xvXSk7XG4gICAgKHt0aW1lOiBuZXh0U291cmNlLCBwb3M6IG5leHRUYXJnZXR9ID0gdGFibGVbaGldKTtcbiAgfVxuXG4gIGNvbnN0IHNwYW4gPSBuZXh0U291cmNlIC0gcHJldlNvdXJjZTtcbiAgcmV0dXJuIHNwYW4gPyBwcmV2VGFyZ2V0ICsgKG5leHRUYXJnZXQgLSBwcmV2VGFyZ2V0KSAqICh2YWwgLSBwcmV2U291cmNlKSAvIHNwYW4gOiBwcmV2VGFyZ2V0O1xufVxuXG5jbGFzcyBUaW1lU2VyaWVzU2NhbGUgZXh0ZW5kcyBUaW1lU2NhbGUge1xuXG4gIHN0YXRpYyBpZCA9ICd0aW1lc2VyaWVzJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IFRpbWVTY2FsZS5kZWZhdWx0cztcblxuICAvKipcblx0ICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG5cdCAqL1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcblxuICAgIC8qKiBAdHlwZSB7b2JqZWN0W119ICovXG4gICAgdGhpcy5fdGFibGUgPSBbXTtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLl9taW5Qb3MgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fdGFibGVSYW5nZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBpbml0T2Zmc2V0cygpIHtcbiAgICBjb25zdCB0aW1lc3RhbXBzID0gdGhpcy5fZ2V0VGltZXN0YW1wc0ZvclRhYmxlKCk7XG4gICAgY29uc3QgdGFibGUgPSB0aGlzLl90YWJsZSA9IHRoaXMuYnVpbGRMb29rdXBUYWJsZSh0aW1lc3RhbXBzKTtcbiAgICB0aGlzLl9taW5Qb3MgPSBpbnRlcnBvbGF0ZSh0YWJsZSwgdGhpcy5taW4pO1xuICAgIHRoaXMuX3RhYmxlUmFuZ2UgPSBpbnRlcnBvbGF0ZSh0YWJsZSwgdGhpcy5tYXgpIC0gdGhpcy5fbWluUG9zO1xuICAgIHN1cGVyLmluaXRPZmZzZXRzKHRpbWVzdGFtcHMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgYW4gYXJyYXkgb2Yge3RpbWUsIHBvc30gb2JqZWN0cyB1c2VkIHRvIGludGVycG9sYXRlIGEgc3BlY2lmaWMgYHRpbWVgIG9yIHBvc2l0aW9uXG5cdCAqIChgcG9zYCkgb24gdGhlIHNjYWxlLCBieSBzZWFyY2hpbmcgZW50cmllcyBiZWZvcmUgYW5kIGFmdGVyIHRoZSByZXF1ZXN0ZWQgdmFsdWUuIGBwb3NgIGlzXG5cdCAqIGEgZGVjaW1hbCBiZXR3ZWVuIDAgYW5kIDE6IDAgYmVpbmcgdGhlIHN0YXJ0IG9mIHRoZSBzY2FsZSAobGVmdCBvciB0b3ApIGFuZCAxIHRoZSBvdGhlclxuXHQgKiBleHRyZW1pdHkgKGxlZnQgKyB3aWR0aCBvciB0b3AgKyBoZWlnaHQpLiBOb3RlIHRoYXQgaXQgd291bGQgYmUgbW9yZSBvcHRpbWl6ZWQgdG8gZGlyZWN0bHlcblx0ICogc3RvcmUgcHJlLWNvbXB1dGVkIHBpeGVscywgYnV0IHRoZSBzY2FsZSBkaW1lbnNpb25zIGFyZSBub3QgZ3VhcmFudGVlZCBhdCB0aGUgdGltZSB3ZSBuZWVkXG5cdCAqIHRvIGNyZWF0ZSB0aGUgbG9va3VwIHRhYmxlLiBUaGUgdGFibGUgQUxXQVlTIGNvbnRhaW5zIGF0IGxlYXN0IHR3byBpdGVtczogbWluIGFuZCBtYXguXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IHRpbWVzdGFtcHNcblx0ICogQHJldHVybiB7b2JqZWN0W119XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGJ1aWxkTG9va3VwVGFibGUodGltZXN0YW1wcykge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzO1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgY29uc3QgdGFibGUgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgcHJldiwgY3VyciwgbmV4dDtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aW1lc3RhbXBzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY3VyciA9IHRpbWVzdGFtcHNbaV07XG4gICAgICBpZiAoY3VyciA+PSBtaW4gJiYgY3VyciA8PSBtYXgpIHtcbiAgICAgICAgaXRlbXMucHVzaChjdXJyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXRlbXMubGVuZ3RoIDwgMikge1xuICAgICAgLy8gSW4gY2FzZSB0aGVyZSBpcyBsZXNzIHRoYXQgMiB0aW1lc3RhbXBzIGJldHdlZW4gbWluIGFuZCBtYXgsIHRoZSBzY2FsZSBpcyBkZWZpbmVkIGJ5IG1pbiBhbmQgbWF4XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7dGltZTogbWluLCBwb3M6IDB9LFxuICAgICAgICB7dGltZTogbWF4LCBwb3M6IDF9XG4gICAgICBdO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIG5leHQgPSBpdGVtc1tpICsgMV07XG4gICAgICBwcmV2ID0gaXRlbXNbaSAtIDFdO1xuICAgICAgY3VyciA9IGl0ZW1zW2ldO1xuXG4gICAgICAvLyBvbmx5IGFkZCBwb2ludHMgdGhhdCBicmVha3MgdGhlIHNjYWxlIGxpbmVhcml0eVxuICAgICAgaWYgKE1hdGgucm91bmQoKG5leHQgKyBwcmV2KSAvIDIpICE9PSBjdXJyKSB7XG4gICAgICAgIHRhYmxlLnB1c2goe3RpbWU6IGN1cnIsIHBvczogaSAvIChpbGVuIC0gMSl9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhYmxlO1xuICB9XG5cbiAgLyoqXG4gICAgKiBHZW5lcmF0ZXMgYWxsIHRpbWVzdGFtcHMgZGVmaW5lZCBpbiB0aGUgZGF0YS5cbiAgICAqIEltcG9ydGFudDogdGhpcyBtZXRob2QgY2FuIHJldHVybiB0aWNrcyBvdXRzaWRlIHRoZSBtaW4gYW5kIG1heCByYW5nZSwgaXQncyB0aGVcbiAgICAqIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBjYWxsaW5nIGNvZGUgdG8gY2xhbXAgdmFsdWVzIGlmIG5lZWRlZC5cbiAgICAqIEBwcm90ZWN0ZWRcbiAgICAqL1xuICBfZ2VuZXJhdGUoKSB7XG4gICAgY29uc3QgbWluID0gdGhpcy5taW47XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXg7XG4gICAgbGV0IHRpbWVzdGFtcHMgPSBzdXBlci5nZXREYXRhVGltZXN0YW1wcygpO1xuICAgIGlmICghdGltZXN0YW1wcy5pbmNsdWRlcyhtaW4pIHx8ICF0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgdGltZXN0YW1wcy5zcGxpY2UoMCwgMCwgbWluKTtcbiAgICB9XG4gICAgaWYgKCF0aW1lc3RhbXBzLmluY2x1ZGVzKG1heCkgfHwgdGltZXN0YW1wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRpbWVzdGFtcHMucHVzaChtYXgpO1xuICAgIH1cbiAgICByZXR1cm4gdGltZXN0YW1wcy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyBhbGwgdGltZXN0YW1wc1xuXHQgKiBAcmV0dXJuIHtudW1iZXJbXX1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRUaW1lc3RhbXBzRm9yVGFibGUoKSB7XG4gICAgbGV0IHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5hbGwgfHwgW107XG5cbiAgICBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdldERhdGFUaW1lc3RhbXBzKCk7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLmdldExhYmVsVGltZXN0YW1wcygpO1xuICAgIGlmIChkYXRhLmxlbmd0aCAmJiBsYWJlbC5sZW5ndGgpIHtcbiAgICAgIC8vIElmIGNvbWJpbmluZyBsYWJlbHMgYW5kIGRhdGEgKGRhdGEgbWlnaHQgbm90IGNvbnRhaW4gYWxsIGxhYmVscyksXG4gICAgICAvLyB3ZSBuZWVkIHRvIHJlY2hlY2sgdW5pcXVlbmVzcyBhbmQgc29ydFxuICAgICAgdGltZXN0YW1wcyA9IHRoaXMubm9ybWFsaXplKGRhdGEuY29uY2F0KGxhYmVsKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVzdGFtcHMgPSBkYXRhLmxlbmd0aCA/IGRhdGEgOiBsYWJlbDtcbiAgICB9XG4gICAgdGltZXN0YW1wcyA9IHRoaXMuX2NhY2hlLmFsbCA9IHRpbWVzdGFtcHM7XG5cbiAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBNaWxsaXNlY29uZHMgc2luY2UgZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQylcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0RGVjaW1hbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIChpbnRlcnBvbGF0ZSh0aGlzLl90YWJsZSwgdmFsdWUpIC0gdGhpcy5fbWluUG9zKSAvIHRoaXMuX3RhYmxlUmFuZ2U7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5fb2Zmc2V0cztcbiAgICBjb25zdCBkZWNpbWFsID0gdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpIC8gb2Zmc2V0cy5mYWN0b3IgLSBvZmZzZXRzLmVuZDtcbiAgICByZXR1cm4gaW50ZXJwb2xhdGUodGhpcy5fdGFibGUsIGRlY2ltYWwgKiB0aGlzLl90YWJsZVJhbmdlICsgdGhpcy5fbWluUG9zLCB0cnVlKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUaW1lU2VyaWVzU2NhbGU7XG4iLCAiZXhwb3J0ICogZnJvbSAnLi9jb250cm9sbGVycy9pbmRleC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2NvcmUvaW5kZXguanMnO1xuZXhwb3J0ICogZnJvbSAnLi9lbGVtZW50cy9pbmRleC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3BsYXRmb3JtL2luZGV4LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vcGx1Z2lucy9pbmRleC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3NjYWxlcy9pbmRleC5qcyc7XG5cbmltcG9ydCAqIGFzIGNvbnRyb2xsZXJzIGZyb20gJy4vY29udHJvbGxlcnMvaW5kZXguanMnO1xuaW1wb3J0ICogYXMgZWxlbWVudHMgZnJvbSAnLi9lbGVtZW50cy9pbmRleC5qcyc7XG5pbXBvcnQgKiBhcyBwbHVnaW5zIGZyb20gJy4vcGx1Z2lucy9pbmRleC5qcyc7XG5pbXBvcnQgKiBhcyBzY2FsZXMgZnJvbSAnLi9zY2FsZXMvaW5kZXguanMnO1xuXG5leHBvcnQge1xuICBjb250cm9sbGVycyxcbiAgZWxlbWVudHMsXG4gIHBsdWdpbnMsXG4gIHNjYWxlcyxcbn07XG5cbmV4cG9ydCBjb25zdCByZWdpc3RlcmFibGVzID0gW1xuICBjb250cm9sbGVycyxcbiAgZWxlbWVudHMsXG4gIHBsdWdpbnMsXG4gIHNjYWxlcyxcbl07XG4iLCAiLy8gdGhlc2UgYXJlbid0IHJlYWxseSBwcml2YXRlLCBidXQgbm9yIGFyZSB0aGV5IHJlYWxseSB1c2VmdWwgdG8gZG9jdW1lbnRcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBMdXhvbkVycm9yIGV4dGVuZHMgRXJyb3Ige31cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZERhdGVUaW1lRXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHtcbiAgY29uc3RydWN0b3IocmVhc29uKSB7XG4gICAgc3VwZXIoYEludmFsaWQgRGF0ZVRpbWU6ICR7cmVhc29uLnRvTWVzc2FnZSgpfWApO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRJbnRlcnZhbEVycm9yIGV4dGVuZHMgTHV4b25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKHJlYXNvbikge1xuICAgIHN1cGVyKGBJbnZhbGlkIEludGVydmFsOiAke3JlYXNvbi50b01lc3NhZ2UoKX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkRHVyYXRpb25FcnJvciBleHRlbmRzIEx1eG9uRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZWFzb24pIHtcbiAgICBzdXBlcihgSW52YWxpZCBEdXJhdGlvbjogJHtyZWFzb24udG9NZXNzYWdlKCl9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHt9XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRVbml0RXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHtcbiAgY29uc3RydWN0b3IodW5pdCkge1xuICAgIHN1cGVyKGBJbnZhbGlkIHVuaXQgJHt1bml0fWApO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRBcmd1bWVudEVycm9yIGV4dGVuZHMgTHV4b25FcnJvciB7fVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBab25lSXNBYnN0cmFjdEVycm9yIGV4dGVuZHMgTHV4b25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiWm9uZSBpcyBhbiBhYnN0cmFjdCBjbGFzc1wiKTtcbiAgfVxufVxuIiwgIi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5jb25zdCBuID0gXCJudW1lcmljXCIsXG4gIHMgPSBcInNob3J0XCIsXG4gIGwgPSBcImxvbmdcIjtcblxuZXhwb3J0IGNvbnN0IERBVEVfU0hPUlQgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBuLFxuICBkYXk6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURV9NRUQgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBzLFxuICBkYXk6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURV9NRURfV0lUSF9XRUVLREFZID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogcyxcbiAgZGF5OiBuLFxuICB3ZWVrZGF5OiBzLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVfRlVMTCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFX0hVR0UgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG4gIHdlZWtkYXk6IGwsXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV9TSU1QTEUgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FX1dJVEhfU0VDT05EUyA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV9XSVRIX1NIT1JUX09GRlNFVCA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIHRpbWVab25lTmFtZTogcyxcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FX1dJVEhfTE9OR19PRkZTRVQgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICB0aW1lWm9uZU5hbWU6IGwsXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV8yNF9TSU1QTEUgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgaG91ckN5Y2xlOiBcImgyM1wiLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfMjRfV0lUSF9TRUNPTkRTID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgaG91ckN5Y2xlOiBcImgyM1wiLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfMjRfV0lUSF9TSE9SVF9PRkZTRVQgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICBob3VyQ3ljbGU6IFwiaDIzXCIsXG4gIHRpbWVab25lTmFtZTogcyxcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FXzI0X1dJVEhfTE9OR19PRkZTRVQgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICBob3VyQ3ljbGU6IFwiaDIzXCIsXG4gIHRpbWVab25lTmFtZTogbCxcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9TSE9SVCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IG4sXG4gIGRheTogbixcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUyA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IG4sXG4gIGRheTogbixcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfTUVEID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogcyxcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfTUVEX1dJVEhfU0VDT05EUyA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IHMsXG4gIGRheTogbixcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfTUVEX1dJVEhfV0VFS0RBWSA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IHMsXG4gIGRheTogbixcbiAgd2Vla2RheTogcyxcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX0ZVTEwgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgdGltZVpvbmVOYW1lOiBzLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX0ZVTExfV0lUSF9TRUNPTkRTID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbCxcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgdGltZVpvbmVOYW1lOiBzLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX0hVR0UgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG4gIHdlZWtkYXk6IGwsXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgdGltZVpvbmVOYW1lOiBsLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX0hVR0VfV0lUSF9TRUNPTkRTID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbCxcbiAgZGF5OiBuLFxuICB3ZWVrZGF5OiBsLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgdGltZVpvbmVOYW1lOiBsLFxufTtcbiIsICJpbXBvcnQgeyBab25lSXNBYnN0cmFjdEVycm9yIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5cbi8qKlxuICogQGludGVyZmFjZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBab25lIHtcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHpvbmVcbiAgICogQGFic3RyYWN0XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgdHlwZSgpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoaXMgem9uZS5cbiAgICogQGFic3RyYWN0XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbmFtZSgpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgZ2V0IGlhbmFOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBvZmZzZXQgaXMga25vd24gdG8gYmUgZml4ZWQgZm9yIHRoZSB3aG9sZSB5ZWFyLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNVbml2ZXJzYWwoKSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvZmZzZXQncyBjb21tb24gbmFtZSAoc3VjaCBhcyBFU1QpIGF0IHRoZSBzcGVjaWZpZWQgdGltZXN0YW1wXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gdHMgLSBFcG9jaCBtaWxsaXNlY29uZHMgZm9yIHdoaWNoIHRvIGdldCB0aGUgbmFtZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIE9wdGlvbnMgdG8gYWZmZWN0IHRoZSBmb3JtYXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMuZm9ybWF0IC0gV2hhdCBzdHlsZSBvZiBvZmZzZXQgdG8gcmV0dXJuLiBBY2NlcHRzICdsb25nJyBvciAnc2hvcnQnLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5sb2NhbGUgLSBXaGF0IGxvY2FsZSB0byByZXR1cm4gdGhlIG9mZnNldCBuYW1lIGluLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBvZmZzZXROYW1lKHRzLCBvcHRzKSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvZmZzZXQncyB2YWx1ZSBhcyBhIHN0cmluZ1xuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRzIC0gRXBvY2ggbWlsbGlzZWNvbmRzIGZvciB3aGljaCB0byBnZXQgdGhlIG9mZnNldFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0IC0gV2hhdCBzdHlsZSBvZiBvZmZzZXQgdG8gcmV0dXJuLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgQWNjZXB0cyAnbmFycm93JywgJ3Nob3J0Jywgb3IgJ3RlY2hpZScuIFJldHVybmluZyAnKzYnLCAnKzA2OjAwJywgb3IgJyswNjAwJyByZXNwZWN0aXZlbHlcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZm9ybWF0T2Zmc2V0KHRzLCBmb3JtYXQpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgb2Zmc2V0IGluIG1pbnV0ZXMgZm9yIHRoaXMgem9uZSBhdCB0aGUgc3BlY2lmaWVkIHRpbWVzdGFtcC5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0cyAtIEVwb2NoIG1pbGxpc2Vjb25kcyBmb3Igd2hpY2ggdG8gY29tcHV0ZSB0aGUgb2Zmc2V0XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIG9mZnNldCh0cykge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBab25lIGlzIGVxdWFsIHRvIGFub3RoZXIgem9uZVxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtab25lfSBvdGhlclpvbmUgLSB0aGUgem9uZSB0byBjb21wYXJlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBlcXVhbHMob3RoZXJab25lKSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIFpvbmUgaXMgdmFsaWQuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBmb3JtYXRPZmZzZXQsIHBhcnNlWm9uZUluZm8gfSBmcm9tIFwiLi4vaW1wbC91dGlsLmpzXCI7XG5pbXBvcnQgWm9uZSBmcm9tIFwiLi4vem9uZS5qc1wiO1xuXG5sZXQgc2luZ2xldG9uID0gbnVsbDtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBsb2NhbCB6b25lIGZvciB0aGlzIEphdmFTY3JpcHQgZW52aXJvbm1lbnQuXG4gKiBAaW1wbGVtZW50cyB7Wm9uZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3lzdGVtWm9uZSBleHRlbmRzIFpvbmUge1xuICAvKipcbiAgICogR2V0IGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIHRoZSBsb2NhbCB6b25lXG4gICAqIEByZXR1cm4ge1N5c3RlbVpvbmV9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGluc3RhbmNlKCkge1xuICAgIGlmIChzaW5nbGV0b24gPT09IG51bGwpIHtcbiAgICAgIHNpbmdsZXRvbiA9IG5ldyBTeXN0ZW1ab25lKCk7XG4gICAgfVxuICAgIHJldHVybiBzaW5nbGV0b247XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gXCJzeXN0ZW1cIjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgpLnJlc29sdmVkT3B0aW9ucygpLnRpbWVab25lO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVW5pdmVyc2FsKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldE5hbWUodHMsIHsgZm9ybWF0LCBsb2NhbGUgfSkge1xuICAgIHJldHVybiBwYXJzZVpvbmVJbmZvKHRzLCBmb3JtYXQsIGxvY2FsZSk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBmb3JtYXRPZmZzZXQodHMsIGZvcm1hdCkge1xuICAgIHJldHVybiBmb3JtYXRPZmZzZXQodGhpcy5vZmZzZXQodHMpLCBmb3JtYXQpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgb2Zmc2V0KHRzKSB7XG4gICAgcmV0dXJuIC1uZXcgRGF0ZSh0cykuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGVxdWFscyhvdGhlclpvbmUpIHtcbiAgICByZXR1cm4gb3RoZXJab25lLnR5cGUgPT09IFwic3lzdGVtXCI7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuIiwgImltcG9ydCB7IGZvcm1hdE9mZnNldCwgcGFyc2Vab25lSW5mbywgaXNVbmRlZmluZWQsIG9ialRvTG9jYWxUUyB9IGZyb20gXCIuLi9pbXBsL3V0aWwuanNcIjtcbmltcG9ydCBab25lIGZyb20gXCIuLi96b25lLmpzXCI7XG5cbmxldCBkdGZDYWNoZSA9IHt9O1xuZnVuY3Rpb24gbWFrZURURih6b25lKSB7XG4gIGlmICghZHRmQ2FjaGVbem9uZV0pIHtcbiAgICBkdGZDYWNoZVt6b25lXSA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KFwiZW4tVVNcIiwge1xuICAgICAgaG91cjEyOiBmYWxzZSxcbiAgICAgIHRpbWVab25lOiB6b25lLFxuICAgICAgeWVhcjogXCJudW1lcmljXCIsXG4gICAgICBtb250aDogXCIyLWRpZ2l0XCIsXG4gICAgICBkYXk6IFwiMi1kaWdpdFwiLFxuICAgICAgaG91cjogXCIyLWRpZ2l0XCIsXG4gICAgICBtaW51dGU6IFwiMi1kaWdpdFwiLFxuICAgICAgc2Vjb25kOiBcIjItZGlnaXRcIixcbiAgICAgIGVyYTogXCJzaG9ydFwiLFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBkdGZDYWNoZVt6b25lXTtcbn1cblxuY29uc3QgdHlwZVRvUG9zID0ge1xuICB5ZWFyOiAwLFxuICBtb250aDogMSxcbiAgZGF5OiAyLFxuICBlcmE6IDMsXG4gIGhvdXI6IDQsXG4gIG1pbnV0ZTogNSxcbiAgc2Vjb25kOiA2LFxufTtcblxuZnVuY3Rpb24gaGFja3lPZmZzZXQoZHRmLCBkYXRlKSB7XG4gIGNvbnN0IGZvcm1hdHRlZCA9IGR0Zi5mb3JtYXQoZGF0ZSkucmVwbGFjZSgvXFx1MjAwRS9nLCBcIlwiKSxcbiAgICBwYXJzZWQgPSAvKFxcZCspXFwvKFxcZCspXFwvKFxcZCspIChBRHxCQyksPyAoXFxkKyk6KFxcZCspOihcXGQrKS8uZXhlYyhmb3JtYXR0ZWQpLFxuICAgIFssIGZNb250aCwgZkRheSwgZlllYXIsIGZhZE9yQmMsIGZIb3VyLCBmTWludXRlLCBmU2Vjb25kXSA9IHBhcnNlZDtcbiAgcmV0dXJuIFtmWWVhciwgZk1vbnRoLCBmRGF5LCBmYWRPckJjLCBmSG91ciwgZk1pbnV0ZSwgZlNlY29uZF07XG59XG5cbmZ1bmN0aW9uIHBhcnRzT2Zmc2V0KGR0ZiwgZGF0ZSkge1xuICBjb25zdCBmb3JtYXR0ZWQgPSBkdGYuZm9ybWF0VG9QYXJ0cyhkYXRlKTtcbiAgY29uc3QgZmlsbGVkID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZm9ybWF0dGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgeyB0eXBlLCB2YWx1ZSB9ID0gZm9ybWF0dGVkW2ldO1xuICAgIGNvbnN0IHBvcyA9IHR5cGVUb1Bvc1t0eXBlXTtcblxuICAgIGlmICh0eXBlID09PSBcImVyYVwiKSB7XG4gICAgICBmaWxsZWRbcG9zXSA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoIWlzVW5kZWZpbmVkKHBvcykpIHtcbiAgICAgIGZpbGxlZFtwb3NdID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZpbGxlZDtcbn1cblxubGV0IGlhbmFab25lQ2FjaGUgPSB7fTtcbi8qKlxuICogQSB6b25lIGlkZW50aWZpZWQgYnkgYW4gSUFOQSBpZGVudGlmaWVyLCBsaWtlIEFtZXJpY2EvTmV3X1lvcmtcbiAqIEBpbXBsZW1lbnRzIHtab25lfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJQU5BWm9uZSBleHRlbmRzIFpvbmUge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBab25lIG5hbWVcbiAgICogQHJldHVybiB7SUFOQVpvbmV9XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlKG5hbWUpIHtcbiAgICBpZiAoIWlhbmFab25lQ2FjaGVbbmFtZV0pIHtcbiAgICAgIGlhbmFab25lQ2FjaGVbbmFtZV0gPSBuZXcgSUFOQVpvbmUobmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBpYW5hWm9uZUNhY2hlW25hbWVdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IGxvY2FsIGNhY2hlcy4gU2hvdWxkIG9ubHkgYmUgbmVjZXNzYXJ5IGluIHRlc3Rpbmcgc2NlbmFyaW9zLlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgc3RhdGljIHJlc2V0Q2FjaGUoKSB7XG4gICAgaWFuYVpvbmVDYWNoZSA9IHt9O1xuICAgIGR0ZkNhY2hlID0ge307XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBzdHJpbmcgaXMgYSB2YWxpZCBzcGVjaWZpZXIuIFRoaXMgb25seSBjaGVja3MgdGhlIHN0cmluZydzIGZvcm1hdCwgbm90IHRoYXQgdGhlIHNwZWNpZmllciBpZGVudGlmaWVzIGEga25vd24gem9uZTsgc2VlIGlzVmFsaWRab25lIGZvciB0aGF0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcyAtIFRoZSBzdHJpbmcgdG8gY2hlY2sgdmFsaWRpdHkgb25cbiAgICogQGV4YW1wbGUgSUFOQVpvbmUuaXNWYWxpZFNwZWNpZmllcihcIkFtZXJpY2EvTmV3X1lvcmtcIikgLy89PiB0cnVlXG4gICAqIEBleGFtcGxlIElBTkFab25lLmlzVmFsaWRTcGVjaWZpZXIoXCJTcG9ydH5+YmxvcnBcIikgLy89PiBmYWxzZVxuICAgKiBAZGVwcmVjYXRlZCBUaGlzIG1ldGhvZCByZXR1cm5zIGZhbHNlIGZvciBzb21lIHZhbGlkIElBTkEgbmFtZXMuIFVzZSBpc1ZhbGlkWm9uZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzVmFsaWRTcGVjaWZpZXIocykge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRab25lKHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgc3RyaW5nIGlkZW50aWZpZXMgYSByZWFsIHpvbmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHpvbmUgLSBUaGUgc3RyaW5nIHRvIGNoZWNrXG4gICAqIEBleGFtcGxlIElBTkFab25lLmlzVmFsaWRab25lKFwiQW1lcmljYS9OZXdfWW9ya1wiKSAvLz0+IHRydWVcbiAgICogQGV4YW1wbGUgSUFOQVpvbmUuaXNWYWxpZFpvbmUoXCJGYW50YXNpYS9DYXN0bGVcIikgLy89PiBmYWxzZVxuICAgKiBAZXhhbXBsZSBJQU5BWm9uZS5pc1ZhbGlkWm9uZShcIlNwb3J0fn5ibG9ycFwiKSAvLz0+IGZhbHNlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNWYWxpZFpvbmUoem9uZSkge1xuICAgIGlmICghem9uZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoXCJlbi1VU1wiLCB7IHRpbWVab25lOiB6b25lIH0pLmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKiBAcHJpdmF0ZSAqKi9cbiAgICB0aGlzLnpvbmVOYW1lID0gbmFtZTtcbiAgICAvKiogQHByaXZhdGUgKiovXG4gICAgdGhpcy52YWxpZCA9IElBTkFab25lLmlzVmFsaWRab25lKG5hbWUpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIFwiaWFuYVwiO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuem9uZU5hbWU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgaXNVbml2ZXJzYWwoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgb2Zmc2V0TmFtZSh0cywgeyBmb3JtYXQsIGxvY2FsZSB9KSB7XG4gICAgcmV0dXJuIHBhcnNlWm9uZUluZm8odHMsIGZvcm1hdCwgbG9jYWxlLCB0aGlzLm5hbWUpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZm9ybWF0T2Zmc2V0KHRzLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHRoaXMub2Zmc2V0KHRzKSwgZm9ybWF0KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldCh0cykge1xuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh0cyk7XG5cbiAgICBpZiAoaXNOYU4oZGF0ZSkpIHJldHVybiBOYU47XG5cbiAgICBjb25zdCBkdGYgPSBtYWtlRFRGKHRoaXMubmFtZSk7XG4gICAgbGV0IFt5ZWFyLCBtb250aCwgZGF5LCBhZE9yQmMsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kXSA9IGR0Zi5mb3JtYXRUb1BhcnRzXG4gICAgICA/IHBhcnRzT2Zmc2V0KGR0ZiwgZGF0ZSlcbiAgICAgIDogaGFja3lPZmZzZXQoZHRmLCBkYXRlKTtcblxuICAgIGlmIChhZE9yQmMgPT09IFwiQkNcIikge1xuICAgICAgeWVhciA9IC1NYXRoLmFicyh5ZWFyKSArIDE7XG4gICAgfVxuXG4gICAgLy8gYmVjYXVzZSB3ZSdyZSB1c2luZyBob3VyMTIgYW5kIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEwMjU1NjQmY2FuPTImcT0lMjIyNCUzQTAwJTIyJTIwZGF0ZXRpbWVmb3JtYXRcbiAgICBjb25zdCBhZGp1c3RlZEhvdXIgPSBob3VyID09PSAyNCA/IDAgOiBob3VyO1xuXG4gICAgY29uc3QgYXNVVEMgPSBvYmpUb0xvY2FsVFMoe1xuICAgICAgeWVhcixcbiAgICAgIG1vbnRoLFxuICAgICAgZGF5LFxuICAgICAgaG91cjogYWRqdXN0ZWRIb3VyLFxuICAgICAgbWludXRlLFxuICAgICAgc2Vjb25kLFxuICAgICAgbWlsbGlzZWNvbmQ6IDAsXG4gICAgfSk7XG5cbiAgICBsZXQgYXNUUyA9ICtkYXRlO1xuICAgIGNvbnN0IG92ZXIgPSBhc1RTICUgMTAwMDtcbiAgICBhc1RTIC09IG92ZXIgPj0gMCA/IG92ZXIgOiAxMDAwICsgb3ZlcjtcbiAgICByZXR1cm4gKGFzVVRDIC0gYXNUUykgLyAoNjAgKiAxMDAwKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGVxdWFscyhvdGhlclpvbmUpIHtcbiAgICByZXR1cm4gb3RoZXJab25lLnR5cGUgPT09IFwiaWFuYVwiICYmIG90aGVyWm9uZS5uYW1lID09PSB0aGlzLm5hbWU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZDtcbiAgfVxufVxuIiwgImltcG9ydCB7IGhhc0xvY2FsZVdlZWtJbmZvLCBoYXNSZWxhdGl2ZSwgcGFkU3RhcnQsIHJvdW5kVG8sIHZhbGlkYXRlV2Vla1NldHRpbmdzIH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuaW1wb3J0ICogYXMgRW5nbGlzaCBmcm9tIFwiLi9lbmdsaXNoLmpzXCI7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSBcIi4uL3NldHRpbmdzLmpzXCI7XG5pbXBvcnQgRGF0ZVRpbWUgZnJvbSBcIi4uL2RhdGV0aW1lLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4uL3pvbmVzL0lBTkFab25lLmpzXCI7XG5cbi8vIHRvZG8gLSByZW1hcCBjYWNoaW5nXG5cbmxldCBpbnRsTEZDYWNoZSA9IHt9O1xuZnVuY3Rpb24gZ2V0Q2FjaGVkTEYobG9jU3RyaW5nLCBvcHRzID0ge30pIHtcbiAgY29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkoW2xvY1N0cmluZywgb3B0c10pO1xuICBsZXQgZHRmID0gaW50bExGQ2FjaGVba2V5XTtcbiAgaWYgKCFkdGYpIHtcbiAgICBkdGYgPSBuZXcgSW50bC5MaXN0Rm9ybWF0KGxvY1N0cmluZywgb3B0cyk7XG4gICAgaW50bExGQ2FjaGVba2V5XSA9IGR0ZjtcbiAgfVxuICByZXR1cm4gZHRmO1xufVxuXG5sZXQgaW50bERUQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGdldENhY2hlZERURihsb2NTdHJpbmcsIG9wdHMgPSB7fSkge1xuICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShbbG9jU3RyaW5nLCBvcHRzXSk7XG4gIGxldCBkdGYgPSBpbnRsRFRDYWNoZVtrZXldO1xuICBpZiAoIWR0Zikge1xuICAgIGR0ZiA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY1N0cmluZywgb3B0cyk7XG4gICAgaW50bERUQ2FjaGVba2V5XSA9IGR0ZjtcbiAgfVxuICByZXR1cm4gZHRmO1xufVxuXG5sZXQgaW50bE51bUNhY2hlID0ge307XG5mdW5jdGlvbiBnZXRDYWNoZWRJTkYobG9jU3RyaW5nLCBvcHRzID0ge30pIHtcbiAgY29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkoW2xvY1N0cmluZywgb3B0c10pO1xuICBsZXQgaW5mID0gaW50bE51bUNhY2hlW2tleV07XG4gIGlmICghaW5mKSB7XG4gICAgaW5mID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxvY1N0cmluZywgb3B0cyk7XG4gICAgaW50bE51bUNhY2hlW2tleV0gPSBpbmY7XG4gIH1cbiAgcmV0dXJuIGluZjtcbn1cblxubGV0IGludGxSZWxDYWNoZSA9IHt9O1xuZnVuY3Rpb24gZ2V0Q2FjaGVkUlRGKGxvY1N0cmluZywgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHsgYmFzZSwgLi4uY2FjaGVLZXlPcHRzIH0gPSBvcHRzOyAvLyBleGNsdWRlIGBiYXNlYCBmcm9tIHRoZSBvcHRpb25zXG4gIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KFtsb2NTdHJpbmcsIGNhY2hlS2V5T3B0c10pO1xuICBsZXQgaW5mID0gaW50bFJlbENhY2hlW2tleV07XG4gIGlmICghaW5mKSB7XG4gICAgaW5mID0gbmV3IEludGwuUmVsYXRpdmVUaW1lRm9ybWF0KGxvY1N0cmluZywgb3B0cyk7XG4gICAgaW50bFJlbENhY2hlW2tleV0gPSBpbmY7XG4gIH1cbiAgcmV0dXJuIGluZjtcbn1cblxubGV0IHN5c0xvY2FsZUNhY2hlID0gbnVsbDtcbmZ1bmN0aW9uIHN5c3RlbUxvY2FsZSgpIHtcbiAgaWYgKHN5c0xvY2FsZUNhY2hlKSB7XG4gICAgcmV0dXJuIHN5c0xvY2FsZUNhY2hlO1xuICB9IGVsc2Uge1xuICAgIHN5c0xvY2FsZUNhY2hlID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoKS5yZXNvbHZlZE9wdGlvbnMoKS5sb2NhbGU7XG4gICAgcmV0dXJuIHN5c0xvY2FsZUNhY2hlO1xuICB9XG59XG5cbmxldCB3ZWVrSW5mb0NhY2hlID0ge307XG5mdW5jdGlvbiBnZXRDYWNoZWRXZWVrSW5mbyhsb2NTdHJpbmcpIHtcbiAgbGV0IGRhdGEgPSB3ZWVrSW5mb0NhY2hlW2xvY1N0cmluZ107XG4gIGlmICghZGF0YSkge1xuICAgIGNvbnN0IGxvY2FsZSA9IG5ldyBJbnRsLkxvY2FsZShsb2NTdHJpbmcpO1xuICAgIC8vIGJyb3dzZXJzIGN1cnJlbnRseSBpbXBsZW1lbnQgdGhpcyBhcyBhIHByb3BlcnR5LCBidXQgc3BlYyBzYXlzIGl0IHNob3VsZCBiZSBhIGdldHRlciBmdW5jdGlvblxuICAgIGRhdGEgPSBcImdldFdlZWtJbmZvXCIgaW4gbG9jYWxlID8gbG9jYWxlLmdldFdlZWtJbmZvKCkgOiBsb2NhbGUud2Vla0luZm87XG4gICAgd2Vla0luZm9DYWNoZVtsb2NTdHJpbmddID0gZGF0YTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gcGFyc2VMb2NhbGVTdHJpbmcobG9jYWxlU3RyKSB7XG4gIC8vIEkgcmVhbGx5IHdhbnQgdG8gYXZvaWQgd3JpdGluZyBhIEJDUCA0NyBwYXJzZXJcbiAgLy8gc2VlLCBlLmcuIGh0dHBzOi8vZ2l0aHViLmNvbS93b29vcm0vYmNwLTQ3XG4gIC8vIEluc3RlYWQsIHdlJ2xsIGRvIHRoaXM6XG5cbiAgLy8gYSkgaWYgdGhlIHN0cmluZyBoYXMgbm8gLXUgZXh0ZW5zaW9ucywganVzdCBsZWF2ZSBpdCBhbG9uZVxuICAvLyBiKSBpZiBpdCBkb2VzLCB1c2UgSW50bCB0byByZXNvbHZlIGV2ZXJ5dGhpbmdcbiAgLy8gYykgaWYgSW50bCBmYWlscywgdHJ5IGFnYWluIHdpdGhvdXQgdGhlIC11XG5cbiAgLy8gcHJpdmF0ZSBzdWJ0YWdzIGFuZCB1bmljb2RlIHN1YnRhZ3MgaGF2ZSBvcmRlcmluZyByZXF1aXJlbWVudHMsXG4gIC8vIGFuZCB3ZSdyZSBub3QgcHJvcGVybHkgcGFyc2luZyB0aGlzLCBzbyBqdXN0IHN0cmlwIG91dCB0aGVcbiAgLy8gcHJpdmF0ZSBvbmVzIGlmIHRoZXkgZXhpc3QuXG4gIGNvbnN0IHhJbmRleCA9IGxvY2FsZVN0ci5pbmRleE9mKFwiLXgtXCIpO1xuICBpZiAoeEluZGV4ICE9PSAtMSkge1xuICAgIGxvY2FsZVN0ciA9IGxvY2FsZVN0ci5zdWJzdHJpbmcoMCwgeEluZGV4KTtcbiAgfVxuXG4gIGNvbnN0IHVJbmRleCA9IGxvY2FsZVN0ci5pbmRleE9mKFwiLXUtXCIpO1xuICBpZiAodUluZGV4ID09PSAtMSkge1xuICAgIHJldHVybiBbbG9jYWxlU3RyXTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgb3B0aW9ucztcbiAgICBsZXQgc2VsZWN0ZWRTdHI7XG4gICAgdHJ5IHtcbiAgICAgIG9wdGlvbnMgPSBnZXRDYWNoZWREVEYobG9jYWxlU3RyKS5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgICAgIHNlbGVjdGVkU3RyID0gbG9jYWxlU3RyO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnN0IHNtYWxsZXIgPSBsb2NhbGVTdHIuc3Vic3RyaW5nKDAsIHVJbmRleCk7XG4gICAgICBvcHRpb25zID0gZ2V0Q2FjaGVkRFRGKHNtYWxsZXIpLnJlc29sdmVkT3B0aW9ucygpO1xuICAgICAgc2VsZWN0ZWRTdHIgPSBzbWFsbGVyO1xuICAgIH1cblxuICAgIGNvbnN0IHsgbnVtYmVyaW5nU3lzdGVtLCBjYWxlbmRhciB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gW3NlbGVjdGVkU3RyLCBudW1iZXJpbmdTeXN0ZW0sIGNhbGVuZGFyXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnRsQ29uZmlnU3RyaW5nKGxvY2FsZVN0ciwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhcikge1xuICBpZiAob3V0cHV0Q2FsZW5kYXIgfHwgbnVtYmVyaW5nU3lzdGVtKSB7XG4gICAgaWYgKCFsb2NhbGVTdHIuaW5jbHVkZXMoXCItdS1cIikpIHtcbiAgICAgIGxvY2FsZVN0ciArPSBcIi11XCI7XG4gICAgfVxuXG4gICAgaWYgKG91dHB1dENhbGVuZGFyKSB7XG4gICAgICBsb2NhbGVTdHIgKz0gYC1jYS0ke291dHB1dENhbGVuZGFyfWA7XG4gICAgfVxuXG4gICAgaWYgKG51bWJlcmluZ1N5c3RlbSkge1xuICAgICAgbG9jYWxlU3RyICs9IGAtbnUtJHtudW1iZXJpbmdTeXN0ZW19YDtcbiAgICB9XG4gICAgcmV0dXJuIGxvY2FsZVN0cjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbG9jYWxlU3RyO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcE1vbnRocyhmKSB7XG4gIGNvbnN0IG1zID0gW107XG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IDEyOyBpKyspIHtcbiAgICBjb25zdCBkdCA9IERhdGVUaW1lLnV0YygyMDA5LCBpLCAxKTtcbiAgICBtcy5wdXNoKGYoZHQpKTtcbiAgfVxuICByZXR1cm4gbXM7XG59XG5cbmZ1bmN0aW9uIG1hcFdlZWtkYXlzKGYpIHtcbiAgY29uc3QgbXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gNzsgaSsrKSB7XG4gICAgY29uc3QgZHQgPSBEYXRlVGltZS51dGMoMjAxNiwgMTEsIDEzICsgaSk7XG4gICAgbXMucHVzaChmKGR0KSk7XG4gIH1cbiAgcmV0dXJuIG1zO1xufVxuXG5mdW5jdGlvbiBsaXN0U3R1ZmYobG9jLCBsZW5ndGgsIGVuZ2xpc2hGbiwgaW50bEZuKSB7XG4gIGNvbnN0IG1vZGUgPSBsb2MubGlzdGluZ01vZGUoKTtcblxuICBpZiAobW9kZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAobW9kZSA9PT0gXCJlblwiKSB7XG4gICAgcmV0dXJuIGVuZ2xpc2hGbihsZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBpbnRsRm4obGVuZ3RoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdXBwb3J0c0Zhc3ROdW1iZXJzKGxvYykge1xuICBpZiAobG9jLm51bWJlcmluZ1N5c3RlbSAmJiBsb2MubnVtYmVyaW5nU3lzdGVtICE9PSBcImxhdG5cIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFxuICAgICAgbG9jLm51bWJlcmluZ1N5c3RlbSA9PT0gXCJsYXRuXCIgfHxcbiAgICAgICFsb2MubG9jYWxlIHx8XG4gICAgICBsb2MubG9jYWxlLnN0YXJ0c1dpdGgoXCJlblwiKSB8fFxuICAgICAgbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jLmludGwpLnJlc29sdmVkT3B0aW9ucygpLm51bWJlcmluZ1N5c3RlbSA9PT0gXCJsYXRuXCJcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5jbGFzcyBQb2x5TnVtYmVyRm9ybWF0dGVyIHtcbiAgY29uc3RydWN0b3IoaW50bCwgZm9yY2VTaW1wbGUsIG9wdHMpIHtcbiAgICB0aGlzLnBhZFRvID0gb3B0cy5wYWRUbyB8fCAwO1xuICAgIHRoaXMuZmxvb3IgPSBvcHRzLmZsb29yIHx8IGZhbHNlO1xuXG4gICAgY29uc3QgeyBwYWRUbywgZmxvb3IsIC4uLm90aGVyT3B0cyB9ID0gb3B0cztcblxuICAgIGlmICghZm9yY2VTaW1wbGUgfHwgT2JqZWN0LmtleXMob3RoZXJPcHRzKS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBpbnRsT3B0cyA9IHsgdXNlR3JvdXBpbmc6IGZhbHNlLCAuLi5vcHRzIH07XG4gICAgICBpZiAob3B0cy5wYWRUbyA+IDApIGludGxPcHRzLm1pbmltdW1JbnRlZ2VyRGlnaXRzID0gb3B0cy5wYWRUbztcbiAgICAgIHRoaXMuaW5mID0gZ2V0Q2FjaGVkSU5GKGludGwsIGludGxPcHRzKTtcbiAgICB9XG4gIH1cblxuICBmb3JtYXQoaSkge1xuICAgIGlmICh0aGlzLmluZikge1xuICAgICAgY29uc3QgZml4ZWQgPSB0aGlzLmZsb29yID8gTWF0aC5mbG9vcihpKSA6IGk7XG4gICAgICByZXR1cm4gdGhpcy5pbmYuZm9ybWF0KGZpeGVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdG8gbWF0Y2ggdGhlIGJyb3dzZXIncyBudW1iZXJmb3JtYXR0ZXIgZGVmYXVsdHNcbiAgICAgIGNvbnN0IGZpeGVkID0gdGhpcy5mbG9vciA/IE1hdGguZmxvb3IoaSkgOiByb3VuZFRvKGksIDMpO1xuICAgICAgcmV0dXJuIHBhZFN0YXJ0KGZpeGVkLCB0aGlzLnBhZFRvKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmNsYXNzIFBvbHlEYXRlRm9ybWF0dGVyIHtcbiAgY29uc3RydWN0b3IoZHQsIGludGwsIG9wdHMpIHtcbiAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgIHRoaXMub3JpZ2luYWxab25lID0gdW5kZWZpbmVkO1xuXG4gICAgbGV0IHogPSB1bmRlZmluZWQ7XG4gICAgaWYgKHRoaXMub3B0cy50aW1lWm9uZSkge1xuICAgICAgLy8gRG9uJ3QgYXBwbHkgYW55IHdvcmthcm91bmRzIGlmIGEgdGltZVpvbmUgaXMgZXhwbGljaXRseSBwcm92aWRlZCBpbiBvcHRzXG4gICAgICB0aGlzLmR0ID0gZHQ7XG4gICAgfSBlbHNlIGlmIChkdC56b25lLnR5cGUgPT09IFwiZml4ZWRcIikge1xuICAgICAgLy8gVVRDLTggb3IgRXRjL1VUQy04IGFyZSBub3QgcGFydCBvZiB0emRhdGEsIG9ubHkgRXRjL0dNVCs4IGFuZCB0aGUgbGlrZS5cbiAgICAgIC8vIFRoYXQgaXMgd2h5IGZpeGVkLW9mZnNldCBUWiBpcyBzZXQgdG8gdGhhdCB1bmxlc3MgaXQgaXM6XG4gICAgICAvLyAxLiBSZXByZXNlbnRpbmcgb2Zmc2V0IDAgd2hlbiBVVEMgaXMgdXNlZCB0byBtYWludGFpbiBwcmV2aW91cyBiZWhhdmlvciBhbmQgZG9lcyBub3QgYmVjb21lIEdNVC5cbiAgICAgIC8vIDIuIFVuc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyOlxuICAgICAgLy8gICAgLSBzb21lIGRvIG5vdCBzdXBwb3J0IEV0Yy9cbiAgICAgIC8vICAgIC0gPCBFdGMvR01ULTE0LCA+IEV0Yy9HTVQrMTIsIGFuZCAzMC1taW51dGUgb3IgNDUtbWludXRlIG9mZnNldHMgYXJlIG5vdCBwYXJ0IG9mIHR6ZGF0YVxuICAgICAgY29uc3QgZ210T2Zmc2V0ID0gLTEgKiAoZHQub2Zmc2V0IC8gNjApO1xuICAgICAgY29uc3Qgb2Zmc2V0WiA9IGdtdE9mZnNldCA+PSAwID8gYEV0Yy9HTVQrJHtnbXRPZmZzZXR9YCA6IGBFdGMvR01UJHtnbXRPZmZzZXR9YDtcbiAgICAgIGlmIChkdC5vZmZzZXQgIT09IDAgJiYgSUFOQVpvbmUuY3JlYXRlKG9mZnNldFopLnZhbGlkKSB7XG4gICAgICAgIHogPSBvZmZzZXRaO1xuICAgICAgICB0aGlzLmR0ID0gZHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb3QgYWxsIGZpeGVkLW9mZnNldCB6b25lcyBsaWtlIEV0Yy8rNDozMCBhcmUgcHJlc2VudCBpbiB0emRhdGEgc29cbiAgICAgICAgLy8gd2UgbWFudWFsbHkgYXBwbHkgdGhlIG9mZnNldCBhbmQgc3Vic3RpdHV0ZSB0aGUgem9uZSBhcyBuZWVkZWQuXG4gICAgICAgIHogPSBcIlVUQ1wiO1xuICAgICAgICB0aGlzLmR0ID0gZHQub2Zmc2V0ID09PSAwID8gZHQgOiBkdC5zZXRab25lKFwiVVRDXCIpLnBsdXMoeyBtaW51dGVzOiBkdC5vZmZzZXQgfSk7XG4gICAgICAgIHRoaXMub3JpZ2luYWxab25lID0gZHQuem9uZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGR0LnpvbmUudHlwZSA9PT0gXCJzeXN0ZW1cIikge1xuICAgICAgdGhpcy5kdCA9IGR0O1xuICAgIH0gZWxzZSBpZiAoZHQuem9uZS50eXBlID09PSBcImlhbmFcIikge1xuICAgICAgdGhpcy5kdCA9IGR0O1xuICAgICAgeiA9IGR0LnpvbmUubmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ3VzdG9tIHpvbmVzIGNhbiBoYXZlIGFueSBvZmZzZXQgLyBvZmZzZXROYW1lIHNvIHdlIGp1c3QgbWFudWFsbHlcbiAgICAgIC8vIGFwcGx5IHRoZSBvZmZzZXQgYW5kIHN1YnN0aXR1dGUgdGhlIHpvbmUgYXMgbmVlZGVkLlxuICAgICAgeiA9IFwiVVRDXCI7XG4gICAgICB0aGlzLmR0ID0gZHQuc2V0Wm9uZShcIlVUQ1wiKS5wbHVzKHsgbWludXRlczogZHQub2Zmc2V0IH0pO1xuICAgICAgdGhpcy5vcmlnaW5hbFpvbmUgPSBkdC56b25lO1xuICAgIH1cblxuICAgIGNvbnN0IGludGxPcHRzID0geyAuLi50aGlzLm9wdHMgfTtcbiAgICBpbnRsT3B0cy50aW1lWm9uZSA9IGludGxPcHRzLnRpbWVab25lIHx8IHo7XG4gICAgdGhpcy5kdGYgPSBnZXRDYWNoZWREVEYoaW50bCwgaW50bE9wdHMpO1xuICB9XG5cbiAgZm9ybWF0KCkge1xuICAgIGlmICh0aGlzLm9yaWdpbmFsWm9uZSkge1xuICAgICAgLy8gSWYgd2UgaGF2ZSB0byBzdWJzdGl0dXRlIGluIHRoZSBhY3R1YWwgem9uZSBuYW1lLCB3ZSBoYXZlIHRvIHVzZVxuICAgICAgLy8gZm9ybWF0VG9QYXJ0cyBzbyB0aGF0IHRoZSB0aW1lem9uZSBjYW4gYmUgcmVwbGFjZWQuXG4gICAgICByZXR1cm4gdGhpcy5mb3JtYXRUb1BhcnRzKClcbiAgICAgICAgLm1hcCgoeyB2YWx1ZSB9KSA9PiB2YWx1ZSlcbiAgICAgICAgLmpvaW4oXCJcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmR0Zi5mb3JtYXQodGhpcy5kdC50b0pTRGF0ZSgpKTtcbiAgfVxuXG4gIGZvcm1hdFRvUGFydHMoKSB7XG4gICAgY29uc3QgcGFydHMgPSB0aGlzLmR0Zi5mb3JtYXRUb1BhcnRzKHRoaXMuZHQudG9KU0RhdGUoKSk7XG4gICAgaWYgKHRoaXMub3JpZ2luYWxab25lKSB7XG4gICAgICByZXR1cm4gcGFydHMubWFwKChwYXJ0KSA9PiB7XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwidGltZVpvbmVOYW1lXCIpIHtcbiAgICAgICAgICBjb25zdCBvZmZzZXROYW1lID0gdGhpcy5vcmlnaW5hbFpvbmUub2Zmc2V0TmFtZSh0aGlzLmR0LnRzLCB7XG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMuZHQubG9jYWxlLFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLm9wdHMudGltZVpvbmVOYW1lLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5wYXJ0LFxuICAgICAgICAgICAgdmFsdWU6IG9mZnNldE5hbWUsXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcGFydDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cztcbiAgfVxuXG4gIHJlc29sdmVkT3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5kdGYucmVzb2x2ZWRPcHRpb25zKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBQb2x5UmVsRm9ybWF0dGVyIHtcbiAgY29uc3RydWN0b3IoaW50bCwgaXNFbmdsaXNoLCBvcHRzKSB7XG4gICAgdGhpcy5vcHRzID0geyBzdHlsZTogXCJsb25nXCIsIC4uLm9wdHMgfTtcbiAgICBpZiAoIWlzRW5nbGlzaCAmJiBoYXNSZWxhdGl2ZSgpKSB7XG4gICAgICB0aGlzLnJ0ZiA9IGdldENhY2hlZFJURihpbnRsLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICBmb3JtYXQoY291bnQsIHVuaXQpIHtcbiAgICBpZiAodGhpcy5ydGYpIHtcbiAgICAgIHJldHVybiB0aGlzLnJ0Zi5mb3JtYXQoY291bnQsIHVuaXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gRW5nbGlzaC5mb3JtYXRSZWxhdGl2ZVRpbWUodW5pdCwgY291bnQsIHRoaXMub3B0cy5udW1lcmljLCB0aGlzLm9wdHMuc3R5bGUgIT09IFwibG9uZ1wiKTtcbiAgICB9XG4gIH1cblxuICBmb3JtYXRUb1BhcnRzKGNvdW50LCB1bml0KSB7XG4gICAgaWYgKHRoaXMucnRmKSB7XG4gICAgICByZXR1cm4gdGhpcy5ydGYuZm9ybWF0VG9QYXJ0cyhjb3VudCwgdW5pdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgZmFsbGJhY2tXZWVrU2V0dGluZ3MgPSB7XG4gIGZpcnN0RGF5OiAxLFxuICBtaW5pbWFsRGF5czogNCxcbiAgd2Vla2VuZDogWzYsIDddLFxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvY2FsZSB7XG4gIHN0YXRpYyBmcm9tT3B0cyhvcHRzKSB7XG4gICAgcmV0dXJuIExvY2FsZS5jcmVhdGUoXG4gICAgICBvcHRzLmxvY2FsZSxcbiAgICAgIG9wdHMubnVtYmVyaW5nU3lzdGVtLFxuICAgICAgb3B0cy5vdXRwdXRDYWxlbmRhcixcbiAgICAgIG9wdHMud2Vla1NldHRpbmdzLFxuICAgICAgb3B0cy5kZWZhdWx0VG9FTlxuICAgICk7XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhciwgd2Vla1NldHRpbmdzLCBkZWZhdWx0VG9FTiA9IGZhbHNlKSB7XG4gICAgY29uc3Qgc3BlY2lmaWVkTG9jYWxlID0gbG9jYWxlIHx8IFNldHRpbmdzLmRlZmF1bHRMb2NhbGU7XG4gICAgLy8gdGhlIHN5c3RlbSBsb2NhbGUgaXMgdXNlZnVsIGZvciBodW1hbiByZWFkYWJsZSBzdHJpbmdzIGJ1dCBhbm5veWluZyBmb3IgcGFyc2luZy9mb3JtYXR0aW5nIGtub3duIGZvcm1hdHNcbiAgICBjb25zdCBsb2NhbGVSID0gc3BlY2lmaWVkTG9jYWxlIHx8IChkZWZhdWx0VG9FTiA/IFwiZW4tVVNcIiA6IHN5c3RlbUxvY2FsZSgpKTtcbiAgICBjb25zdCBudW1iZXJpbmdTeXN0ZW1SID0gbnVtYmVyaW5nU3lzdGVtIHx8IFNldHRpbmdzLmRlZmF1bHROdW1iZXJpbmdTeXN0ZW07XG4gICAgY29uc3Qgb3V0cHV0Q2FsZW5kYXJSID0gb3V0cHV0Q2FsZW5kYXIgfHwgU2V0dGluZ3MuZGVmYXVsdE91dHB1dENhbGVuZGFyO1xuICAgIGNvbnN0IHdlZWtTZXR0aW5nc1IgPSB2YWxpZGF0ZVdlZWtTZXR0aW5ncyh3ZWVrU2V0dGluZ3MpIHx8IFNldHRpbmdzLmRlZmF1bHRXZWVrU2V0dGluZ3M7XG4gICAgcmV0dXJuIG5ldyBMb2NhbGUobG9jYWxlUiwgbnVtYmVyaW5nU3lzdGVtUiwgb3V0cHV0Q2FsZW5kYXJSLCB3ZWVrU2V0dGluZ3NSLCBzcGVjaWZpZWRMb2NhbGUpO1xuICB9XG5cbiAgc3RhdGljIHJlc2V0Q2FjaGUoKSB7XG4gICAgc3lzTG9jYWxlQ2FjaGUgPSBudWxsO1xuICAgIGludGxEVENhY2hlID0ge307XG4gICAgaW50bE51bUNhY2hlID0ge307XG4gICAgaW50bFJlbENhY2hlID0ge307XG4gIH1cblxuICBzdGF0aWMgZnJvbU9iamVjdCh7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhciwgd2Vla1NldHRpbmdzIH0gPSB7fSkge1xuICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhciwgd2Vla1NldHRpbmdzKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGxvY2FsZSwgbnVtYmVyaW5nLCBvdXRwdXRDYWxlbmRhciwgd2Vla1NldHRpbmdzLCBzcGVjaWZpZWRMb2NhbGUpIHtcbiAgICBjb25zdCBbcGFyc2VkTG9jYWxlLCBwYXJzZWROdW1iZXJpbmdTeXN0ZW0sIHBhcnNlZE91dHB1dENhbGVuZGFyXSA9IHBhcnNlTG9jYWxlU3RyaW5nKGxvY2FsZSk7XG5cbiAgICB0aGlzLmxvY2FsZSA9IHBhcnNlZExvY2FsZTtcbiAgICB0aGlzLm51bWJlcmluZ1N5c3RlbSA9IG51bWJlcmluZyB8fCBwYXJzZWROdW1iZXJpbmdTeXN0ZW0gfHwgbnVsbDtcbiAgICB0aGlzLm91dHB1dENhbGVuZGFyID0gb3V0cHV0Q2FsZW5kYXIgfHwgcGFyc2VkT3V0cHV0Q2FsZW5kYXIgfHwgbnVsbDtcbiAgICB0aGlzLndlZWtTZXR0aW5ncyA9IHdlZWtTZXR0aW5ncztcbiAgICB0aGlzLmludGwgPSBpbnRsQ29uZmlnU3RyaW5nKHRoaXMubG9jYWxlLCB0aGlzLm51bWJlcmluZ1N5c3RlbSwgdGhpcy5vdXRwdXRDYWxlbmRhcik7XG5cbiAgICB0aGlzLndlZWtkYXlzQ2FjaGUgPSB7IGZvcm1hdDoge30sIHN0YW5kYWxvbmU6IHt9IH07XG4gICAgdGhpcy5tb250aHNDYWNoZSA9IHsgZm9ybWF0OiB7fSwgc3RhbmRhbG9uZToge30gfTtcbiAgICB0aGlzLm1lcmlkaWVtQ2FjaGUgPSBudWxsO1xuICAgIHRoaXMuZXJhQ2FjaGUgPSB7fTtcblxuICAgIHRoaXMuc3BlY2lmaWVkTG9jYWxlID0gc3BlY2lmaWVkTG9jYWxlO1xuICAgIHRoaXMuZmFzdE51bWJlcnNDYWNoZWQgPSBudWxsO1xuICB9XG5cbiAgZ2V0IGZhc3ROdW1iZXJzKCkge1xuICAgIGlmICh0aGlzLmZhc3ROdW1iZXJzQ2FjaGVkID09IG51bGwpIHtcbiAgICAgIHRoaXMuZmFzdE51bWJlcnNDYWNoZWQgPSBzdXBwb3J0c0Zhc3ROdW1iZXJzKHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZhc3ROdW1iZXJzQ2FjaGVkO1xuICB9XG5cbiAgbGlzdGluZ01vZGUoKSB7XG4gICAgY29uc3QgaXNBY3R1YWxseUVuID0gdGhpcy5pc0VuZ2xpc2goKTtcbiAgICBjb25zdCBoYXNOb1dlaXJkbmVzcyA9XG4gICAgICAodGhpcy5udW1iZXJpbmdTeXN0ZW0gPT09IG51bGwgfHwgdGhpcy5udW1iZXJpbmdTeXN0ZW0gPT09IFwibGF0blwiKSAmJlxuICAgICAgKHRoaXMub3V0cHV0Q2FsZW5kYXIgPT09IG51bGwgfHwgdGhpcy5vdXRwdXRDYWxlbmRhciA9PT0gXCJncmVnb3J5XCIpO1xuICAgIHJldHVybiBpc0FjdHVhbGx5RW4gJiYgaGFzTm9XZWlyZG5lc3MgPyBcImVuXCIgOiBcImludGxcIjtcbiAgfVxuXG4gIGNsb25lKGFsdHMpIHtcbiAgICBpZiAoIWFsdHMgfHwgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYWx0cykubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIExvY2FsZS5jcmVhdGUoXG4gICAgICAgIGFsdHMubG9jYWxlIHx8IHRoaXMuc3BlY2lmaWVkTG9jYWxlLFxuICAgICAgICBhbHRzLm51bWJlcmluZ1N5c3RlbSB8fCB0aGlzLm51bWJlcmluZ1N5c3RlbSxcbiAgICAgICAgYWx0cy5vdXRwdXRDYWxlbmRhciB8fCB0aGlzLm91dHB1dENhbGVuZGFyLFxuICAgICAgICB2YWxpZGF0ZVdlZWtTZXR0aW5ncyhhbHRzLndlZWtTZXR0aW5ncykgfHwgdGhpcy53ZWVrU2V0dGluZ3MsXG4gICAgICAgIGFsdHMuZGVmYXVsdFRvRU4gfHwgZmFsc2VcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmVkZWZhdWx0VG9FTihhbHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSh7IC4uLmFsdHMsIGRlZmF1bHRUb0VOOiB0cnVlIH0pO1xuICB9XG5cbiAgcmVkZWZhdWx0VG9TeXN0ZW0oYWx0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoeyAuLi5hbHRzLCBkZWZhdWx0VG9FTjogZmFsc2UgfSk7XG4gIH1cblxuICBtb250aHMobGVuZ3RoLCBmb3JtYXQgPSBmYWxzZSkge1xuICAgIHJldHVybiBsaXN0U3R1ZmYodGhpcywgbGVuZ3RoLCBFbmdsaXNoLm1vbnRocywgKCkgPT4ge1xuICAgICAgY29uc3QgaW50bCA9IGZvcm1hdCA/IHsgbW9udGg6IGxlbmd0aCwgZGF5OiBcIm51bWVyaWNcIiB9IDogeyBtb250aDogbGVuZ3RoIH0sXG4gICAgICAgIGZvcm1hdFN0ciA9IGZvcm1hdCA/IFwiZm9ybWF0XCIgOiBcInN0YW5kYWxvbmVcIjtcbiAgICAgIGlmICghdGhpcy5tb250aHNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF0pIHtcbiAgICAgICAgdGhpcy5tb250aHNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF0gPSBtYXBNb250aHMoKGR0KSA9PiB0aGlzLmV4dHJhY3QoZHQsIGludGwsIFwibW9udGhcIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubW9udGhzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdO1xuICAgIH0pO1xuICB9XG5cbiAgd2Vla2RheXMobGVuZ3RoLCBmb3JtYXQgPSBmYWxzZSkge1xuICAgIHJldHVybiBsaXN0U3R1ZmYodGhpcywgbGVuZ3RoLCBFbmdsaXNoLndlZWtkYXlzLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbnRsID0gZm9ybWF0XG4gICAgICAgICAgPyB7IHdlZWtkYXk6IGxlbmd0aCwgeWVhcjogXCJudW1lcmljXCIsIG1vbnRoOiBcImxvbmdcIiwgZGF5OiBcIm51bWVyaWNcIiB9XG4gICAgICAgICAgOiB7IHdlZWtkYXk6IGxlbmd0aCB9LFxuICAgICAgICBmb3JtYXRTdHIgPSBmb3JtYXQgPyBcImZvcm1hdFwiIDogXCJzdGFuZGFsb25lXCI7XG4gICAgICBpZiAoIXRoaXMud2Vla2RheXNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF0pIHtcbiAgICAgICAgdGhpcy53ZWVrZGF5c0NhY2hlW2Zvcm1hdFN0cl1bbGVuZ3RoXSA9IG1hcFdlZWtkYXlzKChkdCkgPT5cbiAgICAgICAgICB0aGlzLmV4dHJhY3QoZHQsIGludGwsIFwid2Vla2RheVwiKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud2Vla2RheXNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF07XG4gICAgfSk7XG4gIH1cblxuICBtZXJpZGllbXMoKSB7XG4gICAgcmV0dXJuIGxpc3RTdHVmZihcbiAgICAgIHRoaXMsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICAoKSA9PiBFbmdsaXNoLm1lcmlkaWVtcyxcbiAgICAgICgpID0+IHtcbiAgICAgICAgLy8gSW4gdGhlb3J5IHRoZXJlIGNvdWxkIGJlIGFyaWJpdHJhcnkgZGF5IHBlcmlvZHMuIFdlJ3JlIGdvbm5hIGFzc3VtZSB0aGVyZSBhcmUgZXhhY3RseSB0d29cbiAgICAgICAgLy8gZm9yIEFNIGFuZCBQTS4gVGhpcyBpcyBwcm9iYWJseSB3cm9uZywgYnV0IGl0J3MgbWFrZXMgcGFyc2luZyB3YXkgZWFzaWVyLlxuICAgICAgICBpZiAoIXRoaXMubWVyaWRpZW1DYWNoZSkge1xuICAgICAgICAgIGNvbnN0IGludGwgPSB7IGhvdXI6IFwibnVtZXJpY1wiLCBob3VyQ3ljbGU6IFwiaDEyXCIgfTtcbiAgICAgICAgICB0aGlzLm1lcmlkaWVtQ2FjaGUgPSBbRGF0ZVRpbWUudXRjKDIwMTYsIDExLCAxMywgOSksIERhdGVUaW1lLnV0YygyMDE2LCAxMSwgMTMsIDE5KV0ubWFwKFxuICAgICAgICAgICAgKGR0KSA9PiB0aGlzLmV4dHJhY3QoZHQsIGludGwsIFwiZGF5cGVyaW9kXCIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLm1lcmlkaWVtQ2FjaGU7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIGVyYXMobGVuZ3RoKSB7XG4gICAgcmV0dXJuIGxpc3RTdHVmZih0aGlzLCBsZW5ndGgsIEVuZ2xpc2guZXJhcywgKCkgPT4ge1xuICAgICAgY29uc3QgaW50bCA9IHsgZXJhOiBsZW5ndGggfTtcblxuICAgICAgLy8gVGhpcyBpcyBwcm9ibGVtYXRpYy4gRGlmZmVyZW50IGNhbGVuZGFycyBhcmUgZ29pbmcgdG8gZGVmaW5lIGVyYXMgdG90YWxseSBkaWZmZXJlbnRseS4gV2hhdCBJIG5lZWQgaXMgdGhlIG1pbmltdW0gc2V0IG9mIGRhdGVzXG4gICAgICAvLyB0byBkZWZpbml0ZWx5IGVudW1lcmF0ZSB0aGVtLlxuICAgICAgaWYgKCF0aGlzLmVyYUNhY2hlW2xlbmd0aF0pIHtcbiAgICAgICAgdGhpcy5lcmFDYWNoZVtsZW5ndGhdID0gW0RhdGVUaW1lLnV0YygtNDAsIDEsIDEpLCBEYXRlVGltZS51dGMoMjAxNywgMSwgMSldLm1hcCgoZHQpID0+XG4gICAgICAgICAgdGhpcy5leHRyYWN0KGR0LCBpbnRsLCBcImVyYVwiKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5lcmFDYWNoZVtsZW5ndGhdO1xuICAgIH0pO1xuICB9XG5cbiAgZXh0cmFjdChkdCwgaW50bE9wdHMsIGZpZWxkKSB7XG4gICAgY29uc3QgZGYgPSB0aGlzLmR0Rm9ybWF0dGVyKGR0LCBpbnRsT3B0cyksXG4gICAgICByZXN1bHRzID0gZGYuZm9ybWF0VG9QYXJ0cygpLFxuICAgICAgbWF0Y2hpbmcgPSByZXN1bHRzLmZpbmQoKG0pID0+IG0udHlwZS50b0xvd2VyQ2FzZSgpID09PSBmaWVsZCk7XG4gICAgcmV0dXJuIG1hdGNoaW5nID8gbWF0Y2hpbmcudmFsdWUgOiBudWxsO1xuICB9XG5cbiAgbnVtYmVyRm9ybWF0dGVyKG9wdHMgPSB7fSkge1xuICAgIC8vIHRoaXMgZm9yY2VzaW1wbGUgb3B0aW9uIGlzIG5ldmVyIHVzZWQgKHRoZSBvbmx5IGNhbGxlciBzaG9ydC1jaXJjdWl0cyBvbiBpdCwgYnV0IGl0IHNlZW1zIHNhZmVyIHRvIGxlYXZlKVxuICAgIC8vIChpbiBjb250cmFzdCwgdGhlIHJlc3Qgb2YgdGhlIGNvbmRpdGlvbiBpcyB1c2VkIGhlYXZpbHkpXG4gICAgcmV0dXJuIG5ldyBQb2x5TnVtYmVyRm9ybWF0dGVyKHRoaXMuaW50bCwgb3B0cy5mb3JjZVNpbXBsZSB8fCB0aGlzLmZhc3ROdW1iZXJzLCBvcHRzKTtcbiAgfVxuXG4gIGR0Rm9ybWF0dGVyKGR0LCBpbnRsT3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBQb2x5RGF0ZUZvcm1hdHRlcihkdCwgdGhpcy5pbnRsLCBpbnRsT3B0cyk7XG4gIH1cblxuICByZWxGb3JtYXR0ZXIob3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBQb2x5UmVsRm9ybWF0dGVyKHRoaXMuaW50bCwgdGhpcy5pc0VuZ2xpc2goKSwgb3B0cyk7XG4gIH1cblxuICBsaXN0Rm9ybWF0dGVyKG9wdHMgPSB7fSkge1xuICAgIHJldHVybiBnZXRDYWNoZWRMRih0aGlzLmludGwsIG9wdHMpO1xuICB9XG5cbiAgaXNFbmdsaXNoKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmxvY2FsZSA9PT0gXCJlblwiIHx8XG4gICAgICB0aGlzLmxvY2FsZS50b0xvd2VyQ2FzZSgpID09PSBcImVuLXVzXCIgfHxcbiAgICAgIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHRoaXMuaW50bCkucmVzb2x2ZWRPcHRpb25zKCkubG9jYWxlLnN0YXJ0c1dpdGgoXCJlbi11c1wiKVxuICAgICk7XG4gIH1cblxuICBnZXRXZWVrU2V0dGluZ3MoKSB7XG4gICAgaWYgKHRoaXMud2Vla1NldHRpbmdzKSB7XG4gICAgICByZXR1cm4gdGhpcy53ZWVrU2V0dGluZ3M7XG4gICAgfSBlbHNlIGlmICghaGFzTG9jYWxlV2Vla0luZm8oKSkge1xuICAgICAgcmV0dXJuIGZhbGxiYWNrV2Vla1NldHRpbmdzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ2V0Q2FjaGVkV2Vla0luZm8odGhpcy5sb2NhbGUpO1xuICAgIH1cbiAgfVxuXG4gIGdldFN0YXJ0T2ZXZWVrKCkge1xuICAgIHJldHVybiB0aGlzLmdldFdlZWtTZXR0aW5ncygpLmZpcnN0RGF5O1xuICB9XG5cbiAgZ2V0TWluRGF5c0luRmlyc3RXZWVrKCkge1xuICAgIHJldHVybiB0aGlzLmdldFdlZWtTZXR0aW5ncygpLm1pbmltYWxEYXlzO1xuICB9XG5cbiAgZ2V0V2Vla2VuZERheXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0V2Vla1NldHRpbmdzKCkud2Vla2VuZDtcbiAgfVxuXG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmxvY2FsZSA9PT0gb3RoZXIubG9jYWxlICYmXG4gICAgICB0aGlzLm51bWJlcmluZ1N5c3RlbSA9PT0gb3RoZXIubnVtYmVyaW5nU3lzdGVtICYmXG4gICAgICB0aGlzLm91dHB1dENhbGVuZGFyID09PSBvdGhlci5vdXRwdXRDYWxlbmRhclxuICAgICk7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBmb3JtYXRPZmZzZXQsIHNpZ25lZE9mZnNldCB9IGZyb20gXCIuLi9pbXBsL3V0aWwuanNcIjtcbmltcG9ydCBab25lIGZyb20gXCIuLi96b25lLmpzXCI7XG5cbmxldCBzaW5nbGV0b24gPSBudWxsO1xuXG4vKipcbiAqIEEgem9uZSB3aXRoIGEgZml4ZWQgb2Zmc2V0IChtZWFuaW5nIG5vIERTVClcbiAqIEBpbXBsZW1lbnRzIHtab25lfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaXhlZE9mZnNldFpvbmUgZXh0ZW5kcyBab25lIHtcbiAgLyoqXG4gICAqIEdldCBhIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiBVVENcbiAgICogQHJldHVybiB7Rml4ZWRPZmZzZXRab25lfVxuICAgKi9cbiAgc3RhdGljIGdldCB1dGNJbnN0YW5jZSgpIHtcbiAgICBpZiAoc2luZ2xldG9uID09PSBudWxsKSB7XG4gICAgICBzaW5nbGV0b24gPSBuZXcgRml4ZWRPZmZzZXRab25lKDApO1xuICAgIH1cbiAgICByZXR1cm4gc2luZ2xldG9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBpbnN0YW5jZSB3aXRoIGEgc3BlY2lmaWVkIG9mZnNldFxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gVGhlIG9mZnNldCBpbiBtaW51dGVzXG4gICAqIEByZXR1cm4ge0ZpeGVkT2Zmc2V0Wm9uZX1cbiAgICovXG4gIHN0YXRpYyBpbnN0YW5jZShvZmZzZXQpIHtcbiAgICByZXR1cm4gb2Zmc2V0ID09PSAwID8gRml4ZWRPZmZzZXRab25lLnV0Y0luc3RhbmNlIDogbmV3IEZpeGVkT2Zmc2V0Wm9uZShvZmZzZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBpbnN0YW5jZSBvZiBGaXhlZE9mZnNldFpvbmUgZnJvbSBhIFVUQyBvZmZzZXQgc3RyaW5nLCBsaWtlIFwiVVRDKzZcIlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcyAtIFRoZSBvZmZzZXQgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBleGFtcGxlIEZpeGVkT2Zmc2V0Wm9uZS5wYXJzZVNwZWNpZmllcihcIlVUQys2XCIpXG4gICAqIEBleGFtcGxlIEZpeGVkT2Zmc2V0Wm9uZS5wYXJzZVNwZWNpZmllcihcIlVUQyswNlwiKVxuICAgKiBAZXhhbXBsZSBGaXhlZE9mZnNldFpvbmUucGFyc2VTcGVjaWZpZXIoXCJVVEMtNjowMFwiKVxuICAgKiBAcmV0dXJuIHtGaXhlZE9mZnNldFpvbmV9XG4gICAqL1xuICBzdGF0aWMgcGFyc2VTcGVjaWZpZXIocykge1xuICAgIGlmIChzKSB7XG4gICAgICBjb25zdCByID0gcy5tYXRjaCgvXnV0Yyg/OihbKy1dXFxkezEsMn0pKD86OihcXGR7Mn0pKT8pPyQvaSk7XG4gICAgICBpZiAocikge1xuICAgICAgICByZXR1cm4gbmV3IEZpeGVkT2Zmc2V0Wm9uZShzaWduZWRPZmZzZXQoclsxXSwgclsyXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKG9mZnNldCkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqIEBwcml2YXRlICoqL1xuICAgIHRoaXMuZml4ZWQgPSBvZmZzZXQ7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gXCJmaXhlZFwiO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZml4ZWQgPT09IDAgPyBcIlVUQ1wiIDogYFVUQyR7Zm9ybWF0T2Zmc2V0KHRoaXMuZml4ZWQsIFwibmFycm93XCIpfWA7XG4gIH1cblxuICBnZXQgaWFuYU5hbWUoKSB7XG4gICAgaWYgKHRoaXMuZml4ZWQgPT09IDApIHtcbiAgICAgIHJldHVybiBcIkV0Yy9VVENcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGBFdGMvR01UJHtmb3JtYXRPZmZzZXQoLXRoaXMuZml4ZWQsIFwibmFycm93XCIpfWA7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgb2Zmc2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZm9ybWF0T2Zmc2V0KHRzLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHRoaXMuZml4ZWQsIGZvcm1hdCk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgaXNVbml2ZXJzYWwoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZml4ZWQ7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBlcXVhbHMob3RoZXJab25lKSB7XG4gICAgcmV0dXJuIG90aGVyWm9uZS50eXBlID09PSBcImZpeGVkXCIgJiYgb3RoZXJab25lLmZpeGVkID09PSB0aGlzLmZpeGVkO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiIsICJpbXBvcnQgWm9uZSBmcm9tIFwiLi4vem9uZS5qc1wiO1xuXG4vKipcbiAqIEEgem9uZSB0aGF0IGZhaWxlZCB0byBwYXJzZS4gWW91IHNob3VsZCBuZXZlciBuZWVkIHRvIGluc3RhbnRpYXRlIHRoaXMuXG4gKiBAaW1wbGVtZW50cyB7Wm9uZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW52YWxpZFpvbmUgZXh0ZW5kcyBab25lIHtcbiAgY29uc3RydWN0b3Ioem9uZU5hbWUpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKiAgQHByaXZhdGUgKi9cbiAgICB0aGlzLnpvbmVOYW1lID0gem9uZU5hbWU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gXCJpbnZhbGlkXCI7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy56b25lTmFtZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBpc1VuaXZlcnNhbCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXROYW1lKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZm9ybWF0T2Zmc2V0KCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgb2Zmc2V0KCkge1xuICAgIHJldHVybiBOYU47XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBlcXVhbHMoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4iLCAiLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmltcG9ydCBab25lIGZyb20gXCIuLi96b25lLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4uL3pvbmVzL0lBTkFab25lLmpzXCI7XG5pbXBvcnQgRml4ZWRPZmZzZXRab25lIGZyb20gXCIuLi96b25lcy9maXhlZE9mZnNldFpvbmUuanNcIjtcbmltcG9ydCBJbnZhbGlkWm9uZSBmcm9tIFwiLi4vem9uZXMvaW52YWxpZFpvbmUuanNcIjtcblxuaW1wb3J0IHsgaXNVbmRlZmluZWQsIGlzU3RyaW5nLCBpc051bWJlciB9IGZyb20gXCIuL3V0aWwuanNcIjtcbmltcG9ydCBTeXN0ZW1ab25lIGZyb20gXCIuLi96b25lcy9zeXN0ZW1ab25lLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVab25lKGlucHV0LCBkZWZhdWx0Wm9uZSkge1xuICBsZXQgb2Zmc2V0O1xuICBpZiAoaXNVbmRlZmluZWQoaW5wdXQpIHx8IGlucHV0ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRab25lO1xuICB9IGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgWm9uZSkge1xuICAgIHJldHVybiBpbnB1dDtcbiAgfSBlbHNlIGlmIChpc1N0cmluZyhpbnB1dCkpIHtcbiAgICBjb25zdCBsb3dlcmVkID0gaW5wdXQudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobG93ZXJlZCA9PT0gXCJkZWZhdWx0XCIpIHJldHVybiBkZWZhdWx0Wm9uZTtcbiAgICBlbHNlIGlmIChsb3dlcmVkID09PSBcImxvY2FsXCIgfHwgbG93ZXJlZCA9PT0gXCJzeXN0ZW1cIikgcmV0dXJuIFN5c3RlbVpvbmUuaW5zdGFuY2U7XG4gICAgZWxzZSBpZiAobG93ZXJlZCA9PT0gXCJ1dGNcIiB8fCBsb3dlcmVkID09PSBcImdtdFwiKSByZXR1cm4gRml4ZWRPZmZzZXRab25lLnV0Y0luc3RhbmNlO1xuICAgIGVsc2UgcmV0dXJuIEZpeGVkT2Zmc2V0Wm9uZS5wYXJzZVNwZWNpZmllcihsb3dlcmVkKSB8fCBJQU5BWm9uZS5jcmVhdGUoaW5wdXQpO1xuICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlucHV0KSkge1xuICAgIHJldHVybiBGaXhlZE9mZnNldFpvbmUuaW5zdGFuY2UoaW5wdXQpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJvYmplY3RcIiAmJiBcIm9mZnNldFwiIGluIGlucHV0ICYmIHR5cGVvZiBpbnB1dC5vZmZzZXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIC8vIFRoaXMgaXMgZHVtYiwgYnV0IHRoZSBpbnN0YW5jZW9mIGNoZWNrIGFib3ZlIGRvZXNuJ3Qgc2VlbSB0byByZWFsbHkgd29ya1xuICAgIC8vIHNvIHdlJ3JlIGR1Y2sgY2hlY2tpbmcgaXRcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBJbnZhbGlkWm9uZShpbnB1dCk7XG4gIH1cbn1cbiIsICJpbXBvcnQgU3lzdGVtWm9uZSBmcm9tIFwiLi96b25lcy9zeXN0ZW1ab25lLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4vem9uZXMvSUFOQVpvbmUuanNcIjtcbmltcG9ydCBMb2NhbGUgZnJvbSBcIi4vaW1wbC9sb2NhbGUuanNcIjtcblxuaW1wb3J0IHsgbm9ybWFsaXplWm9uZSB9IGZyb20gXCIuL2ltcGwvem9uZVV0aWwuanNcIjtcbmltcG9ydCB7IHZhbGlkYXRlV2Vla1NldHRpbmdzIH0gZnJvbSBcIi4vaW1wbC91dGlsLmpzXCI7XG5cbmxldCBub3cgPSAoKSA9PiBEYXRlLm5vdygpLFxuICBkZWZhdWx0Wm9uZSA9IFwic3lzdGVtXCIsXG4gIGRlZmF1bHRMb2NhbGUgPSBudWxsLFxuICBkZWZhdWx0TnVtYmVyaW5nU3lzdGVtID0gbnVsbCxcbiAgZGVmYXVsdE91dHB1dENhbGVuZGFyID0gbnVsbCxcbiAgdHdvRGlnaXRDdXRvZmZZZWFyID0gNjAsXG4gIHRocm93T25JbnZhbGlkLFxuICBkZWZhdWx0V2Vla1NldHRpbmdzID0gbnVsbDtcblxuLyoqXG4gKiBTZXR0aW5ncyBjb250YWlucyBzdGF0aWMgZ2V0dGVycyBhbmQgc2V0dGVycyB0aGF0IGNvbnRyb2wgTHV4b24ncyBvdmVyYWxsIGJlaGF2aW9yLiBMdXhvbiBpcyBhIHNpbXBsZSBsaWJyYXJ5IHdpdGggZmV3IG9wdGlvbnMsIGJ1dCB0aGUgb25lcyBpdCBkb2VzIGhhdmUgbGl2ZSBoZXJlLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZXR0aW5ncyB7XG4gIC8qKlxuICAgKiBHZXQgdGhlIGNhbGxiYWNrIGZvciByZXR1cm5pbmcgdGhlIGN1cnJlbnQgdGltZXN0YW1wLlxuICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAqL1xuICBzdGF0aWMgZ2V0IG5vdygpIHtcbiAgICByZXR1cm4gbm93O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY2FsbGJhY2sgZm9yIHJldHVybmluZyB0aGUgY3VycmVudCB0aW1lc3RhbXAuXG4gICAqIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgbnVtYmVyLCB3aGljaCB3aWxsIGJlIGludGVycHJldGVkIGFzIGFuIEVwb2NoIG1pbGxpc2Vjb25kIGNvdW50XG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICogQGV4YW1wbGUgU2V0dGluZ3Mubm93ID0gKCkgPT4gRGF0ZS5ub3coKSArIDMwMDAgLy8gcHJldGVuZCBpdCBpcyAzIHNlY29uZHMgaW4gdGhlIGZ1dHVyZVxuICAgKiBAZXhhbXBsZSBTZXR0aW5ncy5ub3cgPSAoKSA9PiAwIC8vIGFsd2F5cyBwcmV0ZW5kIGl0J3MgSmFuIDEsIDE5NzAgYXQgbWlkbmlnaHQgaW4gVVRDIHRpbWVcbiAgICovXG4gIHN0YXRpYyBzZXQgbm93KG4pIHtcbiAgICBub3cgPSBuO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZGVmYXVsdCB0aW1lIHpvbmUgdG8gY3JlYXRlIERhdGVUaW1lcyBpbi4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogVXNlIHRoZSB2YWx1ZSBcInN5c3RlbVwiIHRvIHJlc2V0IHRoaXMgdmFsdWUgdG8gdGhlIHN5c3RlbSdzIHRpbWUgem9uZS5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBzZXQgZGVmYXVsdFpvbmUoem9uZSkge1xuICAgIGRlZmF1bHRab25lID0gem9uZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlZmF1bHQgdGltZSB6b25lIG9iamVjdCBjdXJyZW50bHkgdXNlZCB0byBjcmVhdGUgRGF0ZVRpbWVzLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0aGUgc3lzdGVtJ3MgdGltZSB6b25lICh0aGUgb25lIHNldCBvbiB0aGUgbWFjaGluZSB0aGF0IHJ1bnMgdGhpcyBjb2RlKS5cbiAgICogQHR5cGUge1pvbmV9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRab25lKCkge1xuICAgIHJldHVybiBub3JtYWxpemVab25lKGRlZmF1bHRab25lLCBTeXN0ZW1ab25lLmluc3RhbmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlZmF1bHQgbG9jYWxlIHRvIGNyZWF0ZSBEYXRlVGltZXMgd2l0aC4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdExvY2FsZSgpIHtcbiAgICByZXR1cm4gZGVmYXVsdExvY2FsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGRlZmF1bHQgbG9jYWxlIHRvIGNyZWF0ZSBEYXRlVGltZXMgd2l0aC4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBzZXQgZGVmYXVsdExvY2FsZShsb2NhbGUpIHtcbiAgICBkZWZhdWx0TG9jYWxlID0gbG9jYWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVmYXVsdCBudW1iZXJpbmcgc3lzdGVtIHRvIGNyZWF0ZSBEYXRlVGltZXMgd2l0aC4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdE51bWJlcmluZ1N5c3RlbSgpIHtcbiAgICByZXR1cm4gZGVmYXVsdE51bWJlcmluZ1N5c3RlbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGRlZmF1bHQgbnVtYmVyaW5nIHN5c3RlbSB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgc2V0IGRlZmF1bHROdW1iZXJpbmdTeXN0ZW0obnVtYmVyaW5nU3lzdGVtKSB7XG4gICAgZGVmYXVsdE51bWJlcmluZ1N5c3RlbSA9IG51bWJlcmluZ1N5c3RlbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlZmF1bHQgb3V0cHV0IGNhbGVuZGFyIHRvIGNyZWF0ZSBEYXRlVGltZXMgd2l0aC4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdE91dHB1dENhbGVuZGFyKCkge1xuICAgIHJldHVybiBkZWZhdWx0T3V0cHV0Q2FsZW5kYXI7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBkZWZhdWx0IG91dHB1dCBjYWxlbmRhciB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgc2V0IGRlZmF1bHRPdXRwdXRDYWxlbmRhcihvdXRwdXRDYWxlbmRhcikge1xuICAgIGRlZmF1bHRPdXRwdXRDYWxlbmRhciA9IG91dHB1dENhbGVuZGFyO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IFdlZWtTZXR0aW5nc1xuICAgKiBAcHJvcGVydHkge251bWJlcn0gZmlyc3REYXlcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1pbmltYWxEYXlzXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IHdlZWtlbmRcbiAgICovXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1dlZWtTZXR0aW5nc3xudWxsfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0V2Vla1NldHRpbmdzKCkge1xuICAgIHJldHVybiBkZWZhdWx0V2Vla1NldHRpbmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93cyBvdmVycmlkaW5nIHRoZSBkZWZhdWx0IGxvY2FsZSB3ZWVrIHNldHRpbmdzLCBpLmUuIHRoZSBzdGFydCBvZiB0aGUgd2VlaywgdGhlIHdlZWtlbmQgYW5kXG4gICAqIGhvdyBtYW55IGRheXMgYXJlIHJlcXVpcmVkIGluIHRoZSBmaXJzdCB3ZWVrIG9mIGEgeWVhci5cbiAgICogRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWVrU2V0dGluZ3N8bnVsbH0gd2Vla1NldHRpbmdzXG4gICAqL1xuICBzdGF0aWMgc2V0IGRlZmF1bHRXZWVrU2V0dGluZ3Mod2Vla1NldHRpbmdzKSB7XG4gICAgZGVmYXVsdFdlZWtTZXR0aW5ncyA9IHZhbGlkYXRlV2Vla1NldHRpbmdzKHdlZWtTZXR0aW5ncyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXRvZmYgeWVhciBhZnRlciB3aGljaCBhIHN0cmluZyBlbmNvZGluZyBhIHllYXIgYXMgdHdvIGRpZ2l0cyBpcyBpbnRlcnByZXRlZCB0byBvY2N1ciBpbiB0aGUgY3VycmVudCBjZW50dXJ5LlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgc3RhdGljIGdldCB0d29EaWdpdEN1dG9mZlllYXIoKSB7XG4gICAgcmV0dXJuIHR3b0RpZ2l0Q3V0b2ZmWWVhcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGN1dG9mZiB5ZWFyIGFmdGVyIHdoaWNoIGEgc3RyaW5nIGVuY29kaW5nIGEgeWVhciBhcyB0d28gZGlnaXRzIGlzIGludGVycHJldGVkIHRvIG9jY3VyIGluIHRoZSBjdXJyZW50IGNlbnR1cnkuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBleGFtcGxlIFNldHRpbmdzLnR3b0RpZ2l0Q3V0b2ZmWWVhciA9IDAgLy8gY3V0LW9mZiB5ZWFyIGlzIDAsIHNvIGFsbCAneXknIGFyZSBpbnRlcnByZXRlZCBhcyBjdXJyZW50IGNlbnR1cnlcbiAgICogQGV4YW1wbGUgU2V0dGluZ3MudHdvRGlnaXRDdXRvZmZZZWFyID0gNTAgLy8gJzQ5JyAtPiAxOTQ5OyAnNTAnIC0+IDIwNTBcbiAgICogQGV4YW1wbGUgU2V0dGluZ3MudHdvRGlnaXRDdXRvZmZZZWFyID0gMTk1MCAvLyBpbnRlcnByZXRlZCBhcyA1MFxuICAgKiBAZXhhbXBsZSBTZXR0aW5ncy50d29EaWdpdEN1dG9mZlllYXIgPSAyMDUwIC8vIEFMU08gaW50ZXJwcmV0ZWQgYXMgNTBcbiAgICovXG4gIHN0YXRpYyBzZXQgdHdvRGlnaXRDdXRvZmZZZWFyKGN1dG9mZlllYXIpIHtcbiAgICB0d29EaWdpdEN1dG9mZlllYXIgPSBjdXRvZmZZZWFyICUgMTAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB3aGV0aGVyIEx1eG9uIHdpbGwgdGhyb3cgd2hlbiBpdCBlbmNvdW50ZXJzIGludmFsaWQgRGF0ZVRpbWVzLCBEdXJhdGlvbnMsIG9yIEludGVydmFsc1xuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBnZXQgdGhyb3dPbkludmFsaWQoKSB7XG4gICAgcmV0dXJuIHRocm93T25JbnZhbGlkO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB3aGV0aGVyIEx1eG9uIHdpbGwgdGhyb3cgd2hlbiBpdCBlbmNvdW50ZXJzIGludmFsaWQgRGF0ZVRpbWVzLCBEdXJhdGlvbnMsIG9yIEludGVydmFsc1xuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBzZXQgdGhyb3dPbkludmFsaWQodCkge1xuICAgIHRocm93T25JbnZhbGlkID0gdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCBMdXhvbidzIGdsb2JhbCBjYWNoZXMuIFNob3VsZCBvbmx5IGJlIG5lY2Vzc2FyeSBpbiB0ZXN0aW5nIHNjZW5hcmlvcy5cbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIHN0YXRpYyByZXNldENhY2hlcygpIHtcbiAgICBMb2NhbGUucmVzZXRDYWNoZSgpO1xuICAgIElBTkFab25lLnJlc2V0Q2FjaGUoKTtcbiAgfVxufVxuIiwgImV4cG9ydCBkZWZhdWx0IGNsYXNzIEludmFsaWQge1xuICBjb25zdHJ1Y3RvcihyZWFzb24sIGV4cGxhbmF0aW9uKSB7XG4gICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gICAgdGhpcy5leHBsYW5hdGlvbiA9IGV4cGxhbmF0aW9uO1xuICB9XG5cbiAgdG9NZXNzYWdlKCkge1xuICAgIGlmICh0aGlzLmV4cGxhbmF0aW9uKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5yZWFzb259OiAke3RoaXMuZXhwbGFuYXRpb259YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucmVhc29uO1xuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIGludGVnZXJCZXR3ZWVuLFxuICBpc0xlYXBZZWFyLFxuICB0aW1lT2JqZWN0LFxuICBkYXlzSW5ZZWFyLFxuICBkYXlzSW5Nb250aCxcbiAgd2Vla3NJbldlZWtZZWFyLFxuICBpc0ludGVnZXIsXG4gIGlzVW5kZWZpbmVkLFxufSBmcm9tIFwiLi91dGlsLmpzXCI7XG5pbXBvcnQgSW52YWxpZCBmcm9tIFwiLi9pbnZhbGlkLmpzXCI7XG5pbXBvcnQgeyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvciB9IGZyb20gXCIuLi9lcnJvcnMuanNcIjtcblxuY29uc3Qgbm9uTGVhcExhZGRlciA9IFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNF0sXG4gIGxlYXBMYWRkZXIgPSBbMCwgMzEsIDYwLCA5MSwgMTIxLCAxNTIsIDE4MiwgMjEzLCAyNDQsIDI3NCwgMzA1LCAzMzVdO1xuXG5mdW5jdGlvbiB1bml0T3V0T2ZSYW5nZSh1bml0LCB2YWx1ZSkge1xuICByZXR1cm4gbmV3IEludmFsaWQoXG4gICAgXCJ1bml0IG91dCBvZiByYW5nZVwiLFxuICAgIGB5b3Ugc3BlY2lmaWVkICR7dmFsdWV9IChvZiB0eXBlICR7dHlwZW9mIHZhbHVlfSkgYXMgYSAke3VuaXR9LCB3aGljaCBpcyBpbnZhbGlkYFxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGF5T2ZXZWVrKHllYXIsIG1vbnRoLCBkYXkpIHtcbiAgY29uc3QgZCA9IG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoIC0gMSwgZGF5KSk7XG5cbiAgaWYgKHllYXIgPCAxMDAgJiYgeWVhciA+PSAwKSB7XG4gICAgZC5zZXRVVENGdWxsWWVhcihkLmdldFVUQ0Z1bGxZZWFyKCkgLSAxOTAwKTtcbiAgfVxuXG4gIGNvbnN0IGpzID0gZC5nZXRVVENEYXkoKTtcblxuICByZXR1cm4ganMgPT09IDAgPyA3IDoganM7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVPcmRpbmFsKHllYXIsIG1vbnRoLCBkYXkpIHtcbiAgcmV0dXJuIGRheSArIChpc0xlYXBZZWFyKHllYXIpID8gbGVhcExhZGRlciA6IG5vbkxlYXBMYWRkZXIpW21vbnRoIC0gMV07XG59XG5cbmZ1bmN0aW9uIHVuY29tcHV0ZU9yZGluYWwoeWVhciwgb3JkaW5hbCkge1xuICBjb25zdCB0YWJsZSA9IGlzTGVhcFllYXIoeWVhcikgPyBsZWFwTGFkZGVyIDogbm9uTGVhcExhZGRlcixcbiAgICBtb250aDAgPSB0YWJsZS5maW5kSW5kZXgoKGkpID0+IGkgPCBvcmRpbmFsKSxcbiAgICBkYXkgPSBvcmRpbmFsIC0gdGFibGVbbW9udGgwXTtcbiAgcmV0dXJuIHsgbW9udGg6IG1vbnRoMCArIDEsIGRheSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNvV2Vla2RheVRvTG9jYWwoaXNvV2Vla2RheSwgc3RhcnRPZldlZWspIHtcbiAgcmV0dXJuICgoaXNvV2Vla2RheSAtIHN0YXJ0T2ZXZWVrICsgNykgJSA3KSArIDE7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ3JlZ29yaWFuVG9XZWVrKGdyZWdPYmosIG1pbkRheXNJbkZpcnN0V2VlayA9IDQsIHN0YXJ0T2ZXZWVrID0gMSkge1xuICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXkgfSA9IGdyZWdPYmosXG4gICAgb3JkaW5hbCA9IGNvbXB1dGVPcmRpbmFsKHllYXIsIG1vbnRoLCBkYXkpLFxuICAgIHdlZWtkYXkgPSBpc29XZWVrZGF5VG9Mb2NhbChkYXlPZldlZWsoeWVhciwgbW9udGgsIGRheSksIHN0YXJ0T2ZXZWVrKTtcblxuICBsZXQgd2Vla051bWJlciA9IE1hdGguZmxvb3IoKG9yZGluYWwgLSB3ZWVrZGF5ICsgMTQgLSBtaW5EYXlzSW5GaXJzdFdlZWspIC8gNyksXG4gICAgd2Vla1llYXI7XG5cbiAgaWYgKHdlZWtOdW1iZXIgPCAxKSB7XG4gICAgd2Vla1llYXIgPSB5ZWFyIC0gMTtcbiAgICB3ZWVrTnVtYmVyID0gd2Vla3NJbldlZWtZZWFyKHdlZWtZZWFyLCBtaW5EYXlzSW5GaXJzdFdlZWssIHN0YXJ0T2ZXZWVrKTtcbiAgfSBlbHNlIGlmICh3ZWVrTnVtYmVyID4gd2Vla3NJbldlZWtZZWFyKHllYXIsIG1pbkRheXNJbkZpcnN0V2Vlaywgc3RhcnRPZldlZWspKSB7XG4gICAgd2Vla1llYXIgPSB5ZWFyICsgMTtcbiAgICB3ZWVrTnVtYmVyID0gMTtcbiAgfSBlbHNlIHtcbiAgICB3ZWVrWWVhciA9IHllYXI7XG4gIH1cblxuICByZXR1cm4geyB3ZWVrWWVhciwgd2Vla051bWJlciwgd2Vla2RheSwgLi4udGltZU9iamVjdChncmVnT2JqKSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2Vla1RvR3JlZ29yaWFuKHdlZWtEYXRhLCBtaW5EYXlzSW5GaXJzdFdlZWsgPSA0LCBzdGFydE9mV2VlayA9IDEpIHtcbiAgY29uc3QgeyB3ZWVrWWVhciwgd2Vla051bWJlciwgd2Vla2RheSB9ID0gd2Vla0RhdGEsXG4gICAgd2Vla2RheU9mSmFuNCA9IGlzb1dlZWtkYXlUb0xvY2FsKGRheU9mV2Vlayh3ZWVrWWVhciwgMSwgbWluRGF5c0luRmlyc3RXZWVrKSwgc3RhcnRPZldlZWspLFxuICAgIHllYXJJbkRheXMgPSBkYXlzSW5ZZWFyKHdlZWtZZWFyKTtcblxuICBsZXQgb3JkaW5hbCA9IHdlZWtOdW1iZXIgKiA3ICsgd2Vla2RheSAtIHdlZWtkYXlPZkphbjQgLSA3ICsgbWluRGF5c0luRmlyc3RXZWVrLFxuICAgIHllYXI7XG5cbiAgaWYgKG9yZGluYWwgPCAxKSB7XG4gICAgeWVhciA9IHdlZWtZZWFyIC0gMTtcbiAgICBvcmRpbmFsICs9IGRheXNJblllYXIoeWVhcik7XG4gIH0gZWxzZSBpZiAob3JkaW5hbCA+IHllYXJJbkRheXMpIHtcbiAgICB5ZWFyID0gd2Vla1llYXIgKyAxO1xuICAgIG9yZGluYWwgLT0gZGF5c0luWWVhcih3ZWVrWWVhcik7XG4gIH0gZWxzZSB7XG4gICAgeWVhciA9IHdlZWtZZWFyO1xuICB9XG5cbiAgY29uc3QgeyBtb250aCwgZGF5IH0gPSB1bmNvbXB1dGVPcmRpbmFsKHllYXIsIG9yZGluYWwpO1xuICByZXR1cm4geyB5ZWFyLCBtb250aCwgZGF5LCAuLi50aW1lT2JqZWN0KHdlZWtEYXRhKSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3JlZ29yaWFuVG9PcmRpbmFsKGdyZWdEYXRhKSB7XG4gIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSB9ID0gZ3JlZ0RhdGE7XG4gIGNvbnN0IG9yZGluYWwgPSBjb21wdXRlT3JkaW5hbCh5ZWFyLCBtb250aCwgZGF5KTtcbiAgcmV0dXJuIHsgeWVhciwgb3JkaW5hbCwgLi4udGltZU9iamVjdChncmVnRGF0YSkgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9yZGluYWxUb0dyZWdvcmlhbihvcmRpbmFsRGF0YSkge1xuICBjb25zdCB7IHllYXIsIG9yZGluYWwgfSA9IG9yZGluYWxEYXRhO1xuICBjb25zdCB7IG1vbnRoLCBkYXkgfSA9IHVuY29tcHV0ZU9yZGluYWwoeWVhciwgb3JkaW5hbCk7XG4gIHJldHVybiB7IHllYXIsIG1vbnRoLCBkYXksIC4uLnRpbWVPYmplY3Qob3JkaW5hbERhdGEpIH07XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgbG9jYWwgd2VlayB1bml0cyBsaWtlIGxvY2FsV2Vla2RheSBhcmUgdXNlZCBpbiBvYmouXG4gKiBJZiBzbywgdmFsaWRhdGVzIHRoYXQgdGhleSBhcmUgbm90IG1peGVkIHdpdGggSVNPIHdlZWsgdW5pdHMgYW5kIHRoZW4gY29waWVzIHRoZW0gdG8gdGhlIG5vcm1hbCB3ZWVrIHVuaXQgcHJvcGVydGllcy5cbiAqIE1vZGlmaWVzIG9iaiBpbi1wbGFjZSFcbiAqIEBwYXJhbSBvYmogdGhlIG9iamVjdCB2YWx1ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZXNMb2NhbFdlZWtWYWx1ZXMob2JqLCBsb2MpIHtcbiAgY29uc3QgaGFzTG9jYWxlV2Vla0RhdGEgPVxuICAgICFpc1VuZGVmaW5lZChvYmoubG9jYWxXZWVrZGF5KSB8fFxuICAgICFpc1VuZGVmaW5lZChvYmoubG9jYWxXZWVrTnVtYmVyKSB8fFxuICAgICFpc1VuZGVmaW5lZChvYmoubG9jYWxXZWVrWWVhcik7XG4gIGlmIChoYXNMb2NhbGVXZWVrRGF0YSkge1xuICAgIGNvbnN0IGhhc0lzb1dlZWtEYXRhID1cbiAgICAgICFpc1VuZGVmaW5lZChvYmoud2Vla2RheSkgfHwgIWlzVW5kZWZpbmVkKG9iai53ZWVrTnVtYmVyKSB8fCAhaXNVbmRlZmluZWQob2JqLndlZWtZZWFyKTtcblxuICAgIGlmIChoYXNJc29XZWVrRGF0YSkge1xuICAgICAgdGhyb3cgbmV3IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yKFxuICAgICAgICBcIkNhbm5vdCBtaXggbG9jYWxlLWJhc2VkIHdlZWsgZmllbGRzIHdpdGggSVNPLWJhc2VkIHdlZWsgZmllbGRzXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQob2JqLmxvY2FsV2Vla2RheSkpIG9iai53ZWVrZGF5ID0gb2JqLmxvY2FsV2Vla2RheTtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKG9iai5sb2NhbFdlZWtOdW1iZXIpKSBvYmoud2Vla051bWJlciA9IG9iai5sb2NhbFdlZWtOdW1iZXI7XG4gICAgaWYgKCFpc1VuZGVmaW5lZChvYmoubG9jYWxXZWVrWWVhcikpIG9iai53ZWVrWWVhciA9IG9iai5sb2NhbFdlZWtZZWFyO1xuICAgIGRlbGV0ZSBvYmoubG9jYWxXZWVrZGF5O1xuICAgIGRlbGV0ZSBvYmoubG9jYWxXZWVrTnVtYmVyO1xuICAgIGRlbGV0ZSBvYmoubG9jYWxXZWVrWWVhcjtcbiAgICByZXR1cm4ge1xuICAgICAgbWluRGF5c0luRmlyc3RXZWVrOiBsb2MuZ2V0TWluRGF5c0luRmlyc3RXZWVrKCksXG4gICAgICBzdGFydE9mV2VlazogbG9jLmdldFN0YXJ0T2ZXZWVrKCksXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyBtaW5EYXlzSW5GaXJzdFdlZWs6IDQsIHN0YXJ0T2ZXZWVrOiAxIH07XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0ludmFsaWRXZWVrRGF0YShvYmosIG1pbkRheXNJbkZpcnN0V2VlayA9IDQsIHN0YXJ0T2ZXZWVrID0gMSkge1xuICBjb25zdCB2YWxpZFllYXIgPSBpc0ludGVnZXIob2JqLndlZWtZZWFyKSxcbiAgICB2YWxpZFdlZWsgPSBpbnRlZ2VyQmV0d2VlbihcbiAgICAgIG9iai53ZWVrTnVtYmVyLFxuICAgICAgMSxcbiAgICAgIHdlZWtzSW5XZWVrWWVhcihvYmoud2Vla1llYXIsIG1pbkRheXNJbkZpcnN0V2Vlaywgc3RhcnRPZldlZWspXG4gICAgKSxcbiAgICB2YWxpZFdlZWtkYXkgPSBpbnRlZ2VyQmV0d2VlbihvYmoud2Vla2RheSwgMSwgNyk7XG5cbiAgaWYgKCF2YWxpZFllYXIpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJ3ZWVrWWVhclwiLCBvYmoud2Vla1llYXIpO1xuICB9IGVsc2UgaWYgKCF2YWxpZFdlZWspIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJ3ZWVrXCIsIG9iai53ZWVrTnVtYmVyKTtcbiAgfSBlbHNlIGlmICghdmFsaWRXZWVrZGF5KSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwid2Vla2RheVwiLCBvYmoud2Vla2RheSk7XG4gIH0gZWxzZSByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNJbnZhbGlkT3JkaW5hbERhdGEob2JqKSB7XG4gIGNvbnN0IHZhbGlkWWVhciA9IGlzSW50ZWdlcihvYmoueWVhciksXG4gICAgdmFsaWRPcmRpbmFsID0gaW50ZWdlckJldHdlZW4ob2JqLm9yZGluYWwsIDEsIGRheXNJblllYXIob2JqLnllYXIpKTtcblxuICBpZiAoIXZhbGlkWWVhcikge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcInllYXJcIiwgb2JqLnllYXIpO1xuICB9IGVsc2UgaWYgKCF2YWxpZE9yZGluYWwpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJvcmRpbmFsXCIsIG9iai5vcmRpbmFsKTtcbiAgfSBlbHNlIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0ludmFsaWRHcmVnb3JpYW5EYXRhKG9iaikge1xuICBjb25zdCB2YWxpZFllYXIgPSBpc0ludGVnZXIob2JqLnllYXIpLFxuICAgIHZhbGlkTW9udGggPSBpbnRlZ2VyQmV0d2VlbihvYmoubW9udGgsIDEsIDEyKSxcbiAgICB2YWxpZERheSA9IGludGVnZXJCZXR3ZWVuKG9iai5kYXksIDEsIGRheXNJbk1vbnRoKG9iai55ZWFyLCBvYmoubW9udGgpKTtcblxuICBpZiAoIXZhbGlkWWVhcikge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcInllYXJcIiwgb2JqLnllYXIpO1xuICB9IGVsc2UgaWYgKCF2YWxpZE1vbnRoKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwibW9udGhcIiwgb2JqLm1vbnRoKTtcbiAgfSBlbHNlIGlmICghdmFsaWREYXkpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJkYXlcIiwgb2JqLmRheSk7XG4gIH0gZWxzZSByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNJbnZhbGlkVGltZURhdGEob2JqKSB7XG4gIGNvbnN0IHsgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kIH0gPSBvYmo7XG4gIGNvbnN0IHZhbGlkSG91ciA9XG4gICAgICBpbnRlZ2VyQmV0d2Vlbihob3VyLCAwLCAyMykgfHxcbiAgICAgIChob3VyID09PSAyNCAmJiBtaW51dGUgPT09IDAgJiYgc2Vjb25kID09PSAwICYmIG1pbGxpc2Vjb25kID09PSAwKSxcbiAgICB2YWxpZE1pbnV0ZSA9IGludGVnZXJCZXR3ZWVuKG1pbnV0ZSwgMCwgNTkpLFxuICAgIHZhbGlkU2Vjb25kID0gaW50ZWdlckJldHdlZW4oc2Vjb25kLCAwLCA1OSksXG4gICAgdmFsaWRNaWxsaXNlY29uZCA9IGludGVnZXJCZXR3ZWVuKG1pbGxpc2Vjb25kLCAwLCA5OTkpO1xuXG4gIGlmICghdmFsaWRIb3VyKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwiaG91clwiLCBob3VyKTtcbiAgfSBlbHNlIGlmICghdmFsaWRNaW51dGUpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJtaW51dGVcIiwgbWludXRlKTtcbiAgfSBlbHNlIGlmICghdmFsaWRTZWNvbmQpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJzZWNvbmRcIiwgc2Vjb25kKTtcbiAgfSBlbHNlIGlmICghdmFsaWRNaWxsaXNlY29uZCkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIm1pbGxpc2Vjb25kXCIsIG1pbGxpc2Vjb25kKTtcbiAgfSBlbHNlIHJldHVybiBmYWxzZTtcbn1cbiIsICIvKlxuICBUaGlzIGlzIGp1c3QgYSBqdW5rIGRyYXdlciwgY29udGFpbmluZyBhbnl0aGluZyB1c2VkIGFjcm9zcyBtdWx0aXBsZSBjbGFzc2VzLlxuICBCZWNhdXNlIEx1eG9uIGlzIHNtYWxsKGlzaCksIHRoaXMgc2hvdWxkIHN0YXkgc21hbGwgYW5kIHdlIHdvbid0IHdvcnJ5IGFib3V0IHNwbGl0dGluZ1xuICBpdCB1cCBpbnRvLCBzYXksIHBhcnNpbmdVdGlsLmpzIGFuZCBiYXNpY1V0aWwuanMgYW5kIHNvIG9uLiBCdXQgdGhleSBhcmUgZGl2aWRlZCB1cCBieSBmZWF0dXJlIGFyZWEuXG4qL1xuXG5pbXBvcnQgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9IGZyb20gXCIuLi9lcnJvcnMuanNcIjtcbmltcG9ydCBTZXR0aW5ncyBmcm9tIFwiLi4vc2V0dGluZ3MuanNcIjtcbmltcG9ydCB7IGRheU9mV2VlaywgaXNvV2Vla2RheVRvTG9jYWwgfSBmcm9tIFwiLi9jb252ZXJzaW9ucy5qc1wiO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuLy8gVFlQRVNcblxuZXhwb3J0IGZ1bmN0aW9uIGlzVW5kZWZpbmVkKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSBcInVuZGVmaW5lZFwiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09IFwibnVtYmVyXCI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0ludGVnZXIobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09IFwibnVtYmVyXCIgJiYgbyAlIDEgPT09IDA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyhvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGF0ZShvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09IFwiW29iamVjdCBEYXRlXVwiO1xufVxuXG4vLyBDQVBBQklMSVRJRVNcblxuZXhwb3J0IGZ1bmN0aW9uIGhhc1JlbGF0aXZlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB0eXBlb2YgSW50bCAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhIUludGwuUmVsYXRpdmVUaW1lRm9ybWF0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNMb2NhbGVXZWVrSW5mbygpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gKFxuICAgICAgdHlwZW9mIEludGwgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICEhSW50bC5Mb2NhbGUgJiZcbiAgICAgIChcIndlZWtJbmZvXCIgaW4gSW50bC5Mb2NhbGUucHJvdG90eXBlIHx8IFwiZ2V0V2Vla0luZm9cIiBpbiBJbnRsLkxvY2FsZS5wcm90b3R5cGUpXG4gICAgKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBPQkpFQ1RTIEFORCBBUlJBWVNcblxuZXhwb3J0IGZ1bmN0aW9uIG1heWJlQXJyYXkodGhpbmcpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodGhpbmcpID8gdGhpbmcgOiBbdGhpbmddO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmVzdEJ5KGFyciwgYnksIGNvbXBhcmUpIHtcbiAgaWYgKGFyci5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBhcnIucmVkdWNlKChiZXN0LCBuZXh0KSA9PiB7XG4gICAgY29uc3QgcGFpciA9IFtieShuZXh0KSwgbmV4dF07XG4gICAgaWYgKCFiZXN0KSB7XG4gICAgICByZXR1cm4gcGFpcjtcbiAgICB9IGVsc2UgaWYgKGNvbXBhcmUoYmVzdFswXSwgcGFpclswXSkgPT09IGJlc3RbMF0pIHtcbiAgICAgIHJldHVybiBiZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGFpcjtcbiAgICB9XG4gIH0sIG51bGwpWzFdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGljayhvYmosIGtleXMpIHtcbiAgcmV0dXJuIGtleXMucmVkdWNlKChhLCBrKSA9PiB7XG4gICAgYVtrXSA9IG9ialtrXTtcbiAgICByZXR1cm4gYTtcbiAgfSwge30pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlV2Vla1NldHRpbmdzKHNldHRpbmdzKSB7XG4gIGlmIChzZXR0aW5ncyA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNldHRpbmdzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiV2VlayBzZXR0aW5ncyBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoXG4gICAgICAhaW50ZWdlckJldHdlZW4oc2V0dGluZ3MuZmlyc3REYXksIDEsIDcpIHx8XG4gICAgICAhaW50ZWdlckJldHdlZW4oc2V0dGluZ3MubWluaW1hbERheXMsIDEsIDcpIHx8XG4gICAgICAhQXJyYXkuaXNBcnJheShzZXR0aW5ncy53ZWVrZW5kKSB8fFxuICAgICAgc2V0dGluZ3Mud2Vla2VuZC5zb21lKCh2KSA9PiAhaW50ZWdlckJldHdlZW4odiwgMSwgNykpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJJbnZhbGlkIHdlZWsgc2V0dGluZ3NcIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBmaXJzdERheTogc2V0dGluZ3MuZmlyc3REYXksXG4gICAgICBtaW5pbWFsRGF5czogc2V0dGluZ3MubWluaW1hbERheXMsXG4gICAgICB3ZWVrZW5kOiBBcnJheS5mcm9tKHNldHRpbmdzLndlZWtlbmQpLFxuICAgIH07XG4gIH1cbn1cblxuLy8gTlVNQkVSUyBBTkQgU1RSSU5HU1xuXG5leHBvcnQgZnVuY3Rpb24gaW50ZWdlckJldHdlZW4odGhpbmcsIGJvdHRvbSwgdG9wKSB7XG4gIHJldHVybiBpc0ludGVnZXIodGhpbmcpICYmIHRoaW5nID49IGJvdHRvbSAmJiB0aGluZyA8PSB0b3A7XG59XG5cbi8vIHggJSBuIGJ1dCB0YWtlcyB0aGUgc2lnbiBvZiBuIGluc3RlYWQgb2YgeFxuZXhwb3J0IGZ1bmN0aW9uIGZsb29yTW9kKHgsIG4pIHtcbiAgcmV0dXJuIHggLSBuICogTWF0aC5mbG9vcih4IC8gbik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYWRTdGFydChpbnB1dCwgbiA9IDIpIHtcbiAgY29uc3QgaXNOZWcgPSBpbnB1dCA8IDA7XG4gIGxldCBwYWRkZWQ7XG4gIGlmIChpc05lZykge1xuICAgIHBhZGRlZCA9IFwiLVwiICsgKFwiXCIgKyAtaW5wdXQpLnBhZFN0YXJ0KG4sIFwiMFwiKTtcbiAgfSBlbHNlIHtcbiAgICBwYWRkZWQgPSAoXCJcIiArIGlucHV0KS5wYWRTdGFydChuLCBcIjBcIik7XG4gIH1cbiAgcmV0dXJuIHBhZGRlZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSW50ZWdlcihzdHJpbmcpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHN0cmluZykgfHwgc3RyaW5nID09PSBudWxsIHx8IHN0cmluZyA9PT0gXCJcIikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHN0cmluZywgMTApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUZsb2F0aW5nKHN0cmluZykge1xuICBpZiAoaXNVbmRlZmluZWQoc3RyaW5nKSB8fCBzdHJpbmcgPT09IG51bGwgfHwgc3RyaW5nID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChzdHJpbmcpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZU1pbGxpcyhmcmFjdGlvbikge1xuICAvLyBSZXR1cm4gdW5kZWZpbmVkIChpbnN0ZWFkIG9mIDApIGluIHRoZXNlIGNhc2VzLCB3aGVyZSBmcmFjdGlvbiBpcyBub3Qgc2V0XG4gIGlmIChpc1VuZGVmaW5lZChmcmFjdGlvbikgfHwgZnJhY3Rpb24gPT09IG51bGwgfHwgZnJhY3Rpb24gPT09IFwiXCIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGYgPSBwYXJzZUZsb2F0KFwiMC5cIiArIGZyYWN0aW9uKSAqIDEwMDA7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoZik7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kVG8obnVtYmVyLCBkaWdpdHMsIHRvd2FyZFplcm8gPSBmYWxzZSkge1xuICBjb25zdCBmYWN0b3IgPSAxMCAqKiBkaWdpdHMsXG4gICAgcm91bmRlciA9IHRvd2FyZFplcm8gPyBNYXRoLnRydW5jIDogTWF0aC5yb3VuZDtcbiAgcmV0dXJuIHJvdW5kZXIobnVtYmVyICogZmFjdG9yKSAvIGZhY3Rvcjtcbn1cblxuLy8gREFURSBCQVNJQ1NcblxuZXhwb3J0IGZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICByZXR1cm4geWVhciAlIDQgPT09IDAgJiYgKHllYXIgJSAxMDAgIT09IDAgfHwgeWVhciAlIDQwMCA9PT0gMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkYXlzSW5ZZWFyKHllYXIpIHtcbiAgcmV0dXJuIGlzTGVhcFllYXIoeWVhcikgPyAzNjYgOiAzNjU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkYXlzSW5Nb250aCh5ZWFyLCBtb250aCkge1xuICBjb25zdCBtb2RNb250aCA9IGZsb29yTW9kKG1vbnRoIC0gMSwgMTIpICsgMSxcbiAgICBtb2RZZWFyID0geWVhciArIChtb250aCAtIG1vZE1vbnRoKSAvIDEyO1xuXG4gIGlmIChtb2RNb250aCA9PT0gMikge1xuICAgIHJldHVybiBpc0xlYXBZZWFyKG1vZFllYXIpID8gMjkgOiAyODtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gWzMxLCBudWxsLCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV1bbW9kTW9udGggLSAxXTtcbiAgfVxufVxuXG4vLyBjb252ZXJ0IGEgY2FsZW5kYXIgb2JqZWN0IHRvIGEgbG9jYWwgdGltZXN0YW1wIChlcG9jaCwgYnV0IHdpdGggdGhlIG9mZnNldCBiYWtlZCBpbilcbmV4cG9ydCBmdW5jdGlvbiBvYmpUb0xvY2FsVFMob2JqKSB7XG4gIGxldCBkID0gRGF0ZS5VVEMoXG4gICAgb2JqLnllYXIsXG4gICAgb2JqLm1vbnRoIC0gMSxcbiAgICBvYmouZGF5LFxuICAgIG9iai5ob3VyLFxuICAgIG9iai5taW51dGUsXG4gICAgb2JqLnNlY29uZCxcbiAgICBvYmoubWlsbGlzZWNvbmRcbiAgKTtcblxuICAvLyBmb3IgbGVnYWN5IHJlYXNvbnMsIHllYXJzIGJldHdlZW4gMCBhbmQgOTkgYXJlIGludGVycHJldGVkIGFzIDE5WFg7IHJldmVydCB0aGF0XG4gIGlmIChvYmoueWVhciA8IDEwMCAmJiBvYmoueWVhciA+PSAwKSB7XG4gICAgZCA9IG5ldyBEYXRlKGQpO1xuICAgIC8vIHNldCB0aGUgbW9udGggYW5kIGRheSBhZ2FpbiwgdGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSB5ZWFyIDIwMDAgaXMgYSBsZWFwIHllYXIsIGJ1dCB5ZWFyIDEwMCBpcyBub3RcbiAgICAvLyBzbyBpZiBvYmoueWVhciBpcyBpbiA5OSwgYnV0IG9iai5kYXkgbWFrZXMgaXQgcm9sbCBvdmVyIGludG8geWVhciAxMDAsXG4gICAgLy8gdGhlIGNhbGN1bGF0aW9ucyBkb25lIGJ5IERhdGUuVVRDIGFyZSB1c2luZyB5ZWFyIDIwMDAgLSB3aGljaCBpcyBpbmNvcnJlY3RcbiAgICBkLnNldFVUQ0Z1bGxZZWFyKG9iai55ZWFyLCBvYmoubW9udGggLSAxLCBvYmouZGF5KTtcbiAgfVxuICByZXR1cm4gK2Q7XG59XG5cbi8vIGFkYXB0ZWQgZnJvbSBtb21lbnQuanM6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2Jsb2IvMDAwYWMxODAwZTYyMGY3NzBmNGViMzFiNWFlOTA4ZjYxNjdiMGFiMi9zcmMvbGliL3VuaXRzL3dlZWstY2FsZW5kYXItdXRpbHMuanNcbmZ1bmN0aW9uIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBtaW5EYXlzSW5GaXJzdFdlZWssIHN0YXJ0T2ZXZWVrKSB7XG4gIGNvbnN0IGZ3ZGx3ID0gaXNvV2Vla2RheVRvTG9jYWwoZGF5T2ZXZWVrKHllYXIsIDEsIG1pbkRheXNJbkZpcnN0V2VlayksIHN0YXJ0T2ZXZWVrKTtcbiAgcmV0dXJuIC1md2RsdyArIG1pbkRheXNJbkZpcnN0V2VlayAtIDE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3ZWVrc0luV2Vla1llYXIod2Vla1llYXIsIG1pbkRheXNJbkZpcnN0V2VlayA9IDQsIHN0YXJ0T2ZXZWVrID0gMSkge1xuICBjb25zdCB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHdlZWtZZWFyLCBtaW5EYXlzSW5GaXJzdFdlZWssIHN0YXJ0T2ZXZWVrKTtcbiAgY29uc3Qgd2Vla09mZnNldE5leHQgPSBmaXJzdFdlZWtPZmZzZXQod2Vla1llYXIgKyAxLCBtaW5EYXlzSW5GaXJzdFdlZWssIHN0YXJ0T2ZXZWVrKTtcbiAgcmV0dXJuIChkYXlzSW5ZZWFyKHdlZWtZZWFyKSAtIHdlZWtPZmZzZXQgKyB3ZWVrT2Zmc2V0TmV4dCkgLyA3O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW50cnVuY2F0ZVllYXIoeWVhcikge1xuICBpZiAoeWVhciA+IDk5KSB7XG4gICAgcmV0dXJuIHllYXI7XG4gIH0gZWxzZSByZXR1cm4geWVhciA+IFNldHRpbmdzLnR3b0RpZ2l0Q3V0b2ZmWWVhciA/IDE5MDAgKyB5ZWFyIDogMjAwMCArIHllYXI7XG59XG5cbi8vIFBBUlNJTkdcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlWm9uZUluZm8odHMsIG9mZnNldEZvcm1hdCwgbG9jYWxlLCB0aW1lWm9uZSA9IG51bGwpIHtcbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHRzKSxcbiAgICBpbnRsT3B0cyA9IHtcbiAgICAgIGhvdXJDeWNsZTogXCJoMjNcIixcbiAgICAgIHllYXI6IFwibnVtZXJpY1wiLFxuICAgICAgbW9udGg6IFwiMi1kaWdpdFwiLFxuICAgICAgZGF5OiBcIjItZGlnaXRcIixcbiAgICAgIGhvdXI6IFwiMi1kaWdpdFwiLFxuICAgICAgbWludXRlOiBcIjItZGlnaXRcIixcbiAgICB9O1xuXG4gIGlmICh0aW1lWm9uZSkge1xuICAgIGludGxPcHRzLnRpbWVab25lID0gdGltZVpvbmU7XG4gIH1cblxuICBjb25zdCBtb2RpZmllZCA9IHsgdGltZVpvbmVOYW1lOiBvZmZzZXRGb3JtYXQsIC4uLmludGxPcHRzIH07XG5cbiAgY29uc3QgcGFyc2VkID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBtb2RpZmllZClcbiAgICAuZm9ybWF0VG9QYXJ0cyhkYXRlKVxuICAgIC5maW5kKChtKSA9PiBtLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0aW1lem9uZW5hbWVcIik7XG4gIHJldHVybiBwYXJzZWQgPyBwYXJzZWQudmFsdWUgOiBudWxsO1xufVxuXG4vLyBzaWduZWRPZmZzZXQoJy01JywgJzMwJykgLT4gLTMzMFxuZXhwb3J0IGZ1bmN0aW9uIHNpZ25lZE9mZnNldChvZmZIb3VyU3RyLCBvZmZNaW51dGVTdHIpIHtcbiAgbGV0IG9mZkhvdXIgPSBwYXJzZUludChvZmZIb3VyU3RyLCAxMCk7XG5cbiAgLy8gZG9uJ3QgfHwgdGhpcyBiZWNhdXNlIHdlIHdhbnQgdG8gcHJlc2VydmUgLTBcbiAgaWYgKE51bWJlci5pc05hTihvZmZIb3VyKSkge1xuICAgIG9mZkhvdXIgPSAwO1xuICB9XG5cbiAgY29uc3Qgb2ZmTWluID0gcGFyc2VJbnQob2ZmTWludXRlU3RyLCAxMCkgfHwgMCxcbiAgICBvZmZNaW5TaWduZWQgPSBvZmZIb3VyIDwgMCB8fCBPYmplY3QuaXMob2ZmSG91ciwgLTApID8gLW9mZk1pbiA6IG9mZk1pbjtcbiAgcmV0dXJuIG9mZkhvdXIgKiA2MCArIG9mZk1pblNpZ25lZDtcbn1cblxuLy8gQ09FUkNJT05cblxuZXhwb3J0IGZ1bmN0aW9uIGFzTnVtYmVyKHZhbHVlKSB7XG4gIGNvbnN0IG51bWVyaWNWYWx1ZSA9IE51bWJlcih2YWx1ZSk7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiIHx8IHZhbHVlID09PSBcIlwiIHx8IE51bWJlci5pc05hTihudW1lcmljVmFsdWUpKVxuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihgSW52YWxpZCB1bml0IHZhbHVlICR7dmFsdWV9YCk7XG4gIHJldHVybiBudW1lcmljVmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVPYmplY3Qob2JqLCBub3JtYWxpemVyKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSB7fTtcbiAgZm9yIChjb25zdCB1IGluIG9iaikge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eShvYmosIHUpKSB7XG4gICAgICBjb25zdCB2ID0gb2JqW3VdO1xuICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsKSBjb250aW51ZTtcbiAgICAgIG5vcm1hbGl6ZWRbbm9ybWFsaXplcih1KV0gPSBhc051bWJlcih2KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRPZmZzZXQob2Zmc2V0LCBmb3JtYXQpIHtcbiAgY29uc3QgaG91cnMgPSBNYXRoLnRydW5jKE1hdGguYWJzKG9mZnNldCAvIDYwKSksXG4gICAgbWludXRlcyA9IE1hdGgudHJ1bmMoTWF0aC5hYnMob2Zmc2V0ICUgNjApKSxcbiAgICBzaWduID0gb2Zmc2V0ID49IDAgPyBcIitcIiA6IFwiLVwiO1xuXG4gIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgY2FzZSBcInNob3J0XCI6XG4gICAgICByZXR1cm4gYCR7c2lnbn0ke3BhZFN0YXJ0KGhvdXJzLCAyKX06JHtwYWRTdGFydChtaW51dGVzLCAyKX1gO1xuICAgIGNhc2UgXCJuYXJyb3dcIjpcbiAgICAgIHJldHVybiBgJHtzaWdufSR7aG91cnN9JHttaW51dGVzID4gMCA/IGA6JHttaW51dGVzfWAgOiBcIlwifWA7XG4gICAgY2FzZSBcInRlY2hpZVwiOlxuICAgICAgcmV0dXJuIGAke3NpZ259JHtwYWRTdGFydChob3VycywgMil9JHtwYWRTdGFydChtaW51dGVzLCAyKX1gO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVmFsdWUgZm9ybWF0ICR7Zm9ybWF0fSBpcyBvdXQgb2YgcmFuZ2UgZm9yIHByb3BlcnR5IGZvcm1hdGApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aW1lT2JqZWN0KG9iaikge1xuICByZXR1cm4gcGljayhvYmosIFtcImhvdXJcIiwgXCJtaW51dGVcIiwgXCJzZWNvbmRcIiwgXCJtaWxsaXNlY29uZFwiXSk7XG59XG4iLCAiaW1wb3J0ICogYXMgRm9ybWF0cyBmcm9tIFwiLi9mb3JtYXRzLmpzXCI7XG5pbXBvcnQgeyBwaWNrIH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuXG5mdW5jdGlvbiBzdHJpbmdpZnkob2JqKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmosIE9iamVjdC5rZXlzKG9iaikuc29ydCgpKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBjb25zdCBtb250aHNMb25nID0gW1xuICBcIkphbnVhcnlcIixcbiAgXCJGZWJydWFyeVwiLFxuICBcIk1hcmNoXCIsXG4gIFwiQXByaWxcIixcbiAgXCJNYXlcIixcbiAgXCJKdW5lXCIsXG4gIFwiSnVseVwiLFxuICBcIkF1Z3VzdFwiLFxuICBcIlNlcHRlbWJlclwiLFxuICBcIk9jdG9iZXJcIixcbiAgXCJOb3ZlbWJlclwiLFxuICBcIkRlY2VtYmVyXCIsXG5dO1xuXG5leHBvcnQgY29uc3QgbW9udGhzU2hvcnQgPSBbXG4gIFwiSmFuXCIsXG4gIFwiRmViXCIsXG4gIFwiTWFyXCIsXG4gIFwiQXByXCIsXG4gIFwiTWF5XCIsXG4gIFwiSnVuXCIsXG4gIFwiSnVsXCIsXG4gIFwiQXVnXCIsXG4gIFwiU2VwXCIsXG4gIFwiT2N0XCIsXG4gIFwiTm92XCIsXG4gIFwiRGVjXCIsXG5dO1xuXG5leHBvcnQgY29uc3QgbW9udGhzTmFycm93ID0gW1wiSlwiLCBcIkZcIiwgXCJNXCIsIFwiQVwiLCBcIk1cIiwgXCJKXCIsIFwiSlwiLCBcIkFcIiwgXCJTXCIsIFwiT1wiLCBcIk5cIiwgXCJEXCJdO1xuXG5leHBvcnQgZnVuY3Rpb24gbW9udGhzKGxlbmd0aCkge1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgXCJuYXJyb3dcIjpcbiAgICAgIHJldHVybiBbLi4ubW9udGhzTmFycm93XTtcbiAgICBjYXNlIFwic2hvcnRcIjpcbiAgICAgIHJldHVybiBbLi4ubW9udGhzU2hvcnRdO1xuICAgIGNhc2UgXCJsb25nXCI6XG4gICAgICByZXR1cm4gWy4uLm1vbnRoc0xvbmddO1xuICAgIGNhc2UgXCJudW1lcmljXCI6XG4gICAgICByZXR1cm4gW1wiMVwiLCBcIjJcIiwgXCIzXCIsIFwiNFwiLCBcIjVcIiwgXCI2XCIsIFwiN1wiLCBcIjhcIiwgXCI5XCIsIFwiMTBcIiwgXCIxMVwiLCBcIjEyXCJdO1xuICAgIGNhc2UgXCIyLWRpZ2l0XCI6XG4gICAgICByZXR1cm4gW1wiMDFcIiwgXCIwMlwiLCBcIjAzXCIsIFwiMDRcIiwgXCIwNVwiLCBcIjA2XCIsIFwiMDdcIiwgXCIwOFwiLCBcIjA5XCIsIFwiMTBcIiwgXCIxMVwiLCBcIjEyXCJdO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgd2Vla2RheXNMb25nID0gW1xuICBcIk1vbmRheVwiLFxuICBcIlR1ZXNkYXlcIixcbiAgXCJXZWRuZXNkYXlcIixcbiAgXCJUaHVyc2RheVwiLFxuICBcIkZyaWRheVwiLFxuICBcIlNhdHVyZGF5XCIsXG4gIFwiU3VuZGF5XCIsXG5dO1xuXG5leHBvcnQgY29uc3Qgd2Vla2RheXNTaG9ydCA9IFtcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiLCBcIlN1blwiXTtcblxuZXhwb3J0IGNvbnN0IHdlZWtkYXlzTmFycm93ID0gW1wiTVwiLCBcIlRcIiwgXCJXXCIsIFwiVFwiLCBcIkZcIiwgXCJTXCIsIFwiU1wiXTtcblxuZXhwb3J0IGZ1bmN0aW9uIHdlZWtkYXlzKGxlbmd0aCkge1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgXCJuYXJyb3dcIjpcbiAgICAgIHJldHVybiBbLi4ud2Vla2RheXNOYXJyb3ddO1xuICAgIGNhc2UgXCJzaG9ydFwiOlxuICAgICAgcmV0dXJuIFsuLi53ZWVrZGF5c1Nob3J0XTtcbiAgICBjYXNlIFwibG9uZ1wiOlxuICAgICAgcmV0dXJuIFsuLi53ZWVrZGF5c0xvbmddO1xuICAgIGNhc2UgXCJudW1lcmljXCI6XG4gICAgICByZXR1cm4gW1wiMVwiLCBcIjJcIiwgXCIzXCIsIFwiNFwiLCBcIjVcIiwgXCI2XCIsIFwiN1wiXTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IG1lcmlkaWVtcyA9IFtcIkFNXCIsIFwiUE1cIl07XG5cbmV4cG9ydCBjb25zdCBlcmFzTG9uZyA9IFtcIkJlZm9yZSBDaHJpc3RcIiwgXCJBbm5vIERvbWluaVwiXTtcblxuZXhwb3J0IGNvbnN0IGVyYXNTaG9ydCA9IFtcIkJDXCIsIFwiQURcIl07XG5cbmV4cG9ydCBjb25zdCBlcmFzTmFycm93ID0gW1wiQlwiLCBcIkFcIl07XG5cbmV4cG9ydCBmdW5jdGlvbiBlcmFzKGxlbmd0aCkge1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgXCJuYXJyb3dcIjpcbiAgICAgIHJldHVybiBbLi4uZXJhc05hcnJvd107XG4gICAgY2FzZSBcInNob3J0XCI6XG4gICAgICByZXR1cm4gWy4uLmVyYXNTaG9ydF07XG4gICAgY2FzZSBcImxvbmdcIjpcbiAgICAgIHJldHVybiBbLi4uZXJhc0xvbmddO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyaWRpZW1Gb3JEYXRlVGltZShkdCkge1xuICByZXR1cm4gbWVyaWRpZW1zW2R0LmhvdXIgPCAxMiA/IDAgOiAxXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdlZWtkYXlGb3JEYXRlVGltZShkdCwgbGVuZ3RoKSB7XG4gIHJldHVybiB3ZWVrZGF5cyhsZW5ndGgpW2R0LndlZWtkYXkgLSAxXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1vbnRoRm9yRGF0ZVRpbWUoZHQsIGxlbmd0aCkge1xuICByZXR1cm4gbW9udGhzKGxlbmd0aClbZHQubW9udGggLSAxXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVyYUZvckRhdGVUaW1lKGR0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGVyYXMobGVuZ3RoKVtkdC55ZWFyIDwgMCA/IDAgOiAxXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFJlbGF0aXZlVGltZSh1bml0LCBjb3VudCwgbnVtZXJpYyA9IFwiYWx3YXlzXCIsIG5hcnJvdyA9IGZhbHNlKSB7XG4gIGNvbnN0IHVuaXRzID0ge1xuICAgIHllYXJzOiBbXCJ5ZWFyXCIsIFwieXIuXCJdLFxuICAgIHF1YXJ0ZXJzOiBbXCJxdWFydGVyXCIsIFwicXRyLlwiXSxcbiAgICBtb250aHM6IFtcIm1vbnRoXCIsIFwibW8uXCJdLFxuICAgIHdlZWtzOiBbXCJ3ZWVrXCIsIFwid2suXCJdLFxuICAgIGRheXM6IFtcImRheVwiLCBcImRheVwiLCBcImRheXNcIl0sXG4gICAgaG91cnM6IFtcImhvdXJcIiwgXCJoci5cIl0sXG4gICAgbWludXRlczogW1wibWludXRlXCIsIFwibWluLlwiXSxcbiAgICBzZWNvbmRzOiBbXCJzZWNvbmRcIiwgXCJzZWMuXCJdLFxuICB9O1xuXG4gIGNvbnN0IGxhc3RhYmxlID0gW1wiaG91cnNcIiwgXCJtaW51dGVzXCIsIFwic2Vjb25kc1wiXS5pbmRleE9mKHVuaXQpID09PSAtMTtcblxuICBpZiAobnVtZXJpYyA9PT0gXCJhdXRvXCIgJiYgbGFzdGFibGUpIHtcbiAgICBjb25zdCBpc0RheSA9IHVuaXQgPT09IFwiZGF5c1wiO1xuICAgIHN3aXRjaCAoY291bnQpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIGlzRGF5ID8gXCJ0b21vcnJvd1wiIDogYG5leHQgJHt1bml0c1t1bml0XVswXX1gO1xuICAgICAgY2FzZSAtMTpcbiAgICAgICAgcmV0dXJuIGlzRGF5ID8gXCJ5ZXN0ZXJkYXlcIiA6IGBsYXN0ICR7dW5pdHNbdW5pdF1bMF19YDtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIGlzRGF5ID8gXCJ0b2RheVwiIDogYHRoaXMgJHt1bml0c1t1bml0XVswXX1gO1xuICAgICAgZGVmYXVsdDogLy8gZmFsbCB0aHJvdWdoXG4gICAgfVxuICB9XG5cbiAgY29uc3QgaXNJblBhc3QgPSBPYmplY3QuaXMoY291bnQsIC0wKSB8fCBjb3VudCA8IDAsXG4gICAgZm10VmFsdWUgPSBNYXRoLmFicyhjb3VudCksXG4gICAgc2luZ3VsYXIgPSBmbXRWYWx1ZSA9PT0gMSxcbiAgICBsaWxVbml0cyA9IHVuaXRzW3VuaXRdLFxuICAgIGZtdFVuaXQgPSBuYXJyb3dcbiAgICAgID8gc2luZ3VsYXJcbiAgICAgICAgPyBsaWxVbml0c1sxXVxuICAgICAgICA6IGxpbFVuaXRzWzJdIHx8IGxpbFVuaXRzWzFdXG4gICAgICA6IHNpbmd1bGFyXG4gICAgICA/IHVuaXRzW3VuaXRdWzBdXG4gICAgICA6IHVuaXQ7XG4gIHJldHVybiBpc0luUGFzdCA/IGAke2ZtdFZhbHVlfSAke2ZtdFVuaXR9IGFnb2AgOiBgaW4gJHtmbXRWYWx1ZX0gJHtmbXRVbml0fWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRTdHJpbmcoa25vd25Gb3JtYXQpIHtcbiAgLy8gdGhlc2UgYWxsIGhhdmUgdGhlIG9mZnNldHMgcmVtb3ZlZCBiZWNhdXNlIHdlIGRvbid0IGhhdmUgYWNjZXNzIHRvIHRoZW1cbiAgLy8gd2l0aG91dCBhbGwgdGhlIGludGwgc3R1ZmYgdGhpcyBpcyBiYWNrZmlsbGluZ1xuICBjb25zdCBmaWx0ZXJlZCA9IHBpY2soa25vd25Gb3JtYXQsIFtcbiAgICAgIFwid2Vla2RheVwiLFxuICAgICAgXCJlcmFcIixcbiAgICAgIFwieWVhclwiLFxuICAgICAgXCJtb250aFwiLFxuICAgICAgXCJkYXlcIixcbiAgICAgIFwiaG91clwiLFxuICAgICAgXCJtaW51dGVcIixcbiAgICAgIFwic2Vjb25kXCIsXG4gICAgICBcInRpbWVab25lTmFtZVwiLFxuICAgICAgXCJob3VyQ3ljbGVcIixcbiAgICBdKSxcbiAgICBrZXkgPSBzdHJpbmdpZnkoZmlsdGVyZWQpLFxuICAgIGRhdGVUaW1lSHVnZSA9IFwiRUVFRSwgTExMTCBkLCB5eXl5LCBoOm1tIGFcIjtcbiAgc3dpdGNoIChrZXkpIHtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVfU0hPUlQpOlxuICAgICAgcmV0dXJuIFwiTS9kL3l5eXlcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVfTUVEKTpcbiAgICAgIHJldHVybiBcIkxMTCBkLCB5eXl5XCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFX01FRF9XSVRIX1dFRUtEQVkpOlxuICAgICAgcmV0dXJuIFwiRUVFLCBMTEwgZCwgeXl5eVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURV9GVUxMKTpcbiAgICAgIHJldHVybiBcIkxMTEwgZCwgeXl5eVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURV9IVUdFKTpcbiAgICAgIHJldHVybiBcIkVFRUUsIExMTEwgZCwgeXl5eVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV9TSU1QTEUpOlxuICAgICAgcmV0dXJuIFwiaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FX1dJVEhfU0VDT05EUyk6XG4gICAgICByZXR1cm4gXCJoOm1tOnNzIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfV0lUSF9TSE9SVF9PRkZTRVQpOlxuICAgICAgcmV0dXJuIFwiaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FX1dJVEhfTE9OR19PRkZTRVQpOlxuICAgICAgcmV0dXJuIFwiaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FXzI0X1NJTVBMRSk6XG4gICAgICByZXR1cm4gXCJISDptbVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV8yNF9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiSEg6bW06c3NcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfMjRfV0lUSF9TSE9SVF9PRkZTRVQpOlxuICAgICAgcmV0dXJuIFwiSEg6bW1cIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfMjRfV0lUSF9MT05HX09GRlNFVCk6XG4gICAgICByZXR1cm4gXCJISDptbVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfU0hPUlQpOlxuICAgICAgcmV0dXJuIFwiTS9kL3l5eXksIGg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfTUVEKTpcbiAgICAgIHJldHVybiBcIkxMTCBkLCB5eXl5LCBoOm1tIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX0ZVTEwpOlxuICAgICAgcmV0dXJuIFwiTExMTCBkLCB5eXl5LCBoOm1tIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX0hVR0UpOlxuICAgICAgcmV0dXJuIGRhdGVUaW1lSHVnZTtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUyk6XG4gICAgICByZXR1cm4gXCJNL2QveXl5eSwgaDptbTpzcyBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9NRURfV0lUSF9TRUNPTkRTKTpcbiAgICAgIHJldHVybiBcIkxMTCBkLCB5eXl5LCBoOm1tOnNzIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX01FRF9XSVRIX1dFRUtEQVkpOlxuICAgICAgcmV0dXJuIFwiRUVFLCBkIExMTCB5eXl5LCBoOm1tIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX0ZVTExfV0lUSF9TRUNPTkRTKTpcbiAgICAgIHJldHVybiBcIkxMTEwgZCwgeXl5eSwgaDptbTpzcyBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9IVUdFX1dJVEhfU0VDT05EUyk6XG4gICAgICByZXR1cm4gXCJFRUVFLCBMTExMIGQsIHl5eXksIGg6bW06c3MgYVwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZGF0ZVRpbWVIdWdlO1xuICB9XG59XG4iLCAiaW1wb3J0ICogYXMgRW5nbGlzaCBmcm9tIFwiLi9lbmdsaXNoLmpzXCI7XG5pbXBvcnQgKiBhcyBGb3JtYXRzIGZyb20gXCIuL2Zvcm1hdHMuanNcIjtcbmltcG9ydCB7IHBhZFN0YXJ0IH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuXG5mdW5jdGlvbiBzdHJpbmdpZnlUb2tlbnMoc3BsaXRzLCB0b2tlblRvU3RyaW5nKSB7XG4gIGxldCBzID0gXCJcIjtcbiAgZm9yIChjb25zdCB0b2tlbiBvZiBzcGxpdHMpIHtcbiAgICBpZiAodG9rZW4ubGl0ZXJhbCkge1xuICAgICAgcyArPSB0b2tlbi52YWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMgKz0gdG9rZW5Ub1N0cmluZyh0b2tlbi52YWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcztcbn1cblxuY29uc3QgbWFjcm9Ub2tlblRvRm9ybWF0T3B0cyA9IHtcbiAgRDogRm9ybWF0cy5EQVRFX1NIT1JULFxuICBERDogRm9ybWF0cy5EQVRFX01FRCxcbiAgREREOiBGb3JtYXRzLkRBVEVfRlVMTCxcbiAgRERERDogRm9ybWF0cy5EQVRFX0hVR0UsXG4gIHQ6IEZvcm1hdHMuVElNRV9TSU1QTEUsXG4gIHR0OiBGb3JtYXRzLlRJTUVfV0lUSF9TRUNPTkRTLFxuICB0dHQ6IEZvcm1hdHMuVElNRV9XSVRIX1NIT1JUX09GRlNFVCxcbiAgdHR0dDogRm9ybWF0cy5USU1FX1dJVEhfTE9OR19PRkZTRVQsXG4gIFQ6IEZvcm1hdHMuVElNRV8yNF9TSU1QTEUsXG4gIFRUOiBGb3JtYXRzLlRJTUVfMjRfV0lUSF9TRUNPTkRTLFxuICBUVFQ6IEZvcm1hdHMuVElNRV8yNF9XSVRIX1NIT1JUX09GRlNFVCxcbiAgVFRUVDogRm9ybWF0cy5USU1FXzI0X1dJVEhfTE9OR19PRkZTRVQsXG4gIGY6IEZvcm1hdHMuREFURVRJTUVfU0hPUlQsXG4gIGZmOiBGb3JtYXRzLkRBVEVUSU1FX01FRCxcbiAgZmZmOiBGb3JtYXRzLkRBVEVUSU1FX0ZVTEwsXG4gIGZmZmY6IEZvcm1hdHMuREFURVRJTUVfSFVHRSxcbiAgRjogRm9ybWF0cy5EQVRFVElNRV9TSE9SVF9XSVRIX1NFQ09ORFMsXG4gIEZGOiBGb3JtYXRzLkRBVEVUSU1FX01FRF9XSVRIX1NFQ09ORFMsXG4gIEZGRjogRm9ybWF0cy5EQVRFVElNRV9GVUxMX1dJVEhfU0VDT05EUyxcbiAgRkZGRjogRm9ybWF0cy5EQVRFVElNRV9IVUdFX1dJVEhfU0VDT05EUyxcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGb3JtYXR0ZXIge1xuICBzdGF0aWMgY3JlYXRlKGxvY2FsZSwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBGb3JtYXR0ZXIobG9jYWxlLCBvcHRzKTtcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZUZvcm1hdChmbXQpIHtcbiAgICAvLyB3aGl0ZS1zcGFjZSBpcyBhbHdheXMgY29uc2lkZXJlZCBhIGxpdGVyYWwgaW4gdXNlci1wcm92aWRlZCBmb3JtYXRzXG4gICAgLy8gdGhlIFwiIFwiIHRva2VuIGhhcyBhIHNwZWNpYWwgbWVhbmluZyAoc2VlIHVuaXRGb3JUb2tlbilcblxuICAgIGxldCBjdXJyZW50ID0gbnVsbCxcbiAgICAgIGN1cnJlbnRGdWxsID0gXCJcIixcbiAgICAgIGJyYWNrZXRlZCA9IGZhbHNlO1xuICAgIGNvbnN0IHNwbGl0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm10Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjID0gZm10LmNoYXJBdChpKTtcbiAgICAgIGlmIChjID09PSBcIidcIikge1xuICAgICAgICBpZiAoY3VycmVudEZ1bGwubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHNwbGl0cy5wdXNoKHsgbGl0ZXJhbDogYnJhY2tldGVkIHx8IC9eXFxzKyQvLnRlc3QoY3VycmVudEZ1bGwpLCB2YWw6IGN1cnJlbnRGdWxsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBudWxsO1xuICAgICAgICBjdXJyZW50RnVsbCA9IFwiXCI7XG4gICAgICAgIGJyYWNrZXRlZCA9ICFicmFja2V0ZWQ7XG4gICAgICB9IGVsc2UgaWYgKGJyYWNrZXRlZCkge1xuICAgICAgICBjdXJyZW50RnVsbCArPSBjO1xuICAgICAgfSBlbHNlIGlmIChjID09PSBjdXJyZW50KSB7XG4gICAgICAgIGN1cnJlbnRGdWxsICs9IGM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY3VycmVudEZ1bGwubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHNwbGl0cy5wdXNoKHsgbGl0ZXJhbDogL15cXHMrJC8udGVzdChjdXJyZW50RnVsbCksIHZhbDogY3VycmVudEZ1bGwgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEZ1bGwgPSBjO1xuICAgICAgICBjdXJyZW50ID0gYztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY3VycmVudEZ1bGwubGVuZ3RoID4gMCkge1xuICAgICAgc3BsaXRzLnB1c2goeyBsaXRlcmFsOiBicmFja2V0ZWQgfHwgL15cXHMrJC8udGVzdChjdXJyZW50RnVsbCksIHZhbDogY3VycmVudEZ1bGwgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNwbGl0cztcbiAgfVxuXG4gIHN0YXRpYyBtYWNyb1Rva2VuVG9Gb3JtYXRPcHRzKHRva2VuKSB7XG4gICAgcmV0dXJuIG1hY3JvVG9rZW5Ub0Zvcm1hdE9wdHNbdG9rZW5dO1xuICB9XG5cbiAgY29uc3RydWN0b3IobG9jYWxlLCBmb3JtYXRPcHRzKSB7XG4gICAgdGhpcy5vcHRzID0gZm9ybWF0T3B0cztcbiAgICB0aGlzLmxvYyA9IGxvY2FsZTtcbiAgICB0aGlzLnN5c3RlbUxvYyA9IG51bGw7XG4gIH1cblxuICBmb3JtYXRXaXRoU3lzdGVtRGVmYXVsdChkdCwgb3B0cykge1xuICAgIGlmICh0aGlzLnN5c3RlbUxvYyA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5zeXN0ZW1Mb2MgPSB0aGlzLmxvYy5yZWRlZmF1bHRUb1N5c3RlbSgpO1xuICAgIH1cbiAgICBjb25zdCBkZiA9IHRoaXMuc3lzdGVtTG9jLmR0Rm9ybWF0dGVyKGR0LCB7IC4uLnRoaXMub3B0cywgLi4ub3B0cyB9KTtcbiAgICByZXR1cm4gZGYuZm9ybWF0KCk7XG4gIH1cblxuICBkdEZvcm1hdHRlcihkdCwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMubG9jLmR0Rm9ybWF0dGVyKGR0LCB7IC4uLnRoaXMub3B0cywgLi4ub3B0cyB9KTtcbiAgfVxuXG4gIGZvcm1hdERhdGVUaW1lKGR0LCBvcHRzKSB7XG4gICAgcmV0dXJuIHRoaXMuZHRGb3JtYXR0ZXIoZHQsIG9wdHMpLmZvcm1hdCgpO1xuICB9XG5cbiAgZm9ybWF0RGF0ZVRpbWVQYXJ0cyhkdCwgb3B0cykge1xuICAgIHJldHVybiB0aGlzLmR0Rm9ybWF0dGVyKGR0LCBvcHRzKS5mb3JtYXRUb1BhcnRzKCk7XG4gIH1cblxuICBmb3JtYXRJbnRlcnZhbChpbnRlcnZhbCwgb3B0cykge1xuICAgIGNvbnN0IGRmID0gdGhpcy5kdEZvcm1hdHRlcihpbnRlcnZhbC5zdGFydCwgb3B0cyk7XG4gICAgcmV0dXJuIGRmLmR0Zi5mb3JtYXRSYW5nZShpbnRlcnZhbC5zdGFydC50b0pTRGF0ZSgpLCBpbnRlcnZhbC5lbmQudG9KU0RhdGUoKSk7XG4gIH1cblxuICByZXNvbHZlZE9wdGlvbnMoZHQsIG9wdHMpIHtcbiAgICByZXR1cm4gdGhpcy5kdEZvcm1hdHRlcihkdCwgb3B0cykucmVzb2x2ZWRPcHRpb25zKCk7XG4gIH1cblxuICBudW0obiwgcCA9IDApIHtcbiAgICAvLyB3ZSBnZXQgc29tZSBwZXJmIG91dCBvZiBkb2luZyB0aGlzIGhlcmUsIGFubm95aW5nbHlcbiAgICBpZiAodGhpcy5vcHRzLmZvcmNlU2ltcGxlKSB7XG4gICAgICByZXR1cm4gcGFkU3RhcnQobiwgcCk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0cyA9IHsgLi4udGhpcy5vcHRzIH07XG5cbiAgICBpZiAocCA+IDApIHtcbiAgICAgIG9wdHMucGFkVG8gPSBwO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmxvYy5udW1iZXJGb3JtYXR0ZXIob3B0cykuZm9ybWF0KG4pO1xuICB9XG5cbiAgZm9ybWF0RGF0ZVRpbWVGcm9tU3RyaW5nKGR0LCBmbXQpIHtcbiAgICBjb25zdCBrbm93bkVuZ2xpc2ggPSB0aGlzLmxvYy5saXN0aW5nTW9kZSgpID09PSBcImVuXCIsXG4gICAgICB1c2VEYXRlVGltZUZvcm1hdHRlciA9IHRoaXMubG9jLm91dHB1dENhbGVuZGFyICYmIHRoaXMubG9jLm91dHB1dENhbGVuZGFyICE9PSBcImdyZWdvcnlcIixcbiAgICAgIHN0cmluZyA9IChvcHRzLCBleHRyYWN0KSA9PiB0aGlzLmxvYy5leHRyYWN0KGR0LCBvcHRzLCBleHRyYWN0KSxcbiAgICAgIGZvcm1hdE9mZnNldCA9IChvcHRzKSA9PiB7XG4gICAgICAgIGlmIChkdC5pc09mZnNldEZpeGVkICYmIGR0Lm9mZnNldCA9PT0gMCAmJiBvcHRzLmFsbG93Wikge1xuICAgICAgICAgIHJldHVybiBcIlpcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkdC5pc1ZhbGlkID8gZHQuem9uZS5mb3JtYXRPZmZzZXQoZHQudHMsIG9wdHMuZm9ybWF0KSA6IFwiXCI7XG4gICAgICB9LFxuICAgICAgbWVyaWRpZW0gPSAoKSA9PlxuICAgICAgICBrbm93bkVuZ2xpc2hcbiAgICAgICAgICA/IEVuZ2xpc2gubWVyaWRpZW1Gb3JEYXRlVGltZShkdClcbiAgICAgICAgICA6IHN0cmluZyh7IGhvdXI6IFwibnVtZXJpY1wiLCBob3VyQ3ljbGU6IFwiaDEyXCIgfSwgXCJkYXlwZXJpb2RcIiksXG4gICAgICBtb250aCA9IChsZW5ndGgsIHN0YW5kYWxvbmUpID0+XG4gICAgICAgIGtub3duRW5nbGlzaFxuICAgICAgICAgID8gRW5nbGlzaC5tb250aEZvckRhdGVUaW1lKGR0LCBsZW5ndGgpXG4gICAgICAgICAgOiBzdHJpbmcoc3RhbmRhbG9uZSA/IHsgbW9udGg6IGxlbmd0aCB9IDogeyBtb250aDogbGVuZ3RoLCBkYXk6IFwibnVtZXJpY1wiIH0sIFwibW9udGhcIiksXG4gICAgICB3ZWVrZGF5ID0gKGxlbmd0aCwgc3RhbmRhbG9uZSkgPT5cbiAgICAgICAga25vd25FbmdsaXNoXG4gICAgICAgICAgPyBFbmdsaXNoLndlZWtkYXlGb3JEYXRlVGltZShkdCwgbGVuZ3RoKVxuICAgICAgICAgIDogc3RyaW5nKFxuICAgICAgICAgICAgICBzdGFuZGFsb25lID8geyB3ZWVrZGF5OiBsZW5ndGggfSA6IHsgd2Vla2RheTogbGVuZ3RoLCBtb250aDogXCJsb25nXCIsIGRheTogXCJudW1lcmljXCIgfSxcbiAgICAgICAgICAgICAgXCJ3ZWVrZGF5XCJcbiAgICAgICAgICAgICksXG4gICAgICBtYXliZU1hY3JvID0gKHRva2VuKSA9PiB7XG4gICAgICAgIGNvbnN0IGZvcm1hdE9wdHMgPSBGb3JtYXR0ZXIubWFjcm9Ub2tlblRvRm9ybWF0T3B0cyh0b2tlbik7XG4gICAgICAgIGlmIChmb3JtYXRPcHRzKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0V2l0aFN5c3RlbURlZmF1bHQoZHQsIGZvcm1hdE9wdHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGVyYSA9IChsZW5ndGgpID0+XG4gICAgICAgIGtub3duRW5nbGlzaCA/IEVuZ2xpc2guZXJhRm9yRGF0ZVRpbWUoZHQsIGxlbmd0aCkgOiBzdHJpbmcoeyBlcmE6IGxlbmd0aCB9LCBcImVyYVwiKSxcbiAgICAgIHRva2VuVG9TdHJpbmcgPSAodG9rZW4pID0+IHtcbiAgICAgICAgLy8gV2hlcmUgcG9zc2libGU6IGh0dHBzOi8vY2xkci51bmljb2RlLm9yZy90cmFuc2xhdGlvbi9kYXRlLXRpbWUvZGF0ZS10aW1lLXN5bWJvbHNcbiAgICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAgIC8vIG1zXG4gICAgICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5taWxsaXNlY29uZCk7XG4gICAgICAgICAgY2FzZSBcInVcIjpcbiAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgICAgY2FzZSBcIlNTU1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0Lm1pbGxpc2Vjb25kLCAzKTtcbiAgICAgICAgICAvLyBzZWNvbmRzXG4gICAgICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5zZWNvbmQpO1xuICAgICAgICAgIGNhc2UgXCJzc1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LnNlY29uZCwgMik7XG4gICAgICAgICAgLy8gZnJhY3Rpb25hbCBzZWNvbmRzXG4gICAgICAgICAgY2FzZSBcInV1XCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oTWF0aC5mbG9vcihkdC5taWxsaXNlY29uZCAvIDEwKSwgMik7XG4gICAgICAgICAgY2FzZSBcInV1dVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKE1hdGguZmxvb3IoZHQubWlsbGlzZWNvbmQgLyAxMDApKTtcbiAgICAgICAgICAvLyBtaW51dGVzXG4gICAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5taW51dGUpO1xuICAgICAgICAgIGNhc2UgXCJtbVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0Lm1pbnV0ZSwgMik7XG4gICAgICAgICAgLy8gaG91cnNcbiAgICAgICAgICBjYXNlIFwiaFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LmhvdXIgJSAxMiA9PT0gMCA/IDEyIDogZHQuaG91ciAlIDEyKTtcbiAgICAgICAgICBjYXNlIFwiaGhcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5ob3VyICUgMTIgPT09IDAgPyAxMiA6IGR0LmhvdXIgJSAxMiwgMik7XG4gICAgICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5ob3VyKTtcbiAgICAgICAgICBjYXNlIFwiSEhcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5ob3VyLCAyKTtcbiAgICAgICAgICAvLyBvZmZzZXRcbiAgICAgICAgICBjYXNlIFwiWlwiOlxuICAgICAgICAgICAgLy8gbGlrZSArNlxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE9mZnNldCh7IGZvcm1hdDogXCJuYXJyb3dcIiwgYWxsb3daOiB0aGlzLm9wdHMuYWxsb3daIH0pO1xuICAgICAgICAgIGNhc2UgXCJaWlwiOlxuICAgICAgICAgICAgLy8gbGlrZSArMDY6MDBcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRPZmZzZXQoeyBmb3JtYXQ6IFwic2hvcnRcIiwgYWxsb3daOiB0aGlzLm9wdHMuYWxsb3daIH0pO1xuICAgICAgICAgIGNhc2UgXCJaWlpcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgKzA2MDBcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRPZmZzZXQoeyBmb3JtYXQ6IFwidGVjaGllXCIsIGFsbG93WjogdGhpcy5vcHRzLmFsbG93WiB9KTtcbiAgICAgICAgICBjYXNlIFwiWlpaWlwiOlxuICAgICAgICAgICAgLy8gbGlrZSBFU1RcbiAgICAgICAgICAgIHJldHVybiBkdC56b25lLm9mZnNldE5hbWUoZHQudHMsIHsgZm9ybWF0OiBcInNob3J0XCIsIGxvY2FsZTogdGhpcy5sb2MubG9jYWxlIH0pO1xuICAgICAgICAgIGNhc2UgXCJaWlpaWlwiOlxuICAgICAgICAgICAgLy8gbGlrZSBFYXN0ZXJuIFN0YW5kYXJkIFRpbWVcbiAgICAgICAgICAgIHJldHVybiBkdC56b25lLm9mZnNldE5hbWUoZHQudHMsIHsgZm9ybWF0OiBcImxvbmdcIiwgbG9jYWxlOiB0aGlzLmxvYy5sb2NhbGUgfSk7XG4gICAgICAgICAgLy8gem9uZVxuICAgICAgICAgIGNhc2UgXCJ6XCI6XG4gICAgICAgICAgICAvLyBsaWtlIEFtZXJpY2EvTmV3X1lvcmtcbiAgICAgICAgICAgIHJldHVybiBkdC56b25lTmFtZTtcbiAgICAgICAgICAvLyBtZXJpZGllbXNcbiAgICAgICAgICBjYXNlIFwiYVwiOlxuICAgICAgICAgICAgcmV0dXJuIG1lcmlkaWVtKCk7XG4gICAgICAgICAgLy8gZGF0ZXNcbiAgICAgICAgICBjYXNlIFwiZFwiOlxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyID8gc3RyaW5nKHsgZGF5OiBcIm51bWVyaWNcIiB9LCBcImRheVwiKSA6IHRoaXMubnVtKGR0LmRheSk7XG4gICAgICAgICAgY2FzZSBcImRkXCI6XG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXIgPyBzdHJpbmcoeyBkYXk6IFwiMi1kaWdpdFwiIH0sIFwiZGF5XCIpIDogdGhpcy5udW0oZHQuZGF5LCAyKTtcbiAgICAgICAgICAvLyB3ZWVrZGF5cyAtIHN0YW5kYWxvbmVcbiAgICAgICAgICBjYXNlIFwiY1wiOlxuICAgICAgICAgICAgLy8gbGlrZSAxXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQud2Vla2RheSk7XG4gICAgICAgICAgY2FzZSBcImNjY1wiOlxuICAgICAgICAgICAgLy8gbGlrZSAnVHVlcydcbiAgICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwic2hvcnRcIiwgdHJ1ZSk7XG4gICAgICAgICAgY2FzZSBcImNjY2NcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgJ1R1ZXNkYXknXG4gICAgICAgICAgICByZXR1cm4gd2Vla2RheShcImxvbmdcIiwgdHJ1ZSk7XG4gICAgICAgICAgY2FzZSBcImNjY2NjXCI6XG4gICAgICAgICAgICAvLyBsaWtlICdUJ1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtkYXkoXCJuYXJyb3dcIiwgdHJ1ZSk7XG4gICAgICAgICAgLy8gd2Vla2RheXMgLSBmb3JtYXRcbiAgICAgICAgICBjYXNlIFwiRVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAxXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQud2Vla2RheSk7XG4gICAgICAgICAgY2FzZSBcIkVFRVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAnVHVlcydcbiAgICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwic2hvcnRcIiwgZmFsc2UpO1xuICAgICAgICAgIGNhc2UgXCJFRUVFXCI6XG4gICAgICAgICAgICAvLyBsaWtlICdUdWVzZGF5J1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtkYXkoXCJsb25nXCIsIGZhbHNlKTtcbiAgICAgICAgICBjYXNlIFwiRUVFRUVcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgJ1QnXG4gICAgICAgICAgICByZXR1cm4gd2Vla2RheShcIm5hcnJvd1wiLCBmYWxzZSk7XG4gICAgICAgICAgLy8gbW9udGhzIC0gc3RhbmRhbG9uZVxuICAgICAgICAgIGNhc2UgXCJMXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDFcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IG1vbnRoOiBcIm51bWVyaWNcIiwgZGF5OiBcIm51bWVyaWNcIiB9LCBcIm1vbnRoXCIpXG4gICAgICAgICAgICAgIDogdGhpcy5udW0oZHQubW9udGgpO1xuICAgICAgICAgIGNhc2UgXCJMTFwiOlxuICAgICAgICAgICAgLy8gbGlrZSAwMSwgZG9lc24ndCBzZWVtIHRvIHdvcmtcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IG1vbnRoOiBcIjItZGlnaXRcIiwgZGF5OiBcIm51bWVyaWNcIiB9LCBcIm1vbnRoXCIpXG4gICAgICAgICAgICAgIDogdGhpcy5udW0oZHQubW9udGgsIDIpO1xuICAgICAgICAgIGNhc2UgXCJMTExcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgSmFuXG4gICAgICAgICAgICByZXR1cm4gbW9udGgoXCJzaG9ydFwiLCB0cnVlKTtcbiAgICAgICAgICBjYXNlIFwiTExMTFwiOlxuICAgICAgICAgICAgLy8gbGlrZSBKYW51YXJ5XG4gICAgICAgICAgICByZXR1cm4gbW9udGgoXCJsb25nXCIsIHRydWUpO1xuICAgICAgICAgIGNhc2UgXCJMTExMTFwiOlxuICAgICAgICAgICAgLy8gbGlrZSBKXG4gICAgICAgICAgICByZXR1cm4gbW9udGgoXCJuYXJyb3dcIiwgdHJ1ZSk7XG4gICAgICAgICAgLy8gbW9udGhzIC0gZm9ybWF0XG4gICAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMVxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgbW9udGg6IFwibnVtZXJpY1wiIH0sIFwibW9udGhcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC5tb250aCk7XG4gICAgICAgICAgY2FzZSBcIk1NXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDAxXG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgPyBzdHJpbmcoeyBtb250aDogXCIyLWRpZ2l0XCIgfSwgXCJtb250aFwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0Lm1vbnRoLCAyKTtcbiAgICAgICAgICBjYXNlIFwiTU1NXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEphblxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoKFwic2hvcnRcIiwgZmFsc2UpO1xuICAgICAgICAgIGNhc2UgXCJNTU1NXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEphbnVhcnlcbiAgICAgICAgICAgIHJldHVybiBtb250aChcImxvbmdcIiwgZmFsc2UpO1xuICAgICAgICAgIGNhc2UgXCJNTU1NTVwiOlxuICAgICAgICAgICAgLy8gbGlrZSBKXG4gICAgICAgICAgICByZXR1cm4gbW9udGgoXCJuYXJyb3dcIiwgZmFsc2UpO1xuICAgICAgICAgIC8vIHllYXJzXG4gICAgICAgICAgY2FzZSBcInlcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMjAxNFxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyID8gc3RyaW5nKHsgeWVhcjogXCJudW1lcmljXCIgfSwgXCJ5ZWFyXCIpIDogdGhpcy5udW0oZHQueWVhcik7XG4gICAgICAgICAgY2FzZSBcInl5XCI6XG4gICAgICAgICAgICAvLyBsaWtlIDE0XG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgPyBzdHJpbmcoeyB5ZWFyOiBcIjItZGlnaXRcIiB9LCBcInllYXJcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC55ZWFyLnRvU3RyaW5nKCkuc2xpY2UoLTIpLCAyKTtcbiAgICAgICAgICBjYXNlIFwieXl5eVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAwMDEyXG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgPyBzdHJpbmcoeyB5ZWFyOiBcIm51bWVyaWNcIiB9LCBcInllYXJcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC55ZWFyLCA0KTtcbiAgICAgICAgICBjYXNlIFwieXl5eXl5XCI6XG4gICAgICAgICAgICAvLyBsaWtlIDAwMDAxMlxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgeWVhcjogXCJudW1lcmljXCIgfSwgXCJ5ZWFyXCIpXG4gICAgICAgICAgICAgIDogdGhpcy5udW0oZHQueWVhciwgNik7XG4gICAgICAgICAgLy8gZXJhc1xuICAgICAgICAgIGNhc2UgXCJHXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEFEXG4gICAgICAgICAgICByZXR1cm4gZXJhKFwic2hvcnRcIik7XG4gICAgICAgICAgY2FzZSBcIkdHXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEFubm8gRG9taW5pXG4gICAgICAgICAgICByZXR1cm4gZXJhKFwibG9uZ1wiKTtcbiAgICAgICAgICBjYXNlIFwiR0dHR0dcIjpcbiAgICAgICAgICAgIHJldHVybiBlcmEoXCJuYXJyb3dcIik7XG4gICAgICAgICAgY2FzZSBcImtrXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQud2Vla1llYXIudG9TdHJpbmcoKS5zbGljZSgtMiksIDIpO1xuICAgICAgICAgIGNhc2UgXCJra2trXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQud2Vla1llYXIsIDQpO1xuICAgICAgICAgIGNhc2UgXCJXXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQud2Vla051bWJlcik7XG4gICAgICAgICAgY2FzZSBcIldXXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQud2Vla051bWJlciwgMik7XG4gICAgICAgICAgY2FzZSBcIm5cIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5sb2NhbFdlZWtOdW1iZXIpO1xuICAgICAgICAgIGNhc2UgXCJublwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LmxvY2FsV2Vla051bWJlciwgMik7XG4gICAgICAgICAgY2FzZSBcImlpXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQubG9jYWxXZWVrWWVhci50b1N0cmluZygpLnNsaWNlKC0yKSwgMik7XG4gICAgICAgICAgY2FzZSBcImlpaWlcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5sb2NhbFdlZWtZZWFyLCA0KTtcbiAgICAgICAgICBjYXNlIFwib1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0Lm9yZGluYWwpO1xuICAgICAgICAgIGNhc2UgXCJvb29cIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5vcmRpbmFsLCAzKTtcbiAgICAgICAgICBjYXNlIFwicVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAxXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQucXVhcnRlcik7XG4gICAgICAgICAgY2FzZSBcInFxXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDAxXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQucXVhcnRlciwgMik7XG4gICAgICAgICAgY2FzZSBcIlhcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShNYXRoLmZsb29yKGR0LnRzIC8gMTAwMCkpO1xuICAgICAgICAgIGNhc2UgXCJ4XCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQudHMpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbWF5YmVNYWNybyh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICByZXR1cm4gc3RyaW5naWZ5VG9rZW5zKEZvcm1hdHRlci5wYXJzZUZvcm1hdChmbXQpLCB0b2tlblRvU3RyaW5nKTtcbiAgfVxuXG4gIGZvcm1hdER1cmF0aW9uRnJvbVN0cmluZyhkdXIsIGZtdCkge1xuICAgIGNvbnN0IHRva2VuVG9GaWVsZCA9ICh0b2tlbikgPT4ge1xuICAgICAgICBzd2l0Y2ggKHRva2VuWzBdKSB7XG4gICAgICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgICAgIHJldHVybiBcIm1pbGxpc2Vjb25kXCI7XG4gICAgICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgICAgIHJldHVybiBcInNlY29uZFwiO1xuICAgICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJtaW51dGVcIjtcbiAgICAgICAgICBjYXNlIFwiaFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiaG91clwiO1xuICAgICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJkYXlcIjtcbiAgICAgICAgICBjYXNlIFwid1wiOlxuICAgICAgICAgICAgcmV0dXJuIFwid2Vla1wiO1xuICAgICAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJtb250aFwiO1xuICAgICAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgICAgICByZXR1cm4gXCJ5ZWFyXCI7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdG9rZW5Ub1N0cmluZyA9IChsaWxkdXIpID0+ICh0b2tlbikgPT4ge1xuICAgICAgICBjb25zdCBtYXBwZWQgPSB0b2tlblRvRmllbGQodG9rZW4pO1xuICAgICAgICBpZiAobWFwcGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGxpbGR1ci5nZXQobWFwcGVkKSwgdG9rZW4ubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b2tlbnMgPSBGb3JtYXR0ZXIucGFyc2VGb3JtYXQoZm10KSxcbiAgICAgIHJlYWxUb2tlbnMgPSB0b2tlbnMucmVkdWNlKFxuICAgICAgICAoZm91bmQsIHsgbGl0ZXJhbCwgdmFsIH0pID0+IChsaXRlcmFsID8gZm91bmQgOiBmb3VuZC5jb25jYXQodmFsKSksXG4gICAgICAgIFtdXG4gICAgICApLFxuICAgICAgY29sbGFwc2VkID0gZHVyLnNoaWZ0VG8oLi4ucmVhbFRva2Vucy5tYXAodG9rZW5Ub0ZpZWxkKS5maWx0ZXIoKHQpID0+IHQpKTtcbiAgICByZXR1cm4gc3RyaW5naWZ5VG9rZW5zKHRva2VucywgdG9rZW5Ub1N0cmluZyhjb2xsYXBzZWQpKTtcbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIHVudHJ1bmNhdGVZZWFyLFxuICBzaWduZWRPZmZzZXQsXG4gIHBhcnNlSW50ZWdlcixcbiAgcGFyc2VNaWxsaXMsXG4gIGlzVW5kZWZpbmVkLFxuICBwYXJzZUZsb2F0aW5nLFxufSBmcm9tIFwiLi91dGlsLmpzXCI7XG5pbXBvcnQgKiBhcyBFbmdsaXNoIGZyb20gXCIuL2VuZ2xpc2guanNcIjtcbmltcG9ydCBGaXhlZE9mZnNldFpvbmUgZnJvbSBcIi4uL3pvbmVzL2ZpeGVkT2Zmc2V0Wm9uZS5qc1wiO1xuaW1wb3J0IElBTkFab25lIGZyb20gXCIuLi96b25lcy9JQU5BWm9uZS5qc1wiO1xuXG4vKlxuICogVGhpcyBmaWxlIGhhbmRsZXMgcGFyc2luZyBmb3Igd2VsbC1zcGVjaWZpZWQgZm9ybWF0cy4gSGVyZSdzIGhvdyBpdCB3b3JrczpcbiAqIFR3byB0aGluZ3MgZ28gaW50byBwYXJzaW5nOiBhIHJlZ2V4IHRvIG1hdGNoIHdpdGggYW5kIGFuIGV4dHJhY3RvciB0byB0YWtlIGFwYXJ0IHRoZSBncm91cHMgaW4gdGhlIG1hdGNoLlxuICogQW4gZXh0cmFjdG9yIGlzIGp1c3QgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgcmVnZXggbWF0Y2ggYXJyYXkgYW5kIHJldHVybnMgYSB7IHllYXI6IC4uLiwgbW9udGg6IC4uLiB9IG9iamVjdFxuICogcGFyc2UoKSBkb2VzIHRoZSB3b3JrIG9mIGV4ZWN1dGluZyB0aGUgcmVnZXggYW5kIGFwcGx5aW5nIHRoZSBleHRyYWN0b3IuIEl0IHRha2VzIG11bHRpcGxlIHJlZ2V4L2V4dHJhY3RvciBwYWlycyB0byB0cnkgaW4gc2VxdWVuY2UuXG4gKiBFeHRyYWN0b3JzIGNhbiB0YWtlIGEgXCJjdXJzb3JcIiByZXByZXNlbnRpbmcgdGhlIG9mZnNldCBpbiB0aGUgbWF0Y2ggdG8gbG9vayBhdC4gVGhpcyBtYWtlcyBpdCBlYXN5IHRvIGNvbWJpbmUgZXh0cmFjdG9ycy5cbiAqIGNvbWJpbmVFeHRyYWN0b3JzKCkgZG9lcyB0aGUgd29yayBvZiBjb21iaW5pbmcgdGhlbSwga2VlcGluZyB0cmFjayBvZiB0aGUgY3Vyc29yIHRocm91Z2ggbXVsdGlwbGUgZXh0cmFjdGlvbnMuXG4gKiBTb21lIGV4dHJhY3Rpb25zIGFyZSBzdXBlciBkdW1iIGFuZCBzaW1wbGVQYXJzZSBhbmQgZnJvbVN0cmluZ3MgaGVscCBEUlkgdGhlbS5cbiAqL1xuXG5jb25zdCBpYW5hUmVnZXggPSAvW0EtWmEtel8rLV17MSwyNTZ9KD86Oj9cXC9bQS1aYS16MC05XystXXsxLDI1Nn0oPzpcXC9bQS1aYS16MC05XystXXsxLDI1Nn0pPyk/LztcblxuZnVuY3Rpb24gY29tYmluZVJlZ2V4ZXMoLi4ucmVnZXhlcykge1xuICBjb25zdCBmdWxsID0gcmVnZXhlcy5yZWR1Y2UoKGYsIHIpID0+IGYgKyByLnNvdXJjZSwgXCJcIik7XG4gIHJldHVybiBSZWdFeHAoYF4ke2Z1bGx9JGApO1xufVxuXG5mdW5jdGlvbiBjb21iaW5lRXh0cmFjdG9ycyguLi5leHRyYWN0b3JzKSB7XG4gIHJldHVybiAobSkgPT5cbiAgICBleHRyYWN0b3JzXG4gICAgICAucmVkdWNlKFxuICAgICAgICAoW21lcmdlZFZhbHMsIG1lcmdlZFpvbmUsIGN1cnNvcl0sIGV4KSA9PiB7XG4gICAgICAgICAgY29uc3QgW3ZhbCwgem9uZSwgbmV4dF0gPSBleChtLCBjdXJzb3IpO1xuICAgICAgICAgIHJldHVybiBbeyAuLi5tZXJnZWRWYWxzLCAuLi52YWwgfSwgem9uZSB8fCBtZXJnZWRab25lLCBuZXh0XTtcbiAgICAgICAgfSxcbiAgICAgICAgW3t9LCBudWxsLCAxXVxuICAgICAgKVxuICAgICAgLnNsaWNlKDAsIDIpO1xufVxuXG5mdW5jdGlvbiBwYXJzZShzLCAuLi5wYXR0ZXJucykge1xuICBpZiAocyA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtudWxsLCBudWxsXTtcbiAgfVxuXG4gIGZvciAoY29uc3QgW3JlZ2V4LCBleHRyYWN0b3JdIG9mIHBhdHRlcm5zKSB7XG4gICAgY29uc3QgbSA9IHJlZ2V4LmV4ZWMocyk7XG4gICAgaWYgKG0pIHtcbiAgICAgIHJldHVybiBleHRyYWN0b3IobSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBbbnVsbCwgbnVsbF07XG59XG5cbmZ1bmN0aW9uIHNpbXBsZVBhcnNlKC4uLmtleXMpIHtcbiAgcmV0dXJuIChtYXRjaCwgY3Vyc29yKSA9PiB7XG4gICAgY29uc3QgcmV0ID0ge307XG4gICAgbGV0IGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgcmV0W2tleXNbaV1dID0gcGFyc2VJbnRlZ2VyKG1hdGNoW2N1cnNvciArIGldKTtcbiAgICB9XG4gICAgcmV0dXJuIFtyZXQsIG51bGwsIGN1cnNvciArIGldO1xuICB9O1xufVxuXG4vLyBJU08gYW5kIFNRTCBwYXJzaW5nXG5jb25zdCBvZmZzZXRSZWdleCA9IC8oPzooWil8KFsrLV1cXGRcXGQpKD86Oj8oXFxkXFxkKSk/KS87XG5jb25zdCBpc29FeHRlbmRlZFpvbmUgPSBgKD86JHtvZmZzZXRSZWdleC5zb3VyY2V9Pyg/OlxcXFxbKCR7aWFuYVJlZ2V4LnNvdXJjZX0pXFxcXF0pPyk/YDtcbmNvbnN0IGlzb1RpbWVCYXNlUmVnZXggPSAvKFxcZFxcZCkoPzo6PyhcXGRcXGQpKD86Oj8oXFxkXFxkKSg/OlsuLF0oXFxkezEsMzB9KSk/KT8pPy87XG5jb25zdCBpc29UaW1lUmVnZXggPSBSZWdFeHAoYCR7aXNvVGltZUJhc2VSZWdleC5zb3VyY2V9JHtpc29FeHRlbmRlZFpvbmV9YCk7XG5jb25zdCBpc29UaW1lRXh0ZW5zaW9uUmVnZXggPSBSZWdFeHAoYCg/OlQke2lzb1RpbWVSZWdleC5zb3VyY2V9KT9gKTtcbmNvbnN0IGlzb1ltZFJlZ2V4ID0gLyhbKy1dXFxkezZ9fFxcZHs0fSkoPzotPyhcXGRcXGQpKD86LT8oXFxkXFxkKSk/KT8vO1xuY29uc3QgaXNvV2Vla1JlZ2V4ID0gLyhcXGR7NH0pLT9XKFxcZFxcZCkoPzotPyhcXGQpKT8vO1xuY29uc3QgaXNvT3JkaW5hbFJlZ2V4ID0gLyhcXGR7NH0pLT8oXFxkezN9KS87XG5jb25zdCBleHRyYWN0SVNPV2Vla0RhdGEgPSBzaW1wbGVQYXJzZShcIndlZWtZZWFyXCIsIFwid2Vla051bWJlclwiLCBcIndlZWtEYXlcIik7XG5jb25zdCBleHRyYWN0SVNPT3JkaW5hbERhdGEgPSBzaW1wbGVQYXJzZShcInllYXJcIiwgXCJvcmRpbmFsXCIpO1xuY29uc3Qgc3FsWW1kUmVnZXggPSAvKFxcZHs0fSktKFxcZFxcZCktKFxcZFxcZCkvOyAvLyBkdW1iZWQtZG93biB2ZXJzaW9uIG9mIHRoZSBJU08gb25lXG5jb25zdCBzcWxUaW1lUmVnZXggPSBSZWdFeHAoXG4gIGAke2lzb1RpbWVCYXNlUmVnZXguc291cmNlfSA/KD86JHtvZmZzZXRSZWdleC5zb3VyY2V9fCgke2lhbmFSZWdleC5zb3VyY2V9KSk/YFxuKTtcbmNvbnN0IHNxbFRpbWVFeHRlbnNpb25SZWdleCA9IFJlZ0V4cChgKD86ICR7c3FsVGltZVJlZ2V4LnNvdXJjZX0pP2ApO1xuXG5mdW5jdGlvbiBpbnQobWF0Y2gsIHBvcywgZmFsbGJhY2spIHtcbiAgY29uc3QgbSA9IG1hdGNoW3Bvc107XG4gIHJldHVybiBpc1VuZGVmaW5lZChtKSA/IGZhbGxiYWNrIDogcGFyc2VJbnRlZ2VyKG0pO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0SVNPWW1kKG1hdGNoLCBjdXJzb3IpIHtcbiAgY29uc3QgaXRlbSA9IHtcbiAgICB5ZWFyOiBpbnQobWF0Y2gsIGN1cnNvciksXG4gICAgbW9udGg6IGludChtYXRjaCwgY3Vyc29yICsgMSwgMSksXG4gICAgZGF5OiBpbnQobWF0Y2gsIGN1cnNvciArIDIsIDEpLFxuICB9O1xuXG4gIHJldHVybiBbaXRlbSwgbnVsbCwgY3Vyc29yICsgM107XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RJU09UaW1lKG1hdGNoLCBjdXJzb3IpIHtcbiAgY29uc3QgaXRlbSA9IHtcbiAgICBob3VyczogaW50KG1hdGNoLCBjdXJzb3IsIDApLFxuICAgIG1pbnV0ZXM6IGludChtYXRjaCwgY3Vyc29yICsgMSwgMCksXG4gICAgc2Vjb25kczogaW50KG1hdGNoLCBjdXJzb3IgKyAyLCAwKSxcbiAgICBtaWxsaXNlY29uZHM6IHBhcnNlTWlsbGlzKG1hdGNoW2N1cnNvciArIDNdKSxcbiAgfTtcblxuICByZXR1cm4gW2l0ZW0sIG51bGwsIGN1cnNvciArIDRdO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0SVNPT2Zmc2V0KG1hdGNoLCBjdXJzb3IpIHtcbiAgY29uc3QgbG9jYWwgPSAhbWF0Y2hbY3Vyc29yXSAmJiAhbWF0Y2hbY3Vyc29yICsgMV0sXG4gICAgZnVsbE9mZnNldCA9IHNpZ25lZE9mZnNldChtYXRjaFtjdXJzb3IgKyAxXSwgbWF0Y2hbY3Vyc29yICsgMl0pLFxuICAgIHpvbmUgPSBsb2NhbCA/IG51bGwgOiBGaXhlZE9mZnNldFpvbmUuaW5zdGFuY2UoZnVsbE9mZnNldCk7XG4gIHJldHVybiBbe30sIHpvbmUsIGN1cnNvciArIDNdO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0SUFOQVpvbmUobWF0Y2gsIGN1cnNvcikge1xuICBjb25zdCB6b25lID0gbWF0Y2hbY3Vyc29yXSA/IElBTkFab25lLmNyZWF0ZShtYXRjaFtjdXJzb3JdKSA6IG51bGw7XG4gIHJldHVybiBbe30sIHpvbmUsIGN1cnNvciArIDFdO1xufVxuXG4vLyBJU08gdGltZSBwYXJzaW5nXG5cbmNvbnN0IGlzb1RpbWVPbmx5ID0gUmVnRXhwKGBeVD8ke2lzb1RpbWVCYXNlUmVnZXguc291cmNlfSRgKTtcblxuLy8gSVNPIGR1cmF0aW9uIHBhcnNpbmdcblxuY29uc3QgaXNvRHVyYXRpb24gPVxuICAvXi0/UCg/Oig/OigtP1xcZHsxLDIwfSg/OlxcLlxcZHsxLDIwfSk/KVkpPyg/OigtP1xcZHsxLDIwfSg/OlxcLlxcZHsxLDIwfSk/KU0pPyg/OigtP1xcZHsxLDIwfSg/OlxcLlxcZHsxLDIwfSk/KVcpPyg/OigtP1xcZHsxLDIwfSg/OlxcLlxcZHsxLDIwfSk/KUQpPyg/OlQoPzooLT9cXGR7MSwyMH0oPzpcXC5cXGR7MSwyMH0pPylIKT8oPzooLT9cXGR7MSwyMH0oPzpcXC5cXGR7MSwyMH0pPylNKT8oPzooLT9cXGR7MSwyMH0pKD86Wy4sXSgtP1xcZHsxLDIwfSkpP1MpPyk/KSQvO1xuXG5mdW5jdGlvbiBleHRyYWN0SVNPRHVyYXRpb24obWF0Y2gpIHtcbiAgY29uc3QgW3MsIHllYXJTdHIsIG1vbnRoU3RyLCB3ZWVrU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyLCBtaWxsaXNlY29uZHNTdHJdID1cbiAgICBtYXRjaDtcblxuICBjb25zdCBoYXNOZWdhdGl2ZVByZWZpeCA9IHNbMF0gPT09IFwiLVwiO1xuICBjb25zdCBuZWdhdGl2ZVNlY29uZHMgPSBzZWNvbmRTdHIgJiYgc2Vjb25kU3RyWzBdID09PSBcIi1cIjtcblxuICBjb25zdCBtYXliZU5lZ2F0ZSA9IChudW0sIGZvcmNlID0gZmFsc2UpID0+XG4gICAgbnVtICE9PSB1bmRlZmluZWQgJiYgKGZvcmNlIHx8IChudW0gJiYgaGFzTmVnYXRpdmVQcmVmaXgpKSA/IC1udW0gOiBudW07XG5cbiAgcmV0dXJuIFtcbiAgICB7XG4gICAgICB5ZWFyczogbWF5YmVOZWdhdGUocGFyc2VGbG9hdGluZyh5ZWFyU3RyKSksXG4gICAgICBtb250aHM6IG1heWJlTmVnYXRlKHBhcnNlRmxvYXRpbmcobW9udGhTdHIpKSxcbiAgICAgIHdlZWtzOiBtYXliZU5lZ2F0ZShwYXJzZUZsb2F0aW5nKHdlZWtTdHIpKSxcbiAgICAgIGRheXM6IG1heWJlTmVnYXRlKHBhcnNlRmxvYXRpbmcoZGF5U3RyKSksXG4gICAgICBob3VyczogbWF5YmVOZWdhdGUocGFyc2VGbG9hdGluZyhob3VyU3RyKSksXG4gICAgICBtaW51dGVzOiBtYXliZU5lZ2F0ZShwYXJzZUZsb2F0aW5nKG1pbnV0ZVN0cikpLFxuICAgICAgc2Vjb25kczogbWF5YmVOZWdhdGUocGFyc2VGbG9hdGluZyhzZWNvbmRTdHIpLCBzZWNvbmRTdHIgPT09IFwiLTBcIiksXG4gICAgICBtaWxsaXNlY29uZHM6IG1heWJlTmVnYXRlKHBhcnNlTWlsbGlzKG1pbGxpc2Vjb25kc1N0ciksIG5lZ2F0aXZlU2Vjb25kcyksXG4gICAgfSxcbiAgXTtcbn1cblxuLy8gVGhlc2UgYXJlIGEgbGl0dGxlIGJyYWluZGVhZC4gRURUICpzaG91bGQqIHRlbGwgdXMgdGhhdCB3ZSdyZSBpbiwgc2F5LCBBbWVyaWNhL05ld19Zb3JrXG4vLyBhbmQgbm90IGp1c3QgdGhhdCB3ZSdyZSBpbiAtMjQwICpyaWdodCBub3cqLiBCdXQgc2luY2UgSSBkb24ndCB0aGluayB0aGVzZSBhcmUgdXNlZCB0aGF0IG9mdGVuXG4vLyBJJ20ganVzdCBnb2luZyB0byBpZ25vcmUgdGhhdFxuY29uc3Qgb2JzT2Zmc2V0cyA9IHtcbiAgR01UOiAwLFxuICBFRFQ6IC00ICogNjAsXG4gIEVTVDogLTUgKiA2MCxcbiAgQ0RUOiAtNSAqIDYwLFxuICBDU1Q6IC02ICogNjAsXG4gIE1EVDogLTYgKiA2MCxcbiAgTVNUOiAtNyAqIDYwLFxuICBQRFQ6IC03ICogNjAsXG4gIFBTVDogLTggKiA2MCxcbn07XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmdzKHdlZWtkYXlTdHIsIHllYXJTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICB5ZWFyOiB5ZWFyU3RyLmxlbmd0aCA9PT0gMiA/IHVudHJ1bmNhdGVZZWFyKHBhcnNlSW50ZWdlcih5ZWFyU3RyKSkgOiBwYXJzZUludGVnZXIoeWVhclN0ciksXG4gICAgbW9udGg6IEVuZ2xpc2gubW9udGhzU2hvcnQuaW5kZXhPZihtb250aFN0cikgKyAxLFxuICAgIGRheTogcGFyc2VJbnRlZ2VyKGRheVN0ciksXG4gICAgaG91cjogcGFyc2VJbnRlZ2VyKGhvdXJTdHIpLFxuICAgIG1pbnV0ZTogcGFyc2VJbnRlZ2VyKG1pbnV0ZVN0ciksXG4gIH07XG5cbiAgaWYgKHNlY29uZFN0cikgcmVzdWx0LnNlY29uZCA9IHBhcnNlSW50ZWdlcihzZWNvbmRTdHIpO1xuICBpZiAod2Vla2RheVN0cikge1xuICAgIHJlc3VsdC53ZWVrZGF5ID1cbiAgICAgIHdlZWtkYXlTdHIubGVuZ3RoID4gM1xuICAgICAgICA/IEVuZ2xpc2gud2Vla2RheXNMb25nLmluZGV4T2Yod2Vla2RheVN0cikgKyAxXG4gICAgICAgIDogRW5nbGlzaC53ZWVrZGF5c1Nob3J0LmluZGV4T2Yod2Vla2RheVN0cikgKyAxO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gUkZDIDI4MjIvNTMyMlxuY29uc3QgcmZjMjgyMiA9XG4gIC9eKD86KE1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1biksXFxzKT8oXFxkezEsMn0pXFxzKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKVxccyhcXGR7Miw0fSlcXHMoXFxkXFxkKTooXFxkXFxkKSg/OjooXFxkXFxkKSk/XFxzKD86KFVUfEdNVHxbRUNNUF1bU0RdVCl8KFtael0pfCg/OihbKy1dXFxkXFxkKShcXGRcXGQpKSkkLztcblxuZnVuY3Rpb24gZXh0cmFjdFJGQzI4MjIobWF0Y2gpIHtcbiAgY29uc3QgW1xuICAgICAgLFxuICAgICAgd2Vla2RheVN0cixcbiAgICAgIGRheVN0cixcbiAgICAgIG1vbnRoU3RyLFxuICAgICAgeWVhclN0cixcbiAgICAgIGhvdXJTdHIsXG4gICAgICBtaW51dGVTdHIsXG4gICAgICBzZWNvbmRTdHIsXG4gICAgICBvYnNPZmZzZXQsXG4gICAgICBtaWxPZmZzZXQsXG4gICAgICBvZmZIb3VyU3RyLFxuICAgICAgb2ZmTWludXRlU3RyLFxuICAgIF0gPSBtYXRjaCxcbiAgICByZXN1bHQgPSBmcm9tU3RyaW5ncyh3ZWVrZGF5U3RyLCB5ZWFyU3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cik7XG5cbiAgbGV0IG9mZnNldDtcbiAgaWYgKG9ic09mZnNldCkge1xuICAgIG9mZnNldCA9IG9ic09mZnNldHNbb2JzT2Zmc2V0XTtcbiAgfSBlbHNlIGlmIChtaWxPZmZzZXQpIHtcbiAgICBvZmZzZXQgPSAwO1xuICB9IGVsc2Uge1xuICAgIG9mZnNldCA9IHNpZ25lZE9mZnNldChvZmZIb3VyU3RyLCBvZmZNaW51dGVTdHIpO1xuICB9XG5cbiAgcmV0dXJuIFtyZXN1bHQsIG5ldyBGaXhlZE9mZnNldFpvbmUob2Zmc2V0KV07XG59XG5cbmZ1bmN0aW9uIHByZXByb2Nlc3NSRkMyODIyKHMpIHtcbiAgLy8gUmVtb3ZlIGNvbW1lbnRzIGFuZCBmb2xkaW5nIHdoaXRlc3BhY2UgYW5kIHJlcGxhY2UgbXVsdGlwbGUtc3BhY2VzIHdpdGggYSBzaW5nbGUgc3BhY2VcbiAgcmV0dXJuIHNcbiAgICAucmVwbGFjZSgvXFwoW14oKV0qXFwpfFtcXG5cXHRdL2csIFwiIFwiKVxuICAgIC5yZXBsYWNlKC8oXFxzXFxzKykvZywgXCIgXCIpXG4gICAgLnRyaW0oKTtcbn1cblxuLy8gaHR0cCBkYXRlXG5cbmNvbnN0IHJmYzExMjMgPVxuICAgIC9eKE1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1biksIChcXGRcXGQpIChKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYykgKFxcZHs0fSkgKFxcZFxcZCk6KFxcZFxcZCk6KFxcZFxcZCkgR01UJC8sXG4gIHJmYzg1MCA9XG4gICAgL14oTW9uZGF5fFR1ZXNkYXl8V2VkbmVzZGF5fFRodXJzZGF5fEZyaWRheXxTYXR1cmRheXxTdW5kYXkpLCAoXFxkXFxkKS0oSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpLShcXGRcXGQpIChcXGRcXGQpOihcXGRcXGQpOihcXGRcXGQpIEdNVCQvLFxuICBhc2NpaSA9XG4gICAgL14oTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSAoSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpICggXFxkfFxcZFxcZCkgKFxcZFxcZCk6KFxcZFxcZCk6KFxcZFxcZCkgKFxcZHs0fSkkLztcblxuZnVuY3Rpb24gZXh0cmFjdFJGQzExMjNPcjg1MChtYXRjaCkge1xuICBjb25zdCBbLCB3ZWVrZGF5U3RyLCBkYXlTdHIsIG1vbnRoU3RyLCB5ZWFyU3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cl0gPSBtYXRjaCxcbiAgICByZXN1bHQgPSBmcm9tU3RyaW5ncyh3ZWVrZGF5U3RyLCB5ZWFyU3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cik7XG4gIHJldHVybiBbcmVzdWx0LCBGaXhlZE9mZnNldFpvbmUudXRjSW5zdGFuY2VdO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0QVNDSUkobWF0Y2gpIHtcbiAgY29uc3QgWywgd2Vla2RheVN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIsIHllYXJTdHJdID0gbWF0Y2gsXG4gICAgcmVzdWx0ID0gZnJvbVN0cmluZ3Mod2Vla2RheVN0ciwgeWVhclN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIpO1xuICByZXR1cm4gW3Jlc3VsdCwgRml4ZWRPZmZzZXRab25lLnV0Y0luc3RhbmNlXTtcbn1cblxuY29uc3QgaXNvWW1kV2l0aFRpbWVFeHRlbnNpb25SZWdleCA9IGNvbWJpbmVSZWdleGVzKGlzb1ltZFJlZ2V4LCBpc29UaW1lRXh0ZW5zaW9uUmVnZXgpO1xuY29uc3QgaXNvV2Vla1dpdGhUaW1lRXh0ZW5zaW9uUmVnZXggPSBjb21iaW5lUmVnZXhlcyhpc29XZWVrUmVnZXgsIGlzb1RpbWVFeHRlbnNpb25SZWdleCk7XG5jb25zdCBpc29PcmRpbmFsV2l0aFRpbWVFeHRlbnNpb25SZWdleCA9IGNvbWJpbmVSZWdleGVzKGlzb09yZGluYWxSZWdleCwgaXNvVGltZUV4dGVuc2lvblJlZ2V4KTtcbmNvbnN0IGlzb1RpbWVDb21iaW5lZFJlZ2V4ID0gY29tYmluZVJlZ2V4ZXMoaXNvVGltZVJlZ2V4KTtcblxuY29uc3QgZXh0cmFjdElTT1ltZFRpbWVBbmRPZmZzZXQgPSBjb21iaW5lRXh0cmFjdG9ycyhcbiAgZXh0cmFjdElTT1ltZCxcbiAgZXh0cmFjdElTT1RpbWUsXG4gIGV4dHJhY3RJU09PZmZzZXQsXG4gIGV4dHJhY3RJQU5BWm9uZVxuKTtcbmNvbnN0IGV4dHJhY3RJU09XZWVrVGltZUFuZE9mZnNldCA9IGNvbWJpbmVFeHRyYWN0b3JzKFxuICBleHRyYWN0SVNPV2Vla0RhdGEsXG4gIGV4dHJhY3RJU09UaW1lLFxuICBleHRyYWN0SVNPT2Zmc2V0LFxuICBleHRyYWN0SUFOQVpvbmVcbik7XG5jb25zdCBleHRyYWN0SVNPT3JkaW5hbERhdGVBbmRUaW1lID0gY29tYmluZUV4dHJhY3RvcnMoXG4gIGV4dHJhY3RJU09PcmRpbmFsRGF0YSxcbiAgZXh0cmFjdElTT1RpbWUsXG4gIGV4dHJhY3RJU09PZmZzZXQsXG4gIGV4dHJhY3RJQU5BWm9uZVxuKTtcbmNvbnN0IGV4dHJhY3RJU09UaW1lQW5kT2Zmc2V0ID0gY29tYmluZUV4dHJhY3RvcnMoXG4gIGV4dHJhY3RJU09UaW1lLFxuICBleHRyYWN0SVNPT2Zmc2V0LFxuICBleHRyYWN0SUFOQVpvbmVcbik7XG5cbi8qXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUlTT0RhdGUocykge1xuICByZXR1cm4gcGFyc2UoXG4gICAgcyxcbiAgICBbaXNvWW1kV2l0aFRpbWVFeHRlbnNpb25SZWdleCwgZXh0cmFjdElTT1ltZFRpbWVBbmRPZmZzZXRdLFxuICAgIFtpc29XZWVrV2l0aFRpbWVFeHRlbnNpb25SZWdleCwgZXh0cmFjdElTT1dlZWtUaW1lQW5kT2Zmc2V0XSxcbiAgICBbaXNvT3JkaW5hbFdpdGhUaW1lRXh0ZW5zaW9uUmVnZXgsIGV4dHJhY3RJU09PcmRpbmFsRGF0ZUFuZFRpbWVdLFxuICAgIFtpc29UaW1lQ29tYmluZWRSZWdleCwgZXh0cmFjdElTT1RpbWVBbmRPZmZzZXRdXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVJGQzI4MjJEYXRlKHMpIHtcbiAgcmV0dXJuIHBhcnNlKHByZXByb2Nlc3NSRkMyODIyKHMpLCBbcmZjMjgyMiwgZXh0cmFjdFJGQzI4MjJdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSFRUUERhdGUocykge1xuICByZXR1cm4gcGFyc2UoXG4gICAgcyxcbiAgICBbcmZjMTEyMywgZXh0cmFjdFJGQzExMjNPcjg1MF0sXG4gICAgW3JmYzg1MCwgZXh0cmFjdFJGQzExMjNPcjg1MF0sXG4gICAgW2FzY2lpLCBleHRyYWN0QVNDSUldXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUlTT0R1cmF0aW9uKHMpIHtcbiAgcmV0dXJuIHBhcnNlKHMsIFtpc29EdXJhdGlvbiwgZXh0cmFjdElTT0R1cmF0aW9uXSk7XG59XG5cbmNvbnN0IGV4dHJhY3RJU09UaW1lT25seSA9IGNvbWJpbmVFeHRyYWN0b3JzKGV4dHJhY3RJU09UaW1lKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSVNPVGltZU9ubHkocykge1xuICByZXR1cm4gcGFyc2UocywgW2lzb1RpbWVPbmx5LCBleHRyYWN0SVNPVGltZU9ubHldKTtcbn1cblxuY29uc3Qgc3FsWW1kV2l0aFRpbWVFeHRlbnNpb25SZWdleCA9IGNvbWJpbmVSZWdleGVzKHNxbFltZFJlZ2V4LCBzcWxUaW1lRXh0ZW5zaW9uUmVnZXgpO1xuY29uc3Qgc3FsVGltZUNvbWJpbmVkUmVnZXggPSBjb21iaW5lUmVnZXhlcyhzcWxUaW1lUmVnZXgpO1xuXG5jb25zdCBleHRyYWN0SVNPVGltZU9mZnNldEFuZElBTkFab25lID0gY29tYmluZUV4dHJhY3RvcnMoXG4gIGV4dHJhY3RJU09UaW1lLFxuICBleHRyYWN0SVNPT2Zmc2V0LFxuICBleHRyYWN0SUFOQVpvbmVcbik7XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVNRTChzKSB7XG4gIHJldHVybiBwYXJzZShcbiAgICBzLFxuICAgIFtzcWxZbWRXaXRoVGltZUV4dGVuc2lvblJlZ2V4LCBleHRyYWN0SVNPWW1kVGltZUFuZE9mZnNldF0sXG4gICAgW3NxbFRpbWVDb21iaW5lZFJlZ2V4LCBleHRyYWN0SVNPVGltZU9mZnNldEFuZElBTkFab25lXVxuICApO1xufVxuIiwgImltcG9ydCB7IEludmFsaWRBcmd1bWVudEVycm9yLCBJbnZhbGlkRHVyYXRpb25FcnJvciwgSW52YWxpZFVuaXRFcnJvciB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IEZvcm1hdHRlciBmcm9tIFwiLi9pbXBsL2Zvcm1hdHRlci5qc1wiO1xuaW1wb3J0IEludmFsaWQgZnJvbSBcIi4vaW1wbC9pbnZhbGlkLmpzXCI7XG5pbXBvcnQgTG9jYWxlIGZyb20gXCIuL2ltcGwvbG9jYWxlLmpzXCI7XG5pbXBvcnQgeyBwYXJzZUlTT0R1cmF0aW9uLCBwYXJzZUlTT1RpbWVPbmx5IH0gZnJvbSBcIi4vaW1wbC9yZWdleFBhcnNlci5qc1wiO1xuaW1wb3J0IHtcbiAgYXNOdW1iZXIsXG4gIGhhc093blByb3BlcnR5LFxuICBpc051bWJlcixcbiAgaXNVbmRlZmluZWQsXG4gIG5vcm1hbGl6ZU9iamVjdCxcbiAgcm91bmRUbyxcbn0gZnJvbSBcIi4vaW1wbC91dGlsLmpzXCI7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSBcIi4vc2V0dGluZ3MuanNcIjtcbmltcG9ydCBEYXRlVGltZSBmcm9tIFwiLi9kYXRldGltZS5qc1wiO1xuXG5jb25zdCBJTlZBTElEID0gXCJJbnZhbGlkIER1cmF0aW9uXCI7XG5cbi8vIHVuaXQgY29udmVyc2lvbiBjb25zdGFudHNcbmV4cG9ydCBjb25zdCBsb3dPcmRlck1hdHJpeCA9IHtcbiAgICB3ZWVrczoge1xuICAgICAgZGF5czogNyxcbiAgICAgIGhvdXJzOiA3ICogMjQsXG4gICAgICBtaW51dGVzOiA3ICogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IDcgKiAyNCAqIDYwICogNjAsXG4gICAgICBtaWxsaXNlY29uZHM6IDcgKiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICAgIH0sXG4gICAgZGF5czoge1xuICAgICAgaG91cnM6IDI0LFxuICAgICAgbWludXRlczogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuICAgIGhvdXJzOiB7IG1pbnV0ZXM6IDYwLCBzZWNvbmRzOiA2MCAqIDYwLCBtaWxsaXNlY29uZHM6IDYwICogNjAgKiAxMDAwIH0sXG4gICAgbWludXRlczogeyBzZWNvbmRzOiA2MCwgbWlsbGlzZWNvbmRzOiA2MCAqIDEwMDAgfSxcbiAgICBzZWNvbmRzOiB7IG1pbGxpc2Vjb25kczogMTAwMCB9LFxuICB9LFxuICBjYXN1YWxNYXRyaXggPSB7XG4gICAgeWVhcnM6IHtcbiAgICAgIHF1YXJ0ZXJzOiA0LFxuICAgICAgbW9udGhzOiAxMixcbiAgICAgIHdlZWtzOiA1MixcbiAgICAgIGRheXM6IDM2NSxcbiAgICAgIGhvdXJzOiAzNjUgKiAyNCxcbiAgICAgIG1pbnV0ZXM6IDM2NSAqIDI0ICogNjAsXG4gICAgICBzZWNvbmRzOiAzNjUgKiAyNCAqIDYwICogNjAsXG4gICAgICBtaWxsaXNlY29uZHM6IDM2NSAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgfSxcbiAgICBxdWFydGVyczoge1xuICAgICAgbW9udGhzOiAzLFxuICAgICAgd2Vla3M6IDEzLFxuICAgICAgZGF5czogOTEsXG4gICAgICBob3VyczogOTEgKiAyNCxcbiAgICAgIG1pbnV0ZXM6IDkxICogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IDkxICogMjQgKiA2MCAqIDYwLFxuICAgICAgbWlsbGlzZWNvbmRzOiA5MSAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgfSxcbiAgICBtb250aHM6IHtcbiAgICAgIHdlZWtzOiA0LFxuICAgICAgZGF5czogMzAsXG4gICAgICBob3VyczogMzAgKiAyNCxcbiAgICAgIG1pbnV0ZXM6IDMwICogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IDMwICogMjQgKiA2MCAqIDYwLFxuICAgICAgbWlsbGlzZWNvbmRzOiAzMCAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgfSxcblxuICAgIC4uLmxvd09yZGVyTWF0cml4LFxuICB9LFxuICBkYXlzSW5ZZWFyQWNjdXJhdGUgPSAxNDYwOTcuMCAvIDQwMCxcbiAgZGF5c0luTW9udGhBY2N1cmF0ZSA9IDE0NjA5Ny4wIC8gNDgwMCxcbiAgYWNjdXJhdGVNYXRyaXggPSB7XG4gICAgeWVhcnM6IHtcbiAgICAgIHF1YXJ0ZXJzOiA0LFxuICAgICAgbW9udGhzOiAxMixcbiAgICAgIHdlZWtzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgLyA3LFxuICAgICAgZGF5czogZGF5c0luWWVhckFjY3VyYXRlLFxuICAgICAgaG91cnM6IGRheXNJblllYXJBY2N1cmF0ZSAqIDI0LFxuICAgICAgbWludXRlczogZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IGRheXNJblllYXJBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuICAgIHF1YXJ0ZXJzOiB7XG4gICAgICBtb250aHM6IDMsXG4gICAgICB3ZWVrczogZGF5c0luWWVhckFjY3VyYXRlIC8gMjgsXG4gICAgICBkYXlzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgLyA0LFxuICAgICAgaG91cnM6IChkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCkgLyA0LFxuICAgICAgbWludXRlczogKGRheXNJblllYXJBY2N1cmF0ZSAqIDI0ICogNjApIC8gNCxcbiAgICAgIHNlY29uZHM6IChkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCAqIDYwICogNjApIC8gNCxcbiAgICAgIG1pbGxpc2Vjb25kczogKGRheXNJblllYXJBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCAqIDEwMDApIC8gNCxcbiAgICB9LFxuICAgIG1vbnRoczoge1xuICAgICAgd2Vla3M6IGRheXNJbk1vbnRoQWNjdXJhdGUgLyA3LFxuICAgICAgZGF5czogZGF5c0luTW9udGhBY2N1cmF0ZSxcbiAgICAgIGhvdXJzOiBkYXlzSW5Nb250aEFjY3VyYXRlICogMjQsXG4gICAgICBtaW51dGVzOiBkYXlzSW5Nb250aEFjY3VyYXRlICogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IGRheXNJbk1vbnRoQWNjdXJhdGUgKiAyNCAqIDYwICogNjAsXG4gICAgICBtaWxsaXNlY29uZHM6IGRheXNJbk1vbnRoQWNjdXJhdGUgKiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICAgIH0sXG4gICAgLi4ubG93T3JkZXJNYXRyaXgsXG4gIH07XG5cbi8vIHVuaXRzIG9yZGVyZWQgYnkgc2l6ZVxuY29uc3Qgb3JkZXJlZFVuaXRzID0gW1xuICBcInllYXJzXCIsXG4gIFwicXVhcnRlcnNcIixcbiAgXCJtb250aHNcIixcbiAgXCJ3ZWVrc1wiLFxuICBcImRheXNcIixcbiAgXCJob3Vyc1wiLFxuICBcIm1pbnV0ZXNcIixcbiAgXCJzZWNvbmRzXCIsXG4gIFwibWlsbGlzZWNvbmRzXCIsXG5dO1xuXG5jb25zdCByZXZlcnNlVW5pdHMgPSBvcmRlcmVkVW5pdHMuc2xpY2UoMCkucmV2ZXJzZSgpO1xuXG4vLyBjbG9uZSByZWFsbHkgbWVhbnMgXCJjcmVhdGUgYW5vdGhlciBpbnN0YW5jZSBqdXN0IGxpa2UgdGhpcyBvbmUsIGJ1dCB3aXRoIHRoZXNlIGNoYW5nZXNcIlxuZnVuY3Rpb24gY2xvbmUoZHVyLCBhbHRzLCBjbGVhciA9IGZhbHNlKSB7XG4gIC8vIGRlZXAgbWVyZ2UgZm9yIHZhbHNcbiAgY29uc3QgY29uZiA9IHtcbiAgICB2YWx1ZXM6IGNsZWFyID8gYWx0cy52YWx1ZXMgOiB7IC4uLmR1ci52YWx1ZXMsIC4uLihhbHRzLnZhbHVlcyB8fCB7fSkgfSxcbiAgICBsb2M6IGR1ci5sb2MuY2xvbmUoYWx0cy5sb2MpLFxuICAgIGNvbnZlcnNpb25BY2N1cmFjeTogYWx0cy5jb252ZXJzaW9uQWNjdXJhY3kgfHwgZHVyLmNvbnZlcnNpb25BY2N1cmFjeSxcbiAgICBtYXRyaXg6IGFsdHMubWF0cml4IHx8IGR1ci5tYXRyaXgsXG4gIH07XG4gIHJldHVybiBuZXcgRHVyYXRpb24oY29uZik7XG59XG5cbmZ1bmN0aW9uIGR1cmF0aW9uVG9NaWxsaXMobWF0cml4LCB2YWxzKSB7XG4gIGxldCBzdW0gPSB2YWxzLm1pbGxpc2Vjb25kcyA/PyAwO1xuICBmb3IgKGNvbnN0IHVuaXQgb2YgcmV2ZXJzZVVuaXRzLnNsaWNlKDEpKSB7XG4gICAgaWYgKHZhbHNbdW5pdF0pIHtcbiAgICAgIHN1bSArPSB2YWxzW3VuaXRdICogbWF0cml4W3VuaXRdW1wibWlsbGlzZWNvbmRzXCJdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3VtO1xufVxuXG4vLyBOQjogbXV0YXRlcyBwYXJhbWV0ZXJzXG5mdW5jdGlvbiBub3JtYWxpemVWYWx1ZXMobWF0cml4LCB2YWxzKSB7XG4gIC8vIHRoZSBsb2dpYyBiZWxvdyBhc3N1bWVzIHRoZSBvdmVyYWxsIHZhbHVlIG9mIHRoZSBkdXJhdGlvbiBpcyBwb3NpdGl2ZVxuICAvLyBpZiB0aGlzIGlzIG5vdCB0aGUgY2FzZSwgZmFjdG9yIGlzIHVzZWQgdG8gbWFrZSBpdCBzb1xuICBjb25zdCBmYWN0b3IgPSBkdXJhdGlvblRvTWlsbGlzKG1hdHJpeCwgdmFscykgPCAwID8gLTEgOiAxO1xuXG4gIG9yZGVyZWRVbml0cy5yZWR1Y2VSaWdodCgocHJldmlvdXMsIGN1cnJlbnQpID0+IHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHZhbHNbY3VycmVudF0pKSB7XG4gICAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNWYWwgPSB2YWxzW3ByZXZpb3VzXSAqIGZhY3RvcjtcbiAgICAgICAgY29uc3QgY29udiA9IG1hdHJpeFtjdXJyZW50XVtwcmV2aW91c107XG5cbiAgICAgICAgLy8gaWYgKHByZXZpb3VzVmFsIDwgMCk6XG4gICAgICAgIC8vIGxvd2VyIG9yZGVyIHVuaXQgaXMgbmVnYXRpdmUgKGUuZy4geyB5ZWFyczogMiwgZGF5czogLTIgfSlcbiAgICAgICAgLy8gbm9ybWFsaXplIHRoaXMgYnkgcmVkdWNpbmcgdGhlIGhpZ2hlciBvcmRlciB1bml0IGJ5IHRoZSBhcHByb3ByaWF0ZSBhbW91bnRcbiAgICAgICAgLy8gYW5kIGluY3JlYXNpbmcgdGhlIGxvd2VyIG9yZGVyIHVuaXRcbiAgICAgICAgLy8gdGhpcyBjYW4gbmV2ZXIgbWFrZSB0aGUgaGlnaGVyIG9yZGVyIHVuaXQgbmVnYXRpdmUsIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBvbmx5IG9wZXJhdGVzXG4gICAgICAgIC8vIG9uIHBvc2l0aXZlIGR1cmF0aW9ucywgc28gdGhlIGFtb3VudCBvZiB0aW1lIHJlcHJlc2VudGVkIGJ5IHRoZSBsb3dlciBvcmRlciB1bml0IGNhbm5vdFxuICAgICAgICAvLyBiZSBsYXJnZXIgdGhhbiB0aGUgaGlnaGVyIG9yZGVyIHVuaXRcbiAgICAgICAgLy8gZWxzZTpcbiAgICAgICAgLy8gbG93ZXIgb3JkZXIgdW5pdCBpcyBwb3NpdGl2ZSAoZS5nLiB7IHllYXJzOiAyLCBkYXlzOiA0NTAgfSBvciB7IHllYXJzOiAtMiwgZGF5czogNDUwIH0pXG4gICAgICAgIC8vIGluIHRoaXMgY2FzZSB3ZSBhdHRlbXB0IHRvIGNvbnZlcnQgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBsb3dlciBvcmRlciB1bml0IGludG9cbiAgICAgICAgLy8gdGhlIGhpZ2hlciBvcmRlciBvbmVcbiAgICAgICAgLy9cbiAgICAgICAgLy8gTWF0aC5mbG9vciB0YWtlcyBjYXJlIG9mIGJvdGggb2YgdGhlc2UgY2FzZXMsIHJvdW5kaW5nIGF3YXkgZnJvbSAwXG4gICAgICAgIC8vIGlmIHByZXZpb3VzVmFsIDwgMCBpdCBtYWtlcyB0aGUgYWJzb2x1dGUgdmFsdWUgbGFyZ2VyXG4gICAgICAgIC8vIGlmIHByZXZpb3VzVmFsID49IGl0IG1ha2VzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBzbWFsbGVyXG4gICAgICAgIGNvbnN0IHJvbGxVcCA9IE1hdGguZmxvb3IocHJldmlvdXNWYWwgLyBjb252KTtcbiAgICAgICAgdmFsc1tjdXJyZW50XSArPSByb2xsVXAgKiBmYWN0b3I7XG4gICAgICAgIHZhbHNbcHJldmlvdXNdIC09IHJvbGxVcCAqIGNvbnYgKiBmYWN0b3I7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHByZXZpb3VzO1xuICAgIH1cbiAgfSwgbnVsbCk7XG5cbiAgLy8gdHJ5IHRvIGNvbnZlcnQgYW55IGRlY2ltYWxzIGludG8gc21hbGxlciB1bml0cyBpZiBwb3NzaWJsZVxuICAvLyBmb3IgZXhhbXBsZSBmb3IgeyB5ZWFyczogMi41LCBkYXlzOiAwLCBzZWNvbmRzOiAwIH0gd2Ugd2FudCB0byBnZXQgeyB5ZWFyczogMiwgZGF5czogMTgyLCBob3VyczogMTIgfVxuICBvcmRlcmVkVW5pdHMucmVkdWNlKChwcmV2aW91cywgY3VycmVudCkgPT4ge1xuICAgIGlmICghaXNVbmRlZmluZWQodmFsc1tjdXJyZW50XSkpIHtcbiAgICAgIGlmIChwcmV2aW91cykge1xuICAgICAgICBjb25zdCBmcmFjdGlvbiA9IHZhbHNbcHJldmlvdXNdICUgMTtcbiAgICAgICAgdmFsc1twcmV2aW91c10gLT0gZnJhY3Rpb247XG4gICAgICAgIHZhbHNbY3VycmVudF0gKz0gZnJhY3Rpb24gKiBtYXRyaXhbcHJldmlvdXNdW2N1cnJlbnRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwcmV2aW91cztcbiAgICB9XG4gIH0sIG51bGwpO1xufVxuXG4vLyBSZW1vdmUgYWxsIHByb3BlcnRpZXMgd2l0aCBhIHZhbHVlIG9mIDAgZnJvbSBhbiBvYmplY3RcbmZ1bmN0aW9uIHJlbW92ZVplcm9lcyh2YWxzKSB7XG4gIGNvbnN0IG5ld1ZhbHMgPSB7fTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFscykpIHtcbiAgICBpZiAodmFsdWUgIT09IDApIHtcbiAgICAgIG5ld1ZhbHNba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3VmFscztcbn1cblxuLyoqXG4gKiBBIER1cmF0aW9uIG9iamVjdCByZXByZXNlbnRzIGEgcGVyaW9kIG9mIHRpbWUsIGxpa2UgXCIyIG1vbnRoc1wiIG9yIFwiMSBkYXksIDEgaG91clwiLiBDb25jZXB0dWFsbHksIGl0J3MganVzdCBhIG1hcCBvZiB1bml0cyB0byB0aGVpciBxdWFudGl0aWVzLCBhY2NvbXBhbmllZCBieSBzb21lIGFkZGl0aW9uYWwgY29uZmlndXJhdGlvbiBhbmQgbWV0aG9kcyBmb3IgY3JlYXRpbmcsIHBhcnNpbmcsIGludGVycm9nYXRpbmcsIHRyYW5zZm9ybWluZywgYW5kIGZvcm1hdHRpbmcgdGhlbS4gVGhleSBjYW4gYmUgdXNlZCBvbiB0aGVpciBvd24gb3IgaW4gY29uanVuY3Rpb24gd2l0aCBvdGhlciBMdXhvbiB0eXBlczsgZm9yIGV4YW1wbGUsIHlvdSBjYW4gdXNlIHtAbGluayBEYXRlVGltZSNwbHVzfSB0byBhZGQgYSBEdXJhdGlvbiBvYmplY3QgdG8gYSBEYXRlVGltZSwgcHJvZHVjaW5nIGFub3RoZXIgRGF0ZVRpbWUuXG4gKlxuICogSGVyZSBpcyBhIGJyaWVmIG92ZXJ2aWV3IG9mIGNvbW1vbmx5IHVzZWQgbWV0aG9kcyBhbmQgZ2V0dGVycyBpbiBEdXJhdGlvbjpcbiAqXG4gKiAqICoqQ3JlYXRpb24qKiBUbyBjcmVhdGUgYSBEdXJhdGlvbiwgdXNlIHtAbGluayBEdXJhdGlvbi5mcm9tTWlsbGlzfSwge0BsaW5rIER1cmF0aW9uLmZyb21PYmplY3R9LCBvciB7QGxpbmsgRHVyYXRpb24uZnJvbUlTT30uXG4gKiAqICoqVW5pdCB2YWx1ZXMqKiBTZWUgdGhlIHtAbGluayBEdXJhdGlvbiN5ZWFyc30sIHtAbGluayBEdXJhdGlvbiNtb250aHN9LCB7QGxpbmsgRHVyYXRpb24jd2Vla3N9LCB7QGxpbmsgRHVyYXRpb24jZGF5c30sIHtAbGluayBEdXJhdGlvbiNob3Vyc30sIHtAbGluayBEdXJhdGlvbiNtaW51dGVzfSwge0BsaW5rIER1cmF0aW9uI3NlY29uZHN9LCB7QGxpbmsgRHVyYXRpb24jbWlsbGlzZWNvbmRzfSBhY2Nlc3NvcnMuXG4gKiAqICoqQ29uZmlndXJhdGlvbioqIFNlZSAge0BsaW5rIER1cmF0aW9uI2xvY2FsZX0gYW5kIHtAbGluayBEdXJhdGlvbiNudW1iZXJpbmdTeXN0ZW19IGFjY2Vzc29ycy5cbiAqICogKipUcmFuc2Zvcm1hdGlvbioqIFRvIGNyZWF0ZSBuZXcgRHVyYXRpb25zIG91dCBvZiBvbGQgb25lcyB1c2Uge0BsaW5rIER1cmF0aW9uI3BsdXN9LCB7QGxpbmsgRHVyYXRpb24jbWludXN9LCB7QGxpbmsgRHVyYXRpb24jbm9ybWFsaXplfSwge0BsaW5rIER1cmF0aW9uI3NldH0sIHtAbGluayBEdXJhdGlvbiNyZWNvbmZpZ3VyZX0sIHtAbGluayBEdXJhdGlvbiNzaGlmdFRvfSwgYW5kIHtAbGluayBEdXJhdGlvbiNuZWdhdGV9LlxuICogKiAqKk91dHB1dCoqIFRvIGNvbnZlcnQgdGhlIER1cmF0aW9uIGludG8gb3RoZXIgcmVwcmVzZW50YXRpb25zLCBzZWUge0BsaW5rIER1cmF0aW9uI2FzfSwge0BsaW5rIER1cmF0aW9uI3RvSVNPfSwge0BsaW5rIER1cmF0aW9uI3RvRm9ybWF0fSwgYW5kIHtAbGluayBEdXJhdGlvbiN0b0pTT059XG4gKlxuICogVGhlcmUncyBhcmUgbW9yZSBtZXRob2RzIGRvY3VtZW50ZWQgYmVsb3cuIEluIGFkZGl0aW9uLCBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBzdWJ0bGVyIHRvcGljcyBsaWtlIGludGVybmF0aW9uYWxpemF0aW9uIGFuZCB2YWxpZGl0eSwgc2VlIHRoZSBleHRlcm5hbCBkb2N1bWVudGF0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEdXJhdGlvbiB7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgY29uc3QgYWNjdXJhdGUgPSBjb25maWcuY29udmVyc2lvbkFjY3VyYWN5ID09PSBcImxvbmd0ZXJtXCIgfHwgZmFsc2U7XG4gICAgbGV0IG1hdHJpeCA9IGFjY3VyYXRlID8gYWNjdXJhdGVNYXRyaXggOiBjYXN1YWxNYXRyaXg7XG5cbiAgICBpZiAoY29uZmlnLm1hdHJpeCkge1xuICAgICAgbWF0cml4ID0gY29uZmlnLm1hdHJpeDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnZhbHVlcyA9IGNvbmZpZy52YWx1ZXM7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5sb2MgPSBjb25maWcubG9jIHx8IExvY2FsZS5jcmVhdGUoKTtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmNvbnZlcnNpb25BY2N1cmFjeSA9IGFjY3VyYXRlID8gXCJsb25ndGVybVwiIDogXCJjYXN1YWxcIjtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmludmFsaWQgPSBjb25maWcuaW52YWxpZCB8fCBudWxsO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubWF0cml4ID0gbWF0cml4O1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaXNMdXhvbkR1cmF0aW9uID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgRHVyYXRpb24gZnJvbSBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCBvZiBtaWxsaXNlY29uZHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIGZvciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSB0aGUgbG9jYWxlIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc3RhdGljIGZyb21NaWxsaXMoY291bnQsIG9wdHMpIHtcbiAgICByZXR1cm4gRHVyYXRpb24uZnJvbU9iamVjdCh7IG1pbGxpc2Vjb25kczogY291bnQgfSwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRHVyYXRpb24gZnJvbSBhIEphdmFTY3JpcHQgb2JqZWN0IHdpdGgga2V5cyBsaWtlICd5ZWFycycgYW5kICdob3VycycuXG4gICAqIElmIHRoaXMgb2JqZWN0IGlzIGVtcHR5IHRoZW4gYSB6ZXJvIG1pbGxpc2Vjb25kcyBkdXJhdGlvbiBpcyByZXR1cm5lZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHRoZSBvYmplY3QgdG8gY3JlYXRlIHRoZSBEYXRlVGltZSBmcm9tXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoueWVhcnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5xdWFydGVyc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm1vbnRoc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLndlZWtzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouZGF5c1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLmhvdXJzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubWludXRlc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLnNlY29uZHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5taWxsaXNlY29uZHNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzPVtdXSAtIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoaXMgRHVyYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIHRoZSBsb2NhbGUgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBwcmVzZXQgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5tYXRyaXg9T2JqZWN0XSAtIHRoZSBjdXN0b20gY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc3RhdGljIGZyb21PYmplY3Qob2JqLCBvcHRzID0ge30pIHtcbiAgICBpZiAob2JqID09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFxuICAgICAgICBgRHVyYXRpb24uZnJvbU9iamVjdDogYXJndW1lbnQgZXhwZWN0ZWQgdG8gYmUgYW4gb2JqZWN0LCBnb3QgJHtcbiAgICAgICAgICBvYmogPT09IG51bGwgPyBcIm51bGxcIiA6IHR5cGVvZiBvYmpcbiAgICAgICAgfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBEdXJhdGlvbih7XG4gICAgICB2YWx1ZXM6IG5vcm1hbGl6ZU9iamVjdChvYmosIER1cmF0aW9uLm5vcm1hbGl6ZVVuaXQpLFxuICAgICAgbG9jOiBMb2NhbGUuZnJvbU9iamVjdChvcHRzKSxcbiAgICAgIGNvbnZlcnNpb25BY2N1cmFjeTogb3B0cy5jb252ZXJzaW9uQWNjdXJhY3ksXG4gICAgICBtYXRyaXg6IG9wdHMubWF0cml4LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIER1cmF0aW9uIGZyb20gRHVyYXRpb25MaWtlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdCB8IG51bWJlciB8IER1cmF0aW9ufSBkdXJhdGlvbkxpa2VcbiAgICogT25lIG9mOlxuICAgKiAtIG9iamVjdCB3aXRoIGtleXMgbGlrZSAneWVhcnMnIGFuZCAnaG91cnMnLlxuICAgKiAtIG51bWJlciByZXByZXNlbnRpbmcgbWlsbGlzZWNvbmRzXG4gICAqIC0gRHVyYXRpb24gaW5zdGFuY2VcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgZnJvbUR1cmF0aW9uTGlrZShkdXJhdGlvbkxpa2UpIHtcbiAgICBpZiAoaXNOdW1iZXIoZHVyYXRpb25MaWtlKSkge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmZyb21NaWxsaXMoZHVyYXRpb25MaWtlKTtcbiAgICB9IGVsc2UgaWYgKER1cmF0aW9uLmlzRHVyYXRpb24oZHVyYXRpb25MaWtlKSkge1xuICAgICAgcmV0dXJuIGR1cmF0aW9uTGlrZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkdXJhdGlvbkxpa2UgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5mcm9tT2JqZWN0KGR1cmF0aW9uTGlrZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcbiAgICAgICAgYFVua25vd24gZHVyYXRpb24gYXJndW1lbnQgJHtkdXJhdGlvbkxpa2V9IG9mIHR5cGUgJHt0eXBlb2YgZHVyYXRpb25MaWtlfWBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIER1cmF0aW9uIGZyb20gYW4gSVNPIDg2MDEgZHVyYXRpb24gc3RyaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRleHQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIGZvciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSB0aGUgbG9jYWxlIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgcHJlc2V0IGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubWF0cml4PU9iamVjdF0gLSB0aGUgcHJlc2V0IGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI0R1cmF0aW9uc1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPKCdQM1k2TTFXNERUMTJIMzBNNVMnKS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogMywgbW9udGhzOiA2LCB3ZWVrczogMSwgZGF5czogNCwgaG91cnM6IDEyLCBtaW51dGVzOiAzMCwgc2Vjb25kczogNSB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU08oJ1BUMjNIJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDIzIH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTTygnUDVZM00nKS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogNSwgbW9udGhzOiAzIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgZnJvbUlTTyh0ZXh0LCBvcHRzKSB7XG4gICAgY29uc3QgW3BhcnNlZF0gPSBwYXJzZUlTT0R1cmF0aW9uKHRleHQpO1xuICAgIGlmIChwYXJzZWQpIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5mcm9tT2JqZWN0KHBhcnNlZCwgb3B0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5pbnZhbGlkKFwidW5wYXJzYWJsZVwiLCBgdGhlIGlucHV0IFwiJHt0ZXh0fVwiIGNhbid0IGJlIHBhcnNlZCBhcyBJU08gODYwMWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEdXJhdGlvbiBmcm9tIGFuIElTTyA4NjAxIHRpbWUgc3RyaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRleHQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIGZvciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSB0aGUgbG9jYWxlIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgcHJlc2V0IGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubWF0cml4PU9iamVjdF0gLSB0aGUgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZXNcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTT1RpbWUoJzExOjIyOjMzLjQ0NCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMjIsIHNlY29uZHM6IDMzLCBtaWxsaXNlY29uZHM6IDQ0NCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU09UaW1lKCcxMTowMCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMCwgc2Vjb25kczogMCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU09UaW1lKCdUMTE6MDAnKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMTEsIG1pbnV0ZXM6IDAsIHNlY29uZHM6IDAgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPVGltZSgnMTEwMCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMCwgc2Vjb25kczogMCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU09UaW1lKCdUMTEwMCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMCwgc2Vjb25kczogMCB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc3RhdGljIGZyb21JU09UaW1lKHRleHQsIG9wdHMpIHtcbiAgICBjb25zdCBbcGFyc2VkXSA9IHBhcnNlSVNPVGltZU9ubHkodGV4dCk7XG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmZyb21PYmplY3QocGFyc2VkLCBvcHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmludmFsaWQoXCJ1bnBhcnNhYmxlXCIsIGB0aGUgaW5wdXQgXCIke3RleHR9XCIgY2FuJ3QgYmUgcGFyc2VkIGFzIElTTyA4NjAxYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnZhbGlkIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uIC0gc2ltcGxlIHN0cmluZyBvZiB3aHkgdGhpcyBkYXRldGltZSBpcyBpbnZhbGlkLiBTaG91bGQgbm90IGNvbnRhaW4gcGFyYW1ldGVycyBvciBhbnl0aGluZyBlbHNlIGRhdGEtZGVwZW5kZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZXhwbGFuYXRpb249bnVsbF0gLSBsb25nZXIgZXhwbGFuYXRpb24sIG1heSBpbmNsdWRlIHBhcmFtZXRlcnMgYW5kIG90aGVyIHVzZWZ1bCBkZWJ1Z2dpbmcgaW5mb3JtYXRpb25cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgaW52YWxpZChyZWFzb24sIGV4cGxhbmF0aW9uID0gbnVsbCkge1xuICAgIGlmICghcmVhc29uKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJuZWVkIHRvIHNwZWNpZnkgYSByZWFzb24gdGhlIER1cmF0aW9uIGlzIGludmFsaWRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgaW52YWxpZCA9IHJlYXNvbiBpbnN0YW5jZW9mIEludmFsaWQgPyByZWFzb24gOiBuZXcgSW52YWxpZChyZWFzb24sIGV4cGxhbmF0aW9uKTtcblxuICAgIGlmIChTZXR0aW5ncy50aHJvd09uSW52YWxpZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWREdXJhdGlvbkVycm9yKGludmFsaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IER1cmF0aW9uKHsgaW52YWxpZCB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBub3JtYWxpemVVbml0KHVuaXQpIHtcbiAgICBjb25zdCBub3JtYWxpemVkID0ge1xuICAgICAgeWVhcjogXCJ5ZWFyc1wiLFxuICAgICAgeWVhcnM6IFwieWVhcnNcIixcbiAgICAgIHF1YXJ0ZXI6IFwicXVhcnRlcnNcIixcbiAgICAgIHF1YXJ0ZXJzOiBcInF1YXJ0ZXJzXCIsXG4gICAgICBtb250aDogXCJtb250aHNcIixcbiAgICAgIG1vbnRoczogXCJtb250aHNcIixcbiAgICAgIHdlZWs6IFwid2Vla3NcIixcbiAgICAgIHdlZWtzOiBcIndlZWtzXCIsXG4gICAgICBkYXk6IFwiZGF5c1wiLFxuICAgICAgZGF5czogXCJkYXlzXCIsXG4gICAgICBob3VyOiBcImhvdXJzXCIsXG4gICAgICBob3VyczogXCJob3Vyc1wiLFxuICAgICAgbWludXRlOiBcIm1pbnV0ZXNcIixcbiAgICAgIG1pbnV0ZXM6IFwibWludXRlc1wiLFxuICAgICAgc2Vjb25kOiBcInNlY29uZHNcIixcbiAgICAgIHNlY29uZHM6IFwic2Vjb25kc1wiLFxuICAgICAgbWlsbGlzZWNvbmQ6IFwibWlsbGlzZWNvbmRzXCIsXG4gICAgICBtaWxsaXNlY29uZHM6IFwibWlsbGlzZWNvbmRzXCIsXG4gICAgfVt1bml0ID8gdW5pdC50b0xvd2VyQ2FzZSgpIDogdW5pdF07XG5cbiAgICBpZiAoIW5vcm1hbGl6ZWQpIHRocm93IG5ldyBJbnZhbGlkVW5pdEVycm9yKHVuaXQpO1xuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gb2JqZWN0IGlzIGEgRHVyYXRpb24uIFdvcmtzIGFjcm9zcyBjb250ZXh0IGJvdW5kYXJpZXNcbiAgICogQHBhcmFtIHtvYmplY3R9IG9cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc0R1cmF0aW9uKG8pIHtcbiAgICByZXR1cm4gKG8gJiYgby5pc0x1eG9uRHVyYXRpb24pIHx8IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCAgdGhlIGxvY2FsZSBvZiBhIER1cmF0aW9uLCBzdWNoICdlbi1HQidcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBsb2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMubG9jLmxvY2FsZSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBudW1iZXJpbmcgc3lzdGVtIG9mIGEgRHVyYXRpb24sIHN1Y2ggJ2JlbmcnLiBUaGUgbnVtYmVyaW5nIHN5c3RlbSBpcyB1c2VkIHdoZW4gZm9ybWF0dGluZyB0aGUgRHVyYXRpb25cbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBudW1iZXJpbmdTeXN0ZW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMubG9jLm51bWJlcmluZ1N5c3RlbSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIER1cmF0aW9uIGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBmb3JtYXQgc3RyaW5nLiBZb3UgbWF5IHVzZSB0aGVzZSB0b2tlbnM6XG4gICAqICogYFNgIGZvciBtaWxsaXNlY29uZHNcbiAgICogKiBgc2AgZm9yIHNlY29uZHNcbiAgICogKiBgbWAgZm9yIG1pbnV0ZXNcbiAgICogKiBgaGAgZm9yIGhvdXJzXG4gICAqICogYGRgIGZvciBkYXlzXG4gICAqICogYHdgIGZvciB3ZWVrc1xuICAgKiAqIGBNYCBmb3IgbW9udGhzXG4gICAqICogYHlgIGZvciB5ZWFyc1xuICAgKiBOb3RlczpcbiAgICogKiBBZGQgcGFkZGluZyBieSByZXBlYXRpbmcgdGhlIHRva2VuLCBlLmcuIFwieXlcIiBwYWRzIHRoZSB5ZWFycyB0byB0d28gZGlnaXRzLCBcImhoaGhcIiBwYWRzIHRoZSBob3VycyBvdXQgdG8gZm91ciBkaWdpdHNcbiAgICogKiBUb2tlbnMgY2FuIGJlIGVzY2FwZWQgYnkgd3JhcHBpbmcgd2l0aCBzaW5nbGUgcXVvdGVzLlxuICAgKiAqIFRoZSBkdXJhdGlvbiB3aWxsIGJlIGNvbnZlcnRlZCB0byB0aGUgc2V0IG9mIHVuaXRzIGluIHRoZSBmb3JtYXQgc3RyaW5nIHVzaW5nIHtAbGluayBEdXJhdGlvbiNzaGlmdFRvfSBhbmQgdGhlIER1cmF0aW9ucydzIGNvbnZlcnNpb24gYWNjdXJhY3kgc2V0dGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZtdCAtIHRoZSBmb3JtYXQgc3RyaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmZsb29yPXRydWVdIC0gZmxvb3IgbnVtZXJpY2FsIHZhbHVlc1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDEsIGRheXM6IDYsIHNlY29uZHM6IDIgfSkudG9Gb3JtYXQoXCJ5IGQgc1wiKSAvLz0+IFwiMSA2IDJcIlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDEsIGRheXM6IDYsIHNlY29uZHM6IDIgfSkudG9Gb3JtYXQoXCJ5eSBkZCBzc3NcIikgLy89PiBcIjAxIDA2IDAwMlwiXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMSwgZGF5czogNiwgc2Vjb25kczogMiB9KS50b0Zvcm1hdChcIk0gU1wiKSAvLz0+IFwiMTIgNTE4NDAyMDAwXCJcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9Gb3JtYXQoZm10LCBvcHRzID0ge30pIHtcbiAgICAvLyByZXZlcnNlLWNvbXBhdCBzaW5jZSAxLjI7IHdlIGFsd2F5cyByb3VuZCBkb3duIG5vdywgbmV2ZXIgdXAsIGFuZCB3ZSBkbyBpdCBieSBkZWZhdWx0XG4gICAgY29uc3QgZm10T3B0cyA9IHtcbiAgICAgIC4uLm9wdHMsXG4gICAgICBmbG9vcjogb3B0cy5yb3VuZCAhPT0gZmFsc2UgJiYgb3B0cy5mbG9vciAhPT0gZmFsc2UsXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkXG4gICAgICA/IEZvcm1hdHRlci5jcmVhdGUodGhpcy5sb2MsIGZtdE9wdHMpLmZvcm1hdER1cmF0aW9uRnJvbVN0cmluZyh0aGlzLCBmbXQpXG4gICAgICA6IElOVkFMSUQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIER1cmF0aW9uIHdpdGggYWxsIHVuaXRzIGluY2x1ZGVkLlxuICAgKiBUbyBtb2RpZnkgaXRzIGJlaGF2aW9yLCB1c2UgYGxpc3RTdHlsZWAgYW5kIGFueSBJbnRsLk51bWJlckZvcm1hdCBvcHRpb24sIHRob3VnaCBgdW5pdERpc3BsYXlgIGlzIGVzcGVjaWFsbHkgcmVsZXZhbnQuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvSW50bC9OdW1iZXJGb3JtYXQvTnVtYmVyRm9ybWF0I29wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBGb3JtYXR0aW5nIG9wdGlvbnMuIEFjY2VwdHMgdGhlIHNhbWUga2V5cyBhcyB0aGUgb3B0aW9ucyBwYXJhbWV0ZXIgb2YgdGhlIG5hdGl2ZSBgSW50bC5OdW1iZXJGb3JtYXRgIGNvbnN0cnVjdG9yLCBhcyB3ZWxsIGFzIGBsaXN0U3R5bGVgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubGlzdFN0eWxlPSduYXJyb3cnXSAtIEhvdyB0byBmb3JtYXQgdGhlIG1lcmdlZCBsaXN0LiBDb3JyZXNwb25kcyB0byB0aGUgYHN0eWxlYCBwcm9wZXJ0eSBvZiB0aGUgb3B0aW9ucyBwYXJhbWV0ZXIgb2YgdGhlIG5hdGl2ZSBgSW50bC5MaXN0Rm9ybWF0YCBjb25zdHJ1Y3Rvci5cbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogdmFyIGR1ciA9IER1cmF0aW9uLmZyb21PYmplY3QoeyBkYXlzOiAxLCBob3VyczogNSwgbWludXRlczogNiB9KVxuICAgKiBkdXIudG9IdW1hbigpIC8vPT4gJzEgZGF5LCA1IGhvdXJzLCA2IG1pbnV0ZXMnXG4gICAqIGR1ci50b0h1bWFuKHsgbGlzdFN0eWxlOiBcImxvbmdcIiB9KSAvLz0+ICcxIGRheSwgNSBob3VycywgYW5kIDYgbWludXRlcydcbiAgICogZHVyLnRvSHVtYW4oeyB1bml0RGlzcGxheTogXCJzaG9ydFwiIH0pIC8vPT4gJzEgZGF5LCA1IGhyLCA2IG1pbidcbiAgICogYGBgXG4gICAqL1xuICB0b0h1bWFuKG9wdHMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gSU5WQUxJRDtcblxuICAgIGNvbnN0IGwgPSBvcmRlcmVkVW5pdHNcbiAgICAgIC5tYXAoKHVuaXQpID0+IHtcbiAgICAgICAgY29uc3QgdmFsID0gdGhpcy52YWx1ZXNbdW5pdF07XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubG9jXG4gICAgICAgICAgLm51bWJlckZvcm1hdHRlcih7IHN0eWxlOiBcInVuaXRcIiwgdW5pdERpc3BsYXk6IFwibG9uZ1wiLCAuLi5vcHRzLCB1bml0OiB1bml0LnNsaWNlKDAsIC0xKSB9KVxuICAgICAgICAgIC5mb3JtYXQodmFsKTtcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKChuKSA9PiBuKTtcblxuICAgIHJldHVybiB0aGlzLmxvY1xuICAgICAgLmxpc3RGb3JtYXR0ZXIoeyB0eXBlOiBcImNvbmp1bmN0aW9uXCIsIHN0eWxlOiBvcHRzLmxpc3RTdHlsZSB8fCBcIm5hcnJvd1wiLCAuLi5vcHRzIH0pXG4gICAgICAuZm9ybWF0KGwpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBKYXZhU2NyaXB0IG9iamVjdCB3aXRoIHRoaXMgRHVyYXRpb24ncyB2YWx1ZXMuXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMSwgZGF5czogNiwgc2Vjb25kczogMiB9KS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogMSwgZGF5czogNiwgc2Vjb25kczogMiB9XG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHRvT2JqZWN0KCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4ge307XG4gICAgcmV0dXJuIHsgLi4udGhpcy52YWx1ZXMgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEdXJhdGlvbi5cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNEdXJhdGlvbnNcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAzLCBzZWNvbmRzOiA0NSB9KS50b0lTTygpIC8vPT4gJ1AzWVQ0NVMnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBtb250aHM6IDQsIHNlY29uZHM6IDQ1IH0pLnRvSVNPKCkgLy89PiAnUDRNVDQ1UydcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IG1vbnRoczogNSB9KS50b0lTTygpIC8vPT4gJ1A1TSdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IG1pbnV0ZXM6IDUgfSkudG9JU08oKSAvLz0+ICdQVDVNJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbWlsbGlzZWNvbmRzOiA2IH0pLnRvSVNPKCkgLy89PiAnUFQwLjAwNlMnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPKCkge1xuICAgIC8vIHdlIGNvdWxkIHVzZSB0aGUgZm9ybWF0dGVyLCBidXQgdGhpcyBpcyBhbiBlYXNpZXIgd2F5IHRvIGdldCB0aGUgbWluaW11bSBzdHJpbmdcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIG51bGw7XG5cbiAgICBsZXQgcyA9IFwiUFwiO1xuICAgIGlmICh0aGlzLnllYXJzICE9PSAwKSBzICs9IHRoaXMueWVhcnMgKyBcIllcIjtcbiAgICBpZiAodGhpcy5tb250aHMgIT09IDAgfHwgdGhpcy5xdWFydGVycyAhPT0gMCkgcyArPSB0aGlzLm1vbnRocyArIHRoaXMucXVhcnRlcnMgKiAzICsgXCJNXCI7XG4gICAgaWYgKHRoaXMud2Vla3MgIT09IDApIHMgKz0gdGhpcy53ZWVrcyArIFwiV1wiO1xuICAgIGlmICh0aGlzLmRheXMgIT09IDApIHMgKz0gdGhpcy5kYXlzICsgXCJEXCI7XG4gICAgaWYgKHRoaXMuaG91cnMgIT09IDAgfHwgdGhpcy5taW51dGVzICE9PSAwIHx8IHRoaXMuc2Vjb25kcyAhPT0gMCB8fCB0aGlzLm1pbGxpc2Vjb25kcyAhPT0gMClcbiAgICAgIHMgKz0gXCJUXCI7XG4gICAgaWYgKHRoaXMuaG91cnMgIT09IDApIHMgKz0gdGhpcy5ob3VycyArIFwiSFwiO1xuICAgIGlmICh0aGlzLm1pbnV0ZXMgIT09IDApIHMgKz0gdGhpcy5taW51dGVzICsgXCJNXCI7XG4gICAgaWYgKHRoaXMuc2Vjb25kcyAhPT0gMCB8fCB0aGlzLm1pbGxpc2Vjb25kcyAhPT0gMClcbiAgICAgIC8vIHRoaXMgd2lsbCBoYW5kbGUgXCJmbG9hdGluZyBwb2ludCBtYWRuZXNzXCIgYnkgcmVtb3ZpbmcgZXh0cmEgZGVjaW1hbCBwbGFjZXNcbiAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU4ODAwNC9pcy1mbG9hdGluZy1wb2ludC1tYXRoLWJyb2tlblxuICAgICAgcyArPSByb3VuZFRvKHRoaXMuc2Vjb25kcyArIHRoaXMubWlsbGlzZWNvbmRzIC8gMTAwMCwgMykgKyBcIlNcIjtcbiAgICBpZiAocyA9PT0gXCJQXCIpIHMgKz0gXCJUMFNcIjtcbiAgICByZXR1cm4gcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEdXJhdGlvbiwgZm9ybWF0dGVkIGFzIGEgdGltZSBvZiBkYXkuXG4gICAqIE5vdGUgdGhhdCB0aGlzIHdpbGwgcmV0dXJuIG51bGwgaWYgdGhlIGR1cmF0aW9uIGlzIGludmFsaWQsIG5lZ2F0aXZlLCBvciBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gMjQgaG91cnMuXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NNaWxsaXNlY29uZHM9ZmFsc2VdIC0gZXhjbHVkZSBtaWxsaXNlY29uZHMgZnJvbSB0aGUgZm9ybWF0IGlmIHRoZXkncmUgMFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnN1cHByZXNzU2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIHNlY29uZHMgZnJvbSB0aGUgZm9ybWF0IGlmIHRoZXkncmUgMFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVQcmVmaXg9ZmFsc2VdIC0gaW5jbHVkZSB0aGUgYFRgIHByZWZpeFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuZm9ybWF0PSdleHRlbmRlZCddIC0gY2hvb3NlIGJldHdlZW4gdGhlIGJhc2ljIGFuZCBleHRlbmRlZCBmb3JtYXRcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxMSB9KS50b0lTT1RpbWUoKSAvLz0+ICcxMTowMDowMC4wMDAnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTEgfSkudG9JU09UaW1lKHsgc3VwcHJlc3NNaWxsaXNlY29uZHM6IHRydWUgfSkgLy89PiAnMTE6MDA6MDAnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTEgfSkudG9JU09UaW1lKHsgc3VwcHJlc3NTZWNvbmRzOiB0cnVlIH0pIC8vPT4gJzExOjAwJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDExIH0pLnRvSVNPVGltZSh7IGluY2x1ZGVQcmVmaXg6IHRydWUgfSkgLy89PiAnVDExOjAwOjAwLjAwMCdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxMSB9KS50b0lTT1RpbWUoeyBmb3JtYXQ6ICdiYXNpYycgfSkgLy89PiAnMTEwMDAwLjAwMCdcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU09UaW1lKG9wdHMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gbnVsbDtcblxuICAgIGNvbnN0IG1pbGxpcyA9IHRoaXMudG9NaWxsaXMoKTtcbiAgICBpZiAobWlsbGlzIDwgMCB8fCBtaWxsaXMgPj0gODY0MDAwMDApIHJldHVybiBudWxsO1xuXG4gICAgb3B0cyA9IHtcbiAgICAgIHN1cHByZXNzTWlsbGlzZWNvbmRzOiBmYWxzZSxcbiAgICAgIHN1cHByZXNzU2Vjb25kczogZmFsc2UsXG4gICAgICBpbmNsdWRlUHJlZml4OiBmYWxzZSxcbiAgICAgIGZvcm1hdDogXCJleHRlbmRlZFwiLFxuICAgICAgLi4ub3B0cyxcbiAgICAgIGluY2x1ZGVPZmZzZXQ6IGZhbHNlLFxuICAgIH07XG5cbiAgICBjb25zdCBkYXRlVGltZSA9IERhdGVUaW1lLmZyb21NaWxsaXMobWlsbGlzLCB7IHpvbmU6IFwiVVRDXCIgfSk7XG4gICAgcmV0dXJuIGRhdGVUaW1lLnRvSVNPVGltZShvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRHVyYXRpb24gYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBKU09OLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9JU08oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRHVyYXRpb24gYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBkZWJ1Z2dpbmcuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnRvSVNPKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIER1cmF0aW9uIGFwcHJvcHJpYXRlIGZvciB0aGUgUkVQTC5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgW1N5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKV0oKSB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIGBEdXJhdGlvbiB7IHZhbHVlczogJHtKU09OLnN0cmluZ2lmeSh0aGlzLnZhbHVlcyl9IH1gO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYER1cmF0aW9uIHsgSW52YWxpZCwgcmVhc29uOiAke3RoaXMuaW52YWxpZFJlYXNvbn0gfWA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gbWlsbGlzZWNvbmRzIHZhbHVlIG9mIHRoaXMgRHVyYXRpb24uXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHRvTWlsbGlzKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gTmFOO1xuXG4gICAgcmV0dXJuIGR1cmF0aW9uVG9NaWxsaXModGhpcy5tYXRyaXgsIHRoaXMudmFsdWVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG1pbGxpc2Vjb25kcyB2YWx1ZSBvZiB0aGlzIER1cmF0aW9uLiBBbGlhcyBvZiB7QGxpbmsgdG9NaWxsaXN9XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHZhbHVlT2YoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9NaWxsaXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIHRoaXMgRHVyYXRpb24gbG9uZ2VyIGJ5IHRoZSBzcGVjaWZpZWQgYW1vdW50LiBSZXR1cm4gYSBuZXdseS1jb25zdHJ1Y3RlZCBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbW91bnQgdG8gYWRkLiBFaXRoZXIgYSBMdXhvbiBEdXJhdGlvbiwgYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCB0aGUgb2JqZWN0IGFyZ3VtZW50IHRvIER1cmF0aW9uLmZyb21PYmplY3QoKVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHBsdXMoZHVyYXRpb24pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG5cbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKSxcbiAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgZm9yIChjb25zdCBrIG9mIG9yZGVyZWRVbml0cykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5KGR1ci52YWx1ZXMsIGspIHx8IGhhc093blByb3BlcnR5KHRoaXMudmFsdWVzLCBrKSkge1xuICAgICAgICByZXN1bHRba10gPSBkdXIuZ2V0KGspICsgdGhpcy5nZXQoayk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdmFsdWVzOiByZXN1bHQgfSwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSB0aGlzIER1cmF0aW9uIHNob3J0ZXIgYnkgdGhlIHNwZWNpZmllZCBhbW91bnQuIFJldHVybiBhIG5ld2x5LWNvbnN0cnVjdGVkIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufE9iamVjdHxudW1iZXJ9IGR1cmF0aW9uIC0gVGhlIGFtb3VudCB0byBzdWJ0cmFjdC4gRWl0aGVyIGEgTHV4b24gRHVyYXRpb24sIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgdGhlIG9iamVjdCBhcmd1bWVudCB0byBEdXJhdGlvbi5mcm9tT2JqZWN0KClcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBtaW51cyhkdXJhdGlvbikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcblxuICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb24pO1xuICAgIHJldHVybiB0aGlzLnBsdXMoZHVyLm5lZ2F0ZSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY2FsZSB0aGlzIER1cmF0aW9uIGJ5IHRoZSBzcGVjaWZpZWQgYW1vdW50LiBSZXR1cm4gYSBuZXdseS1jb25zdHJ1Y3RlZCBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCB1bml0LiBBcml0eSBpcyAxIG9yIDI6IHRoZSB2YWx1ZSBvZiB0aGUgdW5pdCBhbmQsIG9wdGlvbmFsbHksIHRoZSB1bml0IG5hbWUuIE11c3QgcmV0dXJuIGEgbnVtYmVyLlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDEsIG1pbnV0ZXM6IDMwIH0pLm1hcFVuaXRzKHggPT4geCAqIDIpIC8vPT4geyBob3VyczogMiwgbWludXRlczogNjAgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDEsIG1pbnV0ZXM6IDMwIH0pLm1hcFVuaXRzKCh4LCB1KSA9PiB1ID09PSBcImhvdXJzXCIgPyB4ICogMiA6IHgpIC8vPT4geyBob3VyczogMiwgbWludXRlczogMzAgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIG1hcFVuaXRzKGZuKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyh0aGlzLnZhbHVlcykpIHtcbiAgICAgIHJlc3VsdFtrXSA9IGFzTnVtYmVyKGZuKHRoaXMudmFsdWVzW2tdLCBrKSk7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogcmVzdWx0IH0sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgb2YgdW5pdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSBhIHVuaXQgc3VjaCBhcyAnbWludXRlJyBvciAnZGF5J1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHt5ZWFyczogMiwgZGF5czogM30pLmdldCgneWVhcnMnKSAvLz0+IDJcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7eWVhcnM6IDIsIGRheXM6IDN9KS5nZXQoJ21vbnRocycpIC8vPT4gMFxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHt5ZWFyczogMiwgZGF5czogM30pLmdldCgnZGF5cycpIC8vPT4gM1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQodW5pdCkge1xuICAgIHJldHVybiB0aGlzW0R1cmF0aW9uLm5vcm1hbGl6ZVVuaXQodW5pdCldO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIHZhbHVlcyBvZiBzcGVjaWZpZWQgdW5pdHMuIFJldHVybiBhIG5ld2x5LWNvbnN0cnVjdGVkIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzIC0gYSBtYXBwaW5nIG9mIHVuaXRzIHRvIG51bWJlcnNcbiAgICogQGV4YW1wbGUgZHVyLnNldCh7IHllYXJzOiAyMDE3IH0pXG4gICAqIEBleGFtcGxlIGR1ci5zZXQoeyBob3VyczogOCwgbWludXRlczogMzAgfSlcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzZXQodmFsdWVzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuXG4gICAgY29uc3QgbWl4ZWQgPSB7IC4uLnRoaXMudmFsdWVzLCAuLi5ub3JtYWxpemVPYmplY3QodmFsdWVzLCBEdXJhdGlvbi5ub3JtYWxpemVVbml0KSB9O1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogbWl4ZWQgfSk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgbG9jYWxlIGFuZC9vciBudW1iZXJpbmdTeXN0ZW0uICBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRHVyYXRpb24uXG4gICAqIEBleGFtcGxlIGR1ci5yZWNvbmZpZ3VyZSh7IGxvY2FsZTogJ2VuLUdCJyB9KVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHJlY29uZmlndXJlKHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIGNvbnZlcnNpb25BY2N1cmFjeSwgbWF0cml4IH0gPSB7fSkge1xuICAgIGNvbnN0IGxvYyA9IHRoaXMubG9jLmNsb25lKHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0gfSk7XG4gICAgY29uc3Qgb3B0cyA9IHsgbG9jLCBtYXRyaXgsIGNvbnZlcnNpb25BY2N1cmFjeSB9O1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgZHVyYXRpb24gaW4gdGhlIHNwZWNpZmllZCB1bml0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIGEgdW5pdCBzdWNoIGFzICdtaW51dGVzJyBvciAnZGF5cydcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7eWVhcnM6IDF9KS5hcygnZGF5cycpIC8vPT4gMzY1XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3Qoe3llYXJzOiAxfSkuYXMoJ21vbnRocycpIC8vPT4gMTJcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7aG91cnM6IDYwfSkuYXMoJ2RheXMnKSAvLz0+IDIuNVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBhcyh1bml0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuc2hpZnRUbyh1bml0KS5nZXQodW5pdCkgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmVkdWNlIHRoaXMgRHVyYXRpb24gdG8gaXRzIGNhbm9uaWNhbCByZXByZXNlbnRhdGlvbiBpbiBpdHMgY3VycmVudCB1bml0cy5cbiAgICogQXNzdW1pbmcgdGhlIG92ZXJhbGwgdmFsdWUgb2YgdGhlIER1cmF0aW9uIGlzIHBvc2l0aXZlLCB0aGlzIG1lYW5zOlxuICAgKiAtIGV4Y2Vzc2l2ZSB2YWx1ZXMgZm9yIGxvd2VyLW9yZGVyIHVuaXRzIGFyZSBjb252ZXJ0ZWQgdG8gaGlnaGVyLW9yZGVyIHVuaXRzIChpZiBwb3NzaWJsZSwgc2VlIGZpcnN0IGFuZCBzZWNvbmQgZXhhbXBsZSlcbiAgICogLSBuZWdhdGl2ZSBsb3dlci1vcmRlciB1bml0cyBhcmUgY29udmVydGVkIHRvIGhpZ2hlciBvcmRlciB1bml0cyAodGhlcmUgbXVzdCBiZSBzdWNoIGEgaGlnaGVyIG9yZGVyIHVuaXQsIG90aGVyd2lzZVxuICAgKiAgIHRoZSBvdmVyYWxsIHZhbHVlIHdvdWxkIGJlIG5lZ2F0aXZlLCBzZWUgdGhpcmQgZXhhbXBsZSlcbiAgICogLSBmcmFjdGlvbmFsIHZhbHVlcyBmb3IgaGlnaGVyLW9yZGVyIHVuaXRzIGFyZSBjb252ZXJ0ZWQgdG8gbG93ZXItb3JkZXIgdW5pdHMgKGlmIHBvc3NpYmxlLCBzZWUgZm91cnRoIGV4YW1wbGUpXG4gICAqXG4gICAqIElmIHRoZSBvdmVyYWxsIHZhbHVlIGlzIG5lZ2F0aXZlLCB0aGUgcmVzdWx0IG9mIHRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG8gYHRoaXMubmVnYXRlKCkubm9ybWFsaXplKCkubmVnYXRlKClgLlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDIsIGRheXM6IDUwMDAgfSkubm9ybWFsaXplKCkudG9PYmplY3QoKSAvLz0+IHsgeWVhcnM6IDE1LCBkYXlzOiAyNTUgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgZGF5czogNTAwMCB9KS5ub3JtYWxpemUoKS50b09iamVjdCgpIC8vPT4geyBkYXlzOiA1MDAwIH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxMiwgbWludXRlczogLTQ1IH0pLm5vcm1hbGl6ZSgpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMTUgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDIuNSwgZGF5czogMCwgaG91cnM6IDAgfSkubm9ybWFsaXplKCkudG9PYmplY3QoKSAvLz0+IHsgeWVhcnM6IDIsIGRheXM6IDE4MiwgaG91cnM6IDEyIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBub3JtYWxpemUoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IHZhbHMgPSB0aGlzLnRvT2JqZWN0KCk7XG4gICAgbm9ybWFsaXplVmFsdWVzKHRoaXMubWF0cml4LCB2YWxzKTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB2YWx1ZXM6IHZhbHMgfSwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmVzY2FsZSB1bml0cyB0byBpdHMgbGFyZ2VzdCByZXByZXNlbnRhdGlvblxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbWlsbGlzZWNvbmRzOiA5MDAwMCB9KS5yZXNjYWxlKCkudG9PYmplY3QoKSAvLz0+IHsgbWludXRlczogMSwgc2Vjb25kczogMzAgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHJlc2NhbGUoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IHZhbHMgPSByZW1vdmVaZXJvZXModGhpcy5ub3JtYWxpemUoKS5zaGlmdFRvQWxsKCkudG9PYmplY3QoKSk7XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdmFsdWVzOiB2YWxzIH0sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgdGhpcyBEdXJhdGlvbiBpbnRvIGl0cyByZXByZXNlbnRhdGlvbiBpbiBhIGRpZmZlcmVudCBzZXQgb2YgdW5pdHMuXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMSwgc2Vjb25kczogMzAgfSkuc2hpZnRUbygnbWludXRlcycsICdtaWxsaXNlY29uZHMnKS50b09iamVjdCgpIC8vPT4geyBtaW51dGVzOiA2MCwgbWlsbGlzZWNvbmRzOiAzMDAwMCB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc2hpZnRUbyguLi51bml0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcblxuICAgIGlmICh1bml0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHVuaXRzID0gdW5pdHMubWFwKCh1KSA9PiBEdXJhdGlvbi5ub3JtYWxpemVVbml0KHUpKTtcblxuICAgIGNvbnN0IGJ1aWx0ID0ge30sXG4gICAgICBhY2N1bXVsYXRlZCA9IHt9LFxuICAgICAgdmFscyA9IHRoaXMudG9PYmplY3QoKTtcbiAgICBsZXQgbGFzdFVuaXQ7XG5cbiAgICBmb3IgKGNvbnN0IGsgb2Ygb3JkZXJlZFVuaXRzKSB7XG4gICAgICBpZiAodW5pdHMuaW5kZXhPZihrKSA+PSAwKSB7XG4gICAgICAgIGxhc3RVbml0ID0gaztcblxuICAgICAgICBsZXQgb3duID0gMDtcblxuICAgICAgICAvLyBhbnl0aGluZyB3ZSBoYXZlbid0IGJvaWxlZCBkb3duIHlldCBzaG91bGQgZ2V0IGJvaWxlZCB0byB0aGlzIHVuaXRcbiAgICAgICAgZm9yIChjb25zdCBhayBpbiBhY2N1bXVsYXRlZCkge1xuICAgICAgICAgIG93biArPSB0aGlzLm1hdHJpeFtha11ba10gKiBhY2N1bXVsYXRlZFtha107XG4gICAgICAgICAgYWNjdW11bGF0ZWRbYWtdID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBsdXMgYW55dGhpbmcgdGhhdCdzIGFscmVhZHkgaW4gdGhpcyB1bml0XG4gICAgICAgIGlmIChpc051bWJlcih2YWxzW2tdKSkge1xuICAgICAgICAgIG93biArPSB2YWxzW2tdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb25seSBrZWVwIHRoZSBpbnRlZ2VyIHBhcnQgZm9yIG5vdyBpbiB0aGUgaG9wZXMgb2YgcHV0dGluZyBhbnkgZGVjaW1hbCBwYXJ0XG4gICAgICAgIC8vIGludG8gYSBzbWFsbGVyIHVuaXQgbGF0ZXJcbiAgICAgICAgY29uc3QgaSA9IE1hdGgudHJ1bmMob3duKTtcbiAgICAgICAgYnVpbHRba10gPSBpO1xuICAgICAgICBhY2N1bXVsYXRlZFtrXSA9IChvd24gKiAxMDAwIC0gaSAqIDEwMDApIC8gMTAwMDtcblxuICAgICAgICAvLyBvdGhlcndpc2UsIGtlZXAgaXQgaW4gdGhlIHdpbmdzIHRvIGJvaWwgaXQgbGF0ZXJcbiAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIodmFsc1trXSkpIHtcbiAgICAgICAgYWNjdW11bGF0ZWRba10gPSB2YWxzW2tdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFueXRoaW5nIGxlZnRvdmVyIGJlY29tZXMgdGhlIGRlY2ltYWwgZm9yIHRoZSBsYXN0IHVuaXRcbiAgICAvLyBsYXN0VW5pdCBtdXN0IGJlIGRlZmluZWQgc2luY2UgdW5pdHMgaXMgbm90IGVtcHR5XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYWNjdW11bGF0ZWQpIHtcbiAgICAgIGlmIChhY2N1bXVsYXRlZFtrZXldICE9PSAwKSB7XG4gICAgICAgIGJ1aWx0W2xhc3RVbml0XSArPVxuICAgICAgICAgIGtleSA9PT0gbGFzdFVuaXQgPyBhY2N1bXVsYXRlZFtrZXldIDogYWNjdW11bGF0ZWRba2V5XSAvIHRoaXMubWF0cml4W2xhc3RVbml0XVtrZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5vcm1hbGl6ZVZhbHVlcyh0aGlzLm1hdHJpeCwgYnVpbHQpO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogYnVpbHQgfSwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogU2hpZnQgdGhpcyBEdXJhdGlvbiB0byBhbGwgYXZhaWxhYmxlIHVuaXRzLlxuICAgKiBTYW1lIGFzIHNoaWZ0VG8oXCJ5ZWFyc1wiLCBcIm1vbnRoc1wiLCBcIndlZWtzXCIsIFwiZGF5c1wiLCBcImhvdXJzXCIsIFwibWludXRlc1wiLCBcInNlY29uZHNcIiwgXCJtaWxsaXNlY29uZHNcIilcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzaGlmdFRvQWxsKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICByZXR1cm4gdGhpcy5zaGlmdFRvKFxuICAgICAgXCJ5ZWFyc1wiLFxuICAgICAgXCJtb250aHNcIixcbiAgICAgIFwid2Vla3NcIixcbiAgICAgIFwiZGF5c1wiLFxuICAgICAgXCJob3Vyc1wiLFxuICAgICAgXCJtaW51dGVzXCIsXG4gICAgICBcInNlY29uZHNcIixcbiAgICAgIFwibWlsbGlzZWNvbmRzXCJcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbmVnYXRpdmUgb2YgdGhpcyBEdXJhdGlvbi5cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxLCBzZWNvbmRzOiAzMCB9KS5uZWdhdGUoKS50b09iamVjdCgpIC8vPT4geyBob3VyczogLTEsIHNlY29uZHM6IC0zMCB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgbmVnYXRlKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCBuZWdhdGVkID0ge307XG4gICAgZm9yIChjb25zdCBrIG9mIE9iamVjdC5rZXlzKHRoaXMudmFsdWVzKSkge1xuICAgICAgbmVnYXRlZFtrXSA9IHRoaXMudmFsdWVzW2tdID09PSAwID8gMCA6IC10aGlzLnZhbHVlc1trXTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdmFsdWVzOiBuZWdhdGVkIH0sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgeWVhcnMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgeWVhcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLnllYXJzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBxdWFydGVycy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBxdWFydGVycygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMucXVhcnRlcnMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1vbnRocy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBtb250aHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLm1vbnRocyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgd2Vla3NcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB3ZWVrcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMud2Vla3MgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRheXMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgZGF5cygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMuZGF5cyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaG91cnMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgaG91cnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLmhvdXJzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtaW51dGVzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1pbnV0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLm1pbnV0ZXMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNlY29uZHMuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldCBzZWNvbmRzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5zZWNvbmRzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtaWxsaXNlY29uZHMuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldCBtaWxsaXNlY29uZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLm1pbGxpc2Vjb25kcyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgRHVyYXRpb24gaXMgaW52YWxpZC4gSW52YWxpZCBkdXJhdGlvbnMgYXJlIHJldHVybmVkIGJ5IGRpZmYgb3BlcmF0aW9uc1xuICAgKiBvbiBpbnZhbGlkIERhdGVUaW1lcyBvciBJbnRlcnZhbHMuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID09PSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXJyb3IgY29kZSBpZiB0aGlzIER1cmF0aW9uIGJlY2FtZSBpbnZhbGlkLCBvciBudWxsIGlmIHRoZSBEdXJhdGlvbiBpcyB2YWxpZFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaW52YWxpZFJlYXNvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID8gdGhpcy5pbnZhbGlkLnJlYXNvbiA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBleHBsYW5hdGlvbiBvZiB3aHkgdGhpcyBEdXJhdGlvbiBiZWNhbWUgaW52YWxpZCwgb3IgbnVsbCBpZiB0aGUgRHVyYXRpb24gaXMgdmFsaWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBpbnZhbGlkRXhwbGFuYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA/IHRoaXMuaW52YWxpZC5leHBsYW5hdGlvbiA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogRXF1YWxpdHkgY2hlY2tcbiAgICogVHdvIER1cmF0aW9ucyBhcmUgZXF1YWwgaWZmIHRoZXkgaGF2ZSB0aGUgc2FtZSB1bml0cyBhbmQgdGhlIHNhbWUgdmFsdWVzIGZvciBlYWNoIHVuaXQuXG4gICAqIEBwYXJhbSB7RHVyYXRpb259IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCB8fCAhb3RoZXIuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5sb2MuZXF1YWxzKG90aGVyLmxvYykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcSh2MSwgdjIpIHtcbiAgICAgIC8vIENvbnNpZGVyIDAgYW5kIHVuZGVmaW5lZCBhcyBlcXVhbFxuICAgICAgaWYgKHYxID09PSB1bmRlZmluZWQgfHwgdjEgPT09IDApIHJldHVybiB2MiA9PT0gdW5kZWZpbmVkIHx8IHYyID09PSAwO1xuICAgICAgcmV0dXJuIHYxID09PSB2MjtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHUgb2Ygb3JkZXJlZFVuaXRzKSB7XG4gICAgICBpZiAoIWVxKHRoaXMudmFsdWVzW3VdLCBvdGhlci52YWx1ZXNbdV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiIsICJpbXBvcnQgRGF0ZVRpbWUsIHsgZnJpZW5kbHlEYXRlVGltZSB9IGZyb20gXCIuL2RhdGV0aW1lLmpzXCI7XG5pbXBvcnQgRHVyYXRpb24gZnJvbSBcIi4vZHVyYXRpb24uanNcIjtcbmltcG9ydCBTZXR0aW5ncyBmcm9tIFwiLi9zZXR0aW5ncy5qc1wiO1xuaW1wb3J0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIEludmFsaWRJbnRlcnZhbEVycm9yIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgSW52YWxpZCBmcm9tIFwiLi9pbXBsL2ludmFsaWQuanNcIjtcbmltcG9ydCBGb3JtYXR0ZXIgZnJvbSBcIi4vaW1wbC9mb3JtYXR0ZXIuanNcIjtcbmltcG9ydCAqIGFzIEZvcm1hdHMgZnJvbSBcIi4vaW1wbC9mb3JtYXRzLmpzXCI7XG5cbmNvbnN0IElOVkFMSUQgPSBcIkludmFsaWQgSW50ZXJ2YWxcIjtcblxuLy8gY2hlY2tzIGlmIHRoZSBzdGFydCBpcyBlcXVhbCB0byBvciBiZWZvcmUgdGhlIGVuZFxuZnVuY3Rpb24gdmFsaWRhdGVTdGFydEVuZChzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQgfHwgIXN0YXJ0LmlzVmFsaWQpIHtcbiAgICByZXR1cm4gSW50ZXJ2YWwuaW52YWxpZChcIm1pc3Npbmcgb3IgaW52YWxpZCBzdGFydFwiKTtcbiAgfSBlbHNlIGlmICghZW5kIHx8ICFlbmQuaXNWYWxpZCkge1xuICAgIHJldHVybiBJbnRlcnZhbC5pbnZhbGlkKFwibWlzc2luZyBvciBpbnZhbGlkIGVuZFwiKTtcbiAgfSBlbHNlIGlmIChlbmQgPCBzdGFydCkge1xuICAgIHJldHVybiBJbnRlcnZhbC5pbnZhbGlkKFxuICAgICAgXCJlbmQgYmVmb3JlIHN0YXJ0XCIsXG4gICAgICBgVGhlIGVuZCBvZiBhbiBpbnRlcnZhbCBtdXN0IGJlIGFmdGVyIGl0cyBzdGFydCwgYnV0IHlvdSBoYWQgc3RhcnQ9JHtzdGFydC50b0lTTygpfSBhbmQgZW5kPSR7ZW5kLnRvSVNPKCl9YFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBJbnRlcnZhbCBvYmplY3QgcmVwcmVzZW50cyBhIGhhbGYtb3BlbiBpbnRlcnZhbCBvZiB0aW1lLCB3aGVyZSBlYWNoIGVuZHBvaW50IGlzIGEge0BsaW5rIERhdGVUaW1lfS4gQ29uY2VwdHVhbGx5LCBpdCdzIGEgY29udGFpbmVyIGZvciB0aG9zZSB0d28gZW5kcG9pbnRzLCBhY2NvbXBhbmllZCBieSBtZXRob2RzIGZvciBjcmVhdGluZywgcGFyc2luZywgaW50ZXJyb2dhdGluZywgY29tcGFyaW5nLCB0cmFuc2Zvcm1pbmcsIGFuZCBmb3JtYXR0aW5nIHRoZW0uXG4gKlxuICogSGVyZSBpcyBhIGJyaWVmIG92ZXJ2aWV3IG9mIHRoZSBtb3N0IGNvbW1vbmx5IHVzZWQgbWV0aG9kcyBhbmQgZ2V0dGVycyBpbiBJbnRlcnZhbDpcbiAqXG4gKiAqICoqQ3JlYXRpb24qKiBUbyBjcmVhdGUgYW4gSW50ZXJ2YWwsIHVzZSB7QGxpbmsgSW50ZXJ2YWwuZnJvbURhdGVUaW1lc30sIHtAbGluayBJbnRlcnZhbC5hZnRlcn0sIHtAbGluayBJbnRlcnZhbC5iZWZvcmV9LCBvciB7QGxpbmsgSW50ZXJ2YWwuZnJvbUlTT30uXG4gKiAqICoqQWNjZXNzb3JzKiogVXNlIHtAbGluayBJbnRlcnZhbCNzdGFydH0gYW5kIHtAbGluayBJbnRlcnZhbCNlbmR9IHRvIGdldCB0aGUgc3RhcnQgYW5kIGVuZC5cbiAqICogKipJbnRlcnJvZ2F0aW9uKiogVG8gYW5hbHl6ZSB0aGUgSW50ZXJ2YWwsIHVzZSB7QGxpbmsgSW50ZXJ2YWwjY291bnR9LCB7QGxpbmsgSW50ZXJ2YWwjbGVuZ3RofSwge0BsaW5rIEludGVydmFsI2hhc1NhbWV9LCB7QGxpbmsgSW50ZXJ2YWwjY29udGFpbnN9LCB7QGxpbmsgSW50ZXJ2YWwjaXNBZnRlcn0sIG9yIHtAbGluayBJbnRlcnZhbCNpc0JlZm9yZX0uXG4gKiAqICoqVHJhbnNmb3JtYXRpb24qKiBUbyBjcmVhdGUgb3RoZXIgSW50ZXJ2YWxzIG91dCBvZiB0aGlzIG9uZSwgdXNlIHtAbGluayBJbnRlcnZhbCNzZXR9LCB7QGxpbmsgSW50ZXJ2YWwjc3BsaXRBdH0sIHtAbGluayBJbnRlcnZhbCNzcGxpdEJ5fSwge0BsaW5rIEludGVydmFsI2RpdmlkZUVxdWFsbHl9LCB7QGxpbmsgSW50ZXJ2YWwubWVyZ2V9LCB7QGxpbmsgSW50ZXJ2YWwueG9yfSwge0BsaW5rIEludGVydmFsI3VuaW9ufSwge0BsaW5rIEludGVydmFsI2ludGVyc2VjdGlvbn0sIG9yIHtAbGluayBJbnRlcnZhbCNkaWZmZXJlbmNlfS5cbiAqICogKipDb21wYXJpc29uKiogVG8gY29tcGFyZSB0aGlzIEludGVydmFsIHRvIGFub3RoZXIgb25lLCB1c2Uge0BsaW5rIEludGVydmFsI2VxdWFsc30sIHtAbGluayBJbnRlcnZhbCNvdmVybGFwc30sIHtAbGluayBJbnRlcnZhbCNhYnV0c1N0YXJ0fSwge0BsaW5rIEludGVydmFsI2FidXRzRW5kfSwge0BsaW5rIEludGVydmFsI2VuZ3VsZnN9XG4gKiAqICoqT3V0cHV0KiogVG8gY29udmVydCB0aGUgSW50ZXJ2YWwgaW50byBvdGhlciByZXByZXNlbnRhdGlvbnMsIHNlZSB7QGxpbmsgSW50ZXJ2YWwjdG9TdHJpbmd9LCB7QGxpbmsgSW50ZXJ2YWwjdG9Mb2NhbGVTdHJpbmd9LCB7QGxpbmsgSW50ZXJ2YWwjdG9JU099LCB7QGxpbmsgSW50ZXJ2YWwjdG9JU09EYXRlfSwge0BsaW5rIEludGVydmFsI3RvSVNPVGltZX0sIHtAbGluayBJbnRlcnZhbCN0b0Zvcm1hdH0sIGFuZCB7QGxpbmsgSW50ZXJ2YWwjdG9EdXJhdGlvbn0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEludGVydmFsIHtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnMgPSBjb25maWcuc3RhcnQ7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5lID0gY29uZmlnLmVuZDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmludmFsaWQgPSBjb25maWcuaW52YWxpZCB8fCBudWxsO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaXNMdXhvbkludGVydmFsID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW52YWxpZCBJbnRlcnZhbC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvbiAtIHNpbXBsZSBzdHJpbmcgb2Ygd2h5IHRoaXMgSW50ZXJ2YWwgaXMgaW52YWxpZC4gU2hvdWxkIG5vdCBjb250YWluIHBhcmFtZXRlcnMgb3IgYW55dGhpbmcgZWxzZSBkYXRhLWRlcGVuZGVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2V4cGxhbmF0aW9uPW51bGxdIC0gbG9uZ2VyIGV4cGxhbmF0aW9uLCBtYXkgaW5jbHVkZSBwYXJhbWV0ZXJzIGFuZCBvdGhlciB1c2VmdWwgZGVidWdnaW5nIGluZm9ybWF0aW9uXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgc3RhdGljIGludmFsaWQocmVhc29uLCBleHBsYW5hdGlvbiA9IG51bGwpIHtcbiAgICBpZiAoIXJlYXNvbikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwibmVlZCB0byBzcGVjaWZ5IGEgcmVhc29uIHRoZSBJbnRlcnZhbCBpcyBpbnZhbGlkXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGludmFsaWQgPSByZWFzb24gaW5zdGFuY2VvZiBJbnZhbGlkID8gcmVhc29uIDogbmV3IEludmFsaWQocmVhc29uLCBleHBsYW5hdGlvbik7XG5cbiAgICBpZiAoU2V0dGluZ3MudGhyb3dPbkludmFsaWQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkSW50ZXJ2YWxFcnJvcihpbnZhbGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBJbnRlcnZhbCh7IGludmFsaWQgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBJbnRlcnZhbCBmcm9tIGEgc3RhcnQgRGF0ZVRpbWUgYW5kIGFuIGVuZCBEYXRlVGltZS4gSW5jbHVzaXZlIG9mIHRoZSBzdGFydCBidXQgbm90IHRoZSBlbmQuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV8RGF0ZXxPYmplY3R9IHN0YXJ0XG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV8RGF0ZXxPYmplY3R9IGVuZFxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHN0YXRpYyBmcm9tRGF0ZVRpbWVzKHN0YXJ0LCBlbmQpIHtcbiAgICBjb25zdCBidWlsdFN0YXJ0ID0gZnJpZW5kbHlEYXRlVGltZShzdGFydCksXG4gICAgICBidWlsdEVuZCA9IGZyaWVuZGx5RGF0ZVRpbWUoZW5kKTtcblxuICAgIGNvbnN0IHZhbGlkYXRlRXJyb3IgPSB2YWxpZGF0ZVN0YXJ0RW5kKGJ1aWx0U3RhcnQsIGJ1aWx0RW5kKTtcblxuICAgIGlmICh2YWxpZGF0ZUVycm9yID09IG51bGwpIHtcbiAgICAgIHJldHVybiBuZXcgSW50ZXJ2YWwoe1xuICAgICAgICBzdGFydDogYnVpbHRTdGFydCxcbiAgICAgICAgZW5kOiBidWlsdEVuZCxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsaWRhdGVFcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIEludGVydmFsIGZyb20gYSBzdGFydCBEYXRlVGltZSBhbmQgYSBEdXJhdGlvbiB0byBleHRlbmQgdG8uXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV8RGF0ZXxPYmplY3R9IHN0YXJ0XG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSB0aGUgbGVuZ3RoIG9mIHRoZSBJbnRlcnZhbC5cbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICBzdGF0aWMgYWZ0ZXIoc3RhcnQsIGR1cmF0aW9uKSB7XG4gICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUR1cmF0aW9uTGlrZShkdXJhdGlvbiksXG4gICAgICBkdCA9IGZyaWVuZGx5RGF0ZVRpbWUoc3RhcnQpO1xuICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0LCBkdC5wbHVzKGR1cikpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBJbnRlcnZhbCBmcm9tIGFuIGVuZCBEYXRlVGltZSBhbmQgYSBEdXJhdGlvbiB0byBleHRlbmQgYmFja3dhcmRzIHRvLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfERhdGV8T2JqZWN0fSBlbmRcbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIHRoZSBsZW5ndGggb2YgdGhlIEludGVydmFsLlxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHN0YXRpYyBiZWZvcmUoZW5kLCBkdXJhdGlvbikge1xuICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb24pLFxuICAgICAgZHQgPSBmcmllbmRseURhdGVUaW1lKGVuZCk7XG4gICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQubWludXMoZHVyKSwgZHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBJbnRlcnZhbCBmcm9tIGFuIElTTyA4NjAxIHN0cmluZy5cbiAgICogQWNjZXB0cyBgPHN0YXJ0Pi88ZW5kPmAsIGA8c3RhcnQ+LzxkdXJhdGlvbj5gLCBhbmQgYDxkdXJhdGlvbj4vPGVuZD5gIGZvcm1hdHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIElTTyBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSAtIG9wdGlvbnMgdG8gcGFzcyB7QGxpbmsgRGF0ZVRpbWUjZnJvbUlTT30gYW5kIG9wdGlvbmFsbHkge0BsaW5rIER1cmF0aW9uI2Zyb21JU099XG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZV9pbnRlcnZhbHNcbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICBzdGF0aWMgZnJvbUlTTyh0ZXh0LCBvcHRzKSB7XG4gICAgY29uc3QgW3MsIGVdID0gKHRleHQgfHwgXCJcIikuc3BsaXQoXCIvXCIsIDIpO1xuICAgIGlmIChzICYmIGUpIHtcbiAgICAgIGxldCBzdGFydCwgc3RhcnRJc1ZhbGlkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RhcnQgPSBEYXRlVGltZS5mcm9tSVNPKHMsIG9wdHMpO1xuICAgICAgICBzdGFydElzVmFsaWQgPSBzdGFydC5pc1ZhbGlkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzdGFydElzVmFsaWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgbGV0IGVuZCwgZW5kSXNWYWxpZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGVuZCA9IERhdGVUaW1lLmZyb21JU08oZSwgb3B0cyk7XG4gICAgICAgIGVuZElzVmFsaWQgPSBlbmQuaXNWYWxpZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZW5kSXNWYWxpZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnRJc1ZhbGlkICYmIGVuZElzVmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMoc3RhcnQsIGVuZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydElzVmFsaWQpIHtcbiAgICAgICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUlTTyhlLCBvcHRzKTtcbiAgICAgICAgaWYgKGR1ci5pc1ZhbGlkKSB7XG4gICAgICAgICAgcmV0dXJuIEludGVydmFsLmFmdGVyKHN0YXJ0LCBkdXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVuZElzVmFsaWQpIHtcbiAgICAgICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUlTTyhzLCBvcHRzKTtcbiAgICAgICAgaWYgKGR1ci5pc1ZhbGlkKSB7XG4gICAgICAgICAgcmV0dXJuIEludGVydmFsLmJlZm9yZShlbmQsIGR1cik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEludGVydmFsLmludmFsaWQoXCJ1bnBhcnNhYmxlXCIsIGB0aGUgaW5wdXQgXCIke3RleHR9XCIgY2FuJ3QgYmUgcGFyc2VkIGFzIElTTyA4NjAxYCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gb2JqZWN0IGlzIGFuIEludGVydmFsLiBXb3JrcyBhY3Jvc3MgY29udGV4dCBib3VuZGFyaWVzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNJbnRlcnZhbChvKSB7XG4gICAgcmV0dXJuIChvICYmIG8uaXNMdXhvbkludGVydmFsKSB8fCBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdGFydCBvZiB0aGUgSW50ZXJ2YWxcbiAgICogQHR5cGUge0RhdGVUaW1lfVxuICAgKi9cbiAgZ2V0IHN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnMgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVuZCBvZiB0aGUgSW50ZXJ2YWxcbiAgICogQHR5cGUge0RhdGVUaW1lfVxuICAgKi9cbiAgZ2V0IGVuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5lIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIGVuZCBpcyBhdCBsZWFzdCBpdHMgc3RhcnQsIG1lYW5pbmcgdGhhdCB0aGUgSW50ZXJ2YWwgaXNuJ3QgJ2JhY2t3YXJkcycuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZFJlYXNvbiA9PT0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGVycm9yIGNvZGUgaWYgdGhpcyBJbnRlcnZhbCBpcyBpbnZhbGlkLCBvciBudWxsIGlmIHRoZSBJbnRlcnZhbCBpcyB2YWxpZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGludmFsaWRSZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA/IHRoaXMuaW52YWxpZC5yZWFzb24gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXhwbGFuYXRpb24gb2Ygd2h5IHRoaXMgSW50ZXJ2YWwgYmVjYW1lIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIEludGVydmFsIGlzIHZhbGlkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaW52YWxpZEV4cGxhbmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQuZXhwbGFuYXRpb24gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgSW50ZXJ2YWwgaW4gdGhlIHNwZWNpZmllZCB1bml0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIHRoZSB1bml0IChzdWNoIGFzICdob3Vycycgb3IgJ2RheXMnKSB0byByZXR1cm4gdGhlIGxlbmd0aCBpbi5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgbGVuZ3RoKHVuaXQgPSBcIm1pbGxpc2Vjb25kc1wiKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudG9EdXJhdGlvbiguLi5bdW5pdF0pLmdldCh1bml0KSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb3VudCBvZiBtaW51dGVzLCBob3VycywgZGF5cywgbW9udGhzLCBvciB5ZWFycyBpbmNsdWRlZCBpbiB0aGUgSW50ZXJ2YWwsIGV2ZW4gaW4gcGFydC5cbiAgICogVW5saWtlIHtAbGluayBJbnRlcnZhbCNsZW5ndGh9IHRoaXMgY291bnRzIHNlY3Rpb25zIG9mIHRoZSBjYWxlbmRhciwgbm90IHBlcmlvZHMgb2YgdGltZSwgZS5nLiBzcGVjaWZ5aW5nICdkYXknXG4gICAqIGFza3MgJ3doYXQgZGF0ZXMgYXJlIGluY2x1ZGVkIGluIHRoaXMgaW50ZXJ2YWw/Jywgbm90ICdob3cgbWFueSBkYXlzIGxvbmcgaXMgdGhpcyBpbnRlcnZhbD8nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdW5pdD0nbWlsbGlzZWNvbmRzJ10gLSB0aGUgdW5pdCBvZiB0aW1lIHRvIGNvdW50LlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy51c2VMb2NhbGVXZWVrcz1mYWxzZV0gLSBJZiB0cnVlLCB1c2Ugd2Vla3MgYmFzZWQgb24gdGhlIGxvY2FsZSwgaS5lLiB1c2UgdGhlIGxvY2FsZS1kZXBlbmRlbnQgc3RhcnQgb2YgdGhlIHdlZWs7IHRoaXMgb3BlcmF0aW9uIHdpbGwgYWx3YXlzIHVzZSB0aGUgbG9jYWxlIG9mIHRoZSBzdGFydCBEYXRlVGltZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBjb3VudCh1bml0ID0gXCJtaWxsaXNlY29uZHNcIiwgb3B0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gTmFOO1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5zdGFydC5zdGFydE9mKHVuaXQsIG9wdHMpO1xuICAgIGxldCBlbmQ7XG4gICAgaWYgKG9wdHM/LnVzZUxvY2FsZVdlZWtzKSB7XG4gICAgICBlbmQgPSB0aGlzLmVuZC5yZWNvbmZpZ3VyZSh7IGxvY2FsZTogc3RhcnQubG9jYWxlIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmQgPSB0aGlzLmVuZDtcbiAgICB9XG4gICAgZW5kID0gZW5kLnN0YXJ0T2YodW5pdCwgb3B0cyk7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoZW5kLmRpZmYoc3RhcnQsIHVuaXQpLmdldCh1bml0KSkgKyAoZW5kLnZhbHVlT2YoKSAhPT0gdGhpcy5lbmQudmFsdWVPZigpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIHN0YXJ0IGFuZCBlbmQgYXJlIGJvdGggaW4gdGhlIHNhbWUgdW5pdCBvZiB0aW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gdGhlIHVuaXQgb2YgdGltZSB0byBjaGVjayBzYW1lbmVzcyBvblxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzU2FtZSh1bml0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuaXNFbXB0eSgpIHx8IHRoaXMuZS5taW51cygxKS5oYXNTYW1lKHRoaXMucywgdW5pdCkgOiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsIGhhcyB0aGUgc2FtZSBzdGFydCBhbmQgZW5kIERhdGVUaW1lcy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMucy52YWx1ZU9mKCkgPT09IHRoaXMuZS52YWx1ZU9mKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIHN0YXJ0IGlzIGFmdGVyIHRoZSBzcGVjaWZpZWQgRGF0ZVRpbWUuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IGRhdGVUaW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0FmdGVyKGRhdGVUaW1lKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5zID4gZGF0ZVRpbWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIGVuZCBpcyBiZWZvcmUgdGhlIHNwZWNpZmllZCBEYXRlVGltZS5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gZGF0ZVRpbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQmVmb3JlKGRhdGVUaW1lKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5lIDw9IGRhdGVUaW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgY29udGFpbnMgdGhlIHNwZWNpZmllZCBEYXRlVGltZS5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gZGF0ZVRpbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGNvbnRhaW5zKGRhdGVUaW1lKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5zIDw9IGRhdGVUaW1lICYmIHRoaXMuZSA+IGRhdGVUaW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0c1wiIHRoZSBzdGFydCBhbmQvb3IgZW5kIGRhdGVzLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgSW50ZXJ2YWwuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXMgLSB0aGUgdmFsdWVzIHRvIHNldFxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSB2YWx1ZXMuc3RhcnQgLSB0aGUgc3RhcnRpbmcgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtEYXRlVGltZX0gdmFsdWVzLmVuZCAtIHRoZSBlbmRpbmcgRGF0ZVRpbWVcbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICBzZXQoeyBzdGFydCwgZW5kIH0gPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzdGFydCB8fCB0aGlzLnMsIGVuZCB8fCB0aGlzLmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0IHRoaXMgSW50ZXJ2YWwgYXQgZWFjaCBvZiB0aGUgc3BlY2lmaWVkIERhdGVUaW1lc1xuICAgKiBAcGFyYW0gey4uLkRhdGVUaW1lfSBkYXRlVGltZXMgLSB0aGUgdW5pdCBvZiB0aW1lIHRvIGNvdW50LlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHNwbGl0QXQoLi4uZGF0ZVRpbWVzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBbXTtcbiAgICBjb25zdCBzb3J0ZWQgPSBkYXRlVGltZXNcbiAgICAgICAgLm1hcChmcmllbmRseURhdGVUaW1lKVxuICAgICAgICAuZmlsdGVyKChkKSA9PiB0aGlzLmNvbnRhaW5zKGQpKVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYS50b01pbGxpcygpIC0gYi50b01pbGxpcygpKSxcbiAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICBsZXQgeyBzIH0gPSB0aGlzLFxuICAgICAgaSA9IDA7XG5cbiAgICB3aGlsZSAocyA8IHRoaXMuZSkge1xuICAgICAgY29uc3QgYWRkZWQgPSBzb3J0ZWRbaV0gfHwgdGhpcy5lLFxuICAgICAgICBuZXh0ID0gK2FkZGVkID4gK3RoaXMuZSA/IHRoaXMuZSA6IGFkZGVkO1xuICAgICAgcmVzdWx0cy5wdXNoKEludGVydmFsLmZyb21EYXRlVGltZXMocywgbmV4dCkpO1xuICAgICAgcyA9IG5leHQ7XG4gICAgICBpICs9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXQgdGhpcyBJbnRlcnZhbCBpbnRvIHNtYWxsZXIgSW50ZXJ2YWxzLCBlYWNoIG9mIHRoZSBzcGVjaWZpZWQgbGVuZ3RoLlxuICAgKiBMZWZ0IG92ZXIgdGltZSBpcyBncm91cGVkIGludG8gYSBzbWFsbGVyIGludGVydmFsXG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSBUaGUgbGVuZ3RoIG9mIGVhY2ggcmVzdWx0aW5nIGludGVydmFsLlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHNwbGl0QnkoZHVyYXRpb24pIHtcbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKTtcblxuICAgIGlmICghdGhpcy5pc1ZhbGlkIHx8ICFkdXIuaXNWYWxpZCB8fCBkdXIuYXMoXCJtaWxsaXNlY29uZHNcIikgPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBsZXQgeyBzIH0gPSB0aGlzLFxuICAgICAgaWR4ID0gMSxcbiAgICAgIG5leHQ7XG5cbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgd2hpbGUgKHMgPCB0aGlzLmUpIHtcbiAgICAgIGNvbnN0IGFkZGVkID0gdGhpcy5zdGFydC5wbHVzKGR1ci5tYXBVbml0cygoeCkgPT4geCAqIGlkeCkpO1xuICAgICAgbmV4dCA9ICthZGRlZCA+ICt0aGlzLmUgPyB0aGlzLmUgOiBhZGRlZDtcbiAgICAgIHJlc3VsdHMucHVzaChJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHMsIG5leHQpKTtcbiAgICAgIHMgPSBuZXh0O1xuICAgICAgaWR4ICs9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXQgdGhpcyBJbnRlcnZhbCBpbnRvIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHNtYWxsZXIgaW50ZXJ2YWxzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyT2ZQYXJ0cyAtIFRoZSBudW1iZXIgb2YgSW50ZXJ2YWxzIHRvIGRpdmlkZSB0aGUgSW50ZXJ2YWwgaW50by5cbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBkaXZpZGVFcXVhbGx5KG51bWJlck9mUGFydHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiB0aGlzLnNwbGl0QnkodGhpcy5sZW5ndGgoKSAvIG51bWJlck9mUGFydHMpLnNsaWNlKDAsIG51bWJlck9mUGFydHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgb3ZlcmxhcHMgd2l0aCB0aGUgc3BlY2lmaWVkIEludGVydmFsXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBvdmVybGFwcyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmUgPiBvdGhlci5zICYmIHRoaXMucyA8IG90aGVyLmU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIGVuZCBpcyBhZGphY2VudCB0byB0aGUgc3BlY2lmaWVkIEludGVydmFsJ3Mgc3RhcnQuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBhYnV0c1N0YXJ0KG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gK3RoaXMuZSA9PT0gK290aGVyLnM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIHN0YXJ0IGlzIGFkamFjZW50IHRvIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwncyBlbmQuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBhYnV0c0VuZChvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuICtvdGhlci5lID09PSArdGhpcy5zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgZW5ndWxmcyB0aGUgc3RhcnQgYW5kIGVuZCBvZiB0aGUgc3BlY2lmaWVkIEludGVydmFsLlxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZW5ndWxmcyhvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMucyA8PSBvdGhlci5zICYmIHRoaXMuZSA+PSBvdGhlci5lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgaGFzIHRoZSBzYW1lIHN0YXJ0IGFuZCBlbmQgYXMgdGhlIHNwZWNpZmllZCBJbnRlcnZhbC5cbiAgICogQHBhcmFtIHtJbnRlcnZhbH0gb3RoZXJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFscyhvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkIHx8ICFvdGhlci5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucy5lcXVhbHMob3RoZXIucykgJiYgdGhpcy5lLmVxdWFscyhvdGhlci5lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gSW50ZXJ2YWwgcmVwcmVzZW50aW5nIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhpcyBJbnRlcnZhbCBhbmQgdGhlIHNwZWNpZmllZCBJbnRlcnZhbC5cbiAgICogU3BlY2lmaWNhbGx5LCB0aGUgcmVzdWx0aW5nIEludGVydmFsIGhhcyB0aGUgbWF4aW11bSBzdGFydCB0aW1lIGFuZCB0aGUgbWluaW11bSBlbmQgdGltZSBvZiB0aGUgdHdvIEludGVydmFscy5cbiAgICogUmV0dXJucyBudWxsIGlmIHRoZSBpbnRlcnNlY3Rpb24gaXMgZW1wdHksIG1lYW5pbmcsIHRoZSBpbnRlcnZhbHMgZG9uJ3QgaW50ZXJzZWN0LlxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIGludGVyc2VjdGlvbihvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCBzID0gdGhpcy5zID4gb3RoZXIucyA/IHRoaXMucyA6IG90aGVyLnMsXG4gICAgICBlID0gdGhpcy5lIDwgb3RoZXIuZSA/IHRoaXMuZSA6IG90aGVyLmU7XG5cbiAgICBpZiAocyA+PSBlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMocywgZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBJbnRlcnZhbCByZXByZXNlbnRpbmcgdGhlIHVuaW9uIG9mIHRoaXMgSW50ZXJ2YWwgYW5kIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwuXG4gICAqIFNwZWNpZmljYWxseSwgdGhlIHJlc3VsdGluZyBJbnRlcnZhbCBoYXMgdGhlIG1pbmltdW0gc3RhcnQgdGltZSBhbmQgdGhlIG1heGltdW0gZW5kIHRpbWUgb2YgdGhlIHR3byBJbnRlcnZhbHMuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgdW5pb24ob3RoZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgcyA9IHRoaXMucyA8IG90aGVyLnMgPyB0aGlzLnMgOiBvdGhlci5zLFxuICAgICAgZSA9IHRoaXMuZSA+IG90aGVyLmUgPyB0aGlzLmUgOiBvdGhlci5lO1xuICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHMsIGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlIGFuIGFycmF5IG9mIEludGVydmFscyBpbnRvIGEgZXF1aXZhbGVudCBtaW5pbWFsIHNldCBvZiBJbnRlcnZhbHMuXG4gICAqIENvbWJpbmVzIG92ZXJsYXBwaW5nIGFuZCBhZGphY2VudCBJbnRlcnZhbHMuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGludGVydmFsc1xuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyBtZXJnZShpbnRlcnZhbHMpIHtcbiAgICBjb25zdCBbZm91bmQsIGZpbmFsXSA9IGludGVydmFsc1xuICAgICAgLnNvcnQoKGEsIGIpID0+IGEucyAtIGIucylcbiAgICAgIC5yZWR1Y2UoXG4gICAgICAgIChbc29mYXIsIGN1cnJlbnRdLCBpdGVtKSA9PiB7XG4gICAgICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gW3NvZmFyLCBpdGVtXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnQub3ZlcmxhcHMoaXRlbSkgfHwgY3VycmVudC5hYnV0c1N0YXJ0KGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gW3NvZmFyLCBjdXJyZW50LnVuaW9uKGl0ZW0pXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtzb2Zhci5jb25jYXQoW2N1cnJlbnRdKSwgaXRlbV07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBbW10sIG51bGxdXG4gICAgICApO1xuICAgIGlmIChmaW5hbCkge1xuICAgICAgZm91bmQucHVzaChmaW5hbCk7XG4gICAgfVxuICAgIHJldHVybiBmb3VuZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgSW50ZXJ2YWxzIHJlcHJlc2VudGluZyB0aGUgc3BhbnMgb2YgdGltZSB0aGF0IG9ubHkgYXBwZWFyIGluIG9uZSBvZiB0aGUgc3BlY2lmaWVkIEludGVydmFscy5cbiAgICogQHBhcmFtIHtBcnJheX0gaW50ZXJ2YWxzXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIHhvcihpbnRlcnZhbHMpIHtcbiAgICBsZXQgc3RhcnQgPSBudWxsLFxuICAgICAgY3VycmVudENvdW50ID0gMDtcbiAgICBjb25zdCByZXN1bHRzID0gW10sXG4gICAgICBlbmRzID0gaW50ZXJ2YWxzLm1hcCgoaSkgPT4gW1xuICAgICAgICB7IHRpbWU6IGkucywgdHlwZTogXCJzXCIgfSxcbiAgICAgICAgeyB0aW1lOiBpLmUsIHR5cGU6IFwiZVwiIH0sXG4gICAgICBdKSxcbiAgICAgIGZsYXR0ZW5lZCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQoLi4uZW5kcyksXG4gICAgICBhcnIgPSBmbGF0dGVuZWQuc29ydCgoYSwgYikgPT4gYS50aW1lIC0gYi50aW1lKTtcblxuICAgIGZvciAoY29uc3QgaSBvZiBhcnIpIHtcbiAgICAgIGN1cnJlbnRDb3VudCArPSBpLnR5cGUgPT09IFwic1wiID8gMSA6IC0xO1xuXG4gICAgICBpZiAoY3VycmVudENvdW50ID09PSAxKSB7XG4gICAgICAgIHN0YXJ0ID0gaS50aW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHN0YXJ0ICYmICtzdGFydCAhPT0gK2kudGltZSkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHN0YXJ0LCBpLnRpbWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gSW50ZXJ2YWwubWVyZ2UocmVzdWx0cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIEludGVydmFsIHJlcHJlc2VudGluZyB0aGUgc3BhbiBvZiB0aW1lIGluIHRoaXMgSW50ZXJ2YWwgdGhhdCBkb2Vzbid0IG92ZXJsYXAgd2l0aCBhbnkgb2YgdGhlIHNwZWNpZmllZCBJbnRlcnZhbHMuXG4gICAqIEBwYXJhbSB7Li4uSW50ZXJ2YWx9IGludGVydmFsc1xuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGRpZmZlcmVuY2UoLi4uaW50ZXJ2YWxzKSB7XG4gICAgcmV0dXJuIEludGVydmFsLnhvcihbdGhpc10uY29uY2F0KGludGVydmFscykpXG4gICAgICAubWFwKChpKSA9PiB0aGlzLmludGVyc2VjdGlvbihpKSlcbiAgICAgIC5maWx0ZXIoKGkpID0+IGkgJiYgIWkuaXNFbXB0eSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgSW50ZXJ2YWwgYXBwcm9wcmlhdGUgZm9yIGRlYnVnZ2luZy5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEO1xuICAgIHJldHVybiBgWyR7dGhpcy5zLnRvSVNPKCl9IFx1MjAxMyAke3RoaXMuZS50b0lTTygpfSlgO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBJbnRlcnZhbCBhcHByb3ByaWF0ZSBmb3IgdGhlIFJFUEwuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIFtTeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIildKCkge1xuICAgIGlmICh0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBgSW50ZXJ2YWwgeyBzdGFydDogJHt0aGlzLnMudG9JU08oKX0sIGVuZDogJHt0aGlzLmUudG9JU08oKX0gfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBgSW50ZXJ2YWwgeyBJbnZhbGlkLCByZWFzb246ICR7dGhpcy5pbnZhbGlkUmVhc29ufSB9YDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxvY2FsaXplZCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoaXMgSW50ZXJ2YWwuIEFjY2VwdHMgdGhlIHNhbWUgb3B0aW9ucyBhcyB0aGVcbiAgICogSW50bC5EYXRlVGltZUZvcm1hdCBjb25zdHJ1Y3RvciBhbmQgYW55IHByZXNldHMgZGVmaW5lZCBieSBMdXhvbiwgc3VjaCBhc1xuICAgKiB7QGxpbmsgRGF0ZVRpbWUuREFURV9GVUxMfSBvciB7QGxpbmsgRGF0ZVRpbWUuVElNRV9TSU1QTEV9LiBUaGUgZXhhY3QgYmVoYXZpb3Igb2YgdGhpcyBtZXRob2RcbiAgICogaXMgYnJvd3Nlci1zcGVjaWZpYywgYnV0IGluIGdlbmVyYWwgaXQgd2lsbCByZXR1cm4gYW4gYXBwcm9wcmlhdGUgcmVwcmVzZW50YXRpb24gb2YgdGhlXG4gICAqIEludGVydmFsIGluIHRoZSBhc3NpZ25lZCBsb2NhbGUuIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuXG4gICAqIHNwZWNpZmllZC5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlVGltZUZvcm1hdFxuICAgKiBAcGFyYW0ge09iamVjdH0gW2Zvcm1hdE9wdHM9RGF0ZVRpbWUuREFURV9TSE9SVF0gLSBFaXRoZXIgYSBEYXRlVGltZSBwcmVzZXQgb3JcbiAgICogSW50bC5EYXRlVGltZUZvcm1hdCBjb25zdHJ1Y3RvciBvcHRpb25zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIE9wdGlvbnMgdG8gb3ZlcnJpZGUgdGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIHN0YXJ0IERhdGVUaW1lLlxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tSVNPKCcyMDIyLTExLTA3VDA5OjAwWi8yMDIyLTExLTA4VDA5OjAwWicpLnRvTG9jYWxlU3RyaW5nKCk7IC8vPT4gMTEvNy8yMDIyIFx1MjAxMyAxMS84LzIwMjJcbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbUlTTygnMjAyMi0xMS0wN1QwOTowMFovMjAyMi0xMS0wOFQwOTowMFonKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5EQVRFX0ZVTEwpOyAvLz0+IE5vdmVtYmVyIDcgXHUyMDEzIDgsIDIwMjJcbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbUlTTygnMjAyMi0xMS0wN1QwOTowMFovMjAyMi0xMS0wOFQwOTowMFonKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5EQVRFX0ZVTEwsIHsgbG9jYWxlOiAnZnItRlInIH0pOyAvLz0+IDdcdTIwMTM4IG5vdmVtYnJlIDIwMjJcbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbUlTTygnMjAyMi0xMS0wN1QxNzowMFovMjAyMi0xMS0wN1QxOTowMFonKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5USU1FX1NJTVBMRSk7IC8vPT4gNjowMCBcdTIwMTMgODowMCBQTVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tSVNPKCcyMDIyLTExLTA3VDE3OjAwWi8yMDIyLTExLTA3VDE5OjAwWicpLnRvTG9jYWxlU3RyaW5nKHsgd2Vla2RheTogJ3Nob3J0JywgbW9udGg6ICdzaG9ydCcsIGRheTogJzItZGlnaXQnLCBob3VyOiAnMi1kaWdpdCcsIG1pbnV0ZTogJzItZGlnaXQnIH0pOyAvLz0+IE1vbiwgTm92IDA3LCA2OjAwIFx1MjAxMyA4OjAwIHBcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9Mb2NhbGVTdHJpbmcoZm9ybWF0T3B0cyA9IEZvcm1hdHMuREFURV9TSE9SVCwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFxuICAgICAgPyBGb3JtYXR0ZXIuY3JlYXRlKHRoaXMucy5sb2MuY2xvbmUob3B0cyksIGZvcm1hdE9wdHMpLmZvcm1hdEludGVydmFsKHRoaXMpXG4gICAgICA6IElOVkFMSUQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgSW50ZXJ2YWwuXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZV9pbnRlcnZhbHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBUaGUgc2FtZSBvcHRpb25zIGFzIHtAbGluayBEYXRlVGltZSN0b0lTT31cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU08ob3B0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gSU5WQUxJRDtcbiAgICByZXR1cm4gYCR7dGhpcy5zLnRvSVNPKG9wdHMpfS8ke3RoaXMuZS50b0lTTyhvcHRzKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBkYXRlIG9mIHRoaXMgSW50ZXJ2YWwuXG4gICAqIFRoZSB0aW1lIGNvbXBvbmVudHMgYXJlIGlnbm9yZWQuXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZV9pbnRlcnZhbHNcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU09EYXRlKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gSU5WQUxJRDtcbiAgICByZXR1cm4gYCR7dGhpcy5zLnRvSVNPRGF0ZSgpfS8ke3RoaXMuZS50b0lTT0RhdGUoKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aW1lIG9mIHRoaXMgSW50ZXJ2YWwuXG4gICAqIFRoZSBkYXRlIGNvbXBvbmVudHMgYXJlIGlnbm9yZWQuXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZV9pbnRlcnZhbHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBUaGUgc2FtZSBvcHRpb25zIGFzIHtAbGluayBEYXRlVGltZSN0b0lTT31cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU09UaW1lKG9wdHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIElOVkFMSUQ7XG4gICAgcmV0dXJuIGAke3RoaXMucy50b0lTT1RpbWUob3B0cyl9LyR7dGhpcy5lLnRvSVNPVGltZShvcHRzKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBJbnRlcnZhbCBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgZm9ybWF0XG4gICAqIHN0cmluZy4gKipZb3UgbWF5IG5vdCB3YW50IHRoaXMuKiogU2VlIHtAbGluayBJbnRlcnZhbCN0b0xvY2FsZVN0cmluZ30gZm9yIGEgbW9yZSBmbGV4aWJsZVxuICAgKiBmb3JtYXR0aW5nIHRvb2wuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRlRm9ybWF0IC0gVGhlIGZvcm1hdCBzdHJpbmcuIFRoaXMgc3RyaW5nIGZvcm1hdHMgdGhlIHN0YXJ0IGFuZCBlbmQgdGltZS5cbiAgICogU2VlIHtAbGluayBEYXRlVGltZSN0b0Zvcm1hdH0gZm9yIGRldGFpbHMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gT3B0aW9ucy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnNlcGFyYXRvciA9ICAnIFx1MjAxMyAnXSAtIEEgc2VwYXJhdG9yIHRvIHBsYWNlIGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmRcbiAgICogcmVwcmVzZW50YXRpb25zLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0Zvcm1hdChkYXRlRm9ybWF0LCB7IHNlcGFyYXRvciA9IFwiIFx1MjAxMyBcIiB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIElOVkFMSUQ7XG4gICAgcmV0dXJuIGAke3RoaXMucy50b0Zvcm1hdChkYXRlRm9ybWF0KX0ke3NlcGFyYXRvcn0ke3RoaXMuZS50b0Zvcm1hdChkYXRlRm9ybWF0KX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIER1cmF0aW9uIHJlcHJlc2VudGluZyB0aGUgdGltZSBzcGFubmVkIGJ5IHRoaXMgaW50ZXJ2YWwuXG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBbdW5pdD1bJ21pbGxpc2Vjb25kcyddXSAtIHRoZSB1bml0IG9yIHVuaXRzIChzdWNoIGFzICdob3Vycycgb3IgJ2RheXMnKSB0byBpbmNsdWRlIGluIHRoZSBkdXJhdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBjcmVhdGlvbiBvZiB0aGUgRHVyYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLnRvRHVyYXRpb24oKS50b09iamVjdCgpIC8vPT4geyBtaWxsaXNlY29uZHM6IDg4NDg5MjU3IH1cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikudG9EdXJhdGlvbignZGF5cycpLnRvT2JqZWN0KCkgLy89PiB7IGRheXM6IDEuMDI0MTgxMjE1Mjc3Nzc3OCB9XG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLnRvRHVyYXRpb24oWydob3VycycsICdtaW51dGVzJ10pLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAyNCwgbWludXRlczogMzQuODIwOTUgfVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS50b0R1cmF0aW9uKFsnaG91cnMnLCAnbWludXRlcycsICdzZWNvbmRzJ10pLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAyNCwgbWludXRlczogMzQsIHNlY29uZHM6IDQ5LjI1NyB9XG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLnRvRHVyYXRpb24oJ3NlY29uZHMnKS50b09iamVjdCgpIC8vPT4geyBzZWNvbmRzOiA4ODQ4OS4yNTcgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHRvRHVyYXRpb24odW5pdCwgb3B0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uaW52YWxpZCh0aGlzLmludmFsaWRSZWFzb24pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lLmRpZmYodGhpcy5zLCB1bml0LCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gbWFwRm4gb24gdGhlIGludGVydmFsIHN0YXJ0IGFuZCBlbmQsIHJldHVybmluZyBhIG5ldyBJbnRlcnZhbCBmcm9tIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWVzXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1hcEZuXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS5tYXBFbmRwb2ludHMoZW5kcG9pbnQgPT4gZW5kcG9pbnQudG9VVEMoKSlcbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikubWFwRW5kcG9pbnRzKGVuZHBvaW50ID0+IGVuZHBvaW50LnBsdXMoeyBob3VyczogMiB9KSlcbiAgICovXG4gIG1hcEVuZHBvaW50cyhtYXBGbikge1xuICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKG1hcEZuKHRoaXMucyksIG1hcEZuKHRoaXMuZSkpO1xuICB9XG59XG4iLCAiaW1wb3J0IERhdGVUaW1lIGZyb20gXCIuL2RhdGV0aW1lLmpzXCI7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSBcIi4vc2V0dGluZ3MuanNcIjtcbmltcG9ydCBMb2NhbGUgZnJvbSBcIi4vaW1wbC9sb2NhbGUuanNcIjtcbmltcG9ydCBJQU5BWm9uZSBmcm9tIFwiLi96b25lcy9JQU5BWm9uZS5qc1wiO1xuaW1wb3J0IHsgbm9ybWFsaXplWm9uZSB9IGZyb20gXCIuL2ltcGwvem9uZVV0aWwuanNcIjtcblxuaW1wb3J0IHsgaGFzTG9jYWxlV2Vla0luZm8sIGhhc1JlbGF0aXZlIH0gZnJvbSBcIi4vaW1wbC91dGlsLmpzXCI7XG5cbi8qKlxuICogVGhlIEluZm8gY2xhc3MgY29udGFpbnMgc3RhdGljIG1ldGhvZHMgZm9yIHJldHJpZXZpbmcgZ2VuZXJhbCB0aW1lIGFuZCBkYXRlIHJlbGF0ZWQgZGF0YS4gRm9yIGV4YW1wbGUsIGl0IGhhcyBtZXRob2RzIGZvciBmaW5kaW5nIG91dCBpZiBhIHRpbWUgem9uZSBoYXMgYSBEU1QsIGZvciBsaXN0aW5nIHRoZSBtb250aHMgaW4gYW55IHN1cHBvcnRlZCBsb2NhbGUsIGFuZCBmb3IgZGlzY292ZXJpbmcgd2hpY2ggb2YgTHV4b24gZmVhdHVyZXMgYXJlIGF2YWlsYWJsZSBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5mbyB7XG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGUgc3BlY2lmaWVkIHpvbmUgY29udGFpbnMgYSBEU1QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFt6b25lPSdsb2NhbCddIC0gWm9uZSB0byBjaGVjay4gRGVmYXVsdHMgdG8gdGhlIGVudmlyb25tZW50J3MgbG9jYWwgem9uZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBoYXNEU1Qoem9uZSA9IFNldHRpbmdzLmRlZmF1bHRab25lKSB7XG4gICAgY29uc3QgcHJvdG8gPSBEYXRlVGltZS5ub3coKS5zZXRab25lKHpvbmUpLnNldCh7IG1vbnRoOiAxMiB9KTtcblxuICAgIHJldHVybiAhem9uZS5pc1VuaXZlcnNhbCAmJiBwcm90by5vZmZzZXQgIT09IHByb3RvLnNldCh7IG1vbnRoOiA2IH0pLm9mZnNldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGUgc3BlY2lmaWVkIHpvbmUgaXMgYSB2YWxpZCBJQU5BIHNwZWNpZmllci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHpvbmUgLSBab25lIHRvIGNoZWNrXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNWYWxpZElBTkFab25lKHpvbmUpIHtcbiAgICByZXR1cm4gSUFOQVpvbmUuaXNWYWxpZFpvbmUoem9uZSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhlIGlucHV0IGludG8gYSB7QGxpbmsgWm9uZX0gaW5zdGFuY2UuXG4gICAqXG4gICAqICogSWYgYGlucHV0YCBpcyBhbHJlYWR5IGEgWm9uZSBpbnN0YW5jZSwgaXQgaXMgcmV0dXJuZWQgdW5jaGFuZ2VkLlxuICAgKiAqIElmIGBpbnB1dGAgaXMgYSBzdHJpbmcgY29udGFpbmluZyBhIHZhbGlkIHRpbWUgem9uZSBuYW1lLCBhIFpvbmUgaW5zdGFuY2VcbiAgICogICB3aXRoIHRoYXQgbmFtZSBpcyByZXR1cm5lZC5cbiAgICogKiBJZiBgaW5wdXRgIGlzIGEgc3RyaW5nIHRoYXQgZG9lc24ndCByZWZlciB0byBhIGtub3duIHRpbWUgem9uZSwgYSBab25lXG4gICAqICAgaW5zdGFuY2Ugd2l0aCB7QGxpbmsgWm9uZSNpc1ZhbGlkfSA9PSBmYWxzZSBpcyByZXR1cm5lZC5cbiAgICogKiBJZiBgaW5wdXQgaXMgYSBudW1iZXIsIGEgWm9uZSBpbnN0YW5jZSB3aXRoIHRoZSBzcGVjaWZpZWQgZml4ZWQgb2Zmc2V0XG4gICAqICAgaW4gbWludXRlcyBpcyByZXR1cm5lZC5cbiAgICogKiBJZiBgaW5wdXRgIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYCwgdGhlIGRlZmF1bHQgem9uZSBpcyByZXR1cm5lZC5cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZXxudW1iZXJ9IFtpbnB1dF0gLSB0aGUgdmFsdWUgdG8gYmUgY29udmVydGVkXG4gICAqIEByZXR1cm4ge1pvbmV9XG4gICAqL1xuICBzdGF0aWMgbm9ybWFsaXplWm9uZShpbnB1dCkge1xuICAgIHJldHVybiBub3JtYWxpemVab25lKGlucHV0LCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB3ZWVrZGF5IG9uIHdoaWNoIHRoZSB3ZWVrIHN0YXJ0cyBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIGxvY2FsZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGVdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NPYmo9bnVsbF0gLSBhbiBleGlzdGluZyBsb2NhbGUgb2JqZWN0IHRvIHVzZVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgc3RhcnQgb2YgdGhlIHdlZWssIDEgZm9yIE1vbmRheSB0aHJvdWdoIDcgZm9yIFN1bmRheVxuICAgKi9cbiAgc3RhdGljIGdldFN0YXJ0T2ZXZWVrKHsgbG9jYWxlID0gbnVsbCwgbG9jT2JqID0gbnVsbCB9ID0ge30pIHtcbiAgICByZXR1cm4gKGxvY09iaiB8fCBMb2NhbGUuY3JlYXRlKGxvY2FsZSkpLmdldFN0YXJ0T2ZXZWVrKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtaW5pbXVtIG51bWJlciBvZiBkYXlzIG5lY2Vzc2FyeSBpbiBhIHdlZWsgYmVmb3JlIGl0IGlzIGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgbmV4dCB5ZWFyIGFjY29yZGluZ1xuICAgKiB0byB0aGUgZ2l2ZW4gbG9jYWxlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY09iaj1udWxsXSAtIGFuIGV4aXN0aW5nIGxvY2FsZSBvYmplY3QgdG8gdXNlXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0TWluaW11bURheXNJbkZpcnN0V2Vlayh7IGxvY2FsZSA9IG51bGwsIGxvY09iaiA9IG51bGwgfSA9IHt9KSB7XG4gICAgcmV0dXJuIChsb2NPYmogfHwgTG9jYWxlLmNyZWF0ZShsb2NhbGUpKS5nZXRNaW5EYXlzSW5GaXJzdFdlZWsoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdlZWtkYXlzLCB3aGljaCBhcmUgY29uc2lkZXJlZCB0aGUgd2Vla2VuZCBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIGxvY2FsZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY09iaj1udWxsXSAtIGFuIGV4aXN0aW5nIGxvY2FsZSBvYmplY3QgdG8gdXNlXG4gICAqIEByZXR1cm5zIHtudW1iZXJbXX0gYW4gYXJyYXkgb2Ygd2Vla2RheXMsIDEgZm9yIE1vbmRheSB0aHJvdWdoIDcgZm9yIFN1bmRheVxuICAgKi9cbiAgc3RhdGljIGdldFdlZWtlbmRXZWVrZGF5cyh7IGxvY2FsZSA9IG51bGwsIGxvY09iaiA9IG51bGwgfSA9IHt9KSB7XG4gICAgLy8gY29weSB0aGUgYXJyYXksIGJlY2F1c2Ugd2UgY2FjaGUgaXQgaW50ZXJuYWxseVxuICAgIHJldHVybiAobG9jT2JqIHx8IExvY2FsZS5jcmVhdGUobG9jYWxlKSkuZ2V0V2Vla2VuZERheXMoKS5zbGljZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBzdGFuZGFsb25lIG1vbnRoIG5hbWVzLlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGVUaW1lRm9ybWF0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGVuZ3RoPSdsb25nJ10gLSB0aGUgbGVuZ3RoIG9mIHRoZSBtb250aCByZXByZXNlbnRhdGlvbiwgc3VjaCBhcyBcIm51bWVyaWNcIiwgXCIyLWRpZ2l0XCIsIFwibmFycm93XCIsIFwic2hvcnRcIiwgXCJsb25nXCJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGVdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5udW1iZXJpbmdTeXN0ZW09bnVsbF0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jT2JqPW51bGxdIC0gYW4gZXhpc3RpbmcgbG9jYWxlIG9iamVjdCB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm91dHB1dENhbGVuZGFyPSdncmVnb3J5J10gLSB0aGUgY2FsZW5kYXJcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoKVswXSAvLz0+ICdKYW51YXJ5J1xuICAgKiBAZXhhbXBsZSBJbmZvLm1vbnRocygnc2hvcnQnKVswXSAvLz0+ICdKYW4nXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKCdudW1lcmljJylbMF0gLy89PiAnMSdcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoJ3Nob3J0JywgeyBsb2NhbGU6ICdmci1DQScgfSApWzBdIC8vPT4gJ2phbnYuJ1xuICAgKiBAZXhhbXBsZSBJbmZvLm1vbnRocygnbnVtZXJpYycsIHsgbG9jYWxlOiAnYXInIH0pWzBdIC8vPT4gJ1x1MDY2MSdcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoJ2xvbmcnLCB7IG91dHB1dENhbGVuZGFyOiAnaXNsYW1pYycgfSlbMF0gLy89PiAnUmFiaVx1MDJCQiBJJ1xuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyBtb250aHMoXG4gICAgbGVuZ3RoID0gXCJsb25nXCIsXG4gICAgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsLCBsb2NPYmogPSBudWxsLCBvdXRwdXRDYWxlbmRhciA9IFwiZ3JlZ29yeVwiIH0gPSB7fVxuICApIHtcbiAgICByZXR1cm4gKGxvY09iaiB8fCBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhcikpLm1vbnRocyhsZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBmb3JtYXQgbW9udGggbmFtZXMuXG4gICAqIEZvcm1hdCBtb250aHMgZGlmZmVyIGZyb20gc3RhbmRhbG9uZSBtb250aHMgaW4gdGhhdCB0aGV5J3JlIG1lYW50IHRvIGFwcGVhciBuZXh0IHRvIHRoZSBkYXkgb2YgdGhlIG1vbnRoLiBJbiBzb21lIGxhbmd1YWdlcywgdGhhdFxuICAgKiBjaGFuZ2VzIHRoZSBzdHJpbmcuXG4gICAqIFNlZSB7QGxpbmsgSW5mbyNtb250aHN9XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGVuZ3RoPSdsb25nJ10gLSB0aGUgbGVuZ3RoIG9mIHRoZSBtb250aCByZXByZXNlbnRhdGlvbiwgc3VjaCBhcyBcIm51bWVyaWNcIiwgXCIyLWRpZ2l0XCIsIFwibmFycm93XCIsIFwic2hvcnRcIiwgXCJsb25nXCJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGVdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5udW1iZXJpbmdTeXN0ZW09bnVsbF0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jT2JqPW51bGxdIC0gYW4gZXhpc3RpbmcgbG9jYWxlIG9iamVjdCB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm91dHB1dENhbGVuZGFyPSdncmVnb3J5J10gLSB0aGUgY2FsZW5kYXJcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgbW9udGhzRm9ybWF0KFxuICAgIGxlbmd0aCA9IFwibG9uZ1wiLFxuICAgIHsgbG9jYWxlID0gbnVsbCwgbnVtYmVyaW5nU3lzdGVtID0gbnVsbCwgbG9jT2JqID0gbnVsbCwgb3V0cHV0Q2FsZW5kYXIgPSBcImdyZWdvcnlcIiB9ID0ge31cbiAgKSB7XG4gICAgcmV0dXJuIChsb2NPYmogfHwgTG9jYWxlLmNyZWF0ZShsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIpKS5tb250aHMobGVuZ3RoLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2Ygc3RhbmRhbG9uZSB3ZWVrIG5hbWVzLlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGVUaW1lRm9ybWF0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGVuZ3RoPSdsb25nJ10gLSB0aGUgbGVuZ3RoIG9mIHRoZSB3ZWVrZGF5IHJlcHJlc2VudGF0aW9uLCBzdWNoIGFzIFwibmFycm93XCIsIFwic2hvcnRcIiwgXCJsb25nXCIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubnVtYmVyaW5nU3lzdGVtPW51bGxdIC0gdGhlIG51bWJlcmluZyBzeXN0ZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY09iaj1udWxsXSAtIGFuIGV4aXN0aW5nIGxvY2FsZSBvYmplY3QgdG8gdXNlXG4gICAqIEBleGFtcGxlIEluZm8ud2Vla2RheXMoKVswXSAvLz0+ICdNb25kYXknXG4gICAqIEBleGFtcGxlIEluZm8ud2Vla2RheXMoJ3Nob3J0JylbMF0gLy89PiAnTW9uJ1xuICAgKiBAZXhhbXBsZSBJbmZvLndlZWtkYXlzKCdzaG9ydCcsIHsgbG9jYWxlOiAnZnItQ0EnIH0pWzBdIC8vPT4gJ2x1bi4nXG4gICAqIEBleGFtcGxlIEluZm8ud2Vla2RheXMoJ3Nob3J0JywgeyBsb2NhbGU6ICdhcicgfSlbMF0gLy89PiAnXHUwNjI3XHUwNjQ0XHUwNjI3XHUwNjJCXHUwNjQ2XHUwNjRBXHUwNjQ2J1xuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyB3ZWVrZGF5cyhsZW5ndGggPSBcImxvbmdcIiwgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsLCBsb2NPYmogPSBudWxsIH0gPSB7fSkge1xuICAgIHJldHVybiAobG9jT2JqIHx8IExvY2FsZS5jcmVhdGUobG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG51bGwpKS53ZWVrZGF5cyhsZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBmb3JtYXQgd2VlayBuYW1lcy5cbiAgICogRm9ybWF0IHdlZWtkYXlzIGRpZmZlciBmcm9tIHN0YW5kYWxvbmUgd2Vla2RheXMgaW4gdGhhdCB0aGV5J3JlIG1lYW50IHRvIGFwcGVhciBuZXh0IHRvIG1vcmUgZGF0ZSBpbmZvcm1hdGlvbi4gSW4gc29tZSBsYW5ndWFnZXMsIHRoYXRcbiAgICogY2hhbmdlcyB0aGUgc3RyaW5nLlxuICAgKiBTZWUge0BsaW5rIEluZm8jd2Vla2RheXN9XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGVuZ3RoPSdsb25nJ10gLSB0aGUgbGVuZ3RoIG9mIHRoZSBtb250aCByZXByZXNlbnRhdGlvbiwgc3VjaCBhcyBcIm5hcnJvd1wiLCBcInNob3J0XCIsIFwibG9uZ1wiLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT1udWxsXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubnVtYmVyaW5nU3lzdGVtPW51bGxdIC0gdGhlIG51bWJlcmluZyBzeXN0ZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY09iaj1udWxsXSAtIGFuIGV4aXN0aW5nIGxvY2FsZSBvYmplY3QgdG8gdXNlXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIHdlZWtkYXlzRm9ybWF0KFxuICAgIGxlbmd0aCA9IFwibG9uZ1wiLFxuICAgIHsgbG9jYWxlID0gbnVsbCwgbnVtYmVyaW5nU3lzdGVtID0gbnVsbCwgbG9jT2JqID0gbnVsbCB9ID0ge31cbiAgKSB7XG4gICAgcmV0dXJuIChsb2NPYmogfHwgTG9jYWxlLmNyZWF0ZShsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgbnVsbCkpLndlZWtkYXlzKGxlbmd0aCwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIG1lcmlkaWVtcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGVdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBleGFtcGxlIEluZm8ubWVyaWRpZW1zKCkgLy89PiBbICdBTScsICdQTScgXVxuICAgKiBAZXhhbXBsZSBJbmZvLm1lcmlkaWVtcyh7IGxvY2FsZTogJ215JyB9KSAvLz0+IFsgJ1x1MTAxNFx1MTAzNlx1MTAxNFx1MTAwMFx1MTAzQScsICdcdTEwMEFcdTEwMTRcdTEwMzEnIF1cbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgbWVyaWRpZW1zKHsgbG9jYWxlID0gbnVsbCB9ID0ge30pIHtcbiAgICByZXR1cm4gTG9jYWxlLmNyZWF0ZShsb2NhbGUpLm1lcmlkaWVtcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBlcmFzLCBzdWNoIGFzIFsnQkMnLCAnQUQnXS4gVGhlIGxvY2FsZSBjYW4gYmUgc3BlY2lmaWVkLCBidXQgdGhlIGNhbGVuZGFyIHN5c3RlbSBpcyBhbHdheXMgR3JlZ29yaWFuLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xlbmd0aD0nc2hvcnQnXSAtIHRoZSBsZW5ndGggb2YgdGhlIGVyYSByZXByZXNlbnRhdGlvbiwgc3VjaCBhcyBcInNob3J0XCIgb3IgXCJsb25nXCIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAZXhhbXBsZSBJbmZvLmVyYXMoKSAvLz0+IFsgJ0JDJywgJ0FEJyBdXG4gICAqIEBleGFtcGxlIEluZm8uZXJhcygnbG9uZycpIC8vPT4gWyAnQmVmb3JlIENocmlzdCcsICdBbm5vIERvbWluaScgXVxuICAgKiBAZXhhbXBsZSBJbmZvLmVyYXMoJ2xvbmcnLCB7IGxvY2FsZTogJ2ZyJyB9KSAvLz0+IFsgJ2F2YW50IEpcdTAwRTlzdXMtQ2hyaXN0JywgJ2Fwclx1MDBFOHMgSlx1MDBFOXN1cy1DaHJpc3QnIF1cbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgZXJhcyhsZW5ndGggPSBcInNob3J0XCIsIHsgbG9jYWxlID0gbnVsbCB9ID0ge30pIHtcbiAgICByZXR1cm4gTG9jYWxlLmNyZWF0ZShsb2NhbGUsIG51bGwsIFwiZ3JlZ29yeVwiKS5lcmFzKGxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBzZXQgb2YgYXZhaWxhYmxlIGZlYXR1cmVzIGluIHRoaXMgZW52aXJvbm1lbnQuXG4gICAqIFNvbWUgZmVhdHVyZXMgb2YgTHV4b24gYXJlIG5vdCBhdmFpbGFibGUgaW4gYWxsIGVudmlyb25tZW50cy4gRm9yIGV4YW1wbGUsIG9uIG9sZGVyIGJyb3dzZXJzLCByZWxhdGl2ZSB0aW1lIGZvcm1hdHRpbmcgc3VwcG9ydCBpcyBub3QgYXZhaWxhYmxlLiBVc2UgdGhpcyBmdW5jdGlvbiB0byBmaWd1cmUgb3V0IGlmIHRoYXQncyB0aGUgY2FzZS5cbiAgICogS2V5czpcbiAgICogKiBgcmVsYXRpdmVgOiB3aGV0aGVyIHRoaXMgZW52aXJvbm1lbnQgc3VwcG9ydHMgcmVsYXRpdmUgdGltZSBmb3JtYXR0aW5nXG4gICAqICogYGxvY2FsZVdlZWtgOiB3aGV0aGVyIHRoaXMgZW52aXJvbm1lbnQgc3VwcG9ydHMgZGlmZmVyZW50IHdlZWtkYXlzIGZvciB0aGUgc3RhcnQgb2YgdGhlIHdlZWsgYmFzZWQgb24gdGhlIGxvY2FsZVxuICAgKiBAZXhhbXBsZSBJbmZvLmZlYXR1cmVzKCkgLy89PiB7IHJlbGF0aXZlOiBmYWxzZSwgbG9jYWxlV2VlazogdHJ1ZSB9XG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBmZWF0dXJlcygpIHtcbiAgICByZXR1cm4geyByZWxhdGl2ZTogaGFzUmVsYXRpdmUoKSwgbG9jYWxlV2VlazogaGFzTG9jYWxlV2Vla0luZm8oKSB9O1xuICB9XG59XG4iLCAiaW1wb3J0IER1cmF0aW9uIGZyb20gXCIuLi9kdXJhdGlvbi5qc1wiO1xuXG5mdW5jdGlvbiBkYXlEaWZmKGVhcmxpZXIsIGxhdGVyKSB7XG4gIGNvbnN0IHV0Y0RheVN0YXJ0ID0gKGR0KSA9PiBkdC50b1VUQygwLCB7IGtlZXBMb2NhbFRpbWU6IHRydWUgfSkuc3RhcnRPZihcImRheVwiKS52YWx1ZU9mKCksXG4gICAgbXMgPSB1dGNEYXlTdGFydChsYXRlcikgLSB1dGNEYXlTdGFydChlYXJsaWVyKTtcbiAgcmV0dXJuIE1hdGguZmxvb3IoRHVyYXRpb24uZnJvbU1pbGxpcyhtcykuYXMoXCJkYXlzXCIpKTtcbn1cblxuZnVuY3Rpb24gaGlnaE9yZGVyRGlmZnMoY3Vyc29yLCBsYXRlciwgdW5pdHMpIHtcbiAgY29uc3QgZGlmZmVycyA9IFtcbiAgICBbXCJ5ZWFyc1wiLCAoYSwgYikgPT4gYi55ZWFyIC0gYS55ZWFyXSxcbiAgICBbXCJxdWFydGVyc1wiLCAoYSwgYikgPT4gYi5xdWFydGVyIC0gYS5xdWFydGVyICsgKGIueWVhciAtIGEueWVhcikgKiA0XSxcbiAgICBbXCJtb250aHNcIiwgKGEsIGIpID0+IGIubW9udGggLSBhLm1vbnRoICsgKGIueWVhciAtIGEueWVhcikgKiAxMl0sXG4gICAgW1xuICAgICAgXCJ3ZWVrc1wiLFxuICAgICAgKGEsIGIpID0+IHtcbiAgICAgICAgY29uc3QgZGF5cyA9IGRheURpZmYoYSwgYik7XG4gICAgICAgIHJldHVybiAoZGF5cyAtIChkYXlzICUgNykpIC8gNztcbiAgICAgIH0sXG4gICAgXSxcbiAgICBbXCJkYXlzXCIsIGRheURpZmZdLFxuICBdO1xuXG4gIGNvbnN0IHJlc3VsdHMgPSB7fTtcbiAgY29uc3QgZWFybGllciA9IGN1cnNvcjtcbiAgbGV0IGxvd2VzdE9yZGVyLCBoaWdoV2F0ZXI7XG5cbiAgLyogVGhpcyBsb29wIHRyaWVzIHRvIGRpZmYgdXNpbmcgbGFyZ2VyIHVuaXRzIGZpcnN0LlxuICAgICBJZiB3ZSBvdmVyc2hvb3QsIHdlIGJhY2t0cmFjayBhbmQgdHJ5IHRoZSBuZXh0IHNtYWxsZXIgdW5pdC5cbiAgICAgXCJjdXJzb3JcIiBzdGFydHMgb3V0IGF0IHRoZSBlYXJsaWVyIHRpbWVzdGFtcCBhbmQgbW92ZXMgY2xvc2VyIGFuZCBjbG9zZXIgdG8gXCJsYXRlclwiXG4gICAgIGFzIHdlIHVzZSBzbWFsbGVyIGFuZCBzbWFsbGVyIHVuaXRzLlxuICAgICBoaWdoV2F0ZXIga2VlcHMgdHJhY2sgb2Ygd2hlcmUgd2Ugd291bGQgYmUgaWYgd2UgYWRkZWQgb25lIG1vcmUgb2YgdGhlIHNtYWxsZXN0IHVuaXQsXG4gICAgIHRoaXMgaXMgdXNlZCBsYXRlciB0byBwb3RlbnRpYWxseSBjb252ZXJ0IGFueSBkaWZmZXJlbmNlIHNtYWxsZXIgdGhhbiB0aGUgc21hbGxlc3QgaGlnaGVyIG9yZGVyIHVuaXRcbiAgICAgaW50byBhIGZyYWN0aW9uIG9mIHRoYXQgc21hbGxlc3QgaGlnaGVyIG9yZGVyIHVuaXRcbiAgKi9cbiAgZm9yIChjb25zdCBbdW5pdCwgZGlmZmVyXSBvZiBkaWZmZXJzKSB7XG4gICAgaWYgKHVuaXRzLmluZGV4T2YodW5pdCkgPj0gMCkge1xuICAgICAgbG93ZXN0T3JkZXIgPSB1bml0O1xuXG4gICAgICByZXN1bHRzW3VuaXRdID0gZGlmZmVyKGN1cnNvciwgbGF0ZXIpO1xuICAgICAgaGlnaFdhdGVyID0gZWFybGllci5wbHVzKHJlc3VsdHMpO1xuXG4gICAgICBpZiAoaGlnaFdhdGVyID4gbGF0ZXIpIHtcbiAgICAgICAgLy8gd2Ugb3ZlcnNob3QgdGhlIGVuZCBwb2ludCwgYmFja3RyYWNrIGN1cnNvciBieSAxXG4gICAgICAgIHJlc3VsdHNbdW5pdF0tLTtcbiAgICAgICAgY3Vyc29yID0gZWFybGllci5wbHVzKHJlc3VsdHMpO1xuXG4gICAgICAgIC8vIGlmIHdlIGFyZSBzdGlsbCBvdmVyc2hvb3Rpbmcgbm93LCB3ZSBuZWVkIHRvIGJhY2t0cmFjayBhZ2FpblxuICAgICAgICAvLyB0aGlzIGhhcHBlbnMgaW4gY2VydGFpbiBzaXR1YXRpb25zIHdoZW4gZGlmZmluZyB0aW1lcyBpbiBkaWZmZXJlbnQgem9uZXMsXG4gICAgICAgIC8vIGJlY2F1c2UgdGhpcyBjYWxjdWxhdGlvbiBpZ25vcmVzIHRpbWUgem9uZXNcbiAgICAgICAgaWYgKGN1cnNvciA+IGxhdGVyKSB7XG4gICAgICAgICAgLy8ga2VlcCB0aGUgXCJvdmVyc2hvdCBieSAxXCIgYXJvdW5kIGFzIGhpZ2hXYXRlclxuICAgICAgICAgIGhpZ2hXYXRlciA9IGN1cnNvcjtcbiAgICAgICAgICAvLyBiYWNrdHJhY2sgY3Vyc29yIGJ5IDFcbiAgICAgICAgICByZXN1bHRzW3VuaXRdLS07XG4gICAgICAgICAgY3Vyc29yID0gZWFybGllci5wbHVzKHJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJzb3IgPSBoaWdoV2F0ZXI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtjdXJzb3IsIHJlc3VsdHMsIGhpZ2hXYXRlciwgbG93ZXN0T3JkZXJdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoZWFybGllciwgbGF0ZXIsIHVuaXRzLCBvcHRzKSB7XG4gIGxldCBbY3Vyc29yLCByZXN1bHRzLCBoaWdoV2F0ZXIsIGxvd2VzdE9yZGVyXSA9IGhpZ2hPcmRlckRpZmZzKGVhcmxpZXIsIGxhdGVyLCB1bml0cyk7XG5cbiAgY29uc3QgcmVtYWluaW5nTWlsbGlzID0gbGF0ZXIgLSBjdXJzb3I7XG5cbiAgY29uc3QgbG93ZXJPcmRlclVuaXRzID0gdW5pdHMuZmlsdGVyKFxuICAgICh1KSA9PiBbXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgXCJzZWNvbmRzXCIsIFwibWlsbGlzZWNvbmRzXCJdLmluZGV4T2YodSkgPj0gMFxuICApO1xuXG4gIGlmIChsb3dlck9yZGVyVW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGhpZ2hXYXRlciA8IGxhdGVyKSB7XG4gICAgICBoaWdoV2F0ZXIgPSBjdXJzb3IucGx1cyh7IFtsb3dlc3RPcmRlcl06IDEgfSk7XG4gICAgfVxuXG4gICAgaWYgKGhpZ2hXYXRlciAhPT0gY3Vyc29yKSB7XG4gICAgICByZXN1bHRzW2xvd2VzdE9yZGVyXSA9IChyZXN1bHRzW2xvd2VzdE9yZGVyXSB8fCAwKSArIHJlbWFpbmluZ01pbGxpcyAvIChoaWdoV2F0ZXIgLSBjdXJzb3IpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGR1cmF0aW9uID0gRHVyYXRpb24uZnJvbU9iamVjdChyZXN1bHRzLCBvcHRzKTtcblxuICBpZiAobG93ZXJPcmRlclVuaXRzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gRHVyYXRpb24uZnJvbU1pbGxpcyhyZW1haW5pbmdNaWxsaXMsIG9wdHMpXG4gICAgICAuc2hpZnRUbyguLi5sb3dlck9yZGVyVW5pdHMpXG4gICAgICAucGx1cyhkdXJhdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGR1cmF0aW9uO1xuICB9XG59XG4iLCAiY29uc3QgbnVtYmVyaW5nU3lzdGVtcyA9IHtcbiAgYXJhYjogXCJbXFx1MDY2MC1cXHUwNjY5XVwiLFxuICBhcmFiZXh0OiBcIltcXHUwNkYwLVxcdTA2RjldXCIsXG4gIGJhbGk6IFwiW1xcdTFCNTAtXFx1MUI1OV1cIixcbiAgYmVuZzogXCJbXFx1MDlFNi1cXHUwOUVGXVwiLFxuICBkZXZhOiBcIltcXHUwOTY2LVxcdTA5NkZdXCIsXG4gIGZ1bGx3aWRlOiBcIltcXHVGRjEwLVxcdUZGMTldXCIsXG4gIGd1anI6IFwiW1xcdTBBRTYtXFx1MEFFRl1cIixcbiAgaGFuaWRlYzogXCJbXHUzMDA3fFx1NEUwMHxcdTRFOEN8XHU0RTA5fFx1NTZEQnxcdTRFOTR8XHU1MTZEfFx1NEUwM3xcdTUxNkJ8XHU0RTVEXVwiLFxuICBraG1yOiBcIltcXHUxN0UwLVxcdTE3RTldXCIsXG4gIGtuZGE6IFwiW1xcdTBDRTYtXFx1MENFRl1cIixcbiAgbGFvbzogXCJbXFx1MEVEMC1cXHUwRUQ5XVwiLFxuICBsaW1iOiBcIltcXHUxOTQ2LVxcdTE5NEZdXCIsXG4gIG1seW06IFwiW1xcdTBENjYtXFx1MEQ2Rl1cIixcbiAgbW9uZzogXCJbXFx1MTgxMC1cXHUxODE5XVwiLFxuICBteW1yOiBcIltcXHUxMDQwLVxcdTEwNDldXCIsXG4gIG9yeWE6IFwiW1xcdTBCNjYtXFx1MEI2Rl1cIixcbiAgdGFtbGRlYzogXCJbXFx1MEJFNi1cXHUwQkVGXVwiLFxuICB0ZWx1OiBcIltcXHUwQzY2LVxcdTBDNkZdXCIsXG4gIHRoYWk6IFwiW1xcdTBFNTAtXFx1MEU1OV1cIixcbiAgdGlidDogXCJbXFx1MEYyMC1cXHUwRjI5XVwiLFxuICBsYXRuOiBcIlxcXFxkXCIsXG59O1xuXG5jb25zdCBudW1iZXJpbmdTeXN0ZW1zVVRGMTYgPSB7XG4gIGFyYWI6IFsxNjMyLCAxNjQxXSxcbiAgYXJhYmV4dDogWzE3NzYsIDE3ODVdLFxuICBiYWxpOiBbNjk5MiwgNzAwMV0sXG4gIGJlbmc6IFsyNTM0LCAyNTQzXSxcbiAgZGV2YTogWzI0MDYsIDI0MTVdLFxuICBmdWxsd2lkZTogWzY1Mjk2LCA2NTMwM10sXG4gIGd1anI6IFsyNzkwLCAyNzk5XSxcbiAga2htcjogWzYxMTIsIDYxMjFdLFxuICBrbmRhOiBbMzMwMiwgMzMxMV0sXG4gIGxhb286IFszNzkyLCAzODAxXSxcbiAgbGltYjogWzY0NzAsIDY0NzldLFxuICBtbHltOiBbMzQzMCwgMzQzOV0sXG4gIG1vbmc6IFs2MTYwLCA2MTY5XSxcbiAgbXltcjogWzQxNjAsIDQxNjldLFxuICBvcnlhOiBbMjkxOCwgMjkyN10sXG4gIHRhbWxkZWM6IFszMDQ2LCAzMDU1XSxcbiAgdGVsdTogWzMxNzQsIDMxODNdLFxuICB0aGFpOiBbMzY2NCwgMzY3M10sXG4gIHRpYnQ6IFszODcyLCAzODgxXSxcbn07XG5cbmNvbnN0IGhhbmlkZWNDaGFycyA9IG51bWJlcmluZ1N5c3RlbXMuaGFuaWRlYy5yZXBsYWNlKC9bXFxbfFxcXV0vZywgXCJcIikuc3BsaXQoXCJcIik7XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZURpZ2l0cyhzdHIpIHtcbiAgbGV0IHZhbHVlID0gcGFyc2VJbnQoc3RyLCAxMCk7XG4gIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgICAgaWYgKHN0cltpXS5zZWFyY2gobnVtYmVyaW5nU3lzdGVtcy5oYW5pZGVjKSAhPT0gLTEpIHtcbiAgICAgICAgdmFsdWUgKz0gaGFuaWRlY0NoYXJzLmluZGV4T2Yoc3RyW2ldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG51bWJlcmluZ1N5c3RlbXNVVEYxNikge1xuICAgICAgICAgIGNvbnN0IFttaW4sIG1heF0gPSBudW1iZXJpbmdTeXN0ZW1zVVRGMTZba2V5XTtcbiAgICAgICAgICBpZiAoY29kZSA+PSBtaW4gJiYgY29kZSA8PSBtYXgpIHtcbiAgICAgICAgICAgIHZhbHVlICs9IGNvZGUgLSBtaW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlnaXRSZWdleCh7IG51bWJlcmluZ1N5c3RlbSB9LCBhcHBlbmQgPSBcIlwiKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKGAke251bWJlcmluZ1N5c3RlbXNbbnVtYmVyaW5nU3lzdGVtIHx8IFwibGF0blwiXX0ke2FwcGVuZH1gKTtcbn1cbiIsICJpbXBvcnQgeyBwYXJzZU1pbGxpcywgaXNVbmRlZmluZWQsIHVudHJ1bmNhdGVZZWFyLCBzaWduZWRPZmZzZXQsIGhhc093blByb3BlcnR5IH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuaW1wb3J0IEZvcm1hdHRlciBmcm9tIFwiLi9mb3JtYXR0ZXIuanNcIjtcbmltcG9ydCBGaXhlZE9mZnNldFpvbmUgZnJvbSBcIi4uL3pvbmVzL2ZpeGVkT2Zmc2V0Wm9uZS5qc1wiO1xuaW1wb3J0IElBTkFab25lIGZyb20gXCIuLi96b25lcy9JQU5BWm9uZS5qc1wiO1xuaW1wb3J0IERhdGVUaW1lIGZyb20gXCIuLi9kYXRldGltZS5qc1wiO1xuaW1wb3J0IHsgZGlnaXRSZWdleCwgcGFyc2VEaWdpdHMgfSBmcm9tIFwiLi9kaWdpdHMuanNcIjtcbmltcG9ydCB7IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yIH0gZnJvbSBcIi4uL2Vycm9ycy5qc1wiO1xuXG5jb25zdCBNSVNTSU5HX0ZUUCA9IFwibWlzc2luZyBJbnRsLkRhdGVUaW1lRm9ybWF0LmZvcm1hdFRvUGFydHMgc3VwcG9ydFwiO1xuXG5mdW5jdGlvbiBpbnRVbml0KHJlZ2V4LCBwb3N0ID0gKGkpID0+IGkpIHtcbiAgcmV0dXJuIHsgcmVnZXgsIGRlc2VyOiAoW3NdKSA9PiBwb3N0KHBhcnNlRGlnaXRzKHMpKSB9O1xufVxuXG5jb25zdCBOQlNQID0gU3RyaW5nLmZyb21DaGFyQ29kZSgxNjApO1xuY29uc3Qgc3BhY2VPck5CU1AgPSBgWyAke05CU1B9XWA7XG5jb25zdCBzcGFjZU9yTkJTUFJlZ0V4cCA9IG5ldyBSZWdFeHAoc3BhY2VPck5CU1AsIFwiZ1wiKTtcblxuZnVuY3Rpb24gZml4TGlzdFJlZ2V4KHMpIHtcbiAgLy8gbWFrZSBkb3RzIG9wdGlvbmFsIGFuZCBhbHNvIG1ha2UgdGhlbSBsaXRlcmFsXG4gIC8vIG1ha2Ugc3BhY2UgYW5kIG5vbiBicmVha2FibGUgc3BhY2UgY2hhcmFjdGVycyBpbnRlcmNoYW5nZWFibGVcbiAgcmV0dXJuIHMucmVwbGFjZSgvXFwuL2csIFwiXFxcXC4/XCIpLnJlcGxhY2Uoc3BhY2VPck5CU1BSZWdFeHAsIHNwYWNlT3JOQlNQKTtcbn1cblxuZnVuY3Rpb24gc3RyaXBJbnNlbnNpdGl2aXRpZXMocykge1xuICByZXR1cm4gc1xuICAgIC5yZXBsYWNlKC9cXC4vZywgXCJcIikgLy8gaWdub3JlIGRvdHMgdGhhdCB3ZXJlIG1hZGUgb3B0aW9uYWxcbiAgICAucmVwbGFjZShzcGFjZU9yTkJTUFJlZ0V4cCwgXCIgXCIpIC8vIGludGVyY2hhbmdlIHNwYWNlIGFuZCBuYnNwXG4gICAgLnRvTG93ZXJDYXNlKCk7XG59XG5cbmZ1bmN0aW9uIG9uZU9mKHN0cmluZ3MsIHN0YXJ0SW5kZXgpIHtcbiAgaWYgKHN0cmluZ3MgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVnZXg6IFJlZ0V4cChzdHJpbmdzLm1hcChmaXhMaXN0UmVnZXgpLmpvaW4oXCJ8XCIpKSxcbiAgICAgIGRlc2VyOiAoW3NdKSA9PlxuICAgICAgICBzdHJpbmdzLmZpbmRJbmRleCgoaSkgPT4gc3RyaXBJbnNlbnNpdGl2aXRpZXMocykgPT09IHN0cmlwSW5zZW5zaXRpdml0aWVzKGkpKSArIHN0YXJ0SW5kZXgsXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvZmZzZXQocmVnZXgsIGdyb3Vwcykge1xuICByZXR1cm4geyByZWdleCwgZGVzZXI6IChbLCBoLCBtXSkgPT4gc2lnbmVkT2Zmc2V0KGgsIG0pLCBncm91cHMgfTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlKHJlZ2V4KSB7XG4gIHJldHVybiB7IHJlZ2V4LCBkZXNlcjogKFtzXSkgPT4gcyB9O1xufVxuXG5mdW5jdGlvbiBlc2NhcGVUb2tlbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUucmVwbGFjZSgvW1xcLVxcW1xcXXt9KCkqKz8uLFxcXFxcXF4kfCNcXHNdL2csIFwiXFxcXCQmXCIpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB0b2tlblxuICogQHBhcmFtIHtMb2NhbGV9IGxvY1xuICovXG5mdW5jdGlvbiB1bml0Rm9yVG9rZW4odG9rZW4sIGxvYykge1xuICBjb25zdCBvbmUgPSBkaWdpdFJlZ2V4KGxvYyksXG4gICAgdHdvID0gZGlnaXRSZWdleChsb2MsIFwiezJ9XCIpLFxuICAgIHRocmVlID0gZGlnaXRSZWdleChsb2MsIFwiezN9XCIpLFxuICAgIGZvdXIgPSBkaWdpdFJlZ2V4KGxvYywgXCJ7NH1cIiksXG4gICAgc2l4ID0gZGlnaXRSZWdleChsb2MsIFwiezZ9XCIpLFxuICAgIG9uZU9yVHdvID0gZGlnaXRSZWdleChsb2MsIFwiezEsMn1cIiksXG4gICAgb25lVG9UaHJlZSA9IGRpZ2l0UmVnZXgobG9jLCBcInsxLDN9XCIpLFxuICAgIG9uZVRvU2l4ID0gZGlnaXRSZWdleChsb2MsIFwiezEsNn1cIiksXG4gICAgb25lVG9OaW5lID0gZGlnaXRSZWdleChsb2MsIFwiezEsOX1cIiksXG4gICAgdHdvVG9Gb3VyID0gZGlnaXRSZWdleChsb2MsIFwiezIsNH1cIiksXG4gICAgZm91clRvU2l4ID0gZGlnaXRSZWdleChsb2MsIFwiezQsNn1cIiksXG4gICAgbGl0ZXJhbCA9ICh0KSA9PiAoeyByZWdleDogUmVnRXhwKGVzY2FwZVRva2VuKHQudmFsKSksIGRlc2VyOiAoW3NdKSA9PiBzLCBsaXRlcmFsOiB0cnVlIH0pLFxuICAgIHVuaXRhdGUgPSAodCkgPT4ge1xuICAgICAgaWYgKHRva2VuLmxpdGVyYWwpIHtcbiAgICAgICAgcmV0dXJuIGxpdGVyYWwodCk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHQudmFsKSB7XG4gICAgICAgIC8vIGVyYVxuICAgICAgICBjYXNlIFwiR1wiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MuZXJhcyhcInNob3J0XCIpLCAwKTtcbiAgICAgICAgY2FzZSBcIkdHXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5lcmFzKFwibG9uZ1wiKSwgMCk7XG4gICAgICAgIC8vIHllYXJzXG4gICAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lVG9TaXgpO1xuICAgICAgICBjYXNlIFwieXlcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d29Ub0ZvdXIsIHVudHJ1bmNhdGVZZWFyKTtcbiAgICAgICAgY2FzZSBcInl5eXlcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChmb3VyKTtcbiAgICAgICAgY2FzZSBcInl5eXl5XCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQoZm91clRvU2l4KTtcbiAgICAgICAgY2FzZSBcInl5eXl5eVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHNpeCk7XG4gICAgICAgIC8vIG1vbnRoc1xuICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcIk1NXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcIk1NTVwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MubW9udGhzKFwic2hvcnRcIiwgdHJ1ZSksIDEpO1xuICAgICAgICBjYXNlIFwiTU1NTVwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MubW9udGhzKFwibG9uZ1wiLCB0cnVlKSwgMSk7XG4gICAgICAgIGNhc2UgXCJMXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwiTExcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICBjYXNlIFwiTExMXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5tb250aHMoXCJzaG9ydFwiLCBmYWxzZSksIDEpO1xuICAgICAgICBjYXNlIFwiTExMTFwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MubW9udGhzKFwibG9uZ1wiLCBmYWxzZSksIDEpO1xuICAgICAgICAvLyBkYXRlc1xuICAgICAgICBjYXNlIFwiZFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcImRkXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgLy8gb3JkaW5hbHNcbiAgICAgICAgY2FzZSBcIm9cIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVUb1RocmVlKTtcbiAgICAgICAgY2FzZSBcIm9vb1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHRocmVlKTtcbiAgICAgICAgLy8gdGltZVxuICAgICAgICBjYXNlIFwiSEhcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICBjYXNlIFwiSFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcImhoXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcImhcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJtbVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwicVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcInFxXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJzc1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lVG9UaHJlZSk7XG4gICAgICAgIGNhc2UgXCJTU1NcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0aHJlZSk7XG4gICAgICAgIGNhc2UgXCJ1XCI6XG4gICAgICAgICAgcmV0dXJuIHNpbXBsZShvbmVUb05pbmUpO1xuICAgICAgICBjYXNlIFwidXVcIjpcbiAgICAgICAgICByZXR1cm4gc2ltcGxlKG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcInV1dVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZSk7XG4gICAgICAgIC8vIG1lcmlkaWVtXG4gICAgICAgIGNhc2UgXCJhXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5tZXJpZGllbXMoKSwgMCk7XG4gICAgICAgIC8vIHdlZWtZZWFyIChrKVxuICAgICAgICBjYXNlIFwia2tra1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KGZvdXIpO1xuICAgICAgICBjYXNlIFwia2tcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d29Ub0ZvdXIsIHVudHJ1bmNhdGVZZWFyKTtcbiAgICAgICAgLy8gd2Vla051bWJlciAoVylcbiAgICAgICAgY2FzZSBcIldcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJXV1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIC8vIHdlZWtkYXlzXG4gICAgICAgIGNhc2UgXCJFXCI6XG4gICAgICAgIGNhc2UgXCJjXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lKTtcbiAgICAgICAgY2FzZSBcIkVFRVwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2Mud2Vla2RheXMoXCJzaG9ydFwiLCBmYWxzZSksIDEpO1xuICAgICAgICBjYXNlIFwiRUVFRVwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2Mud2Vla2RheXMoXCJsb25nXCIsIGZhbHNlKSwgMSk7XG4gICAgICAgIGNhc2UgXCJjY2NcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLndlZWtkYXlzKFwic2hvcnRcIiwgdHJ1ZSksIDEpO1xuICAgICAgICBjYXNlIFwiY2NjY1wiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2Mud2Vla2RheXMoXCJsb25nXCIsIHRydWUpLCAxKTtcbiAgICAgICAgLy8gb2Zmc2V0L3pvbmVcbiAgICAgICAgY2FzZSBcIlpcIjpcbiAgICAgICAgY2FzZSBcIlpaXCI6XG4gICAgICAgICAgcmV0dXJuIG9mZnNldChuZXcgUmVnRXhwKGAoWystXSR7b25lT3JUd28uc291cmNlfSkoPzo6KCR7dHdvLnNvdXJjZX0pKT9gKSwgMik7XG4gICAgICAgIGNhc2UgXCJaWlpcIjpcbiAgICAgICAgICByZXR1cm4gb2Zmc2V0KG5ldyBSZWdFeHAoYChbKy1dJHtvbmVPclR3by5zb3VyY2V9KSgke3R3by5zb3VyY2V9KT9gKSwgMik7XG4gICAgICAgIC8vIHdlIGRvbid0IHN1cHBvcnQgWlpaWiAoUFNUKSBvciBaWlpaWiAoUGFjaWZpYyBTdGFuZGFyZCBUaW1lKSBpbiBwYXJzaW5nXG4gICAgICAgIC8vIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBhbnkgd2F5IHRvIGZpZ3VyZSBvdXQgd2hhdCB0aGV5IGFyZVxuICAgICAgICBjYXNlIFwielwiOlxuICAgICAgICAgIHJldHVybiBzaW1wbGUoL1thLXpfKy0vXXsxLDI1Nn0/L2kpO1xuICAgICAgICAvLyB0aGlzIHNwZWNpYWwtY2FzZSBcInRva2VuXCIgcmVwcmVzZW50cyBhIHBsYWNlIHdoZXJlIGEgbWFjcm8tdG9rZW4gZXhwYW5kZWQgaW50byBhIHdoaXRlLXNwYWNlIGxpdGVyYWxcbiAgICAgICAgLy8gaW4gdGhpcyBjYXNlIHdlIGFjY2VwdCBhbnkgbm9uLW5ld2xpbmUgd2hpdGUtc3BhY2VcbiAgICAgICAgY2FzZSBcIiBcIjpcbiAgICAgICAgICByZXR1cm4gc2ltcGxlKC9bXlxcU1xcblxccl0vKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbGl0ZXJhbCh0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIGNvbnN0IHVuaXQgPSB1bml0YXRlKHRva2VuKSB8fCB7XG4gICAgaW52YWxpZFJlYXNvbjogTUlTU0lOR19GVFAsXG4gIH07XG5cbiAgdW5pdC50b2tlbiA9IHRva2VuO1xuXG4gIHJldHVybiB1bml0O1xufVxuXG5jb25zdCBwYXJ0VHlwZVN0eWxlVG9Ub2tlblZhbCA9IHtcbiAgeWVhcjoge1xuICAgIFwiMi1kaWdpdFwiOiBcInl5XCIsXG4gICAgbnVtZXJpYzogXCJ5eXl5eVwiLFxuICB9LFxuICBtb250aDoge1xuICAgIG51bWVyaWM6IFwiTVwiLFxuICAgIFwiMi1kaWdpdFwiOiBcIk1NXCIsXG4gICAgc2hvcnQ6IFwiTU1NXCIsXG4gICAgbG9uZzogXCJNTU1NXCIsXG4gIH0sXG4gIGRheToge1xuICAgIG51bWVyaWM6IFwiZFwiLFxuICAgIFwiMi1kaWdpdFwiOiBcImRkXCIsXG4gIH0sXG4gIHdlZWtkYXk6IHtcbiAgICBzaG9ydDogXCJFRUVcIixcbiAgICBsb25nOiBcIkVFRUVcIixcbiAgfSxcbiAgZGF5cGVyaW9kOiBcImFcIixcbiAgZGF5UGVyaW9kOiBcImFcIixcbiAgaG91cjEyOiB7XG4gICAgbnVtZXJpYzogXCJoXCIsXG4gICAgXCIyLWRpZ2l0XCI6IFwiaGhcIixcbiAgfSxcbiAgaG91cjI0OiB7XG4gICAgbnVtZXJpYzogXCJIXCIsXG4gICAgXCIyLWRpZ2l0XCI6IFwiSEhcIixcbiAgfSxcbiAgbWludXRlOiB7XG4gICAgbnVtZXJpYzogXCJtXCIsXG4gICAgXCIyLWRpZ2l0XCI6IFwibW1cIixcbiAgfSxcbiAgc2Vjb25kOiB7XG4gICAgbnVtZXJpYzogXCJzXCIsXG4gICAgXCIyLWRpZ2l0XCI6IFwic3NcIixcbiAgfSxcbiAgdGltZVpvbmVOYW1lOiB7XG4gICAgbG9uZzogXCJaWlpaWlwiLFxuICAgIHNob3J0OiBcIlpaWlwiLFxuICB9LFxufTtcblxuZnVuY3Rpb24gdG9rZW5Gb3JQYXJ0KHBhcnQsIGZvcm1hdE9wdHMsIHJlc29sdmVkT3B0cykge1xuICBjb25zdCB7IHR5cGUsIHZhbHVlIH0gPSBwYXJ0O1xuXG4gIGlmICh0eXBlID09PSBcImxpdGVyYWxcIikge1xuICAgIGNvbnN0IGlzU3BhY2UgPSAvXlxccyskLy50ZXN0KHZhbHVlKTtcbiAgICByZXR1cm4ge1xuICAgICAgbGl0ZXJhbDogIWlzU3BhY2UsXG4gICAgICB2YWw6IGlzU3BhY2UgPyBcIiBcIiA6IHZhbHVlLFxuICAgIH07XG4gIH1cblxuICBjb25zdCBzdHlsZSA9IGZvcm1hdE9wdHNbdHlwZV07XG5cbiAgLy8gVGhlIHVzZXIgbWlnaHQgaGF2ZSBleHBsaWNpdGx5IHNwZWNpZmllZCBob3VyMTIgb3IgaG91ckN5Y2xlXG4gIC8vIGlmIHNvLCByZXNwZWN0IHRoZWlyIGRlY2lzaW9uXG4gIC8vIGlmIG5vdCwgcmVmZXIgYmFjayB0byB0aGUgcmVzb2x2ZWRPcHRzLCB3aGljaCBhcmUgYmFzZWQgb24gdGhlIGxvY2FsZVxuICBsZXQgYWN0dWFsVHlwZSA9IHR5cGU7XG4gIGlmICh0eXBlID09PSBcImhvdXJcIikge1xuICAgIGlmIChmb3JtYXRPcHRzLmhvdXIxMiAhPSBudWxsKSB7XG4gICAgICBhY3R1YWxUeXBlID0gZm9ybWF0T3B0cy5ob3VyMTIgPyBcImhvdXIxMlwiIDogXCJob3VyMjRcIjtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdE9wdHMuaG91ckN5Y2xlICE9IG51bGwpIHtcbiAgICAgIGlmIChmb3JtYXRPcHRzLmhvdXJDeWNsZSA9PT0gXCJoMTFcIiB8fCBmb3JtYXRPcHRzLmhvdXJDeWNsZSA9PT0gXCJoMTJcIikge1xuICAgICAgICBhY3R1YWxUeXBlID0gXCJob3VyMTJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdHVhbFR5cGUgPSBcImhvdXIyNFwiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0b2tlbnMgb25seSBkaWZmZXJlbnRpYXRlIGJldHdlZW4gMjQgaG91cnMgb3Igbm90LFxuICAgICAgLy8gc28gd2UgZG8gbm90IG5lZWQgdG8gY2hlY2sgaG91ckN5Y2xlIGhlcmUsIHdoaWNoIGlzIGxlc3Mgc3VwcG9ydGVkIGFueXdheXNcbiAgICAgIGFjdHVhbFR5cGUgPSByZXNvbHZlZE9wdHMuaG91cjEyID8gXCJob3VyMTJcIiA6IFwiaG91cjI0XCI7XG4gICAgfVxuICB9XG4gIGxldCB2YWwgPSBwYXJ0VHlwZVN0eWxlVG9Ub2tlblZhbFthY3R1YWxUeXBlXTtcbiAgaWYgKHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIpIHtcbiAgICB2YWwgPSB2YWxbc3R5bGVdO1xuICB9XG5cbiAgaWYgKHZhbCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaXRlcmFsOiBmYWxzZSxcbiAgICAgIHZhbCxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gYnVpbGRSZWdleCh1bml0cykge1xuICBjb25zdCByZSA9IHVuaXRzLm1hcCgodSkgPT4gdS5yZWdleCkucmVkdWNlKChmLCByKSA9PiBgJHtmfSgke3Iuc291cmNlfSlgLCBcIlwiKTtcbiAgcmV0dXJuIFtgXiR7cmV9JGAsIHVuaXRzXTtcbn1cblxuZnVuY3Rpb24gbWF0Y2goaW5wdXQsIHJlZ2V4LCBoYW5kbGVycykge1xuICBjb25zdCBtYXRjaGVzID0gaW5wdXQubWF0Y2gocmVnZXgpO1xuXG4gIGlmIChtYXRjaGVzKSB7XG4gICAgY29uc3QgYWxsID0ge307XG4gICAgbGV0IG1hdGNoSW5kZXggPSAxO1xuICAgIGZvciAoY29uc3QgaSBpbiBoYW5kbGVycykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5KGhhbmRsZXJzLCBpKSkge1xuICAgICAgICBjb25zdCBoID0gaGFuZGxlcnNbaV0sXG4gICAgICAgICAgZ3JvdXBzID0gaC5ncm91cHMgPyBoLmdyb3VwcyArIDEgOiAxO1xuICAgICAgICBpZiAoIWgubGl0ZXJhbCAmJiBoLnRva2VuKSB7XG4gICAgICAgICAgYWxsW2gudG9rZW4udmFsWzBdXSA9IGguZGVzZXIobWF0Y2hlcy5zbGljZShtYXRjaEluZGV4LCBtYXRjaEluZGV4ICsgZ3JvdXBzKSk7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2hJbmRleCArPSBncm91cHM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbbWF0Y2hlcywgYWxsXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW21hdGNoZXMsIHt9XTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkYXRlVGltZUZyb21NYXRjaGVzKG1hdGNoZXMpIHtcbiAgY29uc3QgdG9GaWVsZCA9ICh0b2tlbikgPT4ge1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgIHJldHVybiBcIm1pbGxpc2Vjb25kXCI7XG4gICAgICBjYXNlIFwic1wiOlxuICAgICAgICByZXR1cm4gXCJzZWNvbmRcIjtcbiAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgIHJldHVybiBcIm1pbnV0ZVwiO1xuICAgICAgY2FzZSBcImhcIjpcbiAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgIHJldHVybiBcImhvdXJcIjtcbiAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgIHJldHVybiBcImRheVwiO1xuICAgICAgY2FzZSBcIm9cIjpcbiAgICAgICAgcmV0dXJuIFwib3JkaW5hbFwiO1xuICAgICAgY2FzZSBcIkxcIjpcbiAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgIHJldHVybiBcIm1vbnRoXCI7XG4gICAgICBjYXNlIFwieVwiOlxuICAgICAgICByZXR1cm4gXCJ5ZWFyXCI7XG4gICAgICBjYXNlIFwiRVwiOlxuICAgICAgY2FzZSBcImNcIjpcbiAgICAgICAgcmV0dXJuIFwid2Vla2RheVwiO1xuICAgICAgY2FzZSBcIldcIjpcbiAgICAgICAgcmV0dXJuIFwid2Vla051bWJlclwiO1xuICAgICAgY2FzZSBcImtcIjpcbiAgICAgICAgcmV0dXJuIFwid2Vla1llYXJcIjtcbiAgICAgIGNhc2UgXCJxXCI6XG4gICAgICAgIHJldHVybiBcInF1YXJ0ZXJcIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICBsZXQgem9uZSA9IG51bGw7XG4gIGxldCBzcGVjaWZpY09mZnNldDtcbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLnopKSB7XG4gICAgem9uZSA9IElBTkFab25lLmNyZWF0ZShtYXRjaGVzLnopO1xuICB9XG5cbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLlopKSB7XG4gICAgaWYgKCF6b25lKSB7XG4gICAgICB6b25lID0gbmV3IEZpeGVkT2Zmc2V0Wm9uZShtYXRjaGVzLlopO1xuICAgIH1cbiAgICBzcGVjaWZpY09mZnNldCA9IG1hdGNoZXMuWjtcbiAgfVxuXG4gIGlmICghaXNVbmRlZmluZWQobWF0Y2hlcy5xKSkge1xuICAgIG1hdGNoZXMuTSA9IChtYXRjaGVzLnEgLSAxKSAqIDMgKyAxO1xuICB9XG5cbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLmgpKSB7XG4gICAgaWYgKG1hdGNoZXMuaCA8IDEyICYmIG1hdGNoZXMuYSA9PT0gMSkge1xuICAgICAgbWF0Y2hlcy5oICs9IDEyO1xuICAgIH0gZWxzZSBpZiAobWF0Y2hlcy5oID09PSAxMiAmJiBtYXRjaGVzLmEgPT09IDApIHtcbiAgICAgIG1hdGNoZXMuaCA9IDA7XG4gICAgfVxuICB9XG5cbiAgaWYgKG1hdGNoZXMuRyA9PT0gMCAmJiBtYXRjaGVzLnkpIHtcbiAgICBtYXRjaGVzLnkgPSAtbWF0Y2hlcy55O1xuICB9XG5cbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLnUpKSB7XG4gICAgbWF0Y2hlcy5TID0gcGFyc2VNaWxsaXMobWF0Y2hlcy51KTtcbiAgfVxuXG4gIGNvbnN0IHZhbHMgPSBPYmplY3Qua2V5cyhtYXRjaGVzKS5yZWR1Y2UoKHIsIGspID0+IHtcbiAgICBjb25zdCBmID0gdG9GaWVsZChrKTtcbiAgICBpZiAoZikge1xuICAgICAgcltmXSA9IG1hdGNoZXNba107XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH0sIHt9KTtcblxuICByZXR1cm4gW3ZhbHMsIHpvbmUsIHNwZWNpZmljT2Zmc2V0XTtcbn1cblxubGV0IGR1bW15RGF0ZVRpbWVDYWNoZSA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldER1bW15RGF0ZVRpbWUoKSB7XG4gIGlmICghZHVtbXlEYXRlVGltZUNhY2hlKSB7XG4gICAgZHVtbXlEYXRlVGltZUNhY2hlID0gRGF0ZVRpbWUuZnJvbU1pbGxpcygxNTU1NTU1NTU1NTU1KTtcbiAgfVxuXG4gIHJldHVybiBkdW1teURhdGVUaW1lQ2FjaGU7XG59XG5cbmZ1bmN0aW9uIG1heWJlRXhwYW5kTWFjcm9Ub2tlbih0b2tlbiwgbG9jYWxlKSB7XG4gIGlmICh0b2tlbi5saXRlcmFsKSB7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG5cbiAgY29uc3QgZm9ybWF0T3B0cyA9IEZvcm1hdHRlci5tYWNyb1Rva2VuVG9Gb3JtYXRPcHRzKHRva2VuLnZhbCk7XG4gIGNvbnN0IHRva2VucyA9IGZvcm1hdE9wdHNUb1Rva2Vucyhmb3JtYXRPcHRzLCBsb2NhbGUpO1xuXG4gIGlmICh0b2tlbnMgPT0gbnVsbCB8fCB0b2tlbnMuaW5jbHVkZXModW5kZWZpbmVkKSkge1xuICAgIHJldHVybiB0b2tlbjtcbiAgfVxuXG4gIHJldHVybiB0b2tlbnM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRNYWNyb1Rva2Vucyh0b2tlbnMsIGxvY2FsZSkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdCguLi50b2tlbnMubWFwKCh0KSA9PiBtYXliZUV4cGFuZE1hY3JvVG9rZW4odCwgbG9jYWxlKSkpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cGxhaW5Gcm9tVG9rZW5zKGxvY2FsZSwgaW5wdXQsIGZvcm1hdCkge1xuICBjb25zdCB0b2tlbnMgPSBleHBhbmRNYWNyb1Rva2VucyhGb3JtYXR0ZXIucGFyc2VGb3JtYXQoZm9ybWF0KSwgbG9jYWxlKSxcbiAgICB1bml0cyA9IHRva2Vucy5tYXAoKHQpID0+IHVuaXRGb3JUb2tlbih0LCBsb2NhbGUpKSxcbiAgICBkaXNxdWFsaWZ5aW5nVW5pdCA9IHVuaXRzLmZpbmQoKHQpID0+IHQuaW52YWxpZFJlYXNvbik7XG5cbiAgaWYgKGRpc3F1YWxpZnlpbmdVbml0KSB7XG4gICAgcmV0dXJuIHsgaW5wdXQsIHRva2VucywgaW52YWxpZFJlYXNvbjogZGlzcXVhbGlmeWluZ1VuaXQuaW52YWxpZFJlYXNvbiB9O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IFtyZWdleFN0cmluZywgaGFuZGxlcnNdID0gYnVpbGRSZWdleCh1bml0cyksXG4gICAgICByZWdleCA9IFJlZ0V4cChyZWdleFN0cmluZywgXCJpXCIpLFxuICAgICAgW3Jhd01hdGNoZXMsIG1hdGNoZXNdID0gbWF0Y2goaW5wdXQsIHJlZ2V4LCBoYW5kbGVycyksXG4gICAgICBbcmVzdWx0LCB6b25lLCBzcGVjaWZpY09mZnNldF0gPSBtYXRjaGVzXG4gICAgICAgID8gZGF0ZVRpbWVGcm9tTWF0Y2hlcyhtYXRjaGVzKVxuICAgICAgICA6IFtudWxsLCBudWxsLCB1bmRlZmluZWRdO1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eShtYXRjaGVzLCBcImFcIikgJiYgaGFzT3duUHJvcGVydHkobWF0Y2hlcywgXCJIXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IoXG4gICAgICAgIFwiQ2FuJ3QgaW5jbHVkZSBtZXJpZGllbSB3aGVuIHNwZWNpZnlpbmcgMjQtaG91ciBmb3JtYXRcIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgaW5wdXQsIHRva2VucywgcmVnZXgsIHJhd01hdGNoZXMsIG1hdGNoZXMsIHJlc3VsdCwgem9uZSwgc3BlY2lmaWNPZmZzZXQgfTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VGcm9tVG9rZW5zKGxvY2FsZSwgaW5wdXQsIGZvcm1hdCkge1xuICBjb25zdCB7IHJlc3VsdCwgem9uZSwgc3BlY2lmaWNPZmZzZXQsIGludmFsaWRSZWFzb24gfSA9IGV4cGxhaW5Gcm9tVG9rZW5zKGxvY2FsZSwgaW5wdXQsIGZvcm1hdCk7XG4gIHJldHVybiBbcmVzdWx0LCB6b25lLCBzcGVjaWZpY09mZnNldCwgaW52YWxpZFJlYXNvbl07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRPcHRzVG9Ub2tlbnMoZm9ybWF0T3B0cywgbG9jYWxlKSB7XG4gIGlmICghZm9ybWF0T3B0cykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgZm9ybWF0dGVyID0gRm9ybWF0dGVyLmNyZWF0ZShsb2NhbGUsIGZvcm1hdE9wdHMpO1xuICBjb25zdCBkZiA9IGZvcm1hdHRlci5kdEZvcm1hdHRlcihnZXREdW1teURhdGVUaW1lKCkpO1xuICBjb25zdCBwYXJ0cyA9IGRmLmZvcm1hdFRvUGFydHMoKTtcbiAgY29uc3QgcmVzb2x2ZWRPcHRzID0gZGYucmVzb2x2ZWRPcHRpb25zKCk7XG4gIHJldHVybiBwYXJ0cy5tYXAoKHApID0+IHRva2VuRm9yUGFydChwLCBmb3JtYXRPcHRzLCByZXNvbHZlZE9wdHMpKTtcbn1cbiIsICJpbXBvcnQgRHVyYXRpb24gZnJvbSBcIi4vZHVyYXRpb24uanNcIjtcbmltcG9ydCBJbnRlcnZhbCBmcm9tIFwiLi9pbnRlcnZhbC5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuL3NldHRpbmdzLmpzXCI7XG5pbXBvcnQgSW5mbyBmcm9tIFwiLi9pbmZvLmpzXCI7XG5pbXBvcnQgRm9ybWF0dGVyIGZyb20gXCIuL2ltcGwvZm9ybWF0dGVyLmpzXCI7XG5pbXBvcnQgRml4ZWRPZmZzZXRab25lIGZyb20gXCIuL3pvbmVzL2ZpeGVkT2Zmc2V0Wm9uZS5qc1wiO1xuaW1wb3J0IExvY2FsZSBmcm9tIFwiLi9pbXBsL2xvY2FsZS5qc1wiO1xuaW1wb3J0IHtcbiAgaXNVbmRlZmluZWQsXG4gIG1heWJlQXJyYXksXG4gIGlzRGF0ZSxcbiAgaXNOdW1iZXIsXG4gIGJlc3RCeSxcbiAgZGF5c0luTW9udGgsXG4gIGRheXNJblllYXIsXG4gIGlzTGVhcFllYXIsXG4gIHdlZWtzSW5XZWVrWWVhcixcbiAgbm9ybWFsaXplT2JqZWN0LFxuICByb3VuZFRvLFxuICBvYmpUb0xvY2FsVFMsXG4gIHBhZFN0YXJ0LFxufSBmcm9tIFwiLi9pbXBsL3V0aWwuanNcIjtcbmltcG9ydCB7IG5vcm1hbGl6ZVpvbmUgfSBmcm9tIFwiLi9pbXBsL3pvbmVVdGlsLmpzXCI7XG5pbXBvcnQgZGlmZiBmcm9tIFwiLi9pbXBsL2RpZmYuanNcIjtcbmltcG9ydCB7IHBhcnNlUkZDMjgyMkRhdGUsIHBhcnNlSVNPRGF0ZSwgcGFyc2VIVFRQRGF0ZSwgcGFyc2VTUUwgfSBmcm9tIFwiLi9pbXBsL3JlZ2V4UGFyc2VyLmpzXCI7XG5pbXBvcnQge1xuICBwYXJzZUZyb21Ub2tlbnMsXG4gIGV4cGxhaW5Gcm9tVG9rZW5zLFxuICBmb3JtYXRPcHRzVG9Ub2tlbnMsXG4gIGV4cGFuZE1hY3JvVG9rZW5zLFxufSBmcm9tIFwiLi9pbXBsL3Rva2VuUGFyc2VyLmpzXCI7XG5pbXBvcnQge1xuICBncmVnb3JpYW5Ub1dlZWssXG4gIHdlZWtUb0dyZWdvcmlhbixcbiAgZ3JlZ29yaWFuVG9PcmRpbmFsLFxuICBvcmRpbmFsVG9HcmVnb3JpYW4sXG4gIGhhc0ludmFsaWRHcmVnb3JpYW5EYXRhLFxuICBoYXNJbnZhbGlkV2Vla0RhdGEsXG4gIGhhc0ludmFsaWRPcmRpbmFsRGF0YSxcbiAgaGFzSW52YWxpZFRpbWVEYXRhLFxuICB1c2VzTG9jYWxXZWVrVmFsdWVzLFxuICBpc29XZWVrZGF5VG9Mb2NhbCxcbn0gZnJvbSBcIi4vaW1wbC9jb252ZXJzaW9ucy5qc1wiO1xuaW1wb3J0ICogYXMgRm9ybWF0cyBmcm9tIFwiLi9pbXBsL2Zvcm1hdHMuanNcIjtcbmltcG9ydCB7XG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcixcbiAgSW52YWxpZFVuaXRFcnJvcixcbiAgSW52YWxpZERhdGVUaW1lRXJyb3IsXG59IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IEludmFsaWQgZnJvbSBcIi4vaW1wbC9pbnZhbGlkLmpzXCI7XG5cbmNvbnN0IElOVkFMSUQgPSBcIkludmFsaWQgRGF0ZVRpbWVcIjtcbmNvbnN0IE1BWF9EQVRFID0gOC42NGUxNTtcblxuZnVuY3Rpb24gdW5zdXBwb3J0ZWRab25lKHpvbmUpIHtcbiAgcmV0dXJuIG5ldyBJbnZhbGlkKFwidW5zdXBwb3J0ZWQgem9uZVwiLCBgdGhlIHpvbmUgXCIke3pvbmUubmFtZX1cIiBpcyBub3Qgc3VwcG9ydGVkYCk7XG59XG5cbi8vIHdlIGNhY2hlIHdlZWsgZGF0YSBvbiB0aGUgRFQgb2JqZWN0IGFuZCB0aGlzIGludGVybWVkaWF0ZXMgdGhlIGNhY2hlXG4vKipcbiAqIEBwYXJhbSB7RGF0ZVRpbWV9IGR0XG4gKi9cbmZ1bmN0aW9uIHBvc3NpYmx5Q2FjaGVkV2Vla0RhdGEoZHQpIHtcbiAgaWYgKGR0LndlZWtEYXRhID09PSBudWxsKSB7XG4gICAgZHQud2Vla0RhdGEgPSBncmVnb3JpYW5Ub1dlZWsoZHQuYyk7XG4gIH1cbiAgcmV0dXJuIGR0LndlZWtEYXRhO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RGF0ZVRpbWV9IGR0XG4gKi9cbmZ1bmN0aW9uIHBvc3NpYmx5Q2FjaGVkTG9jYWxXZWVrRGF0YShkdCkge1xuICBpZiAoZHQubG9jYWxXZWVrRGF0YSA9PT0gbnVsbCkge1xuICAgIGR0LmxvY2FsV2Vla0RhdGEgPSBncmVnb3JpYW5Ub1dlZWsoXG4gICAgICBkdC5jLFxuICAgICAgZHQubG9jLmdldE1pbkRheXNJbkZpcnN0V2VlaygpLFxuICAgICAgZHQubG9jLmdldFN0YXJ0T2ZXZWVrKClcbiAgICApO1xuICB9XG4gIHJldHVybiBkdC5sb2NhbFdlZWtEYXRhO1xufVxuXG4vLyBjbG9uZSByZWFsbHkgbWVhbnMsIFwibWFrZSBhIG5ldyBvYmplY3Qgd2l0aCB0aGVzZSBtb2RpZmljYXRpb25zXCIuIGFsbCBcInNldHRlcnNcIiByZWFsbHkgdXNlIHRoaXNcbi8vIHRvIGNyZWF0ZSBhIG5ldyBvYmplY3Qgd2hpbGUgb25seSBjaGFuZ2luZyBzb21lIG9mIHRoZSBwcm9wZXJ0aWVzXG5mdW5jdGlvbiBjbG9uZShpbnN0LCBhbHRzKSB7XG4gIGNvbnN0IGN1cnJlbnQgPSB7XG4gICAgdHM6IGluc3QudHMsXG4gICAgem9uZTogaW5zdC56b25lLFxuICAgIGM6IGluc3QuYyxcbiAgICBvOiBpbnN0Lm8sXG4gICAgbG9jOiBpbnN0LmxvYyxcbiAgICBpbnZhbGlkOiBpbnN0LmludmFsaWQsXG4gIH07XG4gIHJldHVybiBuZXcgRGF0ZVRpbWUoeyAuLi5jdXJyZW50LCAuLi5hbHRzLCBvbGQ6IGN1cnJlbnQgfSk7XG59XG5cbi8vIGZpbmQgdGhlIHJpZ2h0IG9mZnNldCBhIGdpdmVuIGxvY2FsIHRpbWUuIFRoZSBvIGlucHV0IGlzIG91ciBndWVzcywgd2hpY2ggZGV0ZXJtaW5lcyB3aGljaFxuLy8gb2Zmc2V0IHdlJ2xsIHBpY2sgaW4gYW1iaWd1b3VzIGNhc2VzIChlLmcuIHRoZXJlIGFyZSB0d28gMyBBTXMgYi9jIEZhbGxiYWNrIERTVClcbmZ1bmN0aW9uIGZpeE9mZnNldChsb2NhbFRTLCBvLCB0eikge1xuICAvLyBPdXIgVVRDIHRpbWUgaXMganVzdCBhIGd1ZXNzIGJlY2F1c2Ugb3VyIG9mZnNldCBpcyBqdXN0IGEgZ3Vlc3NcbiAgbGV0IHV0Y0d1ZXNzID0gbG9jYWxUUyAtIG8gKiA2MCAqIDEwMDA7XG5cbiAgLy8gVGVzdCB3aGV0aGVyIHRoZSB6b25lIG1hdGNoZXMgdGhlIG9mZnNldCBmb3IgdGhpcyB0c1xuICBjb25zdCBvMiA9IHR6Lm9mZnNldCh1dGNHdWVzcyk7XG5cbiAgLy8gSWYgc28sIG9mZnNldCBkaWRuJ3QgY2hhbmdlIGFuZCB3ZSdyZSBkb25lXG4gIGlmIChvID09PSBvMikge1xuICAgIHJldHVybiBbdXRjR3Vlc3MsIG9dO1xuICB9XG5cbiAgLy8gSWYgbm90LCBjaGFuZ2UgdGhlIHRzIGJ5IHRoZSBkaWZmZXJlbmNlIGluIHRoZSBvZmZzZXRcbiAgdXRjR3Vlc3MgLT0gKG8yIC0gbykgKiA2MCAqIDEwMDA7XG5cbiAgLy8gSWYgdGhhdCBnaXZlcyB1cyB0aGUgbG9jYWwgdGltZSB3ZSB3YW50LCB3ZSdyZSBkb25lXG4gIGNvbnN0IG8zID0gdHoub2Zmc2V0KHV0Y0d1ZXNzKTtcbiAgaWYgKG8yID09PSBvMykge1xuICAgIHJldHVybiBbdXRjR3Vlc3MsIG8yXTtcbiAgfVxuXG4gIC8vIElmIGl0J3MgZGlmZmVyZW50LCB3ZSdyZSBpbiBhIGhvbGUgdGltZS4gVGhlIG9mZnNldCBoYXMgY2hhbmdlZCwgYnV0IHRoZSB3ZSBkb24ndCBhZGp1c3QgdGhlIHRpbWVcbiAgcmV0dXJuIFtsb2NhbFRTIC0gTWF0aC5taW4obzIsIG8zKSAqIDYwICogMTAwMCwgTWF0aC5tYXgobzIsIG8zKV07XG59XG5cbi8vIGNvbnZlcnQgYW4gZXBvY2ggdGltZXN0YW1wIGludG8gYSBjYWxlbmRhciBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gb2Zmc2V0XG5mdW5jdGlvbiB0c1RvT2JqKHRzLCBvZmZzZXQpIHtcbiAgdHMgKz0gb2Zmc2V0ICogNjAgKiAxMDAwO1xuXG4gIGNvbnN0IGQgPSBuZXcgRGF0ZSh0cyk7XG5cbiAgcmV0dXJuIHtcbiAgICB5ZWFyOiBkLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgbW9udGg6IGQuZ2V0VVRDTW9udGgoKSArIDEsXG4gICAgZGF5OiBkLmdldFVUQ0RhdGUoKSxcbiAgICBob3VyOiBkLmdldFVUQ0hvdXJzKCksXG4gICAgbWludXRlOiBkLmdldFVUQ01pbnV0ZXMoKSxcbiAgICBzZWNvbmQ6IGQuZ2V0VVRDU2Vjb25kcygpLFxuICAgIG1pbGxpc2Vjb25kOiBkLmdldFVUQ01pbGxpc2Vjb25kcygpLFxuICB9O1xufVxuXG4vLyBjb252ZXJ0IGEgY2FsZW5kYXIgb2JqZWN0IHRvIGEgZXBvY2ggdGltZXN0YW1wXG5mdW5jdGlvbiBvYmpUb1RTKG9iaiwgb2Zmc2V0LCB6b25lKSB7XG4gIHJldHVybiBmaXhPZmZzZXQob2JqVG9Mb2NhbFRTKG9iaiksIG9mZnNldCwgem9uZSk7XG59XG5cbi8vIGNyZWF0ZSBhIG5ldyBEVCBpbnN0YW5jZSBieSBhZGRpbmcgYSBkdXJhdGlvbiwgYWRqdXN0aW5nIGZvciBEU1RzXG5mdW5jdGlvbiBhZGp1c3RUaW1lKGluc3QsIGR1cikge1xuICBjb25zdCBvUHJlID0gaW5zdC5vLFxuICAgIHllYXIgPSBpbnN0LmMueWVhciArIE1hdGgudHJ1bmMoZHVyLnllYXJzKSxcbiAgICBtb250aCA9IGluc3QuYy5tb250aCArIE1hdGgudHJ1bmMoZHVyLm1vbnRocykgKyBNYXRoLnRydW5jKGR1ci5xdWFydGVycykgKiAzLFxuICAgIGMgPSB7XG4gICAgICAuLi5pbnN0LmMsXG4gICAgICB5ZWFyLFxuICAgICAgbW9udGgsXG4gICAgICBkYXk6XG4gICAgICAgIE1hdGgubWluKGluc3QuYy5kYXksIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSkgK1xuICAgICAgICBNYXRoLnRydW5jKGR1ci5kYXlzKSArXG4gICAgICAgIE1hdGgudHJ1bmMoZHVyLndlZWtzKSAqIDcsXG4gICAgfSxcbiAgICBtaWxsaXNUb0FkZCA9IER1cmF0aW9uLmZyb21PYmplY3Qoe1xuICAgICAgeWVhcnM6IGR1ci55ZWFycyAtIE1hdGgudHJ1bmMoZHVyLnllYXJzKSxcbiAgICAgIHF1YXJ0ZXJzOiBkdXIucXVhcnRlcnMgLSBNYXRoLnRydW5jKGR1ci5xdWFydGVycyksXG4gICAgICBtb250aHM6IGR1ci5tb250aHMgLSBNYXRoLnRydW5jKGR1ci5tb250aHMpLFxuICAgICAgd2Vla3M6IGR1ci53ZWVrcyAtIE1hdGgudHJ1bmMoZHVyLndlZWtzKSxcbiAgICAgIGRheXM6IGR1ci5kYXlzIC0gTWF0aC50cnVuYyhkdXIuZGF5cyksXG4gICAgICBob3VyczogZHVyLmhvdXJzLFxuICAgICAgbWludXRlczogZHVyLm1pbnV0ZXMsXG4gICAgICBzZWNvbmRzOiBkdXIuc2Vjb25kcyxcbiAgICAgIG1pbGxpc2Vjb25kczogZHVyLm1pbGxpc2Vjb25kcyxcbiAgICB9KS5hcyhcIm1pbGxpc2Vjb25kc1wiKSxcbiAgICBsb2NhbFRTID0gb2JqVG9Mb2NhbFRTKGMpO1xuXG4gIGxldCBbdHMsIG9dID0gZml4T2Zmc2V0KGxvY2FsVFMsIG9QcmUsIGluc3Quem9uZSk7XG5cbiAgaWYgKG1pbGxpc1RvQWRkICE9PSAwKSB7XG4gICAgdHMgKz0gbWlsbGlzVG9BZGQ7XG4gICAgLy8gdGhhdCBjb3VsZCBoYXZlIGNoYW5nZWQgdGhlIG9mZnNldCBieSBnb2luZyBvdmVyIGEgRFNULCBidXQgd2Ugd2FudCB0byBrZWVwIHRoZSB0cyB0aGUgc2FtZVxuICAgIG8gPSBpbnN0LnpvbmUub2Zmc2V0KHRzKTtcbiAgfVxuXG4gIHJldHVybiB7IHRzLCBvIH07XG59XG5cbi8vIGhlbHBlciB1c2VmdWwgaW4gdHVybmluZyB0aGUgcmVzdWx0cyBvZiBwYXJzaW5nIGludG8gcmVhbCBkYXRlc1xuLy8gYnkgaGFuZGxpbmcgdGhlIHpvbmUgb3B0aW9uc1xuZnVuY3Rpb24gcGFyc2VEYXRhVG9EYXRlVGltZShwYXJzZWQsIHBhcnNlZFpvbmUsIG9wdHMsIGZvcm1hdCwgdGV4dCwgc3BlY2lmaWNPZmZzZXQpIHtcbiAgY29uc3QgeyBzZXRab25lLCB6b25lIH0gPSBvcHRzO1xuICBpZiAoKHBhcnNlZCAmJiBPYmplY3Qua2V5cyhwYXJzZWQpLmxlbmd0aCAhPT0gMCkgfHwgcGFyc2VkWm9uZSkge1xuICAgIGNvbnN0IGludGVycHJldGF0aW9uWm9uZSA9IHBhcnNlZFpvbmUgfHwgem9uZSxcbiAgICAgIGluc3QgPSBEYXRlVGltZS5mcm9tT2JqZWN0KHBhcnNlZCwge1xuICAgICAgICAuLi5vcHRzLFxuICAgICAgICB6b25lOiBpbnRlcnByZXRhdGlvblpvbmUsXG4gICAgICAgIHNwZWNpZmljT2Zmc2V0LFxuICAgICAgfSk7XG4gICAgcmV0dXJuIHNldFpvbmUgPyBpbnN0IDogaW5zdC5zZXRab25lKHpvbmUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKFxuICAgICAgbmV3IEludmFsaWQoXCJ1bnBhcnNhYmxlXCIsIGB0aGUgaW5wdXQgXCIke3RleHR9XCIgY2FuJ3QgYmUgcGFyc2VkIGFzICR7Zm9ybWF0fWApXG4gICAgKTtcbiAgfVxufVxuXG4vLyBpZiB5b3Ugd2FudCB0byBvdXRwdXQgYSB0ZWNobmljYWwgZm9ybWF0IChlLmcuIFJGQyAyODIyKSwgdGhpcyBoZWxwZXJcbi8vIGhlbHBzIGhhbmRsZSB0aGUgZGV0YWlsc1xuZnVuY3Rpb24gdG9UZWNoRm9ybWF0KGR0LCBmb3JtYXQsIGFsbG93WiA9IHRydWUpIHtcbiAgcmV0dXJuIGR0LmlzVmFsaWRcbiAgICA/IEZvcm1hdHRlci5jcmVhdGUoTG9jYWxlLmNyZWF0ZShcImVuLVVTXCIpLCB7XG4gICAgICAgIGFsbG93WixcbiAgICAgICAgZm9yY2VTaW1wbGU6IHRydWUsXG4gICAgICB9KS5mb3JtYXREYXRlVGltZUZyb21TdHJpbmcoZHQsIGZvcm1hdClcbiAgICA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHRvSVNPRGF0ZShvLCBleHRlbmRlZCkge1xuICBjb25zdCBsb25nRm9ybWF0ID0gby5jLnllYXIgPiA5OTk5IHx8IG8uYy55ZWFyIDwgMDtcbiAgbGV0IGMgPSBcIlwiO1xuICBpZiAobG9uZ0Zvcm1hdCAmJiBvLmMueWVhciA+PSAwKSBjICs9IFwiK1wiO1xuICBjICs9IHBhZFN0YXJ0KG8uYy55ZWFyLCBsb25nRm9ybWF0ID8gNiA6IDQpO1xuXG4gIGlmIChleHRlbmRlZCkge1xuICAgIGMgKz0gXCItXCI7XG4gICAgYyArPSBwYWRTdGFydChvLmMubW9udGgpO1xuICAgIGMgKz0gXCItXCI7XG4gICAgYyArPSBwYWRTdGFydChvLmMuZGF5KTtcbiAgfSBlbHNlIHtcbiAgICBjICs9IHBhZFN0YXJ0KG8uYy5tb250aCk7XG4gICAgYyArPSBwYWRTdGFydChvLmMuZGF5KTtcbiAgfVxuICByZXR1cm4gYztcbn1cblxuZnVuY3Rpb24gdG9JU09UaW1lKFxuICBvLFxuICBleHRlbmRlZCxcbiAgc3VwcHJlc3NTZWNvbmRzLFxuICBzdXBwcmVzc01pbGxpc2Vjb25kcyxcbiAgaW5jbHVkZU9mZnNldCxcbiAgZXh0ZW5kZWRab25lXG4pIHtcbiAgbGV0IGMgPSBwYWRTdGFydChvLmMuaG91cik7XG4gIGlmIChleHRlbmRlZCkge1xuICAgIGMgKz0gXCI6XCI7XG4gICAgYyArPSBwYWRTdGFydChvLmMubWludXRlKTtcbiAgICBpZiAoby5jLm1pbGxpc2Vjb25kICE9PSAwIHx8IG8uYy5zZWNvbmQgIT09IDAgfHwgIXN1cHByZXNzU2Vjb25kcykge1xuICAgICAgYyArPSBcIjpcIjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYyArPSBwYWRTdGFydChvLmMubWludXRlKTtcbiAgfVxuXG4gIGlmIChvLmMubWlsbGlzZWNvbmQgIT09IDAgfHwgby5jLnNlY29uZCAhPT0gMCB8fCAhc3VwcHJlc3NTZWNvbmRzKSB7XG4gICAgYyArPSBwYWRTdGFydChvLmMuc2Vjb25kKTtcblxuICAgIGlmIChvLmMubWlsbGlzZWNvbmQgIT09IDAgfHwgIXN1cHByZXNzTWlsbGlzZWNvbmRzKSB7XG4gICAgICBjICs9IFwiLlwiO1xuICAgICAgYyArPSBwYWRTdGFydChvLmMubWlsbGlzZWNvbmQsIDMpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpbmNsdWRlT2Zmc2V0KSB7XG4gICAgaWYgKG8uaXNPZmZzZXRGaXhlZCAmJiBvLm9mZnNldCA9PT0gMCAmJiAhZXh0ZW5kZWRab25lKSB7XG4gICAgICBjICs9IFwiWlwiO1xuICAgIH0gZWxzZSBpZiAoby5vIDwgMCkge1xuICAgICAgYyArPSBcIi1cIjtcbiAgICAgIGMgKz0gcGFkU3RhcnQoTWF0aC50cnVuYygtby5vIC8gNjApKTtcbiAgICAgIGMgKz0gXCI6XCI7XG4gICAgICBjICs9IHBhZFN0YXJ0KE1hdGgudHJ1bmMoLW8ubyAlIDYwKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGMgKz0gXCIrXCI7XG4gICAgICBjICs9IHBhZFN0YXJ0KE1hdGgudHJ1bmMoby5vIC8gNjApKTtcbiAgICAgIGMgKz0gXCI6XCI7XG4gICAgICBjICs9IHBhZFN0YXJ0KE1hdGgudHJ1bmMoby5vICUgNjApKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZXh0ZW5kZWRab25lKSB7XG4gICAgYyArPSBcIltcIiArIG8uem9uZS5pYW5hTmFtZSArIFwiXVwiO1xuICB9XG4gIHJldHVybiBjO1xufVxuXG4vLyBkZWZhdWx0cyBmb3IgdW5zcGVjaWZpZWQgdW5pdHMgaW4gdGhlIHN1cHBvcnRlZCBjYWxlbmRhcnNcbmNvbnN0IGRlZmF1bHRVbml0VmFsdWVzID0ge1xuICAgIG1vbnRoOiAxLFxuICAgIGRheTogMSxcbiAgICBob3VyOiAwLFxuICAgIG1pbnV0ZTogMCxcbiAgICBzZWNvbmQ6IDAsXG4gICAgbWlsbGlzZWNvbmQ6IDAsXG4gIH0sXG4gIGRlZmF1bHRXZWVrVW5pdFZhbHVlcyA9IHtcbiAgICB3ZWVrTnVtYmVyOiAxLFxuICAgIHdlZWtkYXk6IDEsXG4gICAgaG91cjogMCxcbiAgICBtaW51dGU6IDAsXG4gICAgc2Vjb25kOiAwLFxuICAgIG1pbGxpc2Vjb25kOiAwLFxuICB9LFxuICBkZWZhdWx0T3JkaW5hbFVuaXRWYWx1ZXMgPSB7XG4gICAgb3JkaW5hbDogMSxcbiAgICBob3VyOiAwLFxuICAgIG1pbnV0ZTogMCxcbiAgICBzZWNvbmQ6IDAsXG4gICAgbWlsbGlzZWNvbmQ6IDAsXG4gIH07XG5cbi8vIFVuaXRzIGluIHRoZSBzdXBwb3J0ZWQgY2FsZW5kYXJzLCBzb3J0ZWQgYnkgYmlnbmVzc1xuY29uc3Qgb3JkZXJlZFVuaXRzID0gW1wieWVhclwiLCBcIm1vbnRoXCIsIFwiZGF5XCIsIFwiaG91clwiLCBcIm1pbnV0ZVwiLCBcInNlY29uZFwiLCBcIm1pbGxpc2Vjb25kXCJdLFxuICBvcmRlcmVkV2Vla1VuaXRzID0gW1xuICAgIFwid2Vla1llYXJcIixcbiAgICBcIndlZWtOdW1iZXJcIixcbiAgICBcIndlZWtkYXlcIixcbiAgICBcImhvdXJcIixcbiAgICBcIm1pbnV0ZVwiLFxuICAgIFwic2Vjb25kXCIsXG4gICAgXCJtaWxsaXNlY29uZFwiLFxuICBdLFxuICBvcmRlcmVkT3JkaW5hbFVuaXRzID0gW1wieWVhclwiLCBcIm9yZGluYWxcIiwgXCJob3VyXCIsIFwibWludXRlXCIsIFwic2Vjb25kXCIsIFwibWlsbGlzZWNvbmRcIl07XG5cbi8vIHN0YW5kYXJkaXplIGNhc2UgYW5kIHBsdXJhbGl0eSBpbiB1bml0c1xuZnVuY3Rpb24gbm9ybWFsaXplVW5pdCh1bml0KSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSB7XG4gICAgeWVhcjogXCJ5ZWFyXCIsXG4gICAgeWVhcnM6IFwieWVhclwiLFxuICAgIG1vbnRoOiBcIm1vbnRoXCIsXG4gICAgbW9udGhzOiBcIm1vbnRoXCIsXG4gICAgZGF5OiBcImRheVwiLFxuICAgIGRheXM6IFwiZGF5XCIsXG4gICAgaG91cjogXCJob3VyXCIsXG4gICAgaG91cnM6IFwiaG91clwiLFxuICAgIG1pbnV0ZTogXCJtaW51dGVcIixcbiAgICBtaW51dGVzOiBcIm1pbnV0ZVwiLFxuICAgIHF1YXJ0ZXI6IFwicXVhcnRlclwiLFxuICAgIHF1YXJ0ZXJzOiBcInF1YXJ0ZXJcIixcbiAgICBzZWNvbmQ6IFwic2Vjb25kXCIsXG4gICAgc2Vjb25kczogXCJzZWNvbmRcIixcbiAgICBtaWxsaXNlY29uZDogXCJtaWxsaXNlY29uZFwiLFxuICAgIG1pbGxpc2Vjb25kczogXCJtaWxsaXNlY29uZFwiLFxuICAgIHdlZWtkYXk6IFwid2Vla2RheVwiLFxuICAgIHdlZWtkYXlzOiBcIndlZWtkYXlcIixcbiAgICB3ZWVrbnVtYmVyOiBcIndlZWtOdW1iZXJcIixcbiAgICB3ZWVrc251bWJlcjogXCJ3ZWVrTnVtYmVyXCIsXG4gICAgd2Vla251bWJlcnM6IFwid2Vla051bWJlclwiLFxuICAgIHdlZWt5ZWFyOiBcIndlZWtZZWFyXCIsXG4gICAgd2Vla3llYXJzOiBcIndlZWtZZWFyXCIsXG4gICAgb3JkaW5hbDogXCJvcmRpbmFsXCIsXG4gIH1bdW5pdC50b0xvd2VyQ2FzZSgpXTtcblxuICBpZiAoIW5vcm1hbGl6ZWQpIHRocm93IG5ldyBJbnZhbGlkVW5pdEVycm9yKHVuaXQpO1xuXG4gIHJldHVybiBub3JtYWxpemVkO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVVbml0V2l0aExvY2FsV2Vla3ModW5pdCkge1xuICBzd2l0Y2ggKHVuaXQudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgXCJsb2NhbHdlZWtkYXlcIjpcbiAgICBjYXNlIFwibG9jYWx3ZWVrZGF5c1wiOlxuICAgICAgcmV0dXJuIFwibG9jYWxXZWVrZGF5XCI7XG4gICAgY2FzZSBcImxvY2Fsd2Vla251bWJlclwiOlxuICAgIGNhc2UgXCJsb2NhbHdlZWtudW1iZXJzXCI6XG4gICAgICByZXR1cm4gXCJsb2NhbFdlZWtOdW1iZXJcIjtcbiAgICBjYXNlIFwibG9jYWx3ZWVreWVhclwiOlxuICAgIGNhc2UgXCJsb2NhbHdlZWt5ZWFyc1wiOlxuICAgICAgcmV0dXJuIFwibG9jYWxXZWVrWWVhclwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbm9ybWFsaXplVW5pdCh1bml0KTtcbiAgfVxufVxuXG4vLyB0aGlzIGlzIGEgZHVtYmVkIGRvd24gdmVyc2lvbiBvZiBmcm9tT2JqZWN0KCkgdGhhdCBydW5zIGFib3V0IDYwJSBmYXN0ZXJcbi8vIGJ1dCBkb2Vzbid0IGRvIGFueSB2YWxpZGF0aW9uLCBtYWtlcyBhIGJ1bmNoIG9mIGFzc3VtcHRpb25zIGFib3V0IHdoYXQgdW5pdHNcbi8vIGFyZSBwcmVzZW50LCBhbmQgc28gb24uXG5mdW5jdGlvbiBxdWlja0RUKG9iaiwgb3B0cykge1xuICBjb25zdCB6b25lID0gbm9ybWFsaXplWm9uZShvcHRzLnpvbmUsIFNldHRpbmdzLmRlZmF1bHRab25lKSxcbiAgICBsb2MgPSBMb2NhbGUuZnJvbU9iamVjdChvcHRzKSxcbiAgICB0c05vdyA9IFNldHRpbmdzLm5vdygpO1xuXG4gIGxldCB0cywgbztcblxuICAvLyBhc3N1bWUgd2UgaGF2ZSB0aGUgaGlnaGVyLW9yZGVyIHVuaXRzXG4gIGlmICghaXNVbmRlZmluZWQob2JqLnllYXIpKSB7XG4gICAgZm9yIChjb25zdCB1IG9mIG9yZGVyZWRVbml0cykge1xuICAgICAgaWYgKGlzVW5kZWZpbmVkKG9ialt1XSkpIHtcbiAgICAgICAgb2JqW3VdID0gZGVmYXVsdFVuaXRWYWx1ZXNbdV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaW52YWxpZCA9IGhhc0ludmFsaWRHcmVnb3JpYW5EYXRhKG9iaikgfHwgaGFzSW52YWxpZFRpbWVEYXRhKG9iaik7XG4gICAgaWYgKGludmFsaWQpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKGludmFsaWQpO1xuICAgIH1cblxuICAgIGNvbnN0IG9mZnNldFByb3ZpcyA9IHpvbmUub2Zmc2V0KHRzTm93KTtcbiAgICBbdHMsIG9dID0gb2JqVG9UUyhvYmosIG9mZnNldFByb3Zpcywgem9uZSk7XG4gIH0gZWxzZSB7XG4gICAgdHMgPSB0c05vdztcbiAgfVxuXG4gIHJldHVybiBuZXcgRGF0ZVRpbWUoeyB0cywgem9uZSwgbG9jLCBvIH0pO1xufVxuXG5mdW5jdGlvbiBkaWZmUmVsYXRpdmUoc3RhcnQsIGVuZCwgb3B0cykge1xuICBjb25zdCByb3VuZCA9IGlzVW5kZWZpbmVkKG9wdHMucm91bmQpID8gdHJ1ZSA6IG9wdHMucm91bmQsXG4gICAgZm9ybWF0ID0gKGMsIHVuaXQpID0+IHtcbiAgICAgIGMgPSByb3VuZFRvKGMsIHJvdW5kIHx8IG9wdHMuY2FsZW5kYXJ5ID8gMCA6IDIsIHRydWUpO1xuICAgICAgY29uc3QgZm9ybWF0dGVyID0gZW5kLmxvYy5jbG9uZShvcHRzKS5yZWxGb3JtYXR0ZXIob3B0cyk7XG4gICAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdChjLCB1bml0KTtcbiAgICB9LFxuICAgIGRpZmZlciA9ICh1bml0KSA9PiB7XG4gICAgICBpZiAob3B0cy5jYWxlbmRhcnkpIHtcbiAgICAgICAgaWYgKCFlbmQuaGFzU2FtZShzdGFydCwgdW5pdCkpIHtcbiAgICAgICAgICByZXR1cm4gZW5kLnN0YXJ0T2YodW5pdCkuZGlmZihzdGFydC5zdGFydE9mKHVuaXQpLCB1bml0KS5nZXQodW5pdCk7XG4gICAgICAgIH0gZWxzZSByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBlbmQuZGlmZihzdGFydCwgdW5pdCkuZ2V0KHVuaXQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgaWYgKG9wdHMudW5pdCkge1xuICAgIHJldHVybiBmb3JtYXQoZGlmZmVyKG9wdHMudW5pdCksIG9wdHMudW5pdCk7XG4gIH1cblxuICBmb3IgKGNvbnN0IHVuaXQgb2Ygb3B0cy51bml0cykge1xuICAgIGNvbnN0IGNvdW50ID0gZGlmZmVyKHVuaXQpO1xuICAgIGlmIChNYXRoLmFicyhjb3VudCkgPj0gMSkge1xuICAgICAgcmV0dXJuIGZvcm1hdChjb3VudCwgdW5pdCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmb3JtYXQoc3RhcnQgPiBlbmQgPyAtMCA6IDAsIG9wdHMudW5pdHNbb3B0cy51bml0cy5sZW5ndGggLSAxXSk7XG59XG5cbmZ1bmN0aW9uIGxhc3RPcHRzKGFyZ0xpc3QpIHtcbiAgbGV0IG9wdHMgPSB7fSxcbiAgICBhcmdzO1xuICBpZiAoYXJnTGlzdC5sZW5ndGggPiAwICYmIHR5cGVvZiBhcmdMaXN0W2FyZ0xpc3QubGVuZ3RoIC0gMV0gPT09IFwib2JqZWN0XCIpIHtcbiAgICBvcHRzID0gYXJnTGlzdFthcmdMaXN0Lmxlbmd0aCAtIDFdO1xuICAgIGFyZ3MgPSBBcnJheS5mcm9tKGFyZ0xpc3QpLnNsaWNlKDAsIGFyZ0xpc3QubGVuZ3RoIC0gMSk7XG4gIH0gZWxzZSB7XG4gICAgYXJncyA9IEFycmF5LmZyb20oYXJnTGlzdCk7XG4gIH1cbiAgcmV0dXJuIFtvcHRzLCBhcmdzXTtcbn1cblxuLyoqXG4gKiBBIERhdGVUaW1lIGlzIGFuIGltbXV0YWJsZSBkYXRhIHN0cnVjdHVyZSByZXByZXNlbnRpbmcgYSBzcGVjaWZpYyBkYXRlIGFuZCB0aW1lIGFuZCBhY2NvbXBhbnlpbmcgbWV0aG9kcy4gSXQgY29udGFpbnMgY2xhc3MgYW5kIGluc3RhbmNlIG1ldGhvZHMgZm9yIGNyZWF0aW5nLCBwYXJzaW5nLCBpbnRlcnJvZ2F0aW5nLCB0cmFuc2Zvcm1pbmcsIGFuZCBmb3JtYXR0aW5nIHRoZW0uXG4gKlxuICogQSBEYXRlVGltZSBjb21wcmlzZXMgb2Y6XG4gKiAqIEEgdGltZXN0YW1wLiBFYWNoIERhdGVUaW1lIGluc3RhbmNlIHJlZmVycyB0byBhIHNwZWNpZmljIG1pbGxpc2Vjb25kIG9mIHRoZSBVbml4IGVwb2NoLlxuICogKiBBIHRpbWUgem9uZS4gRWFjaCBpbnN0YW5jZSBpcyBjb25zaWRlcmVkIGluIHRoZSBjb250ZXh0IG9mIGEgc3BlY2lmaWMgem9uZSAoYnkgZGVmYXVsdCB0aGUgbG9jYWwgc3lzdGVtJ3Mgem9uZSkuXG4gKiAqIENvbmZpZ3VyYXRpb24gcHJvcGVydGllcyB0aGF0IGVmZmVjdCBob3cgb3V0cHV0IHN0cmluZ3MgYXJlIGZvcm1hdHRlZCwgc3VjaCBhcyBgbG9jYWxlYCwgYG51bWJlcmluZ1N5c3RlbWAsIGFuZCBgb3V0cHV0Q2FsZW5kYXJgLlxuICpcbiAqIEhlcmUgaXMgYSBicmllZiBvdmVydmlldyBvZiB0aGUgbW9zdCBjb21tb25seSB1c2VkIGZ1bmN0aW9uYWxpdHkgaXQgcHJvdmlkZXM6XG4gKlxuICogKiAqKkNyZWF0aW9uKio6IFRvIGNyZWF0ZSBhIERhdGVUaW1lIGZyb20gaXRzIGNvbXBvbmVudHMsIHVzZSBvbmUgb2YgaXRzIGZhY3RvcnkgY2xhc3MgbWV0aG9kczoge0BsaW5rIERhdGVUaW1lLmxvY2FsfSwge0BsaW5rIERhdGVUaW1lLnV0Y30sIGFuZCAobW9zdCBmbGV4aWJseSkge0BsaW5rIERhdGVUaW1lLmZyb21PYmplY3R9LiBUbyBjcmVhdGUgb25lIGZyb20gYSBzdGFuZGFyZCBzdHJpbmcgZm9ybWF0LCB1c2Uge0BsaW5rIERhdGVUaW1lLmZyb21JU099LCB7QGxpbmsgRGF0ZVRpbWUuZnJvbUhUVFB9LCBhbmQge0BsaW5rIERhdGVUaW1lLmZyb21SRkMyODIyfS4gVG8gY3JlYXRlIG9uZSBmcm9tIGEgY3VzdG9tIHN0cmluZyBmb3JtYXQsIHVzZSB7QGxpbmsgRGF0ZVRpbWUuZnJvbUZvcm1hdH0uIFRvIGNyZWF0ZSBvbmUgZnJvbSBhIG5hdGl2ZSBKUyBkYXRlLCB1c2Uge0BsaW5rIERhdGVUaW1lLmZyb21KU0RhdGV9LlxuICogKiAqKkdyZWdvcmlhbiBjYWxlbmRhciBhbmQgdGltZSoqOiBUbyBleGFtaW5lIHRoZSBHcmVnb3JpYW4gcHJvcGVydGllcyBvZiBhIERhdGVUaW1lIGluZGl2aWR1YWxseSAoaS5lIGFzIG9wcG9zZWQgdG8gY29sbGVjdGl2ZWx5IHRocm91Z2gge0BsaW5rIERhdGVUaW1lI3RvT2JqZWN0fSksIHVzZSB0aGUge0BsaW5rIERhdGVUaW1lI3llYXJ9LCB7QGxpbmsgRGF0ZVRpbWUjbW9udGh9LFxuICoge0BsaW5rIERhdGVUaW1lI2RheX0sIHtAbGluayBEYXRlVGltZSNob3VyfSwge0BsaW5rIERhdGVUaW1lI21pbnV0ZX0sIHtAbGluayBEYXRlVGltZSNzZWNvbmR9LCB7QGxpbmsgRGF0ZVRpbWUjbWlsbGlzZWNvbmR9IGFjY2Vzc29ycy5cbiAqICogKipXZWVrIGNhbGVuZGFyKio6IEZvciBJU08gd2VlayBjYWxlbmRhciBhdHRyaWJ1dGVzLCBzZWUgdGhlIHtAbGluayBEYXRlVGltZSN3ZWVrWWVhcn0sIHtAbGluayBEYXRlVGltZSN3ZWVrTnVtYmVyfSwgYW5kIHtAbGluayBEYXRlVGltZSN3ZWVrZGF5fSBhY2Nlc3NvcnMuXG4gKiAqICoqQ29uZmlndXJhdGlvbioqIFNlZSB0aGUge0BsaW5rIERhdGVUaW1lI2xvY2FsZX0gYW5kIHtAbGluayBEYXRlVGltZSNudW1iZXJpbmdTeXN0ZW19IGFjY2Vzc29ycy5cbiAqICogKipUcmFuc2Zvcm1hdGlvbioqOiBUbyB0cmFuc2Zvcm0gdGhlIERhdGVUaW1lIGludG8gb3RoZXIgRGF0ZVRpbWVzLCB1c2Uge0BsaW5rIERhdGVUaW1lI3NldH0sIHtAbGluayBEYXRlVGltZSNyZWNvbmZpZ3VyZX0sIHtAbGluayBEYXRlVGltZSNzZXRab25lfSwge0BsaW5rIERhdGVUaW1lI3NldExvY2FsZX0sIHtAbGluayBEYXRlVGltZS5wbHVzfSwge0BsaW5rIERhdGVUaW1lI21pbnVzfSwge0BsaW5rIERhdGVUaW1lI2VuZE9mfSwge0BsaW5rIERhdGVUaW1lI3N0YXJ0T2Z9LCB7QGxpbmsgRGF0ZVRpbWUjdG9VVEN9LCBhbmQge0BsaW5rIERhdGVUaW1lI3RvTG9jYWx9LlxuICogKiAqKk91dHB1dCoqOiBUbyBjb252ZXJ0IHRoZSBEYXRlVGltZSB0byBvdGhlciByZXByZXNlbnRhdGlvbnMsIHVzZSB0aGUge0BsaW5rIERhdGVUaW1lI3RvUmVsYXRpdmV9LCB7QGxpbmsgRGF0ZVRpbWUjdG9SZWxhdGl2ZUNhbGVuZGFyfSwge0BsaW5rIERhdGVUaW1lI3RvSlNPTn0sIHtAbGluayBEYXRlVGltZSN0b0lTT30sIHtAbGluayBEYXRlVGltZSN0b0hUVFB9LCB7QGxpbmsgRGF0ZVRpbWUjdG9PYmplY3R9LCB7QGxpbmsgRGF0ZVRpbWUjdG9SRkMyODIyfSwge0BsaW5rIERhdGVUaW1lI3RvU3RyaW5nfSwge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSwge0BsaW5rIERhdGVUaW1lI3RvRm9ybWF0fSwge0BsaW5rIERhdGVUaW1lI3RvTWlsbGlzfSBhbmQge0BsaW5rIERhdGVUaW1lI3RvSlNEYXRlfS5cbiAqXG4gKiBUaGVyZSdzIHBsZW50eSBvdGhlcnMgZG9jdW1lbnRlZCBiZWxvdy4gSW4gYWRkaXRpb24sIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHN1YnRsZXIgdG9waWNzIGxpa2UgaW50ZXJuYXRpb25hbGl6YXRpb24sIHRpbWUgem9uZXMsIGFsdGVybmF0aXZlIGNhbGVuZGFycywgdmFsaWRpdHksIGFuZCBzbyBvbiwgc2VlIHRoZSBleHRlcm5hbCBkb2N1bWVudGF0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEYXRlVGltZSB7XG4gIC8qKlxuICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIGNvbnN0IHpvbmUgPSBjb25maWcuem9uZSB8fCBTZXR0aW5ncy5kZWZhdWx0Wm9uZTtcblxuICAgIGxldCBpbnZhbGlkID1cbiAgICAgIGNvbmZpZy5pbnZhbGlkIHx8XG4gICAgICAoTnVtYmVyLmlzTmFOKGNvbmZpZy50cykgPyBuZXcgSW52YWxpZChcImludmFsaWQgaW5wdXRcIikgOiBudWxsKSB8fFxuICAgICAgKCF6b25lLmlzVmFsaWQgPyB1bnN1cHBvcnRlZFpvbmUoem9uZSkgOiBudWxsKTtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnRzID0gaXNVbmRlZmluZWQoY29uZmlnLnRzKSA/IFNldHRpbmdzLm5vdygpIDogY29uZmlnLnRzO1xuXG4gICAgbGV0IGMgPSBudWxsLFxuICAgICAgbyA9IG51bGw7XG4gICAgaWYgKCFpbnZhbGlkKSB7XG4gICAgICBjb25zdCB1bmNoYW5nZWQgPSBjb25maWcub2xkICYmIGNvbmZpZy5vbGQudHMgPT09IHRoaXMudHMgJiYgY29uZmlnLm9sZC56b25lLmVxdWFscyh6b25lKTtcblxuICAgICAgaWYgKHVuY2hhbmdlZCkge1xuICAgICAgICBbYywgb10gPSBbY29uZmlnLm9sZC5jLCBjb25maWcub2xkLm9dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgb3QgPSB6b25lLm9mZnNldCh0aGlzLnRzKTtcbiAgICAgICAgYyA9IHRzVG9PYmoodGhpcy50cywgb3QpO1xuICAgICAgICBpbnZhbGlkID0gTnVtYmVyLmlzTmFOKGMueWVhcikgPyBuZXcgSW52YWxpZChcImludmFsaWQgaW5wdXRcIikgOiBudWxsO1xuICAgICAgICBjID0gaW52YWxpZCA/IG51bGwgOiBjO1xuICAgICAgICBvID0gaW52YWxpZCA/IG51bGwgOiBvdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl96b25lID0gem9uZTtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmxvYyA9IGNvbmZpZy5sb2MgfHwgTG9jYWxlLmNyZWF0ZSgpO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaW52YWxpZCA9IGludmFsaWQ7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy53ZWVrRGF0YSA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5sb2NhbFdlZWtEYXRhID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmMgPSBjO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubyA9IG87XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pc0x1eG9uRGF0ZVRpbWUgPSB0cnVlO1xuICB9XG5cbiAgLy8gQ09OU1RSVUNUXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZvciB0aGUgY3VycmVudCBpbnN0YW50LCBpbiB0aGUgc3lzdGVtJ3MgdGltZSB6b25lLlxuICAgKlxuICAgKiBVc2UgU2V0dGluZ3MgdG8gb3ZlcnJpZGUgdGhlc2UgZGVmYXVsdCB2YWx1ZXMgaWYgbmVlZGVkLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0lTTygpIC8vfj4gbm93IGluIHRoZSBJU08gZm9ybWF0XG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIG5vdygpIHtcbiAgICByZXR1cm4gbmV3IERhdGVUaW1lKHt9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBsb2NhbCBEYXRlVGltZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3llYXJdIC0gVGhlIGNhbGVuZGFyIHllYXIuIElmIG9taXR0ZWQgKGFzIGluLCBjYWxsIGBsb2NhbCgpYCB3aXRoIG5vIGFyZ3VtZW50cyksIHRoZSBjdXJyZW50IHRpbWUgd2lsbCBiZSB1c2VkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbW9udGg9MV0gLSBUaGUgbW9udGgsIDEtaW5kZXhlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RheT0xXSAtIFRoZSBkYXkgb2YgdGhlIG1vbnRoLCAxLWluZGV4ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtob3VyPTBdIC0gVGhlIGhvdXIgb2YgdGhlIGRheSwgaW4gMjQtaG91ciB0aW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWludXRlPTBdIC0gVGhlIG1pbnV0ZSBvZiB0aGUgaG91ciwgbWVhbmluZyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDU5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2Vjb25kPTBdIC0gVGhlIHNlY29uZCBvZiB0aGUgbWludXRlLCBtZWFuaW5nIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgNTlcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttaWxsaXNlY29uZD0wXSAtIFRoZSBtaWxsaXNlY29uZCBvZiB0aGUgc2Vjb25kLCBtZWFuaW5nIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgOTk5XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiBub3dcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoeyB6b25lOiBcIkFtZXJpY2EvTmV3X1lvcmtcIiB9KSAgICAgIC8vfj4gbm93LCBpbiBVUyBlYXN0IGNvYXN0IHRpbWVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDEtMDFUMDA6MDA6MDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMykgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMDFUMDA6MDA6MDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIHsgbG9jYWxlOiBcImZyXCIgfSkgICAgIC8vfj4gMjAxNy0wMy0xMlQwMDowMDowMCwgd2l0aCBhIEZyZW5jaCBsb2NhbGVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUpICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6MDA6MDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUsIHsgem9uZTogXCJ1dGNcIiB9KSAgIC8vfj4gMjAxNy0wMy0xMlQwNTowMDowMCwgaW4gVVRDXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDMsIDEyLCA1LCA0NSkgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjQ1OjAwXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDMsIDEyLCA1LCA0NSwgMTApICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjQ1OjEwXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDMsIDEyLCA1LCA0NSwgMTAsIDc2NSkgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjQ1OjEwLjc2NVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBsb2NhbCgpIHtcbiAgICBjb25zdCBbb3B0cywgYXJnc10gPSBsYXN0T3B0cyhhcmd1bWVudHMpLFxuICAgICAgW3llYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZF0gPSBhcmdzO1xuICAgIHJldHVybiBxdWlja0RUKHsgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kIH0sIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGluIFVUQ1xuICAgKiBAcGFyYW0ge251bWJlcn0gW3llYXJdIC0gVGhlIGNhbGVuZGFyIHllYXIuIElmIG9taXR0ZWQgKGFzIGluLCBjYWxsIGB1dGMoKWAgd2l0aCBubyBhcmd1bWVudHMpLCB0aGUgY3VycmVudCB0aW1lIHdpbGwgYmUgdXNlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW21vbnRoPTFdIC0gVGhlIG1vbnRoLCAxLWluZGV4ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkYXk9MV0gLSBUaGUgZGF5IG9mIHRoZSBtb250aFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2hvdXI9MF0gLSBUaGUgaG91ciBvZiB0aGUgZGF5LCBpbiAyNC1ob3VyIHRpbWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttaW51dGU9MF0gLSBUaGUgbWludXRlIG9mIHRoZSBob3VyLCBtZWFuaW5nIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgNTlcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzZWNvbmQ9MF0gLSBUaGUgc2Vjb25kIG9mIHRoZSBtaW51dGUsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA1OVxuICAgKiBAcGFyYW0ge251bWJlcn0gW21pbGxpc2Vjb25kPTBdIC0gVGhlIG1pbGxpc2Vjb25kIG9mIHRoZSBzZWNvbmQsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA5OTlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubG9jYWxlXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5vdXRwdXRDYWxlbmRhcl0gLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5udW1iZXJpbmdTeXN0ZW1dIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiBub3dcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAxLTAxVDAwOjAwOjAwWlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMDFUMDA6MDA6MDBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzLCAxMikgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwMDowMDowMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMsIDEyLCA1KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjAwOjAwWlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMywgMTIsIDUsIDQ1KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MDBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzLCAxMiwgNSwgNDUsIHsgbG9jYWxlOiBcImZyXCIgfSkgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjQ1OjAwWiB3aXRoIGEgRnJlbmNoIGxvY2FsZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMywgMTIsIDUsIDQ1LCAxMCkgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MTBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzLCAxMiwgNSwgNDUsIDEwLCA3NjUsIHsgbG9jYWxlOiBcImZyXCIgfSkgLy9+PiAyMDE3LTAzLTEyVDA1OjQ1OjEwLjc2NVogd2l0aCBhIEZyZW5jaCBsb2NhbGVcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgdXRjKCkge1xuICAgIGNvbnN0IFtvcHRzLCBhcmdzXSA9IGxhc3RPcHRzKGFyZ3VtZW50cyksXG4gICAgICBbeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXSA9IGFyZ3M7XG5cbiAgICBvcHRzLnpvbmUgPSBGaXhlZE9mZnNldFpvbmUudXRjSW5zdGFuY2U7XG4gICAgcmV0dXJuIHF1aWNrRFQoeyB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQgfSwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhIEphdmFTY3JpcHQgRGF0ZSBvYmplY3QuIFVzZXMgdGhlIGRlZmF1bHQgem9uZS5cbiAgICogQHBhcmFtIHtEYXRlfSBkYXRlIC0gYSBKYXZhU2NyaXB0IERhdGUgb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdGlvbnMuem9uZT0nbG9jYWwnXSAtIHRoZSB6b25lIHRvIHBsYWNlIHRoZSBEYXRlVGltZSBpbnRvXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21KU0RhdGUoZGF0ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgdHMgPSBpc0RhdGUoZGF0ZSkgPyBkYXRlLnZhbHVlT2YoKSA6IE5hTjtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKHRzKSkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoXCJpbnZhbGlkIGlucHV0XCIpO1xuICAgIH1cblxuICAgIGNvbnN0IHpvbmVUb1VzZSA9IG5vcm1hbGl6ZVpvbmUob3B0aW9ucy56b25lLCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSk7XG4gICAgaWYgKCF6b25lVG9Vc2UuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQodW5zdXBwb3J0ZWRab25lKHpvbmVUb1VzZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoe1xuICAgICAgdHM6IHRzLFxuICAgICAgem9uZTogem9uZVRvVXNlLFxuICAgICAgbG9jOiBMb2NhbGUuZnJvbU9iamVjdChvcHRpb25zKSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgZXBvY2ggKG1lYW5pbmcgc2luY2UgMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS4gVXNlcyB0aGUgZGVmYXVsdCB6b25lLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWlsbGlzZWNvbmRzIC0gYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIDE5NzAgVVRDXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdGlvbnMuem9uZT0nbG9jYWwnXSAtIHRoZSB6b25lIHRvIHBsYWNlIHRoZSBEYXRlVGltZSBpbnRvXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sb2NhbGVdIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21NaWxsaXMobWlsbGlzZWNvbmRzLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIWlzTnVtYmVyKG1pbGxpc2Vjb25kcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcbiAgICAgICAgYGZyb21NaWxsaXMgcmVxdWlyZXMgYSBudW1lcmljYWwgaW5wdXQsIGJ1dCByZWNlaXZlZCBhICR7dHlwZW9mIG1pbGxpc2Vjb25kc30gd2l0aCB2YWx1ZSAke21pbGxpc2Vjb25kc31gXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAobWlsbGlzZWNvbmRzIDwgLU1BWF9EQVRFIHx8IG1pbGxpc2Vjb25kcyA+IE1BWF9EQVRFKSB7XG4gICAgICAvLyB0aGlzIGlzbid0IHBlcmZlY3QgYmVjYXVzZSBiZWNhdXNlIHdlIGNhbiBzdGlsbCBlbmQgdXAgb3V0IG9mIHJhbmdlIGJlY2F1c2Ugb2YgYWRkaXRpb25hbCBzaGlmdGluZywgYnV0IGl0J3MgYSBzdGFydFxuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoXCJUaW1lc3RhbXAgb3V0IG9mIHJhbmdlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IERhdGVUaW1lKHtcbiAgICAgICAgdHM6IG1pbGxpc2Vjb25kcyxcbiAgICAgICAgem9uZTogbm9ybWFsaXplWm9uZShvcHRpb25zLnpvbmUsIFNldHRpbmdzLmRlZmF1bHRab25lKSxcbiAgICAgICAgbG9jOiBMb2NhbGUuZnJvbU9iamVjdChvcHRpb25zKSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGEgbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgdGhlIGVwb2NoIChtZWFuaW5nIHNpbmNlIDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuIFVzZXMgdGhlIGRlZmF1bHQgem9uZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlY29uZHMgLSBhIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlIDE5NzAgVVRDXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdGlvbnMuem9uZT0nbG9jYWwnXSAtIHRoZSB6b25lIHRvIHBsYWNlIHRoZSBEYXRlVGltZSBpbnRvXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sb2NhbGVdIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21TZWNvbmRzKHNlY29uZHMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghaXNOdW1iZXIoc2Vjb25kcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImZyb21TZWNvbmRzIHJlcXVpcmVzIGEgbnVtZXJpY2FsIGlucHV0XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IERhdGVUaW1lKHtcbiAgICAgICAgdHM6IHNlY29uZHMgKiAxMDAwLFxuICAgICAgICB6b25lOiBub3JtYWxpemVab25lKG9wdGlvbnMuem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpLFxuICAgICAgICBsb2M6IExvY2FsZS5mcm9tT2JqZWN0KG9wdGlvbnMpLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYSBKYXZhU2NyaXB0IG9iamVjdCB3aXRoIGtleXMgbGlrZSAneWVhcicgYW5kICdob3VyJyB3aXRoIHJlYXNvbmFibGUgZGVmYXVsdHMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSB0aGUgb2JqZWN0IHRvIGNyZWF0ZSB0aGUgRGF0ZVRpbWUgZnJvbVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLnllYXIgLSBhIHllYXIsIHN1Y2ggYXMgMTk4N1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm1vbnRoIC0gYSBtb250aCwgMS0xMlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLmRheSAtIGEgZGF5IG9mIHRoZSBtb250aCwgMS0zMSwgZGVwZW5kaW5nIG9uIHRoZSBtb250aFxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm9yZGluYWwgLSBkYXkgb2YgdGhlIHllYXIsIDEtMzY1IG9yIDM2NlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLndlZWtZZWFyIC0gYW4gSVNPIHdlZWsgeWVhclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLndlZWtOdW1iZXIgLSBhbiBJU08gd2VlayBudW1iZXIsIGJldHdlZW4gMSBhbmQgNTIgb3IgNTMsIGRlcGVuZGluZyBvbiB0aGUgeWVhclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLndlZWtkYXkgLSBhbiBJU08gd2Vla2RheSwgMS03LCB3aGVyZSAxIGlzIE1vbmRheSBhbmQgNyBpcyBTdW5kYXlcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5sb2NhbFdlZWtZZWFyIC0gYSB3ZWVrIHllYXIsIGFjY29yZGluZyB0byB0aGUgbG9jYWxlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubG9jYWxXZWVrTnVtYmVyIC0gYSB3ZWVrIG51bWJlciwgYmV0d2VlbiAxIGFuZCA1MiBvciA1MywgZGVwZW5kaW5nIG9uIHRoZSB5ZWFyLCBhY2NvcmRpbmcgdG8gdGhlIGxvY2FsZVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLmxvY2FsV2Vla2RheSAtIGEgd2Vla2RheSwgMS03LCB3aGVyZSAxIGlzIHRoZSBmaXJzdCBhbmQgNyBpcyB0aGUgbGFzdCBkYXkgb2YgdGhlIHdlZWssIGFjY29yZGluZyB0byB0aGUgbG9jYWxlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouaG91ciAtIGhvdXIgb2YgdGhlIGRheSwgMC0yM1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm1pbnV0ZSAtIG1pbnV0ZSBvZiB0aGUgaG91ciwgMC01OVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLnNlY29uZCAtIHNlY29uZCBvZiB0aGUgbWludXRlLCAwLTU5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubWlsbGlzZWNvbmQgLSBtaWxsaXNlY29uZCBvZiB0aGUgc2Vjb25kLCAwLTk5OVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoaXMgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdHMuem9uZT0nbG9jYWwnXSAtIGludGVycHJldCB0aGUgbnVtYmVycyBpbiB0aGUgY29udGV4dCBvZiBhIHBhcnRpY3VsYXIgem9uZS4gQ2FuIHRha2UgYW55IHZhbHVlIHRha2VuIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byBzZXRab25lKClcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nc3lzdGVtXFwncyBsb2NhbGUnXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgeWVhcjogMTk4MiwgbW9udGg6IDUsIGRheTogMjV9KS50b0lTT0RhdGUoKSAvLz0+ICcxOTgyLTA1LTI1J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgeWVhcjogMTk4MiB9KS50b0lTT0RhdGUoKSAvLz0+ICcxOTgyLTAxLTAxJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgaG91cjogMTAsIG1pbnV0ZTogMjYsIHNlY29uZDogNiB9KSAvL34+IHRvZGF5IGF0IDEwOjI2OjA2XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyBob3VyOiAxMCwgbWludXRlOiAyNiwgc2Vjb25kOiA2IH0sIHsgem9uZTogJ3V0YycgfSksXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyBob3VyOiAxMCwgbWludXRlOiAyNiwgc2Vjb25kOiA2IH0sIHsgem9uZTogJ2xvY2FsJyB9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgaG91cjogMTAsIG1pbnV0ZTogMjYsIHNlY29uZDogNiB9LCB7IHpvbmU6ICdBbWVyaWNhL05ld19Zb3JrJyB9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgd2Vla1llYXI6IDIwMTYsIHdlZWtOdW1iZXI6IDIsIHdlZWtkYXk6IDMgfSkudG9JU09EYXRlKCkgLy89PiAnMjAxNi0wMS0xMydcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IGxvY2FsV2Vla1llYXI6IDIwMjIsIGxvY2FsV2Vla051bWJlcjogMSwgbG9jYWxXZWVrZGF5OiAxIH0sIHsgbG9jYWxlOiBcImVuLVVTXCIgfSkudG9JU09EYXRlKCkgLy89PiAnMjAyMS0xMi0yNidcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbU9iamVjdChvYmosIG9wdHMgPSB7fSkge1xuICAgIG9iaiA9IG9iaiB8fCB7fTtcbiAgICBjb25zdCB6b25lVG9Vc2UgPSBub3JtYWxpemVab25lKG9wdHMuem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpO1xuICAgIGlmICghem9uZVRvVXNlLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKHVuc3VwcG9ydGVkWm9uZSh6b25lVG9Vc2UpKTtcbiAgICB9XG5cbiAgICBjb25zdCBsb2MgPSBMb2NhbGUuZnJvbU9iamVjdChvcHRzKTtcbiAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplT2JqZWN0KG9iaiwgbm9ybWFsaXplVW5pdFdpdGhMb2NhbFdlZWtzKTtcbiAgICBjb25zdCB7IG1pbkRheXNJbkZpcnN0V2Vlaywgc3RhcnRPZldlZWsgfSA9IHVzZXNMb2NhbFdlZWtWYWx1ZXMobm9ybWFsaXplZCwgbG9jKTtcblxuICAgIGNvbnN0IHRzTm93ID0gU2V0dGluZ3Mubm93KCksXG4gICAgICBvZmZzZXRQcm92aXMgPSAhaXNVbmRlZmluZWQob3B0cy5zcGVjaWZpY09mZnNldClcbiAgICAgICAgPyBvcHRzLnNwZWNpZmljT2Zmc2V0XG4gICAgICAgIDogem9uZVRvVXNlLm9mZnNldCh0c05vdyksXG4gICAgICBjb250YWluc09yZGluYWwgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC5vcmRpbmFsKSxcbiAgICAgIGNvbnRhaW5zR3JlZ29yWWVhciA9ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLnllYXIpLFxuICAgICAgY29udGFpbnNHcmVnb3JNRCA9ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLm1vbnRoKSB8fCAhaXNVbmRlZmluZWQobm9ybWFsaXplZC5kYXkpLFxuICAgICAgY29udGFpbnNHcmVnb3IgPSBjb250YWluc0dyZWdvclllYXIgfHwgY29udGFpbnNHcmVnb3JNRCxcbiAgICAgIGRlZmluaXRlV2Vla0RlZiA9IG5vcm1hbGl6ZWQud2Vla1llYXIgfHwgbm9ybWFsaXplZC53ZWVrTnVtYmVyO1xuXG4gICAgLy8gY2FzZXM6XG4gICAgLy8ganVzdCBhIHdlZWtkYXkgLT4gdGhpcyB3ZWVrJ3MgaW5zdGFuY2Ugb2YgdGhhdCB3ZWVrZGF5LCBubyB3b3JyaWVzXG4gICAgLy8gKGdyZWdvcmlhbiBkYXRhIG9yIG9yZGluYWwpICsgKHdlZWtZZWFyIG9yIHdlZWtOdW1iZXIpIC0+IGVycm9yXG4gICAgLy8gKGdyZWdvcmlhbiBtb250aCBvciBkYXkpICsgb3JkaW5hbCAtPiBlcnJvclxuICAgIC8vIG90aGVyd2lzZSBqdXN0IHVzZSB3ZWVrcyBvciBvcmRpbmFscyBvciBncmVnb3JpYW4sIGRlcGVuZGluZyBvbiB3aGF0J3Mgc3BlY2lmaWVkXG5cbiAgICBpZiAoKGNvbnRhaW5zR3JlZ29yIHx8IGNvbnRhaW5zT3JkaW5hbCkgJiYgZGVmaW5pdGVXZWVrRGVmKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IoXG4gICAgICAgIFwiQ2FuJ3QgbWl4IHdlZWtZZWFyL3dlZWtOdW1iZXIgdW5pdHMgd2l0aCB5ZWFyL21vbnRoL2RheSBvciBvcmRpbmFsc1wiXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChjb250YWluc0dyZWdvck1EICYmIGNvbnRhaW5zT3JkaW5hbCkge1xuICAgICAgdGhyb3cgbmV3IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yKFwiQ2FuJ3QgbWl4IG9yZGluYWwgZGF0ZXMgd2l0aCBtb250aC9kYXlcIik7XG4gICAgfVxuXG4gICAgY29uc3QgdXNlV2Vla0RhdGEgPSBkZWZpbml0ZVdlZWtEZWYgfHwgKG5vcm1hbGl6ZWQud2Vla2RheSAmJiAhY29udGFpbnNHcmVnb3IpO1xuXG4gICAgLy8gY29uZmlndXJlIG91cnNlbHZlcyB0byBkZWFsIHdpdGggZ3JlZ29yaWFuIGRhdGVzIG9yIHdlZWsgc3R1ZmZcbiAgICBsZXQgdW5pdHMsXG4gICAgICBkZWZhdWx0VmFsdWVzLFxuICAgICAgb2JqTm93ID0gdHNUb09iaih0c05vdywgb2Zmc2V0UHJvdmlzKTtcbiAgICBpZiAodXNlV2Vla0RhdGEpIHtcbiAgICAgIHVuaXRzID0gb3JkZXJlZFdlZWtVbml0cztcbiAgICAgIGRlZmF1bHRWYWx1ZXMgPSBkZWZhdWx0V2Vla1VuaXRWYWx1ZXM7XG4gICAgICBvYmpOb3cgPSBncmVnb3JpYW5Ub1dlZWsob2JqTm93LCBtaW5EYXlzSW5GaXJzdFdlZWssIHN0YXJ0T2ZXZWVrKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRhaW5zT3JkaW5hbCkge1xuICAgICAgdW5pdHMgPSBvcmRlcmVkT3JkaW5hbFVuaXRzO1xuICAgICAgZGVmYXVsdFZhbHVlcyA9IGRlZmF1bHRPcmRpbmFsVW5pdFZhbHVlcztcbiAgICAgIG9iak5vdyA9IGdyZWdvcmlhblRvT3JkaW5hbChvYmpOb3cpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bml0cyA9IG9yZGVyZWRVbml0cztcbiAgICAgIGRlZmF1bHRWYWx1ZXMgPSBkZWZhdWx0VW5pdFZhbHVlcztcbiAgICB9XG5cbiAgICAvLyBzZXQgZGVmYXVsdCB2YWx1ZXMgZm9yIG1pc3Npbmcgc3R1ZmZcbiAgICBsZXQgZm91bmRGaXJzdCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgdSBvZiB1bml0cykge1xuICAgICAgY29uc3QgdiA9IG5vcm1hbGl6ZWRbdV07XG4gICAgICBpZiAoIWlzVW5kZWZpbmVkKHYpKSB7XG4gICAgICAgIGZvdW5kRmlyc3QgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChmb3VuZEZpcnN0KSB7XG4gICAgICAgIG5vcm1hbGl6ZWRbdV0gPSBkZWZhdWx0VmFsdWVzW3VdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9ybWFsaXplZFt1XSA9IG9iak5vd1t1XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBtYWtlIHN1cmUgdGhlIHZhbHVlcyB3ZSBoYXZlIGFyZSBpbiByYW5nZVxuICAgIGNvbnN0IGhpZ2hlck9yZGVySW52YWxpZCA9IHVzZVdlZWtEYXRhXG4gICAgICAgID8gaGFzSW52YWxpZFdlZWtEYXRhKG5vcm1hbGl6ZWQsIG1pbkRheXNJbkZpcnN0V2Vlaywgc3RhcnRPZldlZWspXG4gICAgICAgIDogY29udGFpbnNPcmRpbmFsXG4gICAgICAgID8gaGFzSW52YWxpZE9yZGluYWxEYXRhKG5vcm1hbGl6ZWQpXG4gICAgICAgIDogaGFzSW52YWxpZEdyZWdvcmlhbkRhdGEobm9ybWFsaXplZCksXG4gICAgICBpbnZhbGlkID0gaGlnaGVyT3JkZXJJbnZhbGlkIHx8IGhhc0ludmFsaWRUaW1lRGF0YShub3JtYWxpemVkKTtcblxuICAgIGlmIChpbnZhbGlkKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChpbnZhbGlkKTtcbiAgICB9XG5cbiAgICAvLyBjb21wdXRlIHRoZSBhY3R1YWwgdGltZVxuICAgIGNvbnN0IGdyZWdvcmlhbiA9IHVzZVdlZWtEYXRhXG4gICAgICAgID8gd2Vla1RvR3JlZ29yaWFuKG5vcm1hbGl6ZWQsIG1pbkRheXNJbkZpcnN0V2Vlaywgc3RhcnRPZldlZWspXG4gICAgICAgIDogY29udGFpbnNPcmRpbmFsXG4gICAgICAgID8gb3JkaW5hbFRvR3JlZ29yaWFuKG5vcm1hbGl6ZWQpXG4gICAgICAgIDogbm9ybWFsaXplZCxcbiAgICAgIFt0c0ZpbmFsLCBvZmZzZXRGaW5hbF0gPSBvYmpUb1RTKGdyZWdvcmlhbiwgb2Zmc2V0UHJvdmlzLCB6b25lVG9Vc2UpLFxuICAgICAgaW5zdCA9IG5ldyBEYXRlVGltZSh7XG4gICAgICAgIHRzOiB0c0ZpbmFsLFxuICAgICAgICB6b25lOiB6b25lVG9Vc2UsXG4gICAgICAgIG86IG9mZnNldEZpbmFsLFxuICAgICAgICBsb2MsXG4gICAgICB9KTtcblxuICAgIC8vIGdyZWdvcmlhbiBkYXRhICsgd2Vla2RheSBzZXJ2ZXMgb25seSB0byB2YWxpZGF0ZVxuICAgIGlmIChub3JtYWxpemVkLndlZWtkYXkgJiYgY29udGFpbnNHcmVnb3IgJiYgb2JqLndlZWtkYXkgIT09IGluc3Qud2Vla2RheSkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoXG4gICAgICAgIFwibWlzbWF0Y2hlZCB3ZWVrZGF5XCIsXG4gICAgICAgIGB5b3UgY2FuJ3Qgc3BlY2lmeSBib3RoIGEgd2Vla2RheSBvZiAke25vcm1hbGl6ZWQud2Vla2RheX0gYW5kIGEgZGF0ZSBvZiAke2luc3QudG9JU08oKX1gXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYW4gSVNPIDg2MDEgc3RyaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIElTTyBzdHJpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRvIGFmZmVjdCB0aGUgY3JlYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdHMuem9uZT0nbG9jYWwnXSAtIHVzZSB0aGlzIHpvbmUgaWYgbm8gb2Zmc2V0IGlzIHNwZWNpZmllZCBpbiB0aGUgaW5wdXQgc3RyaW5nIGl0c2VsZi4gV2lsbCBhbHNvIGNvbnZlcnQgdGhlIHRpbWUgdG8gdGhpcyB6b25lXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2V0Wm9uZT1mYWxzZV0gLSBvdmVycmlkZSB0aGUgem9uZSB3aXRoIGEgZml4ZWQtb2Zmc2V0IHpvbmUgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcgaXRzZWxmLCBpZiBpdCBzcGVjaWZpZXMgb25lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J3N5c3RlbSdzIGxvY2FsZSddIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm91dHB1dENhbGVuZGFyXSAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm51bWJlcmluZ1N5c3RlbV0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSVNPKCcyMDE2LTA1LTI1VDA5OjA4OjM0LjEyMycpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21JU08oJzIwMTYtMDUtMjVUMDk6MDg6MzQuMTIzKzA2OjAwJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUlTTygnMjAxNi0wNS0yNVQwOTowODozNC4xMjMrMDY6MDAnLCB7c2V0Wm9uZTogdHJ1ZX0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21JU08oJzIwMTYtMDUtMjVUMDk6MDg6MzQuMTIzJywge3pvbmU6ICd1dGMnfSlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUlTTygnMjAxNi1XMDUtNCcpXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21JU08odGV4dCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgW3ZhbHMsIHBhcnNlZFpvbmVdID0gcGFyc2VJU09EYXRlKHRleHQpO1xuICAgIHJldHVybiBwYXJzZURhdGFUb0RhdGVUaW1lKHZhbHMsIHBhcnNlZFpvbmUsIG9wdHMsIFwiSVNPIDg2MDFcIiwgdGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhbiBSRkMgMjgyMiBzdHJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgUkZDIDI4MjIgc3RyaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0byBhZmZlY3QgdGhlIGNyZWF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRzLnpvbmU9J2xvY2FsJ10gLSBjb252ZXJ0IHRoZSB0aW1lIHRvIHRoaXMgem9uZS4gU2luY2UgdGhlIG9mZnNldCBpcyBhbHdheXMgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcgaXRzZWxmLCB0aGlzIGhhcyBubyBlZmZlY3Qgb24gdGhlIGludGVycHJldGF0aW9uIG9mIHN0cmluZywgbWVyZWx5IHRoZSB6b25lIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaXMgZXhwcmVzc2VkIGluLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNldFpvbmU9ZmFsc2VdIC0gb3ZlcnJpZGUgdGhlIHpvbmUgd2l0aCBhIGZpeGVkLW9mZnNldCB6b25lIHNwZWNpZmllZCBpbiB0aGUgc3RyaW5nIGl0c2VsZiwgaWYgaXQgc3BlY2lmaWVzIG9uZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdzeXN0ZW0ncyBsb2NhbGUnXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tUkZDMjgyMignMjUgTm92IDIwMTYgMTM6MjM6MTIgR01UJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVJGQzI4MjIoJ0ZyaSwgMjUgTm92IDIwMTYgMTM6MjM6MTIgKzA2MDAnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tUkZDMjgyMignMjUgTm92IDIwMTYgMTM6MjMgWicpXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21SRkMyODIyKHRleHQsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IFt2YWxzLCBwYXJzZWRab25lXSA9IHBhcnNlUkZDMjgyMkRhdGUodGV4dCk7XG4gICAgcmV0dXJuIHBhcnNlRGF0YVRvRGF0ZVRpbWUodmFscywgcGFyc2VkWm9uZSwgb3B0cywgXCJSRkMgMjgyMlwiLCB0ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGFuIEhUVFAgaGVhZGVyIGRhdGVcbiAgICogQHNlZSBodHRwczovL3d3dy53My5vcmcvUHJvdG9jb2xzL3JmYzI2MTYvcmZjMjYxNi1zZWMzLmh0bWwjc2VjMy4zLjFcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgSFRUUCBoZWFkZXIgZGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdG8gYWZmZWN0IHRoZSBjcmVhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gY29udmVydCB0aGUgdGltZSB0byB0aGlzIHpvbmUuIFNpbmNlIEhUVFAgZGF0ZXMgYXJlIGFsd2F5cyBpbiBVVEMsIHRoaXMgaGFzIG5vIGVmZmVjdCBvbiB0aGUgaW50ZXJwcmV0YXRpb24gb2Ygc3RyaW5nLCBtZXJlbHkgdGhlIHpvbmUgdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpcyBleHByZXNzZWQgaW4uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2V0Wm9uZT1mYWxzZV0gLSBvdmVycmlkZSB0aGUgem9uZSB3aXRoIHRoZSBmaXhlZC1vZmZzZXQgem9uZSBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZy4gRm9yIEhUVFAgZGF0ZXMsIHRoaXMgaXMgYWx3YXlzIFVUQywgc28gdGhpcyBvcHRpb24gaXMgZXF1aXZhbGVudCB0byBzZXR0aW5nIHRoZSBgem9uZWAgb3B0aW9uIHRvICd1dGMnLCBidXQgdGhpcyBvcHRpb24gaXMgaW5jbHVkZWQgZm9yIGNvbnNpc3RlbmN5IHdpdGggc2ltaWxhciBtZXRob2RzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdzeXN0ZW0ncyBsb2NhbGUnXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSFRUUCgnU3VuLCAwNiBOb3YgMTk5NCAwODo0OTozNyBHTVQnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSFRUUCgnU3VuZGF5LCAwNi1Ob3YtOTQgMDg6NDk6MzcgR01UJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUhUVFAoJ1N1biBOb3YgIDYgMDg6NDk6MzcgMTk5NCcpXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21IVFRQKHRleHQsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IFt2YWxzLCBwYXJzZWRab25lXSA9IHBhcnNlSFRUUERhdGUodGV4dCk7XG4gICAgcmV0dXJuIHBhcnNlRGF0YVRvRGF0ZVRpbWUodmFscywgcGFyc2VkWm9uZSwgb3B0cywgXCJIVFRQXCIsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYW4gaW5wdXQgc3RyaW5nIGFuZCBmb3JtYXQgc3RyaW5nLlxuICAgKiBEZWZhdWx0cyB0byBlbi1VUyBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkLCByZWdhcmRsZXNzIG9mIHRoZSBzeXN0ZW0ncyBsb2NhbGUuIEZvciBhIHRhYmxlIG9mIHRva2VucyBhbmQgdGhlaXIgaW50ZXJwcmV0YXRpb25zLCBzZWUgW2hlcmVdKGh0dHBzOi8vbW9tZW50LmdpdGh1Yi5pby9sdXhvbi8jL3BhcnNpbmc/aWQ9dGFibGUtb2YtdG9rZW5zKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmbXQgLSB0aGUgZm9ybWF0IHRoZSBzdHJpbmcgaXMgZXhwZWN0ZWQgdG8gYmUgaW4gKHNlZSB0aGUgbGluayBiZWxvdyBmb3IgdGhlIGZvcm1hdHMpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0byBhZmZlY3QgdGhlIGNyZWF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRzLnpvbmU9J2xvY2FsJ10gLSB1c2UgdGhpcyB6b25lIGlmIG5vIG9mZnNldCBpcyBzcGVjaWZpZWQgaW4gdGhlIGlucHV0IHN0cmluZyBpdHNlbGYuIFdpbGwgYWxzbyBjb252ZXJ0IHRoZSBEYXRlVGltZSB0byB0aGlzIHpvbmVcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zZXRab25lPWZhbHNlXSAtIG92ZXJyaWRlIHRoZSB6b25lIHdpdGggYSB6b25lIHNwZWNpZmllZCBpbiB0aGUgc3RyaW5nIGl0c2VsZiwgaWYgaXQgc3BlY2lmaWVzIG9uZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdlbi1VUyddIC0gYSBsb2NhbGUgc3RyaW5nIHRvIHVzZSB3aGVuIHBhcnNpbmcuIFdpbGwgYWxzbyBzZXQgdGhlIERhdGVUaW1lIHRvIHRoaXMgbG9jYWxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZSB3aGVuIHBhcnNpbmcuIFdpbGwgYWxzbyBzZXQgdGhlIHJlc3VsdGluZyBEYXRlVGltZSB0byB0aGlzIG51bWJlcmluZyBzeXN0ZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21Gb3JtYXQodGV4dCwgZm10LCBvcHRzID0ge30pIHtcbiAgICBpZiAoaXNVbmRlZmluZWQodGV4dCkgfHwgaXNVbmRlZmluZWQoZm10KSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiZnJvbUZvcm1hdCByZXF1aXJlcyBhbiBpbnB1dCBzdHJpbmcgYW5kIGEgZm9ybWF0XCIpO1xuICAgIH1cblxuICAgIGNvbnN0IHsgbG9jYWxlID0gbnVsbCwgbnVtYmVyaW5nU3lzdGVtID0gbnVsbCB9ID0gb3B0cyxcbiAgICAgIGxvY2FsZVRvVXNlID0gTG9jYWxlLmZyb21PcHRzKHtcbiAgICAgICAgbG9jYWxlLFxuICAgICAgICBudW1iZXJpbmdTeXN0ZW0sXG4gICAgICAgIGRlZmF1bHRUb0VOOiB0cnVlLFxuICAgICAgfSksXG4gICAgICBbdmFscywgcGFyc2VkWm9uZSwgc3BlY2lmaWNPZmZzZXQsIGludmFsaWRdID0gcGFyc2VGcm9tVG9rZW5zKGxvY2FsZVRvVXNlLCB0ZXh0LCBmbXQpO1xuICAgIGlmIChpbnZhbGlkKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChpbnZhbGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBhcnNlRGF0YVRvRGF0ZVRpbWUodmFscywgcGFyc2VkWm9uZSwgb3B0cywgYGZvcm1hdCAke2ZtdH1gLCB0ZXh0LCBzcGVjaWZpY09mZnNldCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBmcm9tRm9ybWF0IGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBmcm9tU3RyaW5nKHRleHQsIGZtdCwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIERhdGVUaW1lLmZyb21Gb3JtYXQodGV4dCwgZm10LCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGEgU1FMIGRhdGUsIHRpbWUsIG9yIGRhdGV0aW1lXG4gICAqIERlZmF1bHRzIHRvIGVuLVVTIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWQsIHJlZ2FyZGxlc3Mgb2YgdGhlIHN5c3RlbSdzIGxvY2FsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRvIGFmZmVjdCB0aGUgY3JlYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdHMuem9uZT0nbG9jYWwnXSAtIHVzZSB0aGlzIHpvbmUgaWYgbm8gb2Zmc2V0IGlzIHNwZWNpZmllZCBpbiB0aGUgaW5wdXQgc3RyaW5nIGl0c2VsZi4gV2lsbCBhbHNvIGNvbnZlcnQgdGhlIERhdGVUaW1lIHRvIHRoaXMgem9uZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNldFpvbmU9ZmFsc2VdIC0gb3ZlcnJpZGUgdGhlIHpvbmUgd2l0aCBhIHpvbmUgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcgaXRzZWxmLCBpZiBpdCBzcGVjaWZpZXMgb25lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSBhIGxvY2FsZSBzdHJpbmcgdG8gdXNlIHdoZW4gcGFyc2luZy4gV2lsbCBhbHNvIHNldCB0aGUgRGF0ZVRpbWUgdG8gdGhpcyBsb2NhbGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gdXNlIHdoZW4gcGFyc2luZy4gV2lsbCBhbHNvIHNldCB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIHRvIHRoaXMgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNScpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1IDA5OjEyOjM0LjM0MicpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQuMzQyKzA2OjAwJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNC4zNDIgQW1lcmljYS9Mb3NfQW5nZWxlcycpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQuMzQyIEFtZXJpY2EvTG9zX0FuZ2VsZXMnLCB7IHNldFpvbmU6IHRydWUgfSlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNC4zNDInLCB7IHpvbmU6ICdBbWVyaWNhL0xvc19BbmdlbGVzJyB9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcwOToxMjozNC4zNDInKVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tU1FMKHRleHQsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IFt2YWxzLCBwYXJzZWRab25lXSA9IHBhcnNlU1FMKHRleHQpO1xuICAgIHJldHVybiBwYXJzZURhdGFUb0RhdGVUaW1lKHZhbHMsIHBhcnNlZFpvbmUsIG9wdHMsIFwiU1FMXCIsIHRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnZhbGlkIERhdGVUaW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uIC0gc2ltcGxlIHN0cmluZyBvZiB3aHkgdGhpcyBEYXRlVGltZSBpcyBpbnZhbGlkLiBTaG91bGQgbm90IGNvbnRhaW4gcGFyYW1ldGVycyBvciBhbnl0aGluZyBlbHNlIGRhdGEtZGVwZW5kZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2V4cGxhbmF0aW9uPW51bGxdIC0gbG9uZ2VyIGV4cGxhbmF0aW9uLCBtYXkgaW5jbHVkZSBwYXJhbWV0ZXJzIGFuZCBvdGhlciB1c2VmdWwgZGVidWdnaW5nIGluZm9ybWF0aW9uXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGludmFsaWQocmVhc29uLCBleHBsYW5hdGlvbiA9IG51bGwpIHtcbiAgICBpZiAoIXJlYXNvbikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwibmVlZCB0byBzcGVjaWZ5IGEgcmVhc29uIHRoZSBEYXRlVGltZSBpcyBpbnZhbGlkXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGludmFsaWQgPSByZWFzb24gaW5zdGFuY2VvZiBJbnZhbGlkID8gcmVhc29uIDogbmV3IEludmFsaWQocmVhc29uLCBleHBsYW5hdGlvbik7XG5cbiAgICBpZiAoU2V0dGluZ3MudGhyb3dPbkludmFsaWQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkRGF0ZVRpbWVFcnJvcihpbnZhbGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlVGltZSh7IGludmFsaWQgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiBEYXRlVGltZS4gV29ya3MgYWNyb3NzIGNvbnRleHQgYm91bmRhcmllc1xuICAgKiBAcGFyYW0ge29iamVjdH0gb1xuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzRGF0ZVRpbWUobykge1xuICAgIHJldHVybiAobyAmJiBvLmlzTHV4b25EYXRlVGltZSkgfHwgZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUHJvZHVjZSB0aGUgZm9ybWF0IHN0cmluZyBmb3IgYSBzZXQgb2Ygb3B0aW9uc1xuICAgKiBAcGFyYW0gZm9ybWF0T3B0c1xuICAgKiBAcGFyYW0gbG9jYWxlT3B0c1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIHBhcnNlRm9ybWF0Rm9yT3B0cyhmb3JtYXRPcHRzLCBsb2NhbGVPcHRzID0ge30pIHtcbiAgICBjb25zdCB0b2tlbkxpc3QgPSBmb3JtYXRPcHRzVG9Ub2tlbnMoZm9ybWF0T3B0cywgTG9jYWxlLmZyb21PYmplY3QobG9jYWxlT3B0cykpO1xuICAgIHJldHVybiAhdG9rZW5MaXN0ID8gbnVsbCA6IHRva2VuTGlzdC5tYXAoKHQpID0+ICh0ID8gdC52YWwgOiBudWxsKSkuam9pbihcIlwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9kdWNlIHRoZSB0aGUgZnVsbHkgZXhwYW5kZWQgZm9ybWF0IHRva2VuIGZvciB0aGUgbG9jYWxlXG4gICAqIERvZXMgTk9UIHF1b3RlIGNoYXJhY3RlcnMsIHNvIHF1b3RlZCB0b2tlbnMgd2lsbCBub3Qgcm91bmQgdHJpcCBjb3JyZWN0bHlcbiAgICogQHBhcmFtIGZtdFxuICAgKiBAcGFyYW0gbG9jYWxlT3B0c1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGV4cGFuZEZvcm1hdChmbXQsIGxvY2FsZU9wdHMgPSB7fSkge1xuICAgIGNvbnN0IGV4cGFuZGVkID0gZXhwYW5kTWFjcm9Ub2tlbnMoRm9ybWF0dGVyLnBhcnNlRm9ybWF0KGZtdCksIExvY2FsZS5mcm9tT2JqZWN0KGxvY2FsZU9wdHMpKTtcbiAgICByZXR1cm4gZXhwYW5kZWQubWFwKCh0KSA9PiB0LnZhbCkuam9pbihcIlwiKTtcbiAgfVxuXG4gIC8vIElORk9cblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBvZiB1bml0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIGEgdW5pdCBzdWNoIGFzICdtaW51dGUnIG9yICdkYXknXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDcsIDQpLmdldCgnbW9udGgnKTsgLy89PiA3XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDcsIDQpLmdldCgnZGF5Jyk7IC8vPT4gNFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQodW5pdCkge1xuICAgIHJldHVybiB0aGlzW3VuaXRdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgRGF0ZVRpbWUgaXMgdmFsaWQuIEludmFsaWQgRGF0ZVRpbWVzIG9jY3VyIHdoZW46XG4gICAqICogVGhlIERhdGVUaW1lIHdhcyBjcmVhdGVkIGZyb20gaW52YWxpZCBjYWxlbmRhciBpbmZvcm1hdGlvbiwgc3VjaCBhcyB0aGUgMTN0aCBtb250aCBvciBGZWJydWFyeSAzMFxuICAgKiAqIFRoZSBEYXRlVGltZSB3YXMgY3JlYXRlZCBieSBhbiBvcGVyYXRpb24gb24gYW5vdGhlciBpbnZhbGlkIGRhdGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID09PSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXJyb3IgY29kZSBpZiB0aGlzIERhdGVUaW1lIGlzIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIERhdGVUaW1lIGlzIHZhbGlkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaW52YWxpZFJlYXNvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID8gdGhpcy5pbnZhbGlkLnJlYXNvbiA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBleHBsYW5hdGlvbiBvZiB3aHkgdGhpcyBEYXRlVGltZSBiZWNhbWUgaW52YWxpZCwgb3IgbnVsbCBpZiB0aGUgRGF0ZVRpbWUgaXMgdmFsaWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBpbnZhbGlkRXhwbGFuYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA/IHRoaXMuaW52YWxpZC5leHBsYW5hdGlvbiA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsb2NhbGUgb2YgYSBEYXRlVGltZSwgc3VjaCAnZW4tR0InLiBUaGUgbG9jYWxlIGlzIHVzZWQgd2hlbiBmb3JtYXR0aW5nIHRoZSBEYXRlVGltZVxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGxvY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5sb2MubG9jYWxlIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG51bWJlcmluZyBzeXN0ZW0gb2YgYSBEYXRlVGltZSwgc3VjaCAnYmVuZycuIFRoZSBudW1iZXJpbmcgc3lzdGVtIGlzIHVzZWQgd2hlbiBmb3JtYXR0aW5nIHRoZSBEYXRlVGltZVxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG51bWJlcmluZ1N5c3RlbSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5sb2MubnVtYmVyaW5nU3lzdGVtIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG91dHB1dCBjYWxlbmRhciBvZiBhIERhdGVUaW1lLCBzdWNoICdpc2xhbWljJy4gVGhlIG91dHB1dCBjYWxlbmRhciBpcyB1c2VkIHdoZW4gZm9ybWF0dGluZyB0aGUgRGF0ZVRpbWVcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBvdXRwdXRDYWxlbmRhcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5sb2Mub3V0cHV0Q2FsZW5kYXIgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGltZSB6b25lIGFzc29jaWF0ZWQgd2l0aCB0aGlzIERhdGVUaW1lLlxuICAgKiBAdHlwZSB7Wm9uZX1cbiAgICovXG4gIGdldCB6b25lKCkge1xuICAgIHJldHVybiB0aGlzLl96b25lO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZSBvZiB0aGUgdGltZSB6b25lLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IHpvbmVOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnpvbmUubmFtZSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB5ZWFyXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS55ZWFyIC8vPT4gMjAxN1xuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHllYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy55ZWFyIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcXVhcnRlclxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkucXVhcnRlciAvLz0+IDJcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBxdWFydGVyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBNYXRoLmNlaWwodGhpcy5jLm1vbnRoIC8gMykgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtb250aCAoMS0xMikuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5tb250aCAvLz0+IDVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBtb250aCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLm1vbnRoIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGF5IG9mIHRoZSBtb250aCAoMS0zMGlzaCkuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5kYXkgLy89PiAyNVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRheSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLmRheSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGhvdXIgb2YgdGhlIGRheSAoMC0yMykuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1LCA5KS5ob3VyIC8vPT4gOVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGhvdXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy5ob3VyIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWludXRlIG9mIHRoZSBob3VyICgwLTU5KS5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUsIDksIDMwKS5taW51dGUgLy89PiAzMFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1pbnV0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLm1pbnV0ZSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNlY29uZCBvZiB0aGUgbWludXRlICgwLTU5KS5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUsIDksIDMwLCA1Mikuc2Vjb25kIC8vPT4gNTJcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBzZWNvbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy5zZWNvbmQgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtaWxsaXNlY29uZCBvZiB0aGUgc2Vjb25kICgwLTk5OSkuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1LCA5LCAzMCwgNTIsIDY1NCkubWlsbGlzZWNvbmQgLy89PiA2NTRcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBtaWxsaXNlY29uZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLm1pbGxpc2Vjb25kIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgd2VlayB5ZWFyXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAxMiwgMzEpLndlZWtZZWFyIC8vPT4gMjAxNVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdlZWtZZWFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBwb3NzaWJseUNhY2hlZFdlZWtEYXRhKHRoaXMpLndlZWtZZWFyIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgd2VlayBudW1iZXIgb2YgdGhlIHdlZWsgeWVhciAoMS01MmlzaCkuXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkud2Vla051bWJlciAvLz0+IDIxXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2Vla051bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gcG9zc2libHlDYWNoZWRXZWVrRGF0YSh0aGlzKS53ZWVrTnVtYmVyIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGF5IG9mIHRoZSB3ZWVrLlxuICAgKiAxIGlzIE1vbmRheSBhbmQgNyBpcyBTdW5kYXlcbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDExLCAzMSkud2Vla2RheSAvLz0+IDRcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB3ZWVrZGF5KCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBwb3NzaWJseUNhY2hlZFdlZWtEYXRhKHRoaXMpLndlZWtkYXkgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgZGF0ZSBpcyBvbiBhIHdlZWtlbmQgYWNjb3JkaW5nIHRvIHRoZSBsb2NhbGUsIGZhbHNlIG90aGVyd2lzZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc1dlZWtlbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCAmJiB0aGlzLmxvYy5nZXRXZWVrZW5kRGF5cygpLmluY2x1ZGVzKHRoaXMud2Vla2RheSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkYXkgb2YgdGhlIHdlZWsgYWNjb3JkaW5nIHRvIHRoZSBsb2NhbGUuXG4gICAqIDEgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlayBhbmQgNyBpcyB0aGUgbGFzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAqIElmIHRoZSBsb2NhbGUgYXNzaWducyBTdW5kYXkgYXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlaywgdGhlbiBhIGRhdGUgd2hpY2ggaXMgYSBTdW5kYXkgd2lsbCByZXR1cm4gMSxcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGdldCBsb2NhbFdlZWtkYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHBvc3NpYmx5Q2FjaGVkTG9jYWxXZWVrRGF0YSh0aGlzKS53ZWVrZGF5IDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgd2VlayBudW1iZXIgb2YgdGhlIHdlZWsgeWVhciBhY2NvcmRpbmcgdG8gdGhlIGxvY2FsZS4gRGlmZmVyZW50IGxvY2FsZXMgYXNzaWduIHdlZWsgbnVtYmVycyBkaWZmZXJlbnRseSxcbiAgICogYmVjYXVzZSB0aGUgd2VlayBjYW4gc3RhcnQgb24gZGlmZmVyZW50IGRheXMgb2YgdGhlIHdlZWsgKHNlZSBsb2NhbFdlZWtkYXkpIGFuZCBiZWNhdXNlIGEgZGlmZmVyZW50IG51bWJlciBvZiBkYXlzXG4gICAqIGlzIHJlcXVpcmVkIGZvciBhIHdlZWsgdG8gY291bnQgYXMgdGhlIGZpcnN0IHdlZWsgb2YgYSB5ZWFyLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGxvY2FsV2Vla051bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gcG9zc2libHlDYWNoZWRMb2NhbFdlZWtEYXRhKHRoaXMpLndlZWtOdW1iZXIgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB3ZWVrIHllYXIgYWNjb3JkaW5nIHRvIHRoZSBsb2NhbGUuIERpZmZlcmVudCBsb2NhbGVzIGFzc2lnbiB3ZWVrIG51bWJlcnMgKGFuZCB0aGVyZWZvciB3ZWVrIHllYXJzKVxuICAgKiBkaWZmZXJlbnRseSwgc2VlIGxvY2FsV2Vla051bWJlci5cbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGdldCBsb2NhbFdlZWtZZWFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBwb3NzaWJseUNhY2hlZExvY2FsV2Vla0RhdGEodGhpcykud2Vla1llYXIgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBvcmRpbmFsIChtZWFuaW5nIHRoZSBkYXkgb2YgdGhlIHllYXIpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5vcmRpbmFsIC8vPT4gMTQ1XG4gICAqIEB0eXBlIHtudW1iZXJ8RGF0ZVRpbWV9XG4gICAqL1xuICBnZXQgb3JkaW5hbCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gZ3JlZ29yaWFuVG9PcmRpbmFsKHRoaXMuYykub3JkaW5hbCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGh1bWFuIHJlYWRhYmxlIHNob3J0IG1vbnRoIG5hbWUsIHN1Y2ggYXMgJ09jdCcuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAxMCwgMzApLm1vbnRoU2hvcnQgLy89PiBPY3RcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBtb250aFNob3J0KCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBJbmZvLm1vbnRocyhcInNob3J0XCIsIHsgbG9jT2JqOiB0aGlzLmxvYyB9KVt0aGlzLm1vbnRoIC0gMV0gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaHVtYW4gcmVhZGFibGUgbG9uZyBtb250aCBuYW1lLCBzdWNoIGFzICdPY3RvYmVyJy5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDEwLCAzMCkubW9udGhMb25nIC8vPT4gT2N0b2JlclxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG1vbnRoTG9uZygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gSW5mby5tb250aHMoXCJsb25nXCIsIHsgbG9jT2JqOiB0aGlzLmxvYyB9KVt0aGlzLm1vbnRoIC0gMV0gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaHVtYW4gcmVhZGFibGUgc2hvcnQgd2Vla2RheSwgc3VjaCBhcyAnTW9uJy5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDEwLCAzMCkud2Vla2RheVNob3J0IC8vPT4gTW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgd2Vla2RheVNob3J0KCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBJbmZvLndlZWtkYXlzKFwic2hvcnRcIiwgeyBsb2NPYmo6IHRoaXMubG9jIH0pW3RoaXMud2Vla2RheSAtIDFdIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGh1bWFuIHJlYWRhYmxlIGxvbmcgd2Vla2RheSwgc3VjaCBhcyAnTW9uZGF5Jy5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDEwLCAzMCkud2Vla2RheUxvbmcgLy89PiBNb25kYXlcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCB3ZWVrZGF5TG9uZygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gSW5mby53ZWVrZGF5cyhcImxvbmdcIiwgeyBsb2NPYmo6IHRoaXMubG9jIH0pW3RoaXMud2Vla2RheSAtIDFdIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIFVUQyBvZmZzZXQgb2YgdGhpcyBEYXRlVGltZSBpbiBtaW51dGVzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLm9mZnNldCAvLz0+IC0yNDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkub2Zmc2V0IC8vPT4gMFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gK3RoaXMubyA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNob3J0IGh1bWFuIG5hbWUgZm9yIHRoZSB6b25lJ3MgY3VycmVudCBvZmZzZXQsIGZvciBleGFtcGxlIFwiRVNUXCIgb3IgXCJFRFRcIi5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgb2Zmc2V0TmFtZVNob3J0KCkge1xuICAgIGlmICh0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnpvbmUub2Zmc2V0TmFtZSh0aGlzLnRzLCB7XG4gICAgICAgIGZvcm1hdDogXCJzaG9ydFwiLFxuICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxvbmcgaHVtYW4gbmFtZSBmb3IgdGhlIHpvbmUncyBjdXJyZW50IG9mZnNldCwgZm9yIGV4YW1wbGUgXCJFYXN0ZXJuIFN0YW5kYXJkIFRpbWVcIiBvciBcIkVhc3Rlcm4gRGF5bGlnaHQgVGltZVwiLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBvZmZzZXROYW1lTG9uZygpIHtcbiAgICBpZiAodGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy56b25lLm9mZnNldE5hbWUodGhpcy50cywge1xuICAgICAgICBmb3JtYXQ6IFwibG9uZ1wiLFxuICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgd2hldGhlciB0aGlzIHpvbmUncyBvZmZzZXQgZXZlciBjaGFuZ2VzLCBhcyBpbiBhIERTVC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNPZmZzZXRGaXhlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy56b25lLmlzVW5pdmVyc2FsIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgd2hldGhlciB0aGUgRGF0ZVRpbWUgaXMgaW4gYSBEU1QuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzSW5EU1QoKSB7XG4gICAgaWYgKHRoaXMuaXNPZmZzZXRGaXhlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLm9mZnNldCA+IHRoaXMuc2V0KHsgbW9udGg6IDEsIGRheTogMSB9KS5vZmZzZXQgfHxcbiAgICAgICAgdGhpcy5vZmZzZXQgPiB0aGlzLnNldCh7IG1vbnRoOiA1IH0pLm9mZnNldFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRob3NlIERhdGVUaW1lcyB3aGljaCBoYXZlIHRoZSBzYW1lIGxvY2FsIHRpbWUgYXMgdGhpcyBEYXRlVGltZSwgYnV0IGEgZGlmZmVyZW50IG9mZnNldCBmcm9tIFVUQ1xuICAgKiBpbiB0aGlzIERhdGVUaW1lJ3Mgem9uZS4gRHVyaW5nIERTVCBjaGFuZ2VzIGxvY2FsIHRpbWUgY2FuIGJlIGFtYmlndW91cywgZm9yIGV4YW1wbGVcbiAgICogYDIwMjMtMTAtMjlUMDI6MzA6MDBgIGluIGBFdXJvcGUvQmVybGluYCBjYW4gaGF2ZSBvZmZzZXQgYCswMTowMGAgb3IgYCswMjowMGAuXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGJvdGggcG9zc2libGUgRGF0ZVRpbWVzIGlmIHRoaXMgRGF0ZVRpbWUncyBsb2NhbCB0aW1lIGlzIGFtYmlndW91cy5cbiAgICogQHJldHVybnMge0RhdGVUaW1lW119XG4gICAqL1xuICBnZXRQb3NzaWJsZU9mZnNldHMoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQgfHwgdGhpcy5pc09mZnNldEZpeGVkKSB7XG4gICAgICByZXR1cm4gW3RoaXNdO1xuICAgIH1cbiAgICBjb25zdCBkYXlNcyA9IDg2NDAwMDAwO1xuICAgIGNvbnN0IG1pbnV0ZU1zID0gNjAwMDA7XG4gICAgY29uc3QgbG9jYWxUUyA9IG9ialRvTG9jYWxUUyh0aGlzLmMpO1xuICAgIGNvbnN0IG9FYXJsaWVyID0gdGhpcy56b25lLm9mZnNldChsb2NhbFRTIC0gZGF5TXMpO1xuICAgIGNvbnN0IG9MYXRlciA9IHRoaXMuem9uZS5vZmZzZXQobG9jYWxUUyArIGRheU1zKTtcblxuICAgIGNvbnN0IG8xID0gdGhpcy56b25lLm9mZnNldChsb2NhbFRTIC0gb0VhcmxpZXIgKiBtaW51dGVNcyk7XG4gICAgY29uc3QgbzIgPSB0aGlzLnpvbmUub2Zmc2V0KGxvY2FsVFMgLSBvTGF0ZXIgKiBtaW51dGVNcyk7XG4gICAgaWYgKG8xID09PSBvMikge1xuICAgICAgcmV0dXJuIFt0aGlzXTtcbiAgICB9XG4gICAgY29uc3QgdHMxID0gbG9jYWxUUyAtIG8xICogbWludXRlTXM7XG4gICAgY29uc3QgdHMyID0gbG9jYWxUUyAtIG8yICogbWludXRlTXM7XG4gICAgY29uc3QgYzEgPSB0c1RvT2JqKHRzMSwgbzEpO1xuICAgIGNvbnN0IGMyID0gdHNUb09iaih0czIsIG8yKTtcbiAgICBpZiAoXG4gICAgICBjMS5ob3VyID09PSBjMi5ob3VyICYmXG4gICAgICBjMS5taW51dGUgPT09IGMyLm1pbnV0ZSAmJlxuICAgICAgYzEuc2Vjb25kID09PSBjMi5zZWNvbmQgJiZcbiAgICAgIGMxLm1pbGxpc2Vjb25kID09PSBjMi5taWxsaXNlY29uZFxuICAgICkge1xuICAgICAgcmV0dXJuIFtjbG9uZSh0aGlzLCB7IHRzOiB0czEgfSksIGNsb25lKHRoaXMsIHsgdHM6IHRzMiB9KV07XG4gICAgfVxuICAgIHJldHVybiBbdGhpc107XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgRGF0ZVRpbWUgaXMgaW4gYSBsZWFwIHllYXIsIGZhbHNlIG90aGVyd2lzZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE2KS5pc0luTGVhcFllYXIgLy89PiB0cnVlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTMpLmlzSW5MZWFwWWVhciAvLz0+IGZhbHNlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzSW5MZWFwWWVhcigpIHtcbiAgICByZXR1cm4gaXNMZWFwWWVhcih0aGlzLnllYXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBkYXlzIGluIHRoaXMgRGF0ZVRpbWUncyBtb250aFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE2LCAyKS5kYXlzSW5Nb250aCAvLz0+IDI5XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTYsIDMpLmRheXNJbk1vbnRoIC8vPT4gMzFcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBkYXlzSW5Nb250aCgpIHtcbiAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyLCB0aGlzLm1vbnRoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZGF5cyBpbiB0aGlzIERhdGVUaW1lJ3MgeWVhclxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE2KS5kYXlzSW5ZZWFyIC8vPT4gMzY2XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTMpLmRheXNJblllYXIgLy89PiAzNjVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBkYXlzSW5ZZWFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBkYXlzSW5ZZWFyKHRoaXMueWVhcikgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHdlZWtzIGluIHRoaXMgRGF0ZVRpbWUncyB5ZWFyXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDA0KS53ZWVrc0luV2Vla1llYXIgLy89PiA1M1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDEzKS53ZWVrc0luV2Vla1llYXIgLy89PiA1MlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdlZWtzSW5XZWVrWWVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gd2Vla3NJbldlZWtZZWFyKHRoaXMud2Vla1llYXIpIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiB3ZWVrcyBpbiB0aGlzIERhdGVUaW1lJ3MgbG9jYWwgd2VlayB5ZWFyXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMjAsIDYsIHtsb2NhbGU6ICdlbi1VUyd9KS53ZWVrc0luTG9jYWxXZWVrWWVhciAvLz0+IDUyXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMjAsIDYsIHtsb2NhbGU6ICdkZS1ERSd9KS53ZWVrc0luTG9jYWxXZWVrWWVhciAvLz0+IDUzXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2Vla3NJbkxvY2FsV2Vla1llYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFxuICAgICAgPyB3ZWVrc0luV2Vla1llYXIoXG4gICAgICAgICAgdGhpcy5sb2NhbFdlZWtZZWFyLFxuICAgICAgICAgIHRoaXMubG9jLmdldE1pbkRheXNJbkZpcnN0V2VlaygpLFxuICAgICAgICAgIHRoaXMubG9jLmdldFN0YXJ0T2ZXZWVrKClcbiAgICAgICAgKVxuICAgICAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVzb2x2ZWQgSW50bCBvcHRpb25zIGZvciB0aGlzIERhdGVUaW1lLlxuICAgKiBUaGlzIGlzIHVzZWZ1bCBpbiB1bmRlcnN0YW5kaW5nIHRoZSBiZWhhdmlvciBvZiBmb3JtYXR0aW5nIG1ldGhvZHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSB0aGUgc2FtZSBvcHRpb25zIGFzIHRvTG9jYWxlU3RyaW5nXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHJlc29sdmVkTG9jYWxlT3B0aW9ucyhvcHRzID0ge30pIHtcbiAgICBjb25zdCB7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBjYWxlbmRhciB9ID0gRm9ybWF0dGVyLmNyZWF0ZShcbiAgICAgIHRoaXMubG9jLmNsb25lKG9wdHMpLFxuICAgICAgb3B0c1xuICAgICkucmVzb2x2ZWRPcHRpb25zKHRoaXMpO1xuICAgIHJldHVybiB7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhcjogY2FsZW5kYXIgfTtcbiAgfVxuXG4gIC8vIFRSQU5TRk9STVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBEYXRlVGltZSdzIHpvbmUgdG8gVVRDLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqXG4gICAqIEVxdWl2YWxlbnQgdG8ge0BsaW5rIERhdGVUaW1lI3NldFpvbmV9KCd1dGMnKVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29mZnNldD0wXSAtIG9wdGlvbmFsbHksIGFuIG9mZnNldCBmcm9tIFVUQyBpbiBtaW51dGVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cz17fV0gLSBvcHRpb25zIHRvIHBhc3MgdG8gYHNldFpvbmUoKWBcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICB0b1VUQyhvZmZzZXQgPSAwLCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5zZXRab25lKEZpeGVkT2Zmc2V0Wm9uZS5pbnN0YW5jZShvZmZzZXQpLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBEYXRlVGltZSdzIHpvbmUgdG8gdGhlIGhvc3QncyBsb2NhbCB6b25lLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqXG4gICAqIEVxdWl2YWxlbnQgdG8gYHNldFpvbmUoJ2xvY2FsJylgXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgdG9Mb2NhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRab25lKFNldHRpbmdzLmRlZmF1bHRab25lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBEYXRlVGltZSdzIHpvbmUgdG8gc3BlY2lmaWVkIHpvbmUuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEYXRlVGltZS5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhlIHNldHRlciBrZWVwcyB0aGUgdW5kZXJseWluZyB0aW1lIHRoZSBzYW1lIChhcyBpbiwgdGhlIHNhbWUgdGltZXN0YW1wKSwgYnV0IHRoZSBuZXcgaW5zdGFuY2Ugd2lsbCByZXBvcnQgZGlmZmVyZW50IGxvY2FsIHRpbWVzIGFuZCBjb25zaWRlciBEU1RzIHdoZW4gbWFraW5nIGNvbXB1dGF0aW9ucywgYXMgd2l0aCB7QGxpbmsgRGF0ZVRpbWUjcGx1c30uIFlvdSBtYXkgd2lzaCB0byB1c2Uge0BsaW5rIERhdGVUaW1lI3RvTG9jYWx9IGFuZCB7QGxpbmsgRGF0ZVRpbWUjdG9VVEN9IHdoaWNoIHByb3ZpZGUgc2ltcGxlIGNvbnZlbmllbmNlIHdyYXBwZXJzIGZvciBjb21tb25seSB1c2VkIHpvbmVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbem9uZT0nbG9jYWwnXSAtIGEgem9uZSBpZGVudGlmaWVyLiBBcyBhIHN0cmluZywgdGhhdCBjYW4gYmUgYW55IElBTkEgem9uZSBzdXBwb3J0ZWQgYnkgdGhlIGhvc3QgZW52aXJvbm1lbnQsIG9yIGEgZml4ZWQtb2Zmc2V0IG5hbWUgb2YgdGhlIGZvcm0gJ1VUQyszJywgb3IgdGhlIHN0cmluZ3MgJ2xvY2FsJyBvciAndXRjJy4gWW91IG1heSBhbHNvIHN1cHBseSBhbiBpbnN0YW5jZSBvZiBhIHtAbGluayBEYXRlVGltZSNab25lfSBjbGFzcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMua2VlcExvY2FsVGltZT1mYWxzZV0gLSBJZiB0cnVlLCBhZGp1c3QgdGhlIHVuZGVybHlpbmcgdGltZSBzbyB0aGF0IHRoZSBsb2NhbCB0aW1lIHN0YXlzIHRoZSBzYW1lLCBidXQgaW4gdGhlIHRhcmdldCB6b25lLiBZb3Ugc2hvdWxkIHJhcmVseSBuZWVkIHRoaXMuXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc2V0Wm9uZSh6b25lLCB7IGtlZXBMb2NhbFRpbWUgPSBmYWxzZSwga2VlcENhbGVuZGFyVGltZSA9IGZhbHNlIH0gPSB7fSkge1xuICAgIHpvbmUgPSBub3JtYWxpemVab25lKHpvbmUsIFNldHRpbmdzLmRlZmF1bHRab25lKTtcbiAgICBpZiAoem9uZS5lcXVhbHModGhpcy56b25lKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIGlmICghem9uZS5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZCh1bnN1cHBvcnRlZFpvbmUoem9uZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbmV3VFMgPSB0aGlzLnRzO1xuICAgICAgaWYgKGtlZXBMb2NhbFRpbWUgfHwga2VlcENhbGVuZGFyVGltZSkge1xuICAgICAgICBjb25zdCBvZmZzZXRHdWVzcyA9IHpvbmUub2Zmc2V0KHRoaXMudHMpO1xuICAgICAgICBjb25zdCBhc09iaiA9IHRoaXMudG9PYmplY3QoKTtcbiAgICAgICAgW25ld1RTXSA9IG9ialRvVFMoYXNPYmosIG9mZnNldEd1ZXNzLCB6b25lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHRzOiBuZXdUUywgem9uZSB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG9yIG91dHB1dENhbGVuZGFyLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIC0gdGhlIHByb3BlcnRpZXMgdG8gc2V0XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5yZWNvbmZpZ3VyZSh7IGxvY2FsZTogJ2VuLUdCJyB9KVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHJlY29uZmlndXJlKHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyIH0gPSB7fSkge1xuICAgIGNvbnN0IGxvYyA9IHRoaXMubG9jLmNsb25lKHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyIH0pO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IGxvYyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBsb2NhbGUuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEYXRlVGltZS5cbiAgICogSnVzdCBhIGNvbnZlbmllbnQgYWxpYXMgZm9yIHJlY29uZmlndXJlKHsgbG9jYWxlIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5zZXRMb2NhbGUoJ2VuLUdCJylcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzZXRMb2NhbGUobG9jYWxlKSB7XG4gICAgcmV0dXJuIHRoaXMucmVjb25maWd1cmUoeyBsb2NhbGUgfSk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgdmFsdWVzIG9mIHNwZWNpZmllZCB1bml0cy4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIERhdGVUaW1lLlxuICAgKiBZb3UgY2FuIG9ubHkgc2V0IHVuaXRzIHdpdGggdGhpcyBtZXRob2Q7IGZvciBcInNldHRpbmdcIiBtZXRhZGF0YSwgc2VlIHtAbGluayBEYXRlVGltZSNyZWNvbmZpZ3VyZX0gYW5kIHtAbGluayBEYXRlVGltZSNzZXRab25lfS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgYWxzbyBzdXBwb3J0cyBzZXR0aW5nIGxvY2FsZS1iYXNlZCB3ZWVrIHVuaXRzLCBpLmUuIGBsb2NhbFdlZWtkYXlgLCBgbG9jYWxXZWVrTnVtYmVyYCBhbmQgYGxvY2FsV2Vla1llYXJgLlxuICAgKiBUaGV5IGNhbm5vdCBiZSBtaXhlZCB3aXRoIElTTy13ZWVrIHVuaXRzIGxpa2UgYHdlZWtkYXlgLlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzIC0gYSBtYXBwaW5nIG9mIHVuaXRzIHRvIG51bWJlcnNcbiAgICogQGV4YW1wbGUgZHQuc2V0KHsgeWVhcjogMjAxNyB9KVxuICAgKiBAZXhhbXBsZSBkdC5zZXQoeyBob3VyOiA4LCBtaW51dGU6IDMwIH0pXG4gICAqIEBleGFtcGxlIGR0LnNldCh7IHdlZWtkYXk6IDUgfSlcbiAgICogQGV4YW1wbGUgZHQuc2V0KHsgeWVhcjogMjAwNSwgb3JkaW5hbDogMjM0IH0pXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc2V0KHZhbHVlcykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcblxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVPYmplY3QodmFsdWVzLCBub3JtYWxpemVVbml0V2l0aExvY2FsV2Vla3MpO1xuICAgIGNvbnN0IHsgbWluRGF5c0luRmlyc3RXZWVrLCBzdGFydE9mV2VlayB9ID0gdXNlc0xvY2FsV2Vla1ZhbHVlcyhub3JtYWxpemVkLCB0aGlzLmxvYyk7XG5cbiAgICBjb25zdCBzZXR0aW5nV2Vla1N0dWZmID1cbiAgICAgICAgIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQud2Vla1llYXIpIHx8XG4gICAgICAgICFpc1VuZGVmaW5lZChub3JtYWxpemVkLndlZWtOdW1iZXIpIHx8XG4gICAgICAgICFpc1VuZGVmaW5lZChub3JtYWxpemVkLndlZWtkYXkpLFxuICAgICAgY29udGFpbnNPcmRpbmFsID0gIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQub3JkaW5hbCksXG4gICAgICBjb250YWluc0dyZWdvclllYXIgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC55ZWFyKSxcbiAgICAgIGNvbnRhaW5zR3JlZ29yTUQgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC5tb250aCkgfHwgIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQuZGF5KSxcbiAgICAgIGNvbnRhaW5zR3JlZ29yID0gY29udGFpbnNHcmVnb3JZZWFyIHx8IGNvbnRhaW5zR3JlZ29yTUQsXG4gICAgICBkZWZpbml0ZVdlZWtEZWYgPSBub3JtYWxpemVkLndlZWtZZWFyIHx8IG5vcm1hbGl6ZWQud2Vla051bWJlcjtcblxuICAgIGlmICgoY29udGFpbnNHcmVnb3IgfHwgY29udGFpbnNPcmRpbmFsKSAmJiBkZWZpbml0ZVdlZWtEZWYpIHtcbiAgICAgIHRocm93IG5ldyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcihcbiAgICAgICAgXCJDYW4ndCBtaXggd2Vla1llYXIvd2Vla051bWJlciB1bml0cyB3aXRoIHllYXIvbW9udGgvZGF5IG9yIG9yZGluYWxzXCJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRhaW5zR3JlZ29yTUQgJiYgY29udGFpbnNPcmRpbmFsKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IoXCJDYW4ndCBtaXggb3JkaW5hbCBkYXRlcyB3aXRoIG1vbnRoL2RheVwiKTtcbiAgICB9XG5cbiAgICBsZXQgbWl4ZWQ7XG4gICAgaWYgKHNldHRpbmdXZWVrU3R1ZmYpIHtcbiAgICAgIG1peGVkID0gd2Vla1RvR3JlZ29yaWFuKFxuICAgICAgICB7IC4uLmdyZWdvcmlhblRvV2Vlayh0aGlzLmMsIG1pbkRheXNJbkZpcnN0V2Vlaywgc3RhcnRPZldlZWspLCAuLi5ub3JtYWxpemVkIH0sXG4gICAgICAgIG1pbkRheXNJbkZpcnN0V2VlayxcbiAgICAgICAgc3RhcnRPZldlZWtcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghaXNVbmRlZmluZWQobm9ybWFsaXplZC5vcmRpbmFsKSkge1xuICAgICAgbWl4ZWQgPSBvcmRpbmFsVG9HcmVnb3JpYW4oeyAuLi5ncmVnb3JpYW5Ub09yZGluYWwodGhpcy5jKSwgLi4ubm9ybWFsaXplZCB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWl4ZWQgPSB7IC4uLnRoaXMudG9PYmplY3QoKSwgLi4ubm9ybWFsaXplZCB9O1xuXG4gICAgICAvLyBpZiB3ZSBkaWRuJ3Qgc2V0IHRoZSBkYXkgYnV0IHdlIGVuZGVkIHVwIG9uIGFuIG92ZXJmbG93IGRhdGUsXG4gICAgICAvLyB1c2UgdGhlIGxhc3QgZGF5IG9mIHRoZSByaWdodCBtb250aFxuICAgICAgaWYgKGlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQuZGF5KSkge1xuICAgICAgICBtaXhlZC5kYXkgPSBNYXRoLm1pbihkYXlzSW5Nb250aChtaXhlZC55ZWFyLCBtaXhlZC5tb250aCksIG1peGVkLmRheSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgW3RzLCBvXSA9IG9ialRvVFMobWl4ZWQsIHRoaXMubywgdGhpcy56b25lKTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB0cywgbyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBwZXJpb2Qgb2YgdGltZSB0byB0aGlzIERhdGVUaW1lIGFuZCByZXR1cm4gdGhlIHJlc3VsdGluZyBEYXRlVGltZVxuICAgKlxuICAgKiBBZGRpbmcgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG9yIG1pbGxpc2Vjb25kcyBpbmNyZWFzZXMgdGhlIHRpbWVzdGFtcCBieSB0aGUgcmlnaHQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy4gQWRkaW5nIGRheXMsIG1vbnRocywgb3IgeWVhcnMgc2hpZnRzIHRoZSBjYWxlbmRhciwgYWNjb3VudGluZyBmb3IgRFNUcyBhbmQgbGVhcCB5ZWFycyBhbG9uZyB0aGUgd2F5LiBUaHVzLCBgZHQucGx1cyh7IGhvdXJzOiAyNCB9KWAgbWF5IHJlc3VsdCBpbiBhIGRpZmZlcmVudCB0aW1lIHRoYW4gYGR0LnBsdXMoeyBkYXlzOiAxIH0pYCBpZiB0aGVyZSdzIGEgRFNUIHNoaWZ0IGluIGJldHdlZW4uXG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSBUaGUgYW1vdW50IHRvIGFkZC4gRWl0aGVyIGEgTHV4b24gRHVyYXRpb24sIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgdGhlIG9iamVjdCBhcmd1bWVudCB0byBEdXJhdGlvbi5mcm9tT2JqZWN0KClcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cygxMjMpIC8vfj4gaW4gMTIzIG1pbGxpc2Vjb25kc1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgbWludXRlczogMTUgfSkgLy9+PiBpbiAxNSBtaW51dGVzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAxIH0pIC8vfj4gdGhpcyB0aW1lIHRvbW9ycm93XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAtMSB9KSAvL34+IHRoaXMgdGltZSB5ZXN0ZXJkYXlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGhvdXJzOiAzLCBtaW51dGVzOiAxMyB9KSAvL34+IGluIDMgaHIsIDEzIG1pblxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMywgbWludXRlczogMTMgfSkpIC8vfj4gaW4gMyBociwgMTMgbWluXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgcGx1cyhkdXJhdGlvbikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgYWRqdXN0VGltZSh0aGlzLCBkdXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJ0cmFjdCBhIHBlcmlvZCBvZiB0aW1lIHRvIHRoaXMgRGF0ZVRpbWUgYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lXG4gICAqIFNlZSB7QGxpbmsgRGF0ZVRpbWUjcGx1c31cbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbW91bnQgdG8gc3VidHJhY3QuIEVpdGhlciBhIEx1eG9uIER1cmF0aW9uLCBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIHRoZSBvYmplY3QgYXJndW1lbnQgdG8gRHVyYXRpb24uZnJvbU9iamVjdCgpXG4gICBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIG1pbnVzKGR1cmF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb24pLm5lZ2F0ZSgpO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCBhZGp1c3RUaW1lKHRoaXMsIGR1cikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhpcyBEYXRlVGltZSB0byB0aGUgYmVnaW5uaW5nIG9mIGEgdW5pdCBvZiB0aW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIFRoZSB1bml0IHRvIGdvIHRvIHRoZSBiZWdpbm5pbmcgb2YuIENhbiBiZSAneWVhcicsICdxdWFydGVyJywgJ21vbnRoJywgJ3dlZWsnLCAnZGF5JywgJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsIG9yICdtaWxsaXNlY29uZCcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnVzZUxvY2FsZVdlZWtzPWZhbHNlXSAtIElmIHRydWUsIHVzZSB3ZWVrcyBiYXNlZCBvbiB0aGUgbG9jYWxlLCBpLmUuIHVzZSB0aGUgbG9jYWxlLWRlcGVuZGVudCBzdGFydCBvZiB0aGUgd2Vla1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzKS5zdGFydE9mKCdtb250aCcpLnRvSVNPRGF0ZSgpOyAvLz0+ICcyMDE0LTAzLTAxJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzKS5zdGFydE9mKCd5ZWFyJykudG9JU09EYXRlKCk7IC8vPT4gJzIwMTQtMDEtMDEnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLnN0YXJ0T2YoJ3dlZWsnKS50b0lTT0RhdGUoKTsgLy89PiAnMjAxNC0wMy0wMycsIHdlZWtzIGFsd2F5cyBzdGFydCBvbiBNb25kYXlzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMsIDUsIDMwKS5zdGFydE9mKCdkYXknKS50b0lTT1RpbWUoKTsgLy89PiAnMDA6MDAuMDAwLTA1OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzLCA1LCAzMCkuc3RhcnRPZignaG91cicpLnRvSVNPVGltZSgpOyAvLz0+ICcwNTowMDowMC4wMDAtMDU6MDAnXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhcnRPZih1bml0LCB7IHVzZUxvY2FsZVdlZWtzID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuXG4gICAgY29uc3QgbyA9IHt9LFxuICAgICAgbm9ybWFsaXplZFVuaXQgPSBEdXJhdGlvbi5ub3JtYWxpemVVbml0KHVuaXQpO1xuICAgIHN3aXRjaCAobm9ybWFsaXplZFVuaXQpIHtcbiAgICAgIGNhc2UgXCJ5ZWFyc1wiOlxuICAgICAgICBvLm1vbnRoID0gMTtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgXCJxdWFydGVyc1wiOlxuICAgICAgY2FzZSBcIm1vbnRoc1wiOlxuICAgICAgICBvLmRheSA9IDE7XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIFwid2Vla3NcIjpcbiAgICAgIGNhc2UgXCJkYXlzXCI6XG4gICAgICAgIG8uaG91ciA9IDA7XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIFwiaG91cnNcIjpcbiAgICAgICAgby5taW51dGUgPSAwO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSBcIm1pbnV0ZXNcIjpcbiAgICAgICAgby5zZWNvbmQgPSAwO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSBcInNlY29uZHNcIjpcbiAgICAgICAgby5taWxsaXNlY29uZCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1pbGxpc2Vjb25kc1wiOlxuICAgICAgICBicmVhaztcbiAgICAgIC8vIG5vIGRlZmF1bHQsIGludmFsaWQgdW5pdHMgdGhyb3cgaW4gbm9ybWFsaXplVW5pdCgpXG4gICAgfVxuXG4gICAgaWYgKG5vcm1hbGl6ZWRVbml0ID09PSBcIndlZWtzXCIpIHtcbiAgICAgIGlmICh1c2VMb2NhbGVXZWVrcykge1xuICAgICAgICBjb25zdCBzdGFydE9mV2VlayA9IHRoaXMubG9jLmdldFN0YXJ0T2ZXZWVrKCk7XG4gICAgICAgIGNvbnN0IHsgd2Vla2RheSB9ID0gdGhpcztcbiAgICAgICAgaWYgKHdlZWtkYXkgPCBzdGFydE9mV2Vlaykge1xuICAgICAgICAgIG8ud2Vla051bWJlciA9IHRoaXMud2Vla051bWJlciAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgby53ZWVrZGF5ID0gc3RhcnRPZldlZWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvLndlZWtkYXkgPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChub3JtYWxpemVkVW5pdCA9PT0gXCJxdWFydGVyc1wiKSB7XG4gICAgICBjb25zdCBxID0gTWF0aC5jZWlsKHRoaXMubW9udGggLyAzKTtcbiAgICAgIG8ubW9udGggPSAocSAtIDEpICogMyArIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2V0KG8pO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhpcyBEYXRlVGltZSB0byB0aGUgZW5kIChtZWFuaW5nIHRoZSBsYXN0IG1pbGxpc2Vjb25kKSBvZiBhIHVuaXQgb2YgdGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIFRoZSB1bml0IHRvIGdvIHRvIHRoZSBlbmQgb2YuIENhbiBiZSAneWVhcicsICdxdWFydGVyJywgJ21vbnRoJywgJ3dlZWsnLCAnZGF5JywgJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsIG9yICdtaWxsaXNlY29uZCcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnVzZUxvY2FsZVdlZWtzPWZhbHNlXSAtIElmIHRydWUsIHVzZSB3ZWVrcyBiYXNlZCBvbiB0aGUgbG9jYWxlLCBpLmUuIHVzZSB0aGUgbG9jYWxlLWRlcGVuZGVudCBzdGFydCBvZiB0aGUgd2Vla1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzKS5lbmRPZignbW9udGgnKS50b0lTTygpOyAvLz0+ICcyMDE0LTAzLTMxVDIzOjU5OjU5Ljk5OS0wNTowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMykuZW5kT2YoJ3llYXInKS50b0lTTygpOyAvLz0+ICcyMDE0LTEyLTMxVDIzOjU5OjU5Ljk5OS0wNTowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMykuZW5kT2YoJ3dlZWsnKS50b0lTTygpOyAvLyA9PiAnMjAxNC0wMy0wOVQyMzo1OTo1OS45OTktMDU6MDAnLCB3ZWVrcyBzdGFydCBvbiBNb25kYXlzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMsIDUsIDMwKS5lbmRPZignZGF5JykudG9JU08oKTsgLy89PiAnMjAxNC0wMy0wM1QyMzo1OTo1OS45OTktMDU6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMsIDUsIDMwKS5lbmRPZignaG91cicpLnRvSVNPKCk7IC8vPT4gJzIwMTQtMDMtMDNUMDU6NTk6NTkuOTk5LTA1OjAwJ1xuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIGVuZE9mKHVuaXQsIG9wdHMpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkXG4gICAgICA/IHRoaXMucGx1cyh7IFt1bml0XTogMSB9KVxuICAgICAgICAgIC5zdGFydE9mKHVuaXQsIG9wdHMpXG4gICAgICAgICAgLm1pbnVzKDEpXG4gICAgICA6IHRoaXM7XG4gIH1cblxuICAvLyBPVVRQVVRcblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lIGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBmb3JtYXQgc3RyaW5nLlxuICAgKiAqKllvdSBtYXkgbm90IHdhbnQgdGhpcy4qKiBTZWUge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3IgYSBtb3JlIGZsZXhpYmxlIGZvcm1hdHRpbmcgdG9vbC4gRm9yIGEgdGFibGUgb2YgdG9rZW5zIGFuZCB0aGVpciBpbnRlcnByZXRhdGlvbnMsIHNlZSBbaGVyZV0oaHR0cHM6Ly9tb21lbnQuZ2l0aHViLmlvL2x1eG9uLyMvZm9ybWF0dGluZz9pZD10YWJsZS1vZi10b2tlbnMpLlxuICAgKiBEZWZhdWx0cyB0byBlbi1VUyBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkLCByZWdhcmRsZXNzIG9mIHRoZSBzeXN0ZW0ncyBsb2NhbGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmbXQgLSB0aGUgZm9ybWF0IHN0cmluZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdHMgdG8gb3ZlcnJpZGUgdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBvbiB0aGlzIERhdGVUaW1lXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvRm9ybWF0KCd5eXl5IExMTCBkZCcpIC8vPT4gJzIwMTcgQXByIDIyJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5zZXRMb2NhbGUoJ2ZyJykudG9Gb3JtYXQoJ3l5eXkgTExMIGRkJykgLy89PiAnMjAxNyBhdnIuIDIyJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0Zvcm1hdCgneXl5eSBMTEwgZGQnLCB7IGxvY2FsZTogXCJmclwiIH0pIC8vPT4gJzIwMTcgYXZyLiAyMidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Gb3JtYXQoXCJISCAnaG91cnMgYW5kJyBtbSAnbWludXRlcydcIikgLy89PiAnMjAgaG91cnMgYW5kIDU1IG1pbnV0ZXMnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvRm9ybWF0KGZtdCwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFxuICAgICAgPyBGb3JtYXR0ZXIuY3JlYXRlKHRoaXMubG9jLnJlZGVmYXVsdFRvRU4ob3B0cykpLmZvcm1hdERhdGVUaW1lRnJvbVN0cmluZyh0aGlzLCBmbXQpXG4gICAgICA6IElOVkFMSUQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxvY2FsaXplZCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoaXMgZGF0ZS4gQWNjZXB0cyB0aGUgc2FtZSBvcHRpb25zIGFzIHRoZSBJbnRsLkRhdGVUaW1lRm9ybWF0IGNvbnN0cnVjdG9yIGFuZCBhbnkgcHJlc2V0cyBkZWZpbmVkIGJ5IEx1eG9uLCBzdWNoIGFzIGBEYXRlVGltZS5EQVRFX0ZVTExgIG9yIGBEYXRlVGltZS5USU1FX1NJTVBMRWAuXG4gICAqIFRoZSBleGFjdCBiZWhhdmlvciBvZiB0aGlzIG1ldGhvZCBpcyBicm93c2VyLXNwZWNpZmljLCBidXQgaW4gZ2VuZXJhbCBpdCB3aWxsIHJldHVybiBhbiBhcHByb3ByaWF0ZSByZXByZXNlbnRhdGlvblxuICAgKiBvZiB0aGUgRGF0ZVRpbWUgaW4gdGhlIGFzc2lnbmVkIGxvY2FsZS5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZVRpbWVGb3JtYXRcbiAgICogQHBhcmFtIGZvcm1hdE9wdHMge09iamVjdH0gLSBJbnRsLkRhdGVUaW1lRm9ybWF0IGNvbnN0cnVjdG9yIG9wdGlvbnMgYW5kIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdHMgdG8gb3ZlcnJpZGUgdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBvbiB0aGlzIERhdGVUaW1lXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKCk7IC8vPT4gNC8yMC8yMDE3XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnNldExvY2FsZSgnZW4tZ2InKS50b0xvY2FsZVN0cmluZygpOyAvLz0+ICcyMC8wNC8yMDE3J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5EQVRFX0ZVTEwpOyAvLz0+ICdBcHJpbCAyMCwgMjAxNydcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuREFURV9GVUxMLCB7IGxvY2FsZTogJ2ZyJyB9KTsgLy89PiAnMjggYW9cdTAwRkJ0IDIwMjInXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLlRJTUVfU0lNUExFKTsgLy89PiAnMTE6MzIgQU0nXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLkRBVEVUSU1FX1NIT1JUKTsgLy89PiAnNC8yMC8yMDE3LCAxMTozMiBBTSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoeyB3ZWVrZGF5OiAnbG9uZycsIG1vbnRoOiAnbG9uZycsIGRheTogJzItZGlnaXQnIH0pOyAvLz0+ICdUaHVyc2RheSwgQXByaWwgMjAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKHsgd2Vla2RheTogJ3Nob3J0JywgbW9udGg6ICdzaG9ydCcsIGRheTogJzItZGlnaXQnLCBob3VyOiAnMi1kaWdpdCcsIG1pbnV0ZTogJzItZGlnaXQnIH0pOyAvLz0+ICdUaHUsIEFwciAyMCwgMTE6MjcgQU0nXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKHsgaG91cjogJzItZGlnaXQnLCBtaW51dGU6ICcyLWRpZ2l0JywgaG91ckN5Y2xlOiAnaDIzJyB9KTsgLy89PiAnMTE6MzInXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvTG9jYWxlU3RyaW5nKGZvcm1hdE9wdHMgPSBGb3JtYXRzLkRBVEVfU0hPUlQsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRcbiAgICAgID8gRm9ybWF0dGVyLmNyZWF0ZSh0aGlzLmxvYy5jbG9uZShvcHRzKSwgZm9ybWF0T3B0cykuZm9ybWF0RGF0ZVRpbWUodGhpcylcbiAgICAgIDogSU5WQUxJRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGZvcm1hdCBcInBhcnRzXCIsIG1lYW5pbmcgaW5kaXZpZHVhbCB0b2tlbnMgYWxvbmcgd2l0aCBtZXRhZGF0YS4gVGhpcyBpcyBhbGxvd3MgY2FsbGVycyB0byBwb3N0LXByb2Nlc3MgaW5kaXZpZHVhbCBzZWN0aW9ucyBvZiB0aGUgZm9ybWF0dGVkIG91dHB1dC5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZVRpbWVGb3JtYXQvZm9ybWF0VG9QYXJ0c1xuICAgKiBAcGFyYW0gb3B0cyB7T2JqZWN0fSAtIEludGwuRGF0ZVRpbWVGb3JtYXQgY29uc3RydWN0b3Igb3B0aW9ucywgc2FtZSBhcyBgdG9Mb2NhbGVTdHJpbmdgLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVBhcnRzKCk7IC8vPT4gW1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PiAgIHsgdHlwZTogJ2RheScsIHZhbHVlOiAnMjUnIH0sXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLz0+ICAgeyB0eXBlOiAnbGl0ZXJhbCcsIHZhbHVlOiAnLycgfSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT4gICB7IHR5cGU6ICdtb250aCcsIHZhbHVlOiAnMDUnIH0sXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLz0+ICAgeyB0eXBlOiAnbGl0ZXJhbCcsIHZhbHVlOiAnLycgfSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT4gICB7IHR5cGU6ICd5ZWFyJywgdmFsdWU6ICcxOTgyJyB9XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLz0+IF1cbiAgICovXG4gIHRvTG9jYWxlUGFydHMob3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFxuICAgICAgPyBGb3JtYXR0ZXIuY3JlYXRlKHRoaXMubG9jLmNsb25lKG9wdHMpLCBvcHRzKS5mb3JtYXREYXRlVGltZVBhcnRzKHRoaXMpXG4gICAgICA6IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnN1cHByZXNzTWlsbGlzZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgbWlsbGlzZWNvbmRzIGZyb20gdGhlIGZvcm1hdCBpZiB0aGV5J3JlIDBcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc1NlY29uZHM9ZmFsc2VdIC0gZXhjbHVkZSBzZWNvbmRzIGZyb20gdGhlIGZvcm1hdCBpZiB0aGV5J3JlIDBcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlT2Zmc2V0PXRydWVdIC0gaW5jbHVkZSB0aGUgb2Zmc2V0LCBzdWNoIGFzICdaJyBvciAnLTA0OjAwJ1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmV4dGVuZGVkWm9uZT1mYWxzZV0gLSBhZGQgdGhlIHRpbWUgem9uZSBmb3JtYXQgZXh0ZW5zaW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5mb3JtYXQ9J2V4dGVuZGVkJ10gLSBjaG9vc2UgYmV0d2VlbiB0aGUgYmFzaWMgYW5kIGV4dGVuZGVkIGZvcm1hdFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMTk4MywgNSwgMjUpLnRvSVNPKCkgLy89PiAnMTk4Mi0wNS0yNVQwMDowMDowMC4wMDBaJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0lTTygpIC8vPT4gJzIwMTctMDQtMjJUMjA6NDc6MDUuMzM1LTA0OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0lTTyh7IGluY2x1ZGVPZmZzZXQ6IGZhbHNlIH0pIC8vPT4gJzIwMTctMDQtMjJUMjA6NDc6MDUuMzM1J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0lTTyh7IGZvcm1hdDogJ2Jhc2ljJyB9KSAvLz0+ICcyMDE3MDQyMlQyMDQ3MDUuMzM1LTA0MDAnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPKHtcbiAgICBmb3JtYXQgPSBcImV4dGVuZGVkXCIsXG4gICAgc3VwcHJlc3NTZWNvbmRzID0gZmFsc2UsXG4gICAgc3VwcHJlc3NNaWxsaXNlY29uZHMgPSBmYWxzZSxcbiAgICBpbmNsdWRlT2Zmc2V0ID0gdHJ1ZSxcbiAgICBleHRlbmRlZFpvbmUgPSBmYWxzZSxcbiAgfSA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGV4dCA9IGZvcm1hdCA9PT0gXCJleHRlbmRlZFwiO1xuXG4gICAgbGV0IGMgPSB0b0lTT0RhdGUodGhpcywgZXh0KTtcbiAgICBjICs9IFwiVFwiO1xuICAgIGMgKz0gdG9JU09UaW1lKHRoaXMsIGV4dCwgc3VwcHJlc3NTZWNvbmRzLCBzdXBwcmVzc01pbGxpc2Vjb25kcywgaW5jbHVkZU9mZnNldCwgZXh0ZW5kZWRab25lKTtcbiAgICByZXR1cm4gYztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSdzIGRhdGUgY29tcG9uZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuZm9ybWF0PSdleHRlbmRlZCddIC0gY2hvb3NlIGJldHdlZW4gdGhlIGJhc2ljIGFuZCBleHRlbmRlZCBmb3JtYXRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDE5ODIsIDUsIDI1KS50b0lTT0RhdGUoKSAvLz0+ICcxOTgyLTA1LTI1J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMTk4MiwgNSwgMjUpLnRvSVNPRGF0ZSh7IGZvcm1hdDogJ2Jhc2ljJyB9KSAvLz0+ICcxOTgyMDUyNSdcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU09EYXRlKHsgZm9ybWF0ID0gXCJleHRlbmRlZFwiIH0gPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9JU09EYXRlKHRoaXMsIGZvcm1hdCA9PT0gXCJleHRlbmRlZFwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSdzIHdlZWsgZGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMTk4MiwgNSwgMjUpLnRvSVNPV2Vla0RhdGUoKSAvLz0+ICcxOTgyLVcyMS0yJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTT1dlZWtEYXRlKCkge1xuICAgIHJldHVybiB0b1RlY2hGb3JtYXQodGhpcywgXCJra2trLSdXJ1dXLWNcIik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUncyB0aW1lIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc01pbGxpc2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIG1pbGxpc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NTZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldD10cnVlXSAtIGluY2x1ZGUgdGhlIG9mZnNldCwgc3VjaCBhcyAnWicgb3IgJy0wNDowMCdcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5leHRlbmRlZFpvbmU9dHJ1ZV0gLSBhZGQgdGhlIHRpbWUgem9uZSBmb3JtYXQgZXh0ZW5zaW9uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZVByZWZpeD1mYWxzZV0gLSBpbmNsdWRlIHRoZSBgVGAgcHJlZml4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5mb3JtYXQ9J2V4dGVuZGVkJ10gLSBjaG9vc2UgYmV0d2VlbiB0aGUgYmFzaWMgYW5kIGV4dGVuZGVkIGZvcm1hdFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS5zZXQoeyBob3VyOiA3LCBtaW51dGU6IDM0IH0pLnRvSVNPVGltZSgpIC8vPT4gJzA3OjM0OjE5LjM2MVonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLnNldCh7IGhvdXI6IDcsIG1pbnV0ZTogMzQsIHNlY29uZHM6IDAsIG1pbGxpc2Vjb25kczogMCB9KS50b0lTT1RpbWUoeyBzdXBwcmVzc1NlY29uZHM6IHRydWUgfSkgLy89PiAnMDc6MzRaJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS5zZXQoeyBob3VyOiA3LCBtaW51dGU6IDM0IH0pLnRvSVNPVGltZSh7IGZvcm1hdDogJ2Jhc2ljJyB9KSAvLz0+ICcwNzM0MTkuMzYxWidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkuc2V0KHsgaG91cjogNywgbWludXRlOiAzNCB9KS50b0lTT1RpbWUoeyBpbmNsdWRlUHJlZml4OiB0cnVlIH0pIC8vPT4gJ1QwNzozNDoxOS4zNjFaJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTT1RpbWUoe1xuICAgIHN1cHByZXNzTWlsbGlzZWNvbmRzID0gZmFsc2UsXG4gICAgc3VwcHJlc3NTZWNvbmRzID0gZmFsc2UsXG4gICAgaW5jbHVkZU9mZnNldCA9IHRydWUsXG4gICAgaW5jbHVkZVByZWZpeCA9IGZhbHNlLFxuICAgIGV4dGVuZGVkWm9uZSA9IGZhbHNlLFxuICAgIGZvcm1hdCA9IFwiZXh0ZW5kZWRcIixcbiAgfSA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxldCBjID0gaW5jbHVkZVByZWZpeCA/IFwiVFwiIDogXCJcIjtcbiAgICByZXR1cm4gKFxuICAgICAgYyArXG4gICAgICB0b0lTT1RpbWUoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIGZvcm1hdCA9PT0gXCJleHRlbmRlZFwiLFxuICAgICAgICBzdXBwcmVzc1NlY29uZHMsXG4gICAgICAgIHN1cHByZXNzTWlsbGlzZWNvbmRzLFxuICAgICAgICBpbmNsdWRlT2Zmc2V0LFxuICAgICAgICBleHRlbmRlZFpvbmVcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gUkZDIDI4MjItY29tcGF0aWJsZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNCwgNywgMTMpLnRvUkZDMjgyMigpIC8vPT4gJ1N1biwgMTMgSnVsIDIwMTQgMDA6MDA6MDAgKzAwMDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDcsIDEzKS50b1JGQzI4MjIoKSAvLz0+ICdTdW4sIDEzIEp1bCAyMDE0IDAwOjAwOjAwIC0wNDAwJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1JGQzI4MjIoKSB7XG4gICAgcmV0dXJuIHRvVGVjaEZvcm1hdCh0aGlzLCBcIkVFRSwgZGQgTExMIHl5eXkgSEg6bW06c3MgWlpaXCIsIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBIVFRQIGhlYWRlcnMuIFRoZSBvdXRwdXQgaXMgYWx3YXlzIGV4cHJlc3NlZCBpbiBHTVQuXG4gICAqIFNwZWNpZmljYWxseSwgdGhlIHN0cmluZyBjb25mb3JtcyB0byBSRkMgMTEyMy5cbiAgICogQHNlZSBodHRwczovL3d3dy53My5vcmcvUHJvdG9jb2xzL3JmYzI2MTYvcmZjMjYxNi1zZWMzLmh0bWwjc2VjMy4zLjFcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTQsIDcsIDEzKS50b0hUVFAoKSAvLz0+ICdTdW4sIDEzIEp1bCAyMDE0IDAwOjAwOjAwIEdNVCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTQsIDcsIDEzLCAxOSkudG9IVFRQKCkgLy89PiAnU3VuLCAxMyBKdWwgMjAxNCAxOTowMDowMCBHTVQnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSFRUUCgpIHtcbiAgICByZXR1cm4gdG9UZWNoRm9ybWF0KHRoaXMudG9VVEMoKSwgXCJFRUUsIGRkIExMTCB5eXl5IEhIOm1tOnNzICdHTVQnXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIFNRTCBEYXRlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE0LCA3LCAxMykudG9TUUxEYXRlKCkgLy89PiAnMjAxNC0wNy0xMydcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9TUUxEYXRlKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRvSVNPRGF0ZSh0aGlzLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBTUUwgVGltZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlWm9uZT1mYWxzZV0gLSBpbmNsdWRlIHRoZSB6b25lLCBzdWNoIGFzICdBbWVyaWNhL05ld19Zb3JrJy4gT3ZlcnJpZGVzIGluY2x1ZGVPZmZzZXQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldD10cnVlXSAtIGluY2x1ZGUgdGhlIG9mZnNldCwgc3VjaCBhcyAnWicgb3IgJy0wNDowMCdcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlT2Zmc2V0U3BhY2U9dHJ1ZV0gLSBpbmNsdWRlIHRoZSBzcGFjZSBiZXR3ZWVuIHRoZSB0aW1lIGFuZCB0aGUgb2Zmc2V0LCBzdWNoIGFzICcwNToxNToxNi4zNDUgLTA0OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS50b1NRTCgpIC8vPT4gJzA1OjE1OjE2LjM0NSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9TUUwoKSAvLz0+ICcwNToxNToxNi4zNDUgLTA0OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b1NRTCh7IGluY2x1ZGVPZmZzZXQ6IGZhbHNlIH0pIC8vPT4gJzA1OjE1OjE2LjM0NSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9TUUwoeyBpbmNsdWRlWm9uZTogZmFsc2UgfSkgLy89PiAnMDU6MTU6MTYuMzQ1IEFtZXJpY2EvTmV3X1lvcmsnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU1FMVGltZSh7IGluY2x1ZGVPZmZzZXQgPSB0cnVlLCBpbmNsdWRlWm9uZSA9IGZhbHNlLCBpbmNsdWRlT2Zmc2V0U3BhY2UgPSB0cnVlIH0gPSB7fSkge1xuICAgIGxldCBmbXQgPSBcIkhIOm1tOnNzLlNTU1wiO1xuXG4gICAgaWYgKGluY2x1ZGVab25lIHx8IGluY2x1ZGVPZmZzZXQpIHtcbiAgICAgIGlmIChpbmNsdWRlT2Zmc2V0U3BhY2UpIHtcbiAgICAgICAgZm10ICs9IFwiIFwiO1xuICAgICAgfVxuICAgICAgaWYgKGluY2x1ZGVab25lKSB7XG4gICAgICAgIGZtdCArPSBcInpcIjtcbiAgICAgIH0gZWxzZSBpZiAoaW5jbHVkZU9mZnNldCkge1xuICAgICAgICBmbXQgKz0gXCJaWlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0b1RlY2hGb3JtYXQodGhpcywgZm10LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBTUUwgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZVpvbmU9ZmFsc2VdIC0gaW5jbHVkZSB0aGUgem9uZSwgc3VjaCBhcyAnQW1lcmljYS9OZXdfWW9yaycuIE92ZXJyaWRlcyBpbmNsdWRlT2Zmc2V0LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVPZmZzZXQ9dHJ1ZV0gLSBpbmNsdWRlIHRoZSBvZmZzZXQsIHN1Y2ggYXMgJ1onIG9yICctMDQ6MDAnXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldFNwYWNlPXRydWVdIC0gaW5jbHVkZSB0aGUgc3BhY2UgYmV0d2VlbiB0aGUgdGltZSBhbmQgdGhlIG9mZnNldCwgc3VjaCBhcyAnMDU6MTU6MTYuMzQ1IC0wNDowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTQsIDcsIDEzKS50b1NRTCgpIC8vPT4gJzIwMTQtMDctMTMgMDA6MDA6MDAuMDAwIFonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDcsIDEzKS50b1NRTCgpIC8vPT4gJzIwMTQtMDctMTMgMDA6MDA6MDAuMDAwIC0wNDowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgNywgMTMpLnRvU1FMKHsgaW5jbHVkZU9mZnNldDogZmFsc2UgfSkgLy89PiAnMjAxNC0wNy0xMyAwMDowMDowMC4wMDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDcsIDEzKS50b1NRTCh7IGluY2x1ZGVab25lOiB0cnVlIH0pIC8vPT4gJzIwMTQtMDctMTMgMDA6MDA6MDAuMDAwIEFtZXJpY2EvTmV3X1lvcmsnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU1FMKG9wdHMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gYCR7dGhpcy50b1NRTERhdGUoKX0gJHt0aGlzLnRvU1FMVGltZShvcHRzKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgZGVidWdnaW5nXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnRvSVNPKCkgOiBJTlZBTElEO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgdGhlIFJFUEwuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIFtTeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIildKCkge1xuICAgIGlmICh0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBgRGF0ZVRpbWUgeyB0czogJHt0aGlzLnRvSVNPKCl9LCB6b25lOiAke3RoaXMuem9uZS5uYW1lfSwgbG9jYWxlOiAke3RoaXMubG9jYWxlfSB9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGBEYXRlVGltZSB7IEludmFsaWQsIHJlYXNvbjogJHt0aGlzLmludmFsaWRSZWFzb259IH1gO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlcG9jaCBtaWxsaXNlY29uZHMgb2YgdGhpcyBEYXRlVGltZS4gQWxpYXMgb2Yge0BsaW5rIERhdGVUaW1lI3RvTWlsbGlzfVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICB2YWx1ZU9mKCkge1xuICAgIHJldHVybiB0aGlzLnRvTWlsbGlzKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZXBvY2ggbWlsbGlzZWNvbmRzIG9mIHRoaXMgRGF0ZVRpbWUuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHRvTWlsbGlzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnRzIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVwb2NoIHNlY29uZHMgb2YgdGhpcyBEYXRlVGltZS5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgdG9TZWNvbmRzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnRzIC8gMTAwMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlcG9jaCBzZWNvbmRzIChhcyBhIHdob2xlIG51bWJlcikgb2YgdGhpcyBEYXRlVGltZS5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgdG9Vbml4SW50ZWdlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gTWF0aC5mbG9vcih0aGlzLnRzIC8gMTAwMCkgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lIGFwcHJvcHJpYXRlIGZvciB1c2UgaW4gSlNPTi5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvSVNPKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIEJTT04gc2VyaWFsaXphYmxlIGVxdWl2YWxlbnQgdG8gdGhpcyBEYXRlVGltZS5cbiAgICogQHJldHVybiB7RGF0ZX1cbiAgICovXG4gIHRvQlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b0pTRGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBKYXZhU2NyaXB0IG9iamVjdCB3aXRoIHRoaXMgRGF0ZVRpbWUncyB5ZWFyLCBtb250aCwgZGF5LCBhbmQgc28gb24uXG4gICAqIEBwYXJhbSBvcHRzIC0gb3B0aW9ucyBmb3IgZ2VuZXJhdGluZyB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZUNvbmZpZz1mYWxzZV0gLSBpbmNsdWRlIGNvbmZpZ3VyYXRpb24gYXR0cmlidXRlcyBpbiB0aGUgb3V0cHV0XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvT2JqZWN0KCkgLy89PiB7IHllYXI6IDIwMTcsIG1vbnRoOiA0LCBkYXk6IDIyLCBob3VyOiAyMCwgbWludXRlOiA0OSwgc2Vjb25kOiA0MiwgbWlsbGlzZWNvbmQ6IDI2OCB9XG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHRvT2JqZWN0KG9wdHMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4ge307XG5cbiAgICBjb25zdCBiYXNlID0geyAuLi50aGlzLmMgfTtcblxuICAgIGlmIChvcHRzLmluY2x1ZGVDb25maWcpIHtcbiAgICAgIGJhc2Uub3V0cHV0Q2FsZW5kYXIgPSB0aGlzLm91dHB1dENhbGVuZGFyO1xuICAgICAgYmFzZS5udW1iZXJpbmdTeXN0ZW0gPSB0aGlzLmxvYy5udW1iZXJpbmdTeXN0ZW07XG4gICAgICBiYXNlLmxvY2FsZSA9IHRoaXMubG9jLmxvY2FsZTtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIEphdmFTY3JpcHQgRGF0ZSBlcXVpdmFsZW50IHRvIHRoaXMgRGF0ZVRpbWUuXG4gICAqIEByZXR1cm4ge0RhdGV9XG4gICAqL1xuICB0b0pTRGF0ZSgpIHtcbiAgICByZXR1cm4gbmV3IERhdGUodGhpcy5pc1ZhbGlkID8gdGhpcy50cyA6IE5hTik7XG4gIH1cblxuICAvLyBDT01QQVJFXG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBEYXRlVGltZXMgYXMgYSBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gb3RoZXJEYXRlVGltZSAtIHRoZSBEYXRlVGltZSB0byBjb21wYXJlIHRoaXMgb25lIHRvXG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBbdW5pdD1bJ21pbGxpc2Vjb25kcyddXSAtIHRoZSB1bml0IG9yIGFycmF5IG9mIHVuaXRzIChzdWNoIGFzICdob3Vycycgb3IgJ2RheXMnKSB0byBpbmNsdWRlIGluIHRoZSBkdXJhdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBjcmVhdGlvbiBvZiB0aGUgRHVyYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBpMSA9IERhdGVUaW1lLmZyb21JU08oJzE5ODItMDUtMjVUMDk6NDUnKSxcbiAgICogICAgIGkyID0gRGF0ZVRpbWUuZnJvbUlTTygnMTk4My0xMC0xNFQxMDozMCcpO1xuICAgKiBpMi5kaWZmKGkxKS50b09iamVjdCgpIC8vPT4geyBtaWxsaXNlY29uZHM6IDQzODA3NTAwMDAwIH1cbiAgICogaTIuZGlmZihpMSwgJ2hvdXJzJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDEyMTY4Ljc1IH1cbiAgICogaTIuZGlmZihpMSwgWydtb250aHMnLCAnZGF5cyddKS50b09iamVjdCgpIC8vPT4geyBtb250aHM6IDE2LCBkYXlzOiAxOS4wMzEyNSB9XG4gICAqIGkyLmRpZmYoaTEsIFsnbW9udGhzJywgJ2RheXMnLCAnaG91cnMnXSkudG9PYmplY3QoKSAvLz0+IHsgbW9udGhzOiAxNiwgZGF5czogMTksIGhvdXJzOiAwLjc1IH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBkaWZmKG90aGVyRGF0ZVRpbWUsIHVuaXQgPSBcIm1pbGxpc2Vjb25kc1wiLCBvcHRzID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCB8fCAhb3RoZXJEYXRlVGltZS5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uaW52YWxpZChcImNyZWF0ZWQgYnkgZGlmZmluZyBhbiBpbnZhbGlkIERhdGVUaW1lXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGR1ck9wdHMgPSB7IGxvY2FsZTogdGhpcy5sb2NhbGUsIG51bWJlcmluZ1N5c3RlbTogdGhpcy5udW1iZXJpbmdTeXN0ZW0sIC4uLm9wdHMgfTtcblxuICAgIGNvbnN0IHVuaXRzID0gbWF5YmVBcnJheSh1bml0KS5tYXAoRHVyYXRpb24ubm9ybWFsaXplVW5pdCksXG4gICAgICBvdGhlcklzTGF0ZXIgPSBvdGhlckRhdGVUaW1lLnZhbHVlT2YoKSA+IHRoaXMudmFsdWVPZigpLFxuICAgICAgZWFybGllciA9IG90aGVySXNMYXRlciA/IHRoaXMgOiBvdGhlckRhdGVUaW1lLFxuICAgICAgbGF0ZXIgPSBvdGhlcklzTGF0ZXIgPyBvdGhlckRhdGVUaW1lIDogdGhpcyxcbiAgICAgIGRpZmZlZCA9IGRpZmYoZWFybGllciwgbGF0ZXIsIHVuaXRzLCBkdXJPcHRzKTtcblxuICAgIHJldHVybiBvdGhlcklzTGF0ZXIgPyBkaWZmZWQubmVnYXRlKCkgOiBkaWZmZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhpcyBEYXRlVGltZSBhbmQgcmlnaHQgbm93LlxuICAgKiBTZWUge0BsaW5rIERhdGVUaW1lI2RpZmZ9XG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBbdW5pdD1bJ21pbGxpc2Vjb25kcyddXSAtIHRoZSB1bml0IG9yIHVuaXRzIHVuaXRzIChzdWNoIGFzICdob3Vycycgb3IgJ2RheXMnKSB0byBpbmNsdWRlIGluIHRoZSBkdXJhdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdGhhdCBhZmZlY3QgdGhlIGNyZWF0aW9uIG9mIHRoZSBEdXJhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBkaWZmTm93KHVuaXQgPSBcIm1pbGxpc2Vjb25kc1wiLCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5kaWZmKERhdGVUaW1lLm5vdygpLCB1bml0LCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gSW50ZXJ2YWwgc3Bhbm5pbmcgYmV0d2VlbiB0aGlzIERhdGVUaW1lIGFuZCBhbm90aGVyIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IG90aGVyRGF0ZVRpbWUgLSB0aGUgb3RoZXIgZW5kIHBvaW50IG9mIHRoZSBJbnRlcnZhbFxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHVudGlsKG90aGVyRGF0ZVRpbWUpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyh0aGlzLCBvdGhlckRhdGVUaW1lKSA6IHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBEYXRlVGltZSBpcyBpbiB0aGUgc2FtZSB1bml0IG9mIHRpbWUgYXMgYW5vdGhlciBEYXRlVGltZS5cbiAgICogSGlnaGVyLW9yZGVyIHVuaXRzIG11c3QgYWxzbyBiZSBpZGVudGljYWwgZm9yIHRoaXMgZnVuY3Rpb24gdG8gcmV0dXJuIGB0cnVlYC5cbiAgICogTm90ZSB0aGF0IHRpbWUgem9uZXMgYXJlICoqaWdub3JlZCoqIGluIHRoaXMgY29tcGFyaXNvbiwgd2hpY2ggY29tcGFyZXMgdGhlICoqbG9jYWwqKiBjYWxlbmRhciB0aW1lLiBVc2Uge0BsaW5rIERhdGVUaW1lI3NldFpvbmV9IHRvIGNvbnZlcnQgb25lIG9mIHRoZSBkYXRlcyBpZiBuZWVkZWQuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IG90aGVyRGF0ZVRpbWUgLSB0aGUgb3RoZXIgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSB0aGUgdW5pdCBvZiB0aW1lIHRvIGNoZWNrIHNhbWVuZXNzIG9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnVzZUxvY2FsZVdlZWtzPWZhbHNlXSAtIElmIHRydWUsIHVzZSB3ZWVrcyBiYXNlZCBvbiB0aGUgbG9jYWxlLCBpLmUuIHVzZSB0aGUgbG9jYWxlLWRlcGVuZGVudCBzdGFydCBvZiB0aGUgd2Vlazsgb25seSB0aGUgbG9jYWxlIG9mIHRoaXMgRGF0ZVRpbWUgaXMgdXNlZFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5oYXNTYW1lKG90aGVyRFQsICdkYXknKTsgLy9+PiB0cnVlIGlmIG90aGVyRFQgaXMgaW4gdGhlIHNhbWUgY3VycmVudCBjYWxlbmRhciBkYXlcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc1NhbWUob3RoZXJEYXRlVGltZSwgdW5pdCwgb3B0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG5cbiAgICBjb25zdCBpbnB1dE1zID0gb3RoZXJEYXRlVGltZS52YWx1ZU9mKCk7XG4gICAgY29uc3QgYWRqdXN0ZWRUb1pvbmUgPSB0aGlzLnNldFpvbmUob3RoZXJEYXRlVGltZS56b25lLCB7IGtlZXBMb2NhbFRpbWU6IHRydWUgfSk7XG4gICAgcmV0dXJuIChcbiAgICAgIGFkanVzdGVkVG9ab25lLnN0YXJ0T2YodW5pdCwgb3B0cykgPD0gaW5wdXRNcyAmJiBpbnB1dE1zIDw9IGFkanVzdGVkVG9ab25lLmVuZE9mKHVuaXQsIG9wdHMpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFcXVhbGl0eSBjaGVja1xuICAgKiBUd28gRGF0ZVRpbWVzIGFyZSBlcXVhbCBpZiBhbmQgb25seSBpZiB0aGV5IHJlcHJlc2VudCB0aGUgc2FtZSBtaWxsaXNlY29uZCwgaGF2ZSB0aGUgc2FtZSB6b25lIGFuZCBsb2NhdGlvbiwgYW5kIGFyZSBib3RoIHZhbGlkLlxuICAgKiBUbyBjb21wYXJlIGp1c3QgdGhlIG1pbGxpc2Vjb25kIHZhbHVlcywgdXNlIGArZHQxID09PSArZHQyYC5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gb3RoZXIgLSB0aGUgb3RoZXIgRGF0ZVRpbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmlzVmFsaWQgJiZcbiAgICAgIG90aGVyLmlzVmFsaWQgJiZcbiAgICAgIHRoaXMudmFsdWVPZigpID09PSBvdGhlci52YWx1ZU9mKCkgJiZcbiAgICAgIHRoaXMuem9uZS5lcXVhbHMob3RoZXIuem9uZSkgJiZcbiAgICAgIHRoaXMubG9jLmVxdWFscyhvdGhlci5sb2MpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdGhpcyB0aW1lIHJlbGF0aXZlIHRvIG5vdywgc3VjaCBhcyBcImluIHR3byBkYXlzXCIuIENhbiBvbmx5IGludGVybmF0aW9uYWxpemUgaWYgeW91clxuICAgKiBwbGF0Zm9ybSBzdXBwb3J0cyBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdC4gUm91bmRzIGRvd24gYnkgZGVmYXVsdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBvdXRwdXRcbiAgICogQHBhcmFtIHtEYXRlVGltZX0gW29wdGlvbnMuYmFzZT1EYXRlVGltZS5ub3coKV0gLSB0aGUgRGF0ZVRpbWUgdG8gdXNlIGFzIHRoZSBiYXNpcyB0byB3aGljaCB0aGlzIHRpbWUgaXMgY29tcGFyZWQuIERlZmF1bHRzIHRvIG5vdy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnN0eWxlPVwibG9uZ1wiXSAtIHRoZSBzdHlsZSBvZiB1bml0cywgbXVzdCBiZSBcImxvbmdcIiwgXCJzaG9ydFwiLCBvciBcIm5hcnJvd1wiXG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBvcHRpb25zLnVuaXQgLSB1c2UgYSBzcGVjaWZpYyB1bml0IG9yIGFycmF5IG9mIHVuaXRzOyBpZiBvbWl0dGVkLCBvciBhbiBhcnJheSwgdGhlIG1ldGhvZCB3aWxsIHBpY2sgdGhlIGJlc3QgdW5pdC4gVXNlIGFuIGFycmF5IG9yIG9uZSBvZiBcInllYXJzXCIsIFwicXVhcnRlcnNcIiwgXCJtb250aHNcIiwgXCJ3ZWVrc1wiLCBcImRheXNcIiwgXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgb3IgXCJzZWNvbmRzXCJcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yb3VuZD10cnVlXSAtIHdoZXRoZXIgdG8gcm91bmQgdGhlIG51bWJlcnMgaW4gdGhlIG91dHB1dC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnBhZGRpbmc9MF0gLSBwYWRkaW5nIGluIG1pbGxpc2Vjb25kcy4gVGhpcyBhbGxvd3MgeW91IHRvIHJvdW5kIHVwIHRoZSByZXN1bHQgaWYgaXQgZml0cyBpbnNpZGUgdGhlIHRocmVzaG9sZC4gRG9uJ3QgdXNlIGluIGNvbWJpbmF0aW9uIHdpdGgge3JvdW5kOiBmYWxzZX0gYmVjYXVzZSB0aGUgZGVjaW1hbCBvdXRwdXQgd2lsbCBpbmNsdWRlIHRoZSBwYWRkaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5sb2NhbGUgLSBvdmVycmlkZSB0aGUgbG9jYWxlIG9mIHRoaXMgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubnVtYmVyaW5nU3lzdGVtIC0gb3ZlcnJpZGUgdGhlIG51bWJlcmluZ1N5c3RlbSBvZiB0aGlzIERhdGVUaW1lLiBUaGUgSW50bCBzeXN0ZW0gbWF5IGNob29zZSBub3QgdG8gaG9ub3IgdGhpc1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgZGF5czogMSB9KS50b1JlbGF0aXZlKCkgLy89PiBcImluIDEgZGF5XCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkuc2V0TG9jYWxlKFwiZXNcIikudG9SZWxhdGl2ZSh7IGRheXM6IDEgfSkgLy89PiBcImRlbnRybyBkZSAxIGRcdTAwRURhXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGRheXM6IDEgfSkudG9SZWxhdGl2ZSh7IGxvY2FsZTogXCJmclwiIH0pIC8vPT4gXCJkYW5zIDIzIGhldXJlc1wiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLm1pbnVzKHsgZGF5czogMiB9KS50b1JlbGF0aXZlKCkgLy89PiBcIjIgZGF5cyBhZ29cIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5taW51cyh7IGRheXM6IDIgfSkudG9SZWxhdGl2ZSh7IHVuaXQ6IFwiaG91cnNcIiB9KSAvLz0+IFwiNDggaG91cnMgYWdvXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkubWludXMoeyBob3VyczogMzYgfSkudG9SZWxhdGl2ZSh7IHJvdW5kOiBmYWxzZSB9KSAvLz0+IFwiMS41IGRheXMgYWdvXCJcbiAgICovXG4gIHRvUmVsYXRpdmUob3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGJhc2UgPSBvcHRpb25zLmJhc2UgfHwgRGF0ZVRpbWUuZnJvbU9iamVjdCh7fSwgeyB6b25lOiB0aGlzLnpvbmUgfSksXG4gICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nID8gKHRoaXMgPCBiYXNlID8gLW9wdGlvbnMucGFkZGluZyA6IG9wdGlvbnMucGFkZGluZykgOiAwO1xuICAgIGxldCB1bml0cyA9IFtcInllYXJzXCIsIFwibW9udGhzXCIsIFwiZGF5c1wiLCBcImhvdXJzXCIsIFwibWludXRlc1wiLCBcInNlY29uZHNcIl07XG4gICAgbGV0IHVuaXQgPSBvcHRpb25zLnVuaXQ7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy51bml0KSkge1xuICAgICAgdW5pdHMgPSBvcHRpb25zLnVuaXQ7XG4gICAgICB1bml0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gZGlmZlJlbGF0aXZlKGJhc2UsIHRoaXMucGx1cyhwYWRkaW5nKSwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIG51bWVyaWM6IFwiYWx3YXlzXCIsXG4gICAgICB1bml0cyxcbiAgICAgIHVuaXQsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGRhdGUgcmVsYXRpdmUgdG8gdG9kYXksIHN1Y2ggYXMgXCJ5ZXN0ZXJkYXlcIiBvciBcIm5leHQgbW9udGhcIi5cbiAgICogT25seSBpbnRlcm5hdGlvbmFsaXplcyBvbiBwbGF0Zm9ybXMgdGhhdCBzdXBwb3J0cyBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBvdXRwdXRcbiAgICogQHBhcmFtIHtEYXRlVGltZX0gW29wdGlvbnMuYmFzZT1EYXRlVGltZS5ub3coKV0gLSB0aGUgRGF0ZVRpbWUgdG8gdXNlIGFzIHRoZSBiYXNpcyB0byB3aGljaCB0aGlzIHRpbWUgaXMgY29tcGFyZWQuIERlZmF1bHRzIHRvIG5vdy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubG9jYWxlIC0gb3ZlcnJpZGUgdGhlIGxvY2FsZSBvZiB0aGlzIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnVuaXQgLSB1c2UgYSBzcGVjaWZpYyB1bml0OyBpZiBvbWl0dGVkLCB0aGUgbWV0aG9kIHdpbGwgcGljayB0aGUgdW5pdC4gVXNlIG9uZSBvZiBcInllYXJzXCIsIFwicXVhcnRlcnNcIiwgXCJtb250aHNcIiwgXCJ3ZWVrc1wiLCBvciBcImRheXNcIlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5udW1iZXJpbmdTeXN0ZW0gLSBvdmVycmlkZSB0aGUgbnVtYmVyaW5nU3lzdGVtIG9mIHRoaXMgRGF0ZVRpbWUuIFRoZSBJbnRsIHN5c3RlbSBtYXkgY2hvb3NlIG5vdCB0byBob25vciB0aGlzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAxIH0pLnRvUmVsYXRpdmVDYWxlbmRhcigpIC8vPT4gXCJ0b21vcnJvd1wiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnNldExvY2FsZShcImVzXCIpLnBsdXMoeyBkYXlzOiAxIH0pLnRvUmVsYXRpdmUoKSAvLz0+IFwiXCJtYVx1MDBGMWFuYVwiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAxIH0pLnRvUmVsYXRpdmVDYWxlbmRhcih7IGxvY2FsZTogXCJmclwiIH0pIC8vPT4gXCJkZW1haW5cIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5taW51cyh7IGRheXM6IDIgfSkudG9SZWxhdGl2ZUNhbGVuZGFyKCkgLy89PiBcIjIgZGF5cyBhZ29cIlxuICAgKi9cbiAgdG9SZWxhdGl2ZUNhbGVuZGFyKG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gbnVsbDtcblxuICAgIHJldHVybiBkaWZmUmVsYXRpdmUob3B0aW9ucy5iYXNlIHx8IERhdGVUaW1lLmZyb21PYmplY3Qoe30sIHsgem9uZTogdGhpcy56b25lIH0pLCB0aGlzLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgbnVtZXJpYzogXCJhdXRvXCIsXG4gICAgICB1bml0czogW1wieWVhcnNcIiwgXCJtb250aHNcIiwgXCJkYXlzXCJdLFxuICAgICAgY2FsZW5kYXJ5OiB0cnVlLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbWluIG9mIHNldmVyYWwgZGF0ZSB0aW1lc1xuICAgKiBAcGFyYW0gey4uLkRhdGVUaW1lfSBkYXRlVGltZXMgLSB0aGUgRGF0ZVRpbWVzIGZyb20gd2hpY2ggdG8gY2hvb3NlIHRoZSBtaW5pbXVtXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfSB0aGUgbWluIERhdGVUaW1lLCBvciB1bmRlZmluZWQgaWYgY2FsbGVkIHdpdGggbm8gYXJndW1lbnRcbiAgICovXG4gIHN0YXRpYyBtaW4oLi4uZGF0ZVRpbWVzKSB7XG4gICAgaWYgKCFkYXRlVGltZXMuZXZlcnkoRGF0ZVRpbWUuaXNEYXRlVGltZSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm1pbiByZXF1aXJlcyBhbGwgYXJndW1lbnRzIGJlIERhdGVUaW1lc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGJlc3RCeShkYXRlVGltZXMsIChpKSA9PiBpLnZhbHVlT2YoKSwgTWF0aC5taW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbWF4IG9mIHNldmVyYWwgZGF0ZSB0aW1lc1xuICAgKiBAcGFyYW0gey4uLkRhdGVUaW1lfSBkYXRlVGltZXMgLSB0aGUgRGF0ZVRpbWVzIGZyb20gd2hpY2ggdG8gY2hvb3NlIHRoZSBtYXhpbXVtXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfSB0aGUgbWF4IERhdGVUaW1lLCBvciB1bmRlZmluZWQgaWYgY2FsbGVkIHdpdGggbm8gYXJndW1lbnRcbiAgICovXG4gIHN0YXRpYyBtYXgoLi4uZGF0ZVRpbWVzKSB7XG4gICAgaWYgKCFkYXRlVGltZXMuZXZlcnkoRGF0ZVRpbWUuaXNEYXRlVGltZSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm1heCByZXF1aXJlcyBhbGwgYXJndW1lbnRzIGJlIERhdGVUaW1lc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGJlc3RCeShkYXRlVGltZXMsIChpKSA9PiBpLnZhbHVlT2YoKSwgTWF0aC5tYXgpO1xuICB9XG5cbiAgLy8gTUlTQ1xuXG4gIC8qKlxuICAgKiBFeHBsYWluIGhvdyBhIHN0cmluZyB3b3VsZCBiZSBwYXJzZWQgYnkgZnJvbUZvcm1hdCgpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm10IC0gdGhlIGZvcm1hdCB0aGUgc3RyaW5nIGlzIGV4cGVjdGVkIHRvIGJlIGluIChzZWUgZGVzY3JpcHRpb24pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyB0YWtlbiBieSBmcm9tRm9ybWF0KClcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGZyb21Gb3JtYXRFeHBsYWluKHRleHQsIGZtdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsIH0gPSBvcHRpb25zLFxuICAgICAgbG9jYWxlVG9Vc2UgPSBMb2NhbGUuZnJvbU9wdHMoe1xuICAgICAgICBsb2NhbGUsXG4gICAgICAgIG51bWJlcmluZ1N5c3RlbSxcbiAgICAgICAgZGVmYXVsdFRvRU46IHRydWUsXG4gICAgICB9KTtcbiAgICByZXR1cm4gZXhwbGFpbkZyb21Ub2tlbnMobG9jYWxlVG9Vc2UsIHRleHQsIGZtdCk7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGZyb21Gb3JtYXRFeHBsYWluIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBmcm9tU3RyaW5nRXhwbGFpbih0ZXh0LCBmbXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBEYXRlVGltZS5mcm9tRm9ybWF0RXhwbGFpbih0ZXh0LCBmbXQsIG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gRk9STUFUIFBSRVNFVFNcblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAxMC8xNC8xOTgzXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVfU0hPUlQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURV9TSE9SVDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdPY3QgMTQsIDE5ODMnXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVfTUVEKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVfTUVEO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ0ZyaSwgT2N0IDE0LCAxOTgzJ1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFX01FRF9XSVRIX1dFRUtEQVkoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURV9NRURfV0lUSF9XRUVLREFZO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ09jdG9iZXIgMTQsIDE5ODMnXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVfRlVMTCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFX0ZVTEw7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnVHVlc2RheSwgT2N0b2JlciAxNCwgMTk4MydcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURV9IVUdFKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVfSFVHRTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMCBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FX1NJTVBMRSgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FX1NJTVBMRTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMyBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FX1dJVEhfU0VDT05EUygpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FX1dJVEhfU0VDT05EUztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMyBBTSBFRFQnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgVElNRV9XSVRIX1NIT1JUX09GRlNFVCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FX1dJVEhfU0hPUlRfT0ZGU0VUO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzIEFNIEVhc3Rlcm4gRGF5bGlnaHQgVGltZScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FX1dJVEhfTE9OR19PRkZTRVQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuVElNRV9XSVRIX0xPTkdfT0ZGU0VUO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwJywgYWx3YXlzIDI0LWhvdXIuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfMjRfU0lNUExFKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfMjRfU0lNUExFO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzJywgYWx3YXlzIDI0LWhvdXIuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfMjRfV0lUSF9TRUNPTkRTKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfMjRfV0lUSF9TRUNPTkRTO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzIEVEVCcsIGFsd2F5cyAyNC1ob3VyLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VUKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfMjRfV0lUSF9TSE9SVF9PRkZTRVQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzA6MjMgRWFzdGVybiBEYXlsaWdodCBUaW1lJywgYWx3YXlzIDI0LWhvdXIuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfMjRfV0lUSF9MT05HX09GRlNFVCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FXzI0X1dJVEhfTE9OR19PRkZTRVQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMTAvMTQvMTk4MywgOTozMCBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9TSE9SVCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9TSE9SVDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcxMC8xNC8xOTgzLCA5OjMwOjMzIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUygpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9TSE9SVF9XSVRIX1NFQ09ORFM7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0IDE0LCAxOTgzLCA5OjMwIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX01FRCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9NRUQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0IDE0LCAxOTgzLCA5OjMwOjMzIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX01FRF9XSVRIX1NFQ09ORFMoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfTUVEX1dJVEhfU0VDT05EUztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdGcmksIDE0IE9jdCAxOTgzLCA5OjMwIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX01FRF9XSVRIX1dFRUtEQVkoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfTUVEX1dJVEhfV0VFS0RBWTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdPY3RvYmVyIDE0LCAxOTgzLCA5OjMwIEFNIEVEVCcuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9GVUxMKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX0ZVTEw7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0b2JlciAxNCwgMTk4MywgOTozMDozMyBBTSBFRFQnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFMoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFM7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnRnJpZGF5LCBPY3RvYmVyIDE0LCAxOTgzLCA5OjMwIEFNIEVhc3Rlcm4gRGF5bGlnaHQgVGltZScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9IVUdFKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX0hVR0U7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnRnJpZGF5LCBPY3RvYmVyIDE0LCAxOTgzLCA5OjMwOjMzIEFNIEVhc3Rlcm4gRGF5bGlnaHQgVGltZScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9IVUdFX1dJVEhfU0VDT05EUygpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9IVUdFX1dJVEhfU0VDT05EUztcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcmllbmRseURhdGVUaW1lKGRhdGVUaW1laXNoKSB7XG4gIGlmIChEYXRlVGltZS5pc0RhdGVUaW1lKGRhdGVUaW1laXNoKSkge1xuICAgIHJldHVybiBkYXRlVGltZWlzaDtcbiAgfSBlbHNlIGlmIChkYXRlVGltZWlzaCAmJiBkYXRlVGltZWlzaC52YWx1ZU9mICYmIGlzTnVtYmVyKGRhdGVUaW1laXNoLnZhbHVlT2YoKSkpIHtcbiAgICByZXR1cm4gRGF0ZVRpbWUuZnJvbUpTRGF0ZShkYXRlVGltZWlzaCk7XG4gIH0gZWxzZSBpZiAoZGF0ZVRpbWVpc2ggJiYgdHlwZW9mIGRhdGVUaW1laXNoID09PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIERhdGVUaW1lLmZyb21PYmplY3QoZGF0ZVRpbWVpc2gpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcbiAgICAgIGBVbmtub3duIGRhdGV0aW1lIGFyZ3VtZW50OiAke2RhdGVUaW1laXNofSwgb2YgdHlwZSAke3R5cGVvZiBkYXRlVGltZWlzaH1gXG4gICAgKTtcbiAgfVxufVxuIiwgIi8qIVxuICogY2hhcnRqcy1hZGFwdGVyLWx1eG9uIHYxLjMuMVxuICogaHR0cHM6Ly93d3cuY2hhcnRqcy5vcmdcbiAqIChjKSAyMDIzIGNoYXJ0anMtYWRhcHRlci1sdXhvbiBDb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQgeyBfYWRhcHRlcnMgfSBmcm9tICdjaGFydC5qcyc7XG5pbXBvcnQgeyBEYXRlVGltZSB9IGZyb20gJ2x1eG9uJztcblxuY29uc3QgRk9STUFUUyA9IHtcbiAgZGF0ZXRpbWU6IERhdGVUaW1lLkRBVEVUSU1FX01FRF9XSVRIX1NFQ09ORFMsXG4gIG1pbGxpc2Vjb25kOiAnaDptbTpzcy5TU1MgYScsXG4gIHNlY29uZDogRGF0ZVRpbWUuVElNRV9XSVRIX1NFQ09ORFMsXG4gIG1pbnV0ZTogRGF0ZVRpbWUuVElNRV9TSU1QTEUsXG4gIGhvdXI6IHtob3VyOiAnbnVtZXJpYyd9LFxuICBkYXk6IHtkYXk6ICdudW1lcmljJywgbW9udGg6ICdzaG9ydCd9LFxuICB3ZWVrOiAnREQnLFxuICBtb250aDoge21vbnRoOiAnc2hvcnQnLCB5ZWFyOiAnbnVtZXJpYyd9LFxuICBxdWFydGVyOiBcIidRJ3EgLSB5eXl5XCIsXG4gIHllYXI6IHt5ZWFyOiAnbnVtZXJpYyd9XG59O1xuXG5fYWRhcHRlcnMuX2RhdGUub3ZlcnJpZGUoe1xuICBfaWQ6ICdsdXhvbicsIC8vIERFQlVHXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3JlYXRlOiBmdW5jdGlvbih0aW1lKSB7XG4gICAgcmV0dXJuIERhdGVUaW1lLmZyb21NaWxsaXModGltZSwgdGhpcy5vcHRpb25zKTtcbiAgfSxcblxuICBpbml0KGNoYXJ0T3B0aW9ucykge1xuICAgIGlmICghdGhpcy5vcHRpb25zLmxvY2FsZSkge1xuICAgICAgdGhpcy5vcHRpb25zLmxvY2FsZSA9IGNoYXJ0T3B0aW9ucy5sb2NhbGU7XG4gICAgfVxuICB9LFxuXG4gIGZvcm1hdHM6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBGT1JNQVRTO1xuICB9LFxuXG4gIHBhcnNlOiBmdW5jdGlvbih2YWx1ZSwgZm9ybWF0KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5fY3JlYXRlKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAodHlwZW9mIGZvcm1hdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFsdWUgPSBEYXRlVGltZS5mcm9tRm9ybWF0KHZhbHVlLCBmb3JtYXQsIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBEYXRlVGltZS5mcm9tSVNPKHZhbHVlLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgdmFsdWUgPSBEYXRlVGltZS5mcm9tSlNEYXRlKHZhbHVlLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnICYmICEodmFsdWUgaW5zdGFuY2VvZiBEYXRlVGltZSkpIHtcbiAgICAgIHZhbHVlID0gRGF0ZVRpbWUuZnJvbU9iamVjdCh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlLmlzVmFsaWQgPyB2YWx1ZS52YWx1ZU9mKCkgOiBudWxsO1xuICB9LFxuXG4gIGZvcm1hdDogZnVuY3Rpb24odGltZSwgZm9ybWF0KSB7XG4gICAgY29uc3QgZGF0ZXRpbWUgPSB0aGlzLl9jcmVhdGUodGltZSk7XG4gICAgcmV0dXJuIHR5cGVvZiBmb3JtYXQgPT09ICdzdHJpbmcnXG4gICAgICA/IGRhdGV0aW1lLnRvRm9ybWF0KGZvcm1hdClcbiAgICAgIDogZGF0ZXRpbWUudG9Mb2NhbGVTdHJpbmcoZm9ybWF0KTtcbiAgfSxcblxuICBhZGQ6IGZ1bmN0aW9uKHRpbWUsIGFtb3VudCwgdW5pdCkge1xuICAgIGNvbnN0IGFyZ3MgPSB7fTtcbiAgICBhcmdzW3VuaXRdID0gYW1vdW50O1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGUodGltZSkucGx1cyhhcmdzKS52YWx1ZU9mKCk7XG4gIH0sXG5cbiAgZGlmZjogZnVuY3Rpb24obWF4LCBtaW4sIHVuaXQpIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlKG1heCkuZGlmZih0aGlzLl9jcmVhdGUobWluKSkuYXModW5pdCkudmFsdWVPZigpO1xuICB9LFxuXG4gIHN0YXJ0T2Y6IGZ1bmN0aW9uKHRpbWUsIHVuaXQsIHdlZWtkYXkpIHtcbiAgICBpZiAodW5pdCA9PT0gJ2lzb1dlZWsnKSB7XG4gICAgICB3ZWVrZGF5ID0gTWF0aC50cnVuYyhNYXRoLm1pbihNYXRoLm1heCgwLCB3ZWVrZGF5KSwgNikpO1xuICAgICAgY29uc3QgZGF0ZVRpbWUgPSB0aGlzLl9jcmVhdGUodGltZSk7XG4gICAgICByZXR1cm4gZGF0ZVRpbWUubWludXMoe2RheXM6IChkYXRlVGltZS53ZWVrZGF5IC0gd2Vla2RheSArIDcpICUgN30pLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuaXQgPyB0aGlzLl9jcmVhdGUodGltZSkuc3RhcnRPZih1bml0KS52YWx1ZU9mKCkgOiB0aW1lO1xuICB9LFxuXG4gIGVuZE9mOiBmdW5jdGlvbih0aW1lLCB1bml0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZSh0aW1lKS5lbmRPZih1bml0KS52YWx1ZU9mKCk7XG4gIH1cbn0pO1xuIiwgImltcG9ydCB7IENoYXJ0LCBEb3VnaG51dENvbnRyb2xsZXIsIEFyY0VsZW1lbnQsIFRvb2x0aXAsIExlZ2VuZCB9IGZyb20gJ2NoYXJ0LmpzJztcbmltcG9ydCBcImNoYXJ0anMtYWRhcHRlci1sdXhvblwiO1xuXG5jbGFzcyBIdW5nZXJDb250cm9sbGVyIGV4dGVuZHMgRG91Z2hudXRDb250cm9sbGVyIHtcblxuICAgIGRyYXcoKSB7XG4gICAgICAgIHN1cGVyLmRyYXcoYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5jaGFydC53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuY2hhcnQuaGVpZ2h0O1xuXG4gICAgICAgIHZhciBmb250U2l6ZSA9IChoZWlnaHQgLyAxMTQpLnRvRml4ZWQoMik7XG4gICAgICAgIHRoaXMuY2hhcnQuY3R4LmZvbnQgPSBmb250U2l6ZSArIFwiZW0gVmVyZGFuYVwiO1xuICAgICAgICB0aGlzLmNoYXJ0LmN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuICAgICAgICB0aGlzLmNoYXJ0LmN0eC5maWxsU3R5bGUgPSBcImdyZWVuXCI7XG5cbiAgICAgICAgdmFyIHRleHQgPSB0aGlzLmdldFN0YXR1c1RleHQoKSxcbiAgICAgICAgICAgIHRleHRYID0gTWF0aC5yb3VuZCgod2lkdGggLSB0aGlzLmNoYXJ0LmN0eC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aCkgLyAyKSxcbiAgICAgICAgICAgIHRleHRZID0gaGVpZ2h0IC0gdGhpcy5jaGFydC5jdHgubWVhc3VyZVRleHQodGV4dCkuaGFuZ2luZ0Jhc2VsaW5lO1xuXG4gICAgICAgIHRoaXMuY2hhcnQuY3R4LmZpbGxTdHlsZSA9IHRoaXMuZ2V0VGV4dENvbG9yKCk7XG4gICAgICAgIHRoaXMuY2hhcnQuY3R4LmZpbGxUZXh0KHRleHQsIHRleHRYLCB0ZXh0WSk7XG4gICAgfVxuXG4gICAgZ2V0U3RhdHVzVGV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hhcnQuaHVuZ2VyTGV2ZWwgPj01MCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhcnQubGFuZ1snb2snXTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNoYXJ0Lmh1bmdlckxldmVsID49MjApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYXJ0LmxhbmdbJ2h1bmdyeSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNoYXJ0LmxhbmdbJ3N0YXJ2aW5nJ107XG4gICAgfVxuXG4gICAgZ2V0VGV4dENvbG9yKCkge1xuICAgICAgICBpZiAodGhpcy5jaGFydC5odW5nZXJMZXZlbCA+PTUwKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJncmVlblwiO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY2hhcnQuaHVuZ2VyTGV2ZWwgPj0yMCkge1xuICAgICAgICAgICAgcmV0dXJuIFwib3JhbmdlXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwicmVkXCI7XG4gICAgfVxufVxuXG5IdW5nZXJDb250cm9sbGVyLmlkID0gJ2h1bmdlcic7XG5IdW5nZXJDb250cm9sbGVyLmRlZmF1bHRzID0gRG91Z2hudXRDb250cm9sbGVyLmRlZmF1bHRzO1xuXG5DaGFydC5yZWdpc3RlcihIdW5nZXJDb250cm9sbGVyLCBBcmNFbGVtZW50LCBUb29sdGlwLCBMZWdlbmQpO1xuXG5leHBvcnQgeyBDaGFydCB9O1xuIiwgImltcG9ydCB7IENoYXJ0IH0gZnJvbSBcIi4uL2h1bmdlci1jaGFydFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkdWNrRmVlZGVyV2lkZ2V0KHsgY2hhcnQsIGxhbmcsIHN0YXJ2YXRpb25SYXRlLCBicmVhZEhlYWx0aH0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBodW5nZXJMZXZlbDogMTAwLFxuICAgICAgICBkdWNrc011cmRlcmVkOiAwLFxuICAgICAgICBhdWRpb1BsYXllZDogZmFsc2UsXG4gICAgICAgIGluaXQoKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRDaGFydCgpO1xuXG4gICAgICAgICAgICBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5odW5nZXJMZXZlbC0tO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaHVuZ2VyTGV2ZWwgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaHVuZ2VyTGV2ZWwgPSAxMDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHVja3NNdXJkZXJlZCsrOyBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDaGFydCgpO1xuICAgICAgICAgICAgfSwgc3RhcnZhdGlvblJhdGUpO1xuXG4gICAgICAgICAgICAvLyBQcmV2ZW50IGF1ZGlvIHNwYW1cbiAgICAgICAgICAgIHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvUGxheWVkID0gZmFsc2U7XG4gICAgICAgICAgICB9LCAzMDAwKVxuICAgICAgICB9LFxuICAgICAgICBmZWVkRHVjaygpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hdWRpb1BsYXllZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJHJlZnMuZHVja21vZGVBdWRpby5wbGF5KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb1BsYXllZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuaHVuZ2VyTGV2ZWwgKz1icmVhZEhlYWx0aDtcbiAgICAgICAgICAgIGlmICh0aGlzLmh1bmdlckxldmVsID4gMTAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5odW5nZXJMZXZlbCA9IDEwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ2hhcnQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbml0Q2hhcnQoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdDaGFydCA9IG5ldyBDaGFydCh0aGlzLiRyZWZzLmNhbnZhcywge1xuICAgICAgICAgICAgICAgIHR5cGU6IGNoYXJ0LnR5cGUsXG4gICAgICAgICAgICAgICAgZGF0YTogY2hhcnQuY2FjaGVkRGF0YSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBjaGFydC5vcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBuZXdDaGFydC5odW5nZXJMZXZlbCA9IHRoaXMuaHVuZ2VyTGV2ZWw7XG4gICAgICAgICAgICBuZXdDaGFydC5sYW5nID0gbGFuZztcbiAgICAgICAgICAgIHJldHVybiBuZXdDaGFydDtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlQ2hhcnQoKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFydCA9IHRoaXMuZ2V0Q2hhcnQoKVxuICAgICAgICAgICAgY2hhcnQuZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0czpbe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBbdGhpcy5odW5nZXJMZXZlbCwgMTAwIC0gdGhpcy5odW5nZXJMZXZlbF0sXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogW3RoaXMuZ2V0U3RhdGVDb2xvdXIoKSwgXCJHcmF5XCJdXG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgbGFuZzogbGFuZ1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhcnQuaHVuZ2VyTGV2ZWwgPSB0aGlzLmh1bmdlckxldmVsO1xuICAgICAgICAgICAgY2hhcnQudXBkYXRlKCdyZXNpemUnKVxuICAgICAgICB9LFxuICAgICAgICBnZXRTdGF0ZUNvbG91cigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmh1bmdlckxldmVsID49NTAgPyBcIkdyZWVuXCI6IHRoaXMuaHVuZ2VyTGV2ZWwgPj0gMjAgPyBcIk9yYW5nZVwiOiBcIlJlZFwiO1xuICAgICAgICB9LFxuICAgICAgICBnZXRDaGFydCgpIHtcbiAgICAgICAgICAgIHJldHVybiBDaGFydC5nZXRDaGFydCh0aGlzLiRyZWZzLmNhbnZhcyk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7OztBQU1BLFNBQVMsTUFBTSxHQUFHO0FBQ2hCLFNBQU8sSUFBSSxNQUFNO0FBQ25CO0FBQ0EsSUFBTSxNQUFNLENBQUMsR0FBR0EsSUFBRyxNQUFNLEtBQUssSUFBSSxLQUFLLElBQUksR0FBRyxDQUFDLEdBQUdBLEVBQUM7QUFDbkQsU0FBUyxJQUFJLEdBQUc7QUFDZCxTQUFPLElBQUksTUFBTSxJQUFJLElBQUksR0FBRyxHQUFHLEdBQUc7QUFDcEM7QUFJQSxTQUFTLElBQUksR0FBRztBQUNkLFNBQU8sSUFBSSxNQUFNLElBQUksR0FBRyxHQUFHLEdBQUcsR0FBRztBQUNuQztBQUNBLFNBQVMsSUFBSSxHQUFHO0FBQ2QsU0FBTyxJQUFJLE1BQU0sSUFBSSxJQUFJLElBQUksS0FBSyxHQUFHLENBQUM7QUFDeEM7QUFDQSxTQUFTLElBQUksR0FBRztBQUNkLFNBQU8sSUFBSSxNQUFNLElBQUksR0FBRyxHQUFHLEdBQUcsR0FBRztBQUNuQztBQUVBLElBQU0sUUFBUSxFQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFH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QUNILEdBQUc7QUFBQSxFQUNILEdBQUc7QUFBQSxFQUNILEdBQUc7QUFBQSxFQUNILEdBQUc7QUFBQSxFQUNILEdBQUc7QUFBQSxFQUNILEdBQUc7QUFBQSxFQUNILEdBQUc7QUFDTDtBQUNBLElBQU0sVUFBVTtBQUFBLEVBQ2QsUUFBUTtBQUFBLEVBQ1IsYUFBYTtBQUFBLEVBQ2IsTUFBTTtBQUFBLEVBQ04sV0FBVztBQUFBLEVBQ1gsTUFBTTtBQUFBLEVBQ04sT0FBTztBQUFBLEVBQ1AsUUFBUTtBQUFBLEVBQ1IsT0FBTztBQUFBLEVBQ1AsY0FBYztBQUFBLEVBQ2QsSUFBSTtBQUFBLEVBQ0osU0FBUztBQUFBLEVBQ1QsTUFBTTtBQUFBLEVBQ04sV0FBVztBQUFBLEVBQ1gsUUFBUTtBQUFBLEVBQ1IsVUFBVTtBQUFBLEVBQ1YsU0FBUztBQUFBLEVBQ1QsS0FBSztBQUFBLEVBQ0wsYUFBYTtBQUFBLEVBQ2IsU0FBUztBQUFBLEVBQ1QsU0FBUztBQUFBLEVBQ1QsTUFBTTtBQUFBLEVBQ04sS0FBSztBQUFBLEVBQ0wsT0FBTztBQUFBLEVBQ1AsU0FBUztBQUFBLEVBQ1QsTUFBTTtBQUFBLEVBQ04sTUFBTTtBQUFBLEVBQ04sTUFBTTtBQUFBLEVBQ04sUUFBUTtBQUFBLEVBQ1IsU0FBUztBQUFBLEVBQ1QsVUFBVTtBQUFBLEVBQ1YsUUFBUTtBQUFBLEVBQ1IsT0FBTztBQUFBLEVBQ1AsS0FBSztBQUFBLEVBQ0wsUUFBUTtBQUFBLEVBQ1IsUUFBUTtBQUFBLEVBQ1IsTUFBTTtBQUFBLEVBQ04sT0FBTztBQUFBLEVBQ1AsT0FBTztBQUFBLEVBQ1AsS0FBSztBQUFBLEVBQ0wsUUFBUTtBQUFBLEVBQ1IsUUFBUTtBQUFBLEVBQ1IsVUFBVTtBQUFBLEVBQ1YsUUFBUTtBQUFBLEVBQ1IsUUFBUTtBQUFBLEVBQ1IsVUFBVTtBQUFBLEVBQ1YsVUFBVTtBQUFBLEVBQ1YsVUFBVTtBQUFBLEVBQ1YsVUFBVTtBQUFBLEVBQ1YsUUFBUTtBQUFBLEVBQ1IsU0FBUztBQUFBLEVBQ1QsV0FBVztBQUFBLEVBQ1gsS0FBSztBQUFBLEVBQ0wsUUFBUTtBQUFBLEVBQ1IsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsT0FBTztBQUFBLEVBQ1AsS0FBSztBQUFBLEVBQ0wsU0FBUztBQUFBLEVBQ1QsUUFBUTtBQUFBLEVBQ1IsU0FBUztBQUFBLEVBQ1QsT0FBTztBQUFBLEVBQ1AsTUFBTTtBQUFBLEVBQ04sT0FBTztBQUFBLEVBQ1AsUUFBUTtBQUFBLEVBQ1IsV0FBVztBQUFBLEVBQ1gsU0FBUztBQUFBLEVBQ1QsWUFBWTtBQUFBLEVBQ1osS0FBSztBQUFBLEVBQ0wsTUFBTTtBQUFBLEVBQ04sT0FBTztBQUFBLEVBQ1AsV0FBVztBQUFBLEVBQ1gsTUFBTTtBQUFBLEVBQ04sTUFBTTtBQUFBLEVBQ04sTUFBTTtBQUFBLEVBQ04sTUFBTTtBQUFBLEVBQ04sUUFBUTtBQUFBLEVBQ1IsUUFBUTtBQUFBLEVBQ1IsUUFBUTtBQUFBLEVBQ1IsT0FBTztBQUFBLEVBQ1AsT0FBTztBQUFBLEVBQ1AsU0FBUztBQUFBLEVBQ1QsS0FBSztBQUFBLEVBQ0wsTUFBTTtBQUFBLEVBQ04sU0FBUztBQUFBLEVBQ1QsS0FBSztBQUFBLEVBQ0wsUUFBUTtBQUFBLEVBQ1IsT0FBTztBQUFBLEVBQ1AsWUFBWTtBQUFBLEVBQ1osS0FBSztBQUFBLEVBQ0wsT0FBTztBQUFBLEVBQ1AsUUFBUTtBQUFBLEVBQ1IsUUFBUTtBQUFBLEVBQ1IsTUFBTTtBQUFBLEVBQ04sV0FBVztBQUFBLEVBQ1gsS0FBSztBQUFBLEVBQ0wsVUFBVTtBQUFBLEVBQ1YsWUFBWTtBQUFBLEVBQ1osU0FBUztBQUFBLEVBQ1QsVUFBVTtBQUFBLEVBQ1YsU0FBUztBQUFBLEVBQ1QsWUFBWTtBQUFBLEVBQ1osTUFBTTtBQUFBLEVBQ04sUUFBUTtBQUFBLEVBQ1IsTUFBTTtBQUFBLEVBQ04sU0FBUztBQUFBLEVBQ1QsT0FBTztBQUFBLEVBQ1AsU0FBUztBQUFBLEVBQ1QsTUFBTTtBQUFBLEVBQ04sV0FBVztBQUFBLEVBQ1gsUUFBUTtBQUFBLEVBQ1IsT0FBTztBQUFBLEVBQ1AsWUFBWTtB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QUFDMUI7QUFFQSxJQUFNZSxPQUFNO0FBQUEsRUFDVixHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQ0w7QUFDQSxJQUFNQyxXQUFVO0FBQUEsRUFDZCxRQUFRO0FBQUEsRUFDUixhQUFhO0FBQUEsRUFDYixNQUFNO0FBQUEsRUFDTixXQUFXO0FBQUEsRUFDWCxNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxjQUFjO0FBQUEsRUFDZCxJQUFJO0FBQUEsRUFDSixTQUFTO0FBQUEsRUFDVCxNQUFNO0FBQUEsRUFDTixXQUFXO0FBQUEsRUFDWCxRQUFRO0FBQUEsRUFDUixVQUFVO0FBQUEsRUFDVixTQUFTO0FBQUEsRUFDVCxLQUFLO0FBQUEsRUFDTCxhQUFhO0FBQUEsRUFDYixTQUFTO0FBQUEsRUFDVCxTQUFTO0FBQUEsRUFDVCxNQUFNO0FBQUEsRUFDTixLQUFLO0FBQUEsRUFDTCxPQUFPO0FBQUEsRUFDUCxTQUFTO0FBQUEsRUFDVCxNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixRQUFRO0FBQUEsRUFDUixTQUFTO0FBQUEsRUFDVCxVQUFVO0FBQUEsRUFDVixRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxLQUFLO0FBQUEsRUFDTCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxLQUFLO0FBQUEsRUFDTCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixVQUFVO0FBQUEsRUFDVixRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixVQUFVO0FBQUEsRUFDVixVQUFVO0FBQUEsRUFDVixVQUFVO0FBQUEsRUFDVixVQUFVO0FBQUEsRUFDVixRQUFRO0FBQUEsRUFDUixTQUFTO0FBQUEsRUFDVCxXQUFXO0FBQUEsRUFDWCxLQUFLO0FBQUEsRUFDTCxRQUFRO0FBQUEsRUFDUixLQUFLO0FBQUEsRUFDTCxLQUFLO0FBQUEsRUFDTCxPQUFPO0FBQUEsRUFDUCxLQUFLO0FBQUEsRUFDTCxTQUFTO0FBQUEsRUFDVCxRQUFRO0FBQUEsRUFDUixTQUFTO0FBQUEsRUFDVCxPQUFPO0FBQUEsRUFDUCxNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixXQUFXO0FBQUEsRUFDWCxTQUFTO0FBQUEsRUFDVCxZQUFZO0FBQUEsRUFDWixLQUFLO0FBQUEsRUFDTCxNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxXQUFXO0FBQUEsRUFDWCxNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxTQUFTO0FBQUEsRUFDVCxLQUFLO0FBQUEsRUFDTCxNQUFNO0FBQUEsRUFDTixTQUFTO0FBQUEsRUFDVCxLQUFLO0FBQUEsRUFDTCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxZQUFZO0FBQUEsRUFDWixLQUFLO0FBQUEsRUFDTCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixNQUFNO0FBQUEsRUFDTixXQUFXO0FBQUEsRUFDWCxLQUFLO0FBQUEsRUFDTCxVQUFVO0FBQUEsRUFDVixZQUFZO0FBQUEsRUFDWixTQUFTO0FBQUEsRUFDVCxVQUFVO0FBQUEsRUFDVixTQUFTO0FBQUEsRUFDVCxZQUFZO0FBQUEsRUFDWixNQUFNO0FBQUEsRUFDTixRQUFRO0FBQUEsRUFDUixNQUFNO0FBQUEsRUFDTixTQUFTO0FBQUEsRUFDVCxPQUFPO0FBQUEsRUFDUCxTQUFTO0FBQUEsRUFDVCxNQUFNO0FBQUEsRUFDTixXQUFXO0FBQUEsRUFDWCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxZQUFZO0FBQUEsRUFDWixXQUFXO0FBQUEsRUFDWCxTQUFTO0FBQUEsRUFDVCxNQUFNO0FBQUEsRUFDTixLQUFLO0FBQUEsRUFDTCxNQUFNO0FBQUEsRUFDTixTQUFTO0FBQUEsRUFDVCxPQUFPO0FBQUEsRUFDUCxhQUFhO0FBQUEsRUFDYixJQUFJO0FBQUEsRUFDSixVQUFVO0FBQUEsRUFDVixPQUFPO0FBQUEsRUFDUCxXQUFXO0FBQUEsRUFDWCxPQUFPO0FBQUEsRUFDUCxXQUFXO0FBQUEsRUFDWCxPQUFPO0FBQUEsRUFDUCxTQUFTO0FBQUEsRUFDVCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxLQUFLO0FBQUEsRUFDTCxNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixVQUFVO0FBQUEsRUFDVixRQUFRO0FBQUEsRUFDUixLQUFLO0FBQUEsRUFDTCxLQUFLO0FBQUEsRUFDTCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixJQUFJO0FBQUEsRUFDSixPQUFPO0FBQUEsRUFDUCxLQUFLO0FBQUEsRUFDTCxNQUFNO0FBQUEsRUFDTixXQUFXO0FBQUEsRUFDWCxJQUFJO0FBQUEsRUFDSixPQUFPO0FBQ1Q7QUFDQSxTQUFTQyxVQUFTO0FBQ2hCLFFBQU0s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QSxVQUNOLE1BQU0sQ0FBQyxLQUFLLGFBQWEsTUFBTSxLQUFLLFdBQVc7QUFBQSxVQUMvQyxpQkFBaUIsQ0FBQyxLQUFLLGVBQWUsR0FBRyxNQUFNO0FBQUEsUUFDbkQsQ0FBQztBQUFBLFFBQ0Q7QUFBQSxNQUNKO0FBQ0EsTUFBQUEsT0FBTSxjQUFjLEtBQUs7QUFDekIsTUFBQUEsT0FBTSxPQUFPLFFBQVE7QUFBQSxJQUN6QjtBQUFBLElBQ0EsaUJBQWlCO0FBQ2IsYUFBTyxLQUFLLGVBQWMsS0FBSyxVQUFTLEtBQUssZUFBZSxLQUFLLFdBQVU7QUFBQSxJQUMvRTtBQUFBLElBQ0EsV0FBVztBQUNQLGFBQU8sTUFBTSxTQUFTLEtBQUssTUFBTSxNQUFNO0FBQUEsSUFDM0M7QUFBQSxFQUNKO0FBQ0o7IiwKICAibmFtZXMiOiBbImwiLCAicyIsICJsIiwgIm4iLCAiY29sb3IiLCAibm9vcCIsICJ1aWQiLCAiaWQiLCAiaXNOdWxsT3JVbmRlZiIsICJ2YWx1ZSIsICJpc0FycmF5IiwgIkFycmF5IiwgInR5cGUiLCAiT2JqZWN0IiwgInByb3RvdHlwZSIsICJ0b1N0cmluZyIsICJjYWxsIiwgInNsaWNlIiwgImlzT2JqZWN0IiwgImlzTnVtYmVyRmluaXRlIiwgIk51bWJlciIsICJpc0Zpbml0ZSIsICJmaW5pdGVPckRlZmF1bHQiLCAiZGVmYXVsdFZhbHVlIiwgInZhbHVlT3JEZWZhdWx0IiwgInRvUGVyY2VudGFnZSIsICJkaW1lbnNpb24iLCAiZW5kc1dpdGgiLCAicGFyc2VGbG9hdCIsICJ0b0RpbWVuc2lvbiIsICJjYWxsYmFjayIsICJmbiIsICJhcmdzIiwgInRoaXNBcmciLCAiYXBwbHkiLCAiZWFjaCIsICJsb29wYWJsZSIsICJyZXZlcnNlIiwgImkiLCAibGVuIiwgImtleXMiLCAibGVuZ3RoIiwgIl9lbGVtZW50c0VxdWFsIiwgImEwIiwgImExIiwgImlsZW4iLCAidjAiLCAidjEiLCAiZGF0YXNldEluZGV4IiwgImluZGV4IiwgImNsb25lIiwgInNvdXJjZSIsICJtYXAiLCAidGFyZ2V0IiwgImNyZWF0ZSIsICJrbGVuIiwgImsiLCAiaXNWYWxpZEtleSIsICJrZXkiLCAiaW5kZXhPZiIsICJfbWVyZ2VyIiwgIm9wdGlvbnMiLCAidHZhbCIsICJzdmFsIiwgIm1lcmdlIiwgInNvdXJjZXMiLCAibWVyZ2VyIiwgImN1cnJlbnQiLCAibWVyZ2VJZiIsICJfbWVyZ2VySWYiLCAiaGFzT3duUHJvcGVydHkiLCAia2V5UmVzb2x2ZXJzIiwgInYiLCAieCIsICJvIiwgInkiLCAiX3NwbGl0S2V5IiwgImtleSIsICJwYXJ0cyIsICJzcGxpdCIsICJrZXlzIiwgInRtcCIsICJwYXJ0IiwgImVuZHNXaXRoIiwgInNsaWNlIiwgInB1c2giLCAiX2dldEtleVJlc29sdmVyIiwgIm9iaiIsICJrIiwgInJlc29sdmVPYmplY3RLZXkiLCAicmVzb2x2ZXIiLCAiX2NhcGl0YWxpemUiLCAic3RyIiwgImNoYXJBdCIsICJ0b1VwcGVyQ2FzZSIsICJkZWZpbmVkIiwgInZhbHVlIiwgImlzRnVuY3Rpb24iLCAic2V0c0VxdWFsIiwgImEiLCAiYiIsICJzaXplIiwgIml0ZW0iLCAiaGFzIiwgIl9pc0NsaWNrRXZlbnQiLCAiZSIsICJ0eXBlIiwgIlBJIiwgIk1hdGgiLCAiVEFVIiwgIlBJVEFVIiwgIklORklOSVRZIiwgIk51bWJlciIsICJQT1NJVElWRV9JTkZJTklUWSIsICJSQURfUEVSX0RFRyIsICJIQUxGX1BJIiwgIlFVQVJURVJfUEkiLCAiVFdPX1RISVJEU19QSSIsICJsb2cxMCIsICJzaWduIiwgImFsbW9zdEVxdWFscyIsICJlcHNpbG9uIiwgImFicyIsICJuaWNlTnVtIiwgInJhbmdlIiwgInJvdW5kZWRSYW5nZSIsICJyb3VuZCIsICJuaWNlUmFuZ2UiLCAicG93IiwgImZsb29yIiwgImZyYWN0aW9uIiwgIm5pY2VGcmFjdGlvbiIsICJfZmFjdG9yaXplIiwgInJlc3VsdCIsICJzcXJ0IiwgImkiLCAic29ydCIsICJwb3AiLCAiaXNOdW1iZXIiLCAibiIsICJpc05hTiIsICJwYXJzZUZsb2F0IiwgImlzRmluaXRlIiwgImFsbW9zdFdob2xlIiwgInJvdW5kZWQiLCAiX3NldE1pbkFuZE1heEJ5S2V5IiwgImFycmF5IiwgInRhcmdldCIsICJwcm9wZXJ0eSIsICJpbGVuIiwgImxlbmd0aCIsICJtaW4iLCAibWF4IiwgInRvUmFkaWFucyIsICJkZWdyZWVzIiwgInRvRGVncmVlcyIsICJyYWRpYW5zIiwgIl9kZWNpbWFsUGxhY2VzIiwgImlzRmluaXRlTnVtYmVyIiwgInAiLCAiZ2V0QW5nbGVGcm9tUG9pbnQiLCAiY2VudHJlUG9pbnQiLCAiYW5nbGVQb2ludCIsICJkaXN0YW5jZUZyb21YQ2VudGVyIiwgImRpc3RhbmNlRnJvbVlDZW50ZXIiLCAicmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyIiwgImFuZ2xlIiwgImF0YW4yIiwgImRpc3RhbmNlIiwgImRpc3RhbmNlQmV0d2VlblBvaW50cyIsICJwdDEiLCAicHQyIiwgIl9ub3JtYWxpemVBbmdsZSIsICJhIiwgIlRBVSIsICJfYW5nbGVCZXR3ZWVuIiwgImFuZ2xlIiwgInN0YXJ0IiwgImVuZCIsICJzYW1lQW5nbGVJc0Z1bGxDaXJjbGUiLCAicyIsICJlIiwgImFuZ2xlVG9TdGFydCIsICJhbmdsZVRvRW5kIiwgInN0YXJ0VG9BbmdsZSIsICJlbmRUb0FuZ2xlIiwgIl9saW1pdFZhbHVlIiwgInZhbHVlIiwgIm1pbiIsICJtYXgiLCAiTWF0aCIsICJfaW50MTZSYW5nZSIsICJfaXNCZXR3ZWVuIiwgImVwc2lsb24iLCAiX2xvb2t1cCIsICJ0YWJsZSIsICJjbXAiLCAiaW5kZXgiLCAiaGkiLCAibGVuZ3RoIiwgImxvIiwgIm1pZCIsICJfbG9va3VwQnlLZXkiLCAia2V5IiwgImxhc3QiLCAidGkiLCAiX3Jsb29rdXBCeUtleSIsICJfZmlsdGVyQmV0d2VlbiIsICJ2YWx1ZXMiLCAic2xpY2UiLCAiYXJyYXlFdmVudHMiLCAibGlzdGVuQXJyYXlFdmVudHMiLCAiYXJyYXkiLCAibGlzdGVuZXIiLCAiX2NoYXJ0anMiLCAibGlzdGVuZXJzIiwgInB1c2giLCAiT2JqZWN0IiwgImRlZmluZVByb3BlcnR5IiwgImNvbmZpZ3VyYWJsZSIsICJlbnVtZXJhYmxlIiwgImZvckVhY2giLCAibWV0aG9kIiwgIl9jYXBpdGFsaXplIiwgImJhc2UiLCAiYXJncyIsICJyZXMiLCAiYXBwbHkiLCAib2JqZWN0IiwgInVubGlzdGVuQXJyYXlFdmVudHMiLCAic3R1YiIsICJpbmRleE9mIiwgInNwbGljZSIsICJfYXJyYXlVbmlxdWUiLCAiaXRlbXMiLCAic2V0IiwgIlNldCIsICJzaXplIiwgIkFycmF5IiwgImZyb20iLCAicmVxdWVzdEFuaW1GcmFtZSIsICJ3aW5kb3ciLCAiY2FsbGJhY2siLCAicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwgInRocm90dGxlZCIsICJmbiIsICJ0aGlzQXJnIiwgImFyZ3NUb1VzZSIsICJ0aWNraW5nIiwgImFyZ3MiLCAiY2FsbCIsICJhcHBseSIsICJkZWJvdW5jZSIsICJkZWxheSIsICJ0aW1lb3V0IiwgImNsZWFyVGltZW91dCIsICJzZXRUaW1lb3V0IiwgIl90b0xlZnRSaWdodENlbnRlciIsICJhbGlnbiIsICJfYWxpZ25TdGFydEVuZCIsICJzdGFydCIsICJlbmQiLCAiX3RleHRYIiwgImxlZnQiLCAicmlnaHQiLCAicnRsIiwgImNoZWNrIiwgImF0RWRnZSIsICJ0IiwgImVsYXN0aWNJbiIsICJzIiwgInAiLCAiTWF0aCIsICJwb3ciLCAic2luIiwgIlRBVSIsICJlbGFzdGljT3V0IiwgImVmZmVjdHMiLCAibGluZWFyIiwgImVhc2VJblF1YWQiLCAiZWFzZU91dFF1YWQiLCAiZWFzZUluT3V0UXVhZCIsICJlYXNlSW5DdWJpYyIsICJlYXNlT3V0Q3ViaWMiLCAiZWFzZUluT3V0Q3ViaWMiLCAiZWFzZUluUXVhcnQiLCAiZWFzZU91dFF1YXJ0IiwgImVhc2VJbk91dFF1YXJ0IiwgImVhc2VJblF1aW50IiwgImVhc2VPdXRRdWludCIsICJlYXNlSW5PdXRRdWludCIsICJlYXNlSW5TaW5lIiwgImNvcyIsICJIQUxGX1BJIiwgImVhc2VPdXRTaW5lIiwgImVhc2VJbk91dFNpbmUiLCAiUEkiLCAiZWFzZUluRXhwbyIsICJlYXNlT3V0RXhwbyIsICJlYXNlSW5PdXRFeHBvIiwgImVhc2VJbkNpcmMiLCAic3FydCIsICJlYXNlT3V0Q2lyYyIsICJlYXNlSW5PdXRDaXJjIiwgImVhc2VJbkVsYXN0aWMiLCAiZWFzZU91dEVsYXN0aWMiLCAiZWFzZUluT3V0RWxhc3RpYyIsICJlYXNlSW5CYWNrIiwgImVhc2VPdXRCYWNrIiwgImVhc2VJbk91dEJhY2siLCAiZWFzZUluQm91bmNlIiwgImVhc2VPdXRCb3VuY2UiLCAibSIsICJkIiwgImVhc2VJbk91dEJvdW5jZSIsICJpc1BhdHRlcm5PckdyYWRpZW50IiwgInZhbHVlIiwgInR5cGUiLCAidG9TdHJpbmciLCAiY29sb3IiLCAiQ29sb3IiLCAiZ2V0SG92ZXJDb2xvciIsICJzYXR1cmF0ZSIsICJkYXJrZW4iLCAiaGV4U3RyaW5nIiwgIm51bWJlcnMiLCAiY29sb3JzIiwgImFwcGx5QW5pbWF0aW9uc0RlZmF1bHRzIiwgImRlZmF1bHRzIiwgInNldCIsICJkZWxheSIsICJ1bmRlZmluZWQiLCAiZHVyYXRpb24iLCAiZWFzaW5nIiwgImZuIiwgImZyb20iLCAibG9vcCIsICJ0byIsICJkZXNjcmliZSIsICJfZmFsbGJhY2siLCAiX2luZGV4YWJsZSIsICJfc2NyaXB0YWJsZSIsICJuYW1lIiwgInByb3BlcnRpZXMiLCAiYWN0aXZlIiwgImFuaW1hdGlvbiIsICJyZXNpemUiLCAic2hvdyIsICJhbmltYXRpb25zIiwgInZpc2libGUiLCAiaGlkZSIsICJ2IiwgImFwcGx5TGF5b3V0c0RlZmF1bHRzIiwgImF1dG9QYWRkaW5nIiwgInBhZGRpbmciLCAidG9wIiwgInJpZ2h0IiwgImJvdHRvbSIsICJsZWZ0IiwgImludGxDYWNoZSIsICJNYXAiLCAiZ2V0TnVtYmVyRm9ybWF0IiwgImxvY2FsZSIsICJvcHRpb25zIiwgImNhY2hlS2V5IiwgIkpTT04iLCAic3RyaW5naWZ5IiwgImZvcm1hdHRlciIsICJnZXQiLCAiSW50bCIsICJOdW1iZXJGb3JtYXQiLCAiZm9ybWF0TnVtYmVyIiwgIm51bSIsICJmb3JtYXQiLCAiZm9ybWF0dGVycyIsICJ2YWx1ZXMiLCAiaXNBcnJheSIsICJudW1lcmljIiwgInRpY2tWYWx1ZSIsICJpbmRleCIsICJ0aWNrcyIsICJjaGFydCIsICJub3RhdGlvbiIsICJkZWx0YSIsICJsZW5ndGgiLCAibWF4VGljayIsICJtYXgiLCAiYWJzIiwgImNhbGN1bGF0ZURlbHRhIiwgImxvZ0RlbHRhIiwgImxvZzEwIiwgIm51bURlY2ltYWwiLCAiaXNOYU4iLCAibWluIiwgImZsb29yIiwgIm1pbmltdW1GcmFjdGlvbkRpZ2l0cyIsICJtYXhpbXVtRnJhY3Rpb25EaWdpdHMiLCAiT2JqZWN0IiwgImFzc2lnbiIsICJsb2dhcml0aG1pYyIsICJyZW1haW4iLCAic2lnbmlmaWNhbmQiLCAiaW5jbHVkZXMiLCAiY2FsbCIsICJhcHBseVNjYWxlRGVmYXVsdHMiLCAiZGlzcGxheSIsICJvZmZzZXQiLCAicmV2ZXJzZSIsICJiZWdpbkF0WmVybyIsICJib3VuZHMiLCAiY2xpcCIsICJncmFjZSIsICJncmlkIiwgImxpbmVXaWR0aCIsICJkcmF3T25DaGFydEFyZWEiLCAiZHJhd1RpY2tzIiwgInRpY2tMZW5ndGgiLCAidGlja1dpZHRoIiwgIl9jdHgiLCAidGlja0NvbG9yIiwgImJvcmRlciIsICJkYXNoIiwgImRhc2hPZmZzZXQiLCAid2lkdGgiLCAidGl0bGUiLCAidGV4dCIsICJtaW5Sb3RhdGlvbiIsICJtYXhSb3RhdGlvbiIsICJtaXJyb3IiLCAidGV4dFN0cm9rZVdpZHRoIiwgInRleHRTdHJva2VDb2xvciIsICJhdXRvU2tpcCIsICJhdXRvU2tpcFBhZGRpbmciLCAibGFiZWxPZmZzZXQiLCAiY2FsbGJhY2siLCAiVGlja3MiLCAibWlub3IiLCAibWFqb3IiLCAiYWxpZ24iLCAiY3Jvc3NBbGlnbiIsICJzaG93TGFiZWxCYWNrZHJvcCIsICJiYWNrZHJvcENvbG9yIiwgImJhY2tkcm9wUGFkZGluZyIsICJyb3V0ZSIsICJzdGFydHNXaXRoIiwgIm92ZXJyaWRlcyIsICJjcmVhdGUiLCAiZGVzY3JpcHRvcnMiLCAiZ2V0U2NvcGUiLCAibm9kZSIsICJrZXkiLCAia2V5cyIsICJzcGxpdCIsICJpIiwgIm4iLCAiayIsICJyb290IiwgInNjb3BlIiwgIm1lcmdlIiwgIkRlZmF1bHRzIiwgImNvbnN0cnVjdG9yIiwgIl9kZXNjcmlwdG9ycyIsICJfYXBwbGllcnMiLCAiYmFja2dyb3VuZENvbG9yIiwgImJvcmRlckNvbG9yIiwgImRhdGFzZXRzIiwgImRldmljZVBpeGVsUmF0aW8iLCAiY29udGV4dCIsICJwbGF0Zm9ybSIsICJnZXREZXZpY2VQaXhlbFJhdGlvIiwgImVsZW1lbnRzIiwgImV2ZW50cyIsICJmb250IiwgImZhbWlseSIsICJzaXplIiwgInN0eWxlIiwgImxpbmVIZWlnaHQiLCAid2VpZ2h0IiwgImhvdmVyIiwgImhvdmVyQmFja2dyb3VuZENvbG9yIiwgImN0eCIsICJob3ZlckJvcmRlckNvbG9yIiwgImhvdmVyQ29sb3IiLCAiaW5kZXhBeGlzIiwgImludGVyYWN0aW9uIiwgIm1vZGUiLCAiaW50ZXJzZWN0IiwgImluY2x1ZGVJbnZpc2libGUiLCAibWFpbnRhaW5Bc3BlY3RSYXRpbyIsICJvbkhvdmVyIiwgIm9uQ2xpY2siLCAicGFyc2luZyIsICJwbHVnaW5zIiwgInJlc3BvbnNpdmUiLCAic2NhbGUiLCAic2NhbGVzIiwgInNob3dMaW5lIiwgImRyYXdBY3RpdmVFbGVtZW50c09uVG9wIiwgImFwcGx5IiwgIm92ZXJyaWRlIiwgInRhcmdldFNjb3BlIiwgInRhcmdldE5hbWUiLCAic2NvcGVPYmplY3QiLCAidGFyZ2V0U2NvcGVPYmplY3QiLCAicHJpdmF0ZU5hbWUiLCAiZGVmaW5lUHJvcGVydGllcyIsICJ3cml0YWJsZSIsICJlbnVtZXJhYmxlIiwgImxvY2FsIiwgInRhcmdldCIsICJpc09iamVjdCIsICJ2YWx1ZU9yRGVmYXVsdCIsICJhcHBsaWVycyIsICJmb3JFYWNoIiwgInRvRm9udFN0cmluZyIsICJpc051bGxPclVuZGVmIiwgIl9tZWFzdXJlVGV4dCIsICJkYXRhIiwgImdjIiwgImxvbmdlc3QiLCAic3RyaW5nIiwgInRleHRXaWR0aCIsICJtZWFzdXJlVGV4dCIsICJwdXNoIiwgIl9sb25nZXN0VGV4dCIsICJhcnJheU9mVGhpbmdzIiwgImNhY2hlIiwgImdhcmJhZ2VDb2xsZWN0IiwgInNhdmUiLCAiaWxlbiIsICJqIiwgImpsZW4iLCAidGhpbmciLCAibmVzdGVkVGhpbmciLCAicmVzdG9yZSIsICJnY0xlbiIsICJzcGxpY2UiLCAiX2FsaWduUGl4ZWwiLCAicGl4ZWwiLCAiY3VycmVudERldmljZVBpeGVsUmF0aW8iLCAiaGFsZldpZHRoIiwgInJvdW5kIiwgImNsZWFyQ2FudmFzIiwgImNhbnZhcyIsICJnZXRDb250ZXh0IiwgInJlc2V0VHJhbnNmb3JtIiwgImNsZWFyUmVjdCIsICJoZWlnaHQiLCAiZHJhd1BvaW50IiwgIngiLCAieSIsICJkcmF3UG9pbnRMZWdlbmQiLCAidyIsICJ4T2Zmc2V0IiwgInlPZmZzZXQiLCAiY29ybmVyUmFkaXVzIiwgInhPZmZzZXRXIiwgInlPZmZzZXRXIiwgInBvaW50U3R5bGUiLCAicm90YXRpb24iLCAicmFkaXVzIiwgInJhZCIsICJSQURfUEVSX0RFRyIsICJ0cmFuc2xhdGUiLCAicm90YXRlIiwgImRyYXdJbWFnZSIsICJiZWdpblBhdGgiLCAiZWxsaXBzZSIsICJhcmMiLCAiY2xvc2VQYXRoIiwgIm1vdmVUbyIsICJUV09fVEhJUkRTX1BJIiwgImxpbmVUbyIsICJRVUFSVEVSX1BJIiwgIlNRUlQxXzIiLCAicmVjdCIsICJmaWxsIiwgImJvcmRlcldpZHRoIiwgInN0cm9rZSIsICJfaXNQb2ludEluQXJlYSIsICJwb2ludCIsICJhcmVhIiwgIm1hcmdpbiIsICJjbGlwQXJlYSIsICJ1bmNsaXBBcmVhIiwgInNldFJlbmRlck9wdHMiLCAiY3R4IiwgIm9wdHMiLCAidHJhbnNsYXRpb24iLCAidHJhbnNsYXRlIiwgImlzTnVsbE9yVW5kZWYiLCAicm90YXRpb24iLCAicm90YXRlIiwgImNvbG9yIiwgImZpbGxTdHlsZSIsICJ0ZXh0QWxpZ24iLCAidGV4dEJhc2VsaW5lIiwgImRlY29yYXRlVGV4dCIsICJ4IiwgInkiLCAibGluZSIsICJzdHJpa2V0aHJvdWdoIiwgInVuZGVybGluZSIsICJtZXRyaWNzIiwgIm1lYXN1cmVUZXh0IiwgImxlZnQiLCAiYWN0dWFsQm91bmRpbmdCb3hMZWZ0IiwgInJpZ2h0IiwgImFjdHVhbEJvdW5kaW5nQm94UmlnaHQiLCAidG9wIiwgImFjdHVhbEJvdW5kaW5nQm94QXNjZW50IiwgImJvdHRvbSIsICJhY3R1YWxCb3VuZGluZ0JveERlc2NlbnQiLCAieURlY29yYXRpb24iLCAic3Ryb2tlU3R5bGUiLCAiYmVnaW5QYXRoIiwgImxpbmVXaWR0aCIsICJkZWNvcmF0aW9uV2lkdGgiLCAibW92ZVRvIiwgImxpbmVUbyIsICJzdHJva2UiLCAiZHJhd0JhY2tkcm9wIiwgIm9sZENvbG9yIiwgImZpbGxSZWN0IiwgIndpZHRoIiwgImhlaWdodCIsICJyZW5kZXJUZXh0IiwgInRleHQiLCAiZm9udCIsICJsaW5lcyIsICJpc0FycmF5IiwgInN0cm9rZVdpZHRoIiwgInN0cm9rZUNvbG9yIiwgImkiLCAic2F2ZSIsICJzdHJpbmciLCAibGVuZ3RoIiwgImJhY2tkcm9wIiwgInN0cm9rZVRleHQiLCAibWF4V2lkdGgiLCAiZmlsbFRleHQiLCAiTnVtYmVyIiwgImxpbmVIZWlnaHQiLCAicmVzdG9yZSIsICJhZGRSb3VuZGVkUmVjdFBhdGgiLCAicmVjdCIsICJ3IiwgImgiLCAicmFkaXVzIiwgImFyYyIsICJ0b3BMZWZ0IiwgIlBJIiwgImJvdHRvbUxlZnQiLCAiSEFMRl9QSSIsICJib3R0b21SaWdodCIsICJ0b3BSaWdodCIsICJMSU5FX0hFSUdIVCIsICJGT05UX1NUWUxFIiwgInRvTGluZUhlaWdodCIsICJ2YWx1ZSIsICJzaXplIiwgIm1hdGNoZXMiLCAibWF0Y2giLCAibnVtYmVyT3JaZXJvIiwgInYiLCAiX3JlYWRWYWx1ZVRvUHJvcHMiLCAicHJvcHMiLCAicmV0IiwgIm9ialByb3BzIiwgImlzT2JqZWN0IiwgImtleXMiLCAiT2JqZWN0IiwgInJlYWQiLCAicHJvcCIsICJ2YWx1ZU9yRGVmYXVsdCIsICJ0b1RSQkwiLCAidG9UUkJMQ29ybmVycyIsICJ0b1BhZGRpbmciLCAib2JqIiwgInRvRm9udCIsICJvcHRpb25zIiwgImZhbGxiYWNrIiwgImRlZmF1bHRzIiwgInBhcnNlSW50IiwgInN0eWxlIiwgImNvbnNvbGUiLCAid2FybiIsICJ1bmRlZmluZWQiLCAiZmFtaWx5IiwgIndlaWdodCIsICJ0b0ZvbnRTdHJpbmciLCAicmVzb2x2ZSIsICJpbnB1dHMiLCAiY29udGV4dCIsICJpbmRleCIsICJpbmZvIiwgImNhY2hlYWJsZSIsICJpbGVuIiwgIl9hZGRHcmFjZSIsICJtaW5tYXgiLCAiZ3JhY2UiLCAiYmVnaW5BdFplcm8iLCAibWluIiwgIm1heCIsICJjaGFuZ2UiLCAidG9EaW1lbnNpb24iLCAia2VlcFplcm8iLCAiYWRkIiwgIk1hdGgiLCAiYWJzIiwgImNyZWF0ZUNvbnRleHQiLCAicGFyZW50Q29udGV4dCIsICJhc3NpZ24iLCAiY3JlYXRlIiwgIl9jcmVhdGVSZXNvbHZlciIsICJzY29wZXMiLCAicHJlZml4ZXMiLCAicm9vdFNjb3BlcyIsICJnZXRUYXJnZXQiLCAiZmluYWxSb290U2NvcGVzIiwgIl9yZXNvbHZlIiwgImNhY2hlIiwgIlN5bWJvbCIsICJ0b1N0cmluZ1RhZyIsICJfY2FjaGVhYmxlIiwgIl9zY29wZXMiLCAiX3Jvb3RTY29wZXMiLCAiX2ZhbGxiYWNrIiwgIl9nZXRUYXJnZXQiLCAib3ZlcnJpZGUiLCAic2NvcGUiLCAiUHJveHkiLCAiZGVsZXRlUHJvcGVydHkiLCAidGFyZ2V0IiwgIl9rZXlzIiwgImdldCIsICJfY2FjaGVkIiwgIl9yZXNvbHZlV2l0aFByZWZpeGVzIiwgImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsICJSZWZsZWN0IiwgImdldFByb3RvdHlwZU9mIiwgImhhcyIsICJnZXRLZXlzRnJvbUFsbFNjb3BlcyIsICJpbmNsdWRlcyIsICJvd25LZXlzIiwgInNldCIsICJzdG9yYWdlIiwgIl9zdG9yYWdlIiwgIl9hdHRhY2hDb250ZXh0IiwgInByb3h5IiwgInN1YlByb3h5IiwgImRlc2NyaXB0b3JEZWZhdWx0cyIsICJfcHJveHkiLCAiX2NvbnRleHQiLCAiX3N1YlByb3h5IiwgIl9zdGFjayIsICJTZXQiLCAiX2Rlc2NyaXB0b3JzIiwgInNldENvbnRleHQiLCAicmVjZWl2ZXIiLCAiX3Jlc29sdmVXaXRoQ29udGV4dCIsICJhbGxLZXlzIiwgImVudW1lcmFibGUiLCAiY29uZmlndXJhYmxlIiwgInNjcmlwdGFibGUiLCAiaW5kZXhhYmxlIiwgIl9zY3JpcHRhYmxlIiwgIl9pbmRleGFibGUiLCAiX2FsbEtleXMiLCAiaXNTY3JpcHRhYmxlIiwgImlzRnVuY3Rpb24iLCAiaXNJbmRleGFibGUiLCAicmVhZEtleSIsICJwcmVmaXgiLCAibmFtZSIsICJfY2FwaXRhbGl6ZSIsICJuZWVkc1N1YlJlc29sdmVyIiwgImNvbnN0cnVjdG9yIiwgInByb3RvdHlwZSIsICJoYXNPd25Qcm9wZXJ0eSIsICJjYWxsIiwgImRlc2NyaXB0b3JzIiwgIl9yZXNvbHZlU2NyaXB0YWJsZSIsICJfcmVzb2x2ZUFycmF5IiwgImdldFZhbHVlIiwgIkVycm9yIiwgIkFycmF5IiwgImZyb20iLCAiam9pbiIsICJkZWxldGUiLCAiY3JlYXRlU3ViUmVzb2x2ZXIiLCAiYXJyIiwgImZpbHRlciIsICJzIiwgIml0ZW0iLCAicmVzb2x2ZXIiLCAicHVzaCIsICJyZXNvbHZlRmFsbGJhY2siLCAiZ2V0U2NvcGUiLCAia2V5IiwgInBhcmVudCIsICJyZXNvbHZlT2JqZWN0S2V5IiwgImFkZFNjb3BlcyIsICJwYXJlbnRTY29wZXMiLCAicGFyZW50RmFsbGJhY2siLCAiYWxsU2NvcGVzIiwgImFkZFNjb3Blc0Zyb21LZXkiLCAic3ViR2V0VGFyZ2V0IiwgInJlc29sdmVLZXlzRnJvbUFsbFNjb3BlcyIsICJrIiwgInN0YXJ0c1dpdGgiLCAiRVBTSUxPTiIsICJOdW1iZXIiLCAiX2lzRG9tU3VwcG9ydGVkIiwgIndpbmRvdyIsICJkb2N1bWVudCIsICJfZ2V0UGFyZW50Tm9kZSIsICJkb21Ob2RlIiwgInBhcmVudCIsICJwYXJlbnROb2RlIiwgInRvU3RyaW5nIiwgImhvc3QiLCAicGFyc2VNYXhTdHlsZSIsICJzdHlsZVZhbHVlIiwgIm5vZGUiLCAicGFyZW50UHJvcGVydHkiLCAidmFsdWVJblBpeGVscyIsICJwYXJzZUludCIsICJpbmRleE9mIiwgImdldENvbXB1dGVkU3R5bGUiLCAiZWxlbWVudCIsICJvd25lckRvY3VtZW50IiwgImRlZmF1bHRWaWV3IiwgImdldFN0eWxlIiwgImVsIiwgInByb3BlcnR5IiwgImdldFByb3BlcnR5VmFsdWUiLCAicG9zaXRpb25zIiwgImdldFBvc2l0aW9uZWRTdHlsZSIsICJzdHlsZXMiLCAic3R5bGUiLCAic3VmZml4IiwgInJlc3VsdCIsICJpIiwgInBvcyIsICJwYXJzZUZsb2F0IiwgIndpZHRoIiwgImxlZnQiLCAicmlnaHQiLCAiaGVpZ2h0IiwgInRvcCIsICJib3R0b20iLCAidXNlT2Zmc2V0UG9zIiwgIngiLCAieSIsICJ0YXJnZXQiLCAic2hhZG93Um9vdCIsICJnZXRDYW52YXNQb3NpdGlvbiIsICJlIiwgImNhbnZhcyIsICJ0b3VjaGVzIiwgInNvdXJjZSIsICJsZW5ndGgiLCAib2Zmc2V0WCIsICJvZmZzZXRZIiwgImJveCIsICJyZWN0IiwgImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsICJjbGllbnRYIiwgImNsaWVudFkiLCAiZ2V0UmVsYXRpdmVQb3NpdGlvbiIsICJldmVudCIsICJjaGFydCIsICJjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyIsICJib3JkZXJCb3giLCAiYm94U2l6aW5nIiwgInBhZGRpbmdzIiwgImJvcmRlcnMiLCAieE9mZnNldCIsICJ5T2Zmc2V0IiwgIk1hdGgiLCAicm91bmQiLCAiZ2V0Q29udGFpbmVyU2l6ZSIsICJtYXhXaWR0aCIsICJtYXhIZWlnaHQiLCAidW5kZWZpbmVkIiwgImNvbnRhaW5lciIsICJjbGllbnRXaWR0aCIsICJjbGllbnRIZWlnaHQiLCAiY29udGFpbmVyU3R5bGUiLCAiY29udGFpbmVyQm9yZGVyIiwgImNvbnRhaW5lclBhZGRpbmciLCAiSU5GSU5JVFkiLCAicm91bmQxIiwgInYiLCAiZ2V0TWF4aW11bVNpemUiLCAiYmJXaWR0aCIsICJiYkhlaWdodCIsICJhc3BlY3RSYXRpbyIsICJtYXJnaW5zIiwgImNvbnRhaW5lclNpemUiLCAibWF4IiwgIm1pbiIsICJtYWludGFpbkhlaWdodCIsICJmbG9vciIsICJyZXRpbmFTY2FsZSIsICJmb3JjZVJhdGlvIiwgImZvcmNlU3R5bGUiLCAicGl4ZWxSYXRpbyIsICJkZXZpY2VIZWlnaHQiLCAiZGV2aWNlV2lkdGgiLCAiY3R4IiwgInNldFRyYW5zZm9ybSIsICJzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zIiwgInBhc3NpdmVTdXBwb3J0ZWQiLCAib3B0aW9ucyIsICJwYXNzaXZlIiwgImFkZEV2ZW50TGlzdGVuZXIiLCAicmVtb3ZlRXZlbnRMaXN0ZW5lciIsICJyZWFkVXNlZFNpemUiLCAidmFsdWUiLCAibWF0Y2hlcyIsICJtYXRjaCIsICJnZXRSaWdodFRvTGVmdEFkYXB0ZXIiLCAicmVjdFgiLCAid2lkdGgiLCAieCIsICJzZXRXaWR0aCIsICJ3IiwgInRleHRBbGlnbiIsICJhbGlnbiIsICJ4UGx1cyIsICJ2YWx1ZSIsICJsZWZ0Rm9yTHRyIiwgIml0ZW1XaWR0aCIsICJnZXRMZWZ0VG9SaWdodEFkYXB0ZXIiLCAiX2l0ZW1XaWR0aCIsICJnZXRSdGxBZGFwdGVyIiwgInJ0bCIsICJvdmVycmlkZVRleHREaXJlY3Rpb24iLCAiY3R4IiwgImRpcmVjdGlvbiIsICJzdHlsZSIsICJvcmlnaW5hbCIsICJjYW52YXMiLCAiZ2V0UHJvcGVydHlWYWx1ZSIsICJnZXRQcm9wZXJ0eVByaW9yaXR5IiwgInNldFByb3BlcnR5IiwgInByZXZUZXh0RGlyZWN0aW9uIiwgInJlc3RvcmVUZXh0RGlyZWN0aW9uIiwgInVuZGVmaW5lZCIsICJBbmltYXRvciIsICJjb25zdHJ1Y3RvciIsICJfcmVxdWVzdCIsICJfY2hhcnRzIiwgIk1hcCIsICJfcnVubmluZyIsICJfbGFzdERhdGUiLCAidW5kZWZpbmVkIiwgIl9ub3RpZnkiLCAiY2hhcnQiLCAiYW5pbXMiLCAiZGF0ZSIsICJ0eXBlIiwgImNhbGxiYWNrcyIsICJsaXN0ZW5lcnMiLCAibnVtU3RlcHMiLCAiZHVyYXRpb24iLCAiZm9yRWFjaCIsICJmbiIsICJpbml0aWFsIiwgImN1cnJlbnRTdGVwIiwgIk1hdGgiLCAibWluIiwgInN0YXJ0IiwgIl9yZWZyZXNoIiwgInJlcXVlc3RBbmltRnJhbWUiLCAiY2FsbCIsICJ3aW5kb3ciLCAiX3VwZGF0ZSIsICJEYXRlIiwgIm5vdyIsICJyZW1haW5pbmciLCAicnVubmluZyIsICJpdGVtcyIsICJsZW5ndGgiLCAiaSIsICJkcmF3IiwgIml0ZW0iLCAiX2FjdGl2ZSIsICJfdG90YWwiLCAidGljayIsICJwb3AiLCAiX2dldEFuaW1zIiwgImNoYXJ0cyIsICJnZXQiLCAiY29tcGxldGUiLCAicHJvZ3Jlc3MiLCAic2V0IiwgImxpc3RlbiIsICJldmVudCIsICJjYiIsICJwdXNoIiwgImFkZCIsICJoYXMiLCAicmVkdWNlIiwgImFjYyIsICJjdXIiLCAibWF4IiwgIl9kdXJhdGlvbiIsICJzdG9wIiwgImNhbmNlbCIsICJyZW1vdmUiLCAiZGVsZXRlIiwgInRyYW5zcGFyZW50IiwgImludGVycG9sYXRvcnMiLCAiYm9vbGVhbiIsICJmcm9tIiwgInRvIiwgImZhY3RvciIsICJjb2xvciIsICJjMCIsICJoZWxwZXJzQ29sb3IiLCAiYzEiLCAidmFsaWQiLCAibWl4IiwgImhleFN0cmluZyIsICJudW1iZXIiLCAiQW5pbWF0aW9uIiwgImNmZyIsICJ0YXJnZXQiLCAicHJvcCIsICJjdXJyZW50VmFsdWUiLCAicmVzb2x2ZSIsICJfZm4iLCAiX2Vhc2luZyIsICJlZmZlY3RzIiwgImVhc2luZyIsICJsaW5lYXIiLCAiX3N0YXJ0IiwgImZsb29yIiwgImRlbGF5IiwgIl9sb29wIiwgImxvb3AiLCAiX3RhcmdldCIsICJfcHJvcCIsICJfZnJvbSIsICJfdG8iLCAiX3Byb21pc2VzIiwgImFjdGl2ZSIsICJ1cGRhdGUiLCAiZWxhcHNlZCIsICJyZW1haW4iLCAid2FpdCIsICJwcm9taXNlcyIsICJQcm9taXNlIiwgInJlcyIsICJyZWoiLCAicmVzb2x2ZWQiLCAibWV0aG9kIiwgIkFuaW1hdGlvbnMiLCAiY29uZmlnIiwgIl9jaGFydCIsICJfcHJvcGVydGllcyIsICJjb25maWd1cmUiLCAiaXNPYmplY3QiLCAiYW5pbWF0aW9uT3B0aW9ucyIsICJPYmplY3QiLCAia2V5cyIsICJkZWZhdWx0cyIsICJhbmltYXRpb24iLCAiYW5pbWF0ZWRQcm9wcyIsICJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwgImtleSIsICJvcHRpb24iLCAiaXNBcnJheSIsICJwcm9wZXJ0aWVzIiwgIl9hbmltYXRlT3B0aW9ucyIsICJ2YWx1ZXMiLCAibmV3T3B0aW9ucyIsICJvcHRpb25zIiwgInJlc29sdmVUYXJnZXRPcHRpb25zIiwgImFuaW1hdGlvbnMiLCAiX2NyZWF0ZUFuaW1hdGlvbnMiLCAiJHNoYXJlZCIsICJhd2FpdEFsbCIsICIkYW5pbWF0aW9ucyIsICJ0aGVuIiwgInByb3BzIiwgImNoYXJBdCIsICJ2YWx1ZSIsICJzaXplIiwgImFzc2lnbiIsICJhbmltYXRvciIsICJhbmltIiwgImFsbCIsICJzY2FsZUNsaXAiLCAic2NhbGUiLCAiYWxsb3dlZE92ZXJmbG93IiwgIm9wdHMiLCAicmV2ZXJzZSIsICJlbmQiLCAiZGVmYXVsdENsaXAiLCAieFNjYWxlIiwgInlTY2FsZSIsICJ4IiwgInkiLCAidG9wIiwgInJpZ2h0IiwgImJvdHRvbSIsICJsZWZ0IiwgInRvQ2xpcCIsICJ0IiwgInIiLCAiYiIsICJsIiwgImRpc2FibGVkIiwgImdldFNvcnRlZERhdGFzZXRJbmRpY2VzIiwgImZpbHRlclZpc2libGUiLCAibWV0YXNldHMiLCAiX2dldFNvcnRlZERhdGFzZXRNZXRhcyIsICJpbGVuIiwgImluZGV4IiwgImFwcGx5U3RhY2siLCAic3RhY2siLCAiZHNJbmRleCIsICJzaW5nbGVNb2RlIiwgIm1vZGUiLCAiZGF0YXNldEluZGV4IiwgIm90aGVyVmFsdWUiLCAiaXNGaW5pdGUiLCAic2lnbiIsICJjb252ZXJ0T2JqZWN0RGF0YVRvQXJyYXkiLCAiZGF0YSIsICJhZGF0YSIsICJBcnJheSIsICJpc1N0YWNrZWQiLCAibWV0YSIsICJzdGFja2VkIiwgImdldFN0YWNrS2V5IiwgImluZGV4U2NhbGUiLCAidmFsdWVTY2FsZSIsICJpZCIsICJnZXRVc2VyQm91bmRzIiwgIm1pbkRlZmluZWQiLCAibWF4RGVmaW5lZCIsICJOdW1iZXIiLCAiTkVHQVRJVkVfSU5GSU5JVFkiLCAiUE9TSVRJVkVfSU5GSU5JVFkiLCAiZ2V0T3JDcmVhdGVTdGFjayIsICJzdGFja3MiLCAic3RhY2tLZXkiLCAiaW5kZXhWYWx1ZSIsICJzdWJTdGFjayIsICJnZXRMYXN0SW5kZXhJblN0YWNrIiwgInZTY2FsZSIsICJwb3NpdGl2ZSIsICJnZXRNYXRjaGluZ1Zpc2libGVNZXRhcyIsICJ1cGRhdGVTdGFja3MiLCAiY29udHJvbGxlciIsICJwYXJzZWQiLCAiX2NhY2hlZE1ldGEiLCAiX3N0YWNrcyIsICJpU2NhbGUiLCAiaUF4aXMiLCAiYXhpcyIsICJ2QXhpcyIsICJpdGVtU3RhY2tzIiwgIl90b3AiLCAiX2JvdHRvbSIsICJ2aXN1YWxWYWx1ZXMiLCAiX3Zpc3VhbFZhbHVlcyIsICJnZXRGaXJzdFNjYWxlSWQiLCAic2NhbGVzIiwgImZpbHRlciIsICJzaGlmdCIsICJjcmVhdGVEYXRhc2V0Q29udGV4dCIsICJwYXJlbnQiLCAiY3JlYXRlQ29udGV4dCIsICJkYXRhc2V0IiwgImNyZWF0ZURhdGFDb250ZXh0IiwgImVsZW1lbnQiLCAiZGF0YUluZGV4IiwgInJhdyIsICJjbGVhclN0YWNrcyIsICJfcGFyc2VkIiwgImlzRGlyZWN0VXBkYXRlTW9kZSIsICJjbG9uZUlmTm90U2hhcmVkIiwgImNhY2hlZCIsICJzaGFyZWQiLCAiY3JlYXRlU3RhY2siLCAiY2FuU3RhY2siLCAiaGlkZGVuIiwgIl9zdGFja2VkIiwgIkRhdGFzZXRDb250cm9sbGVyIiwgIl9jdHgiLCAiY3R4IiwgIl9jYWNoZWREYXRhT3B0cyIsICJnZXRNZXRhIiwgIl90eXBlIiwgIl9wYXJzaW5nIiwgIl9kYXRhIiwgIl9vYmplY3REYXRhIiwgIl9zaGFyZWRPcHRpb25zIiwgIl9kcmF3U3RhcnQiLCAiX2RyYXdDb3VudCIsICJlbmFibGVPcHRpb25TaGFyaW5nIiwgInN1cHBvcnRzRGVjaW1hdGlvbiIsICIkY29udGV4dCIsICJfc3luY0xpc3QiLCAiZGF0YXNldEVsZW1lbnRUeXBlIiwgImRhdGFFbGVtZW50VHlwZSIsICJpbml0aWFsaXplIiwgImxpbmtTY2FsZXMiLCAiYWRkRWxlbWVudHMiLCAiZmlsbCIsICJpc1BsdWdpbkVuYWJsZWQiLCAiY29uc29sZSIsICJ3YXJuIiwgInVwZGF0ZUluZGV4IiwgImdldERhdGFzZXQiLCAiY2hvb3NlSWQiLCAieGlkIiwgInhBeGlzSUQiLCAidmFsdWVPckRlZmF1bHQiLCAieWlkIiwgInlBeGlzSUQiLCAicmlkIiwgInJBeGlzSUQiLCAiaW5kZXhBeGlzIiwgImlpZCIsICJpQXhpc0lEIiwgInZpZCIsICJ2QXhpc0lEIiwgImdldFNjYWxlRm9ySWQiLCAiclNjYWxlIiwgImRhdGFzZXRzIiwgImdldERhdGFzZXRNZXRhIiwgInNjYWxlSUQiLCAiX2dldE90aGVyU2NhbGUiLCAicmVzZXQiLCAiX2Rlc3Ryb3kiLCAidW5saXN0ZW5BcnJheUV2ZW50cyIsICJfZGF0YUNoZWNrIiwgImlzRXh0ZW5zaWJsZSIsICJsaXN0ZW5BcnJheUV2ZW50cyIsICJidWlsZE9yVXBkYXRlRWxlbWVudHMiLCAicmVzZXROZXdFbGVtZW50cyIsICJzdGFja0NoYW5nZWQiLCAib2xkU3RhY2tlZCIsICJfcmVzeW5jRWxlbWVudHMiLCAic2NvcGVLZXlzIiwgImRhdGFzZXRTY29wZUtleXMiLCAic2NvcGVzIiwgImdldE9wdGlvblNjb3BlcyIsICJjcmVhdGVSZXNvbHZlciIsICJnZXRDb250ZXh0IiwgInBhcnNpbmciLCAicGFyc2UiLCAiY291bnQiLCAic29ydGVkIiwgIl9zb3J0ZWQiLCAicHJldiIsICJwYXJzZUFycmF5RGF0YSIsICJwYXJzZU9iamVjdERhdGEiLCAicGFyc2VQcmltaXRpdmVEYXRhIiwgImlzTm90SW5PcmRlckNvbXBhcmVkVG9QcmV2IiwgImxhYmVscyIsICJnZXRMYWJlbHMiLCAic2luZ2xlU2NhbGUiLCAieEF4aXNLZXkiLCAieUF4aXNLZXkiLCAicmVzb2x2ZU9iamVjdEtleSIsICJnZXRQYXJzZWQiLCAiZ2V0RGF0YUVsZW1lbnQiLCAidXBkYXRlUmFuZ2VGcm9tUGFyc2VkIiwgInJhbmdlIiwgInBhcnNlZFZhbHVlIiwgIk5hTiIsICJnZXRNaW5NYXgiLCAib3RoZXJTY2FsZSIsICJvdGhlck1pbiIsICJvdGhlck1heCIsICJfc2tpcCIsICJnZXRBbGxQYXJzZWRWYWx1ZXMiLCAiZ2V0TWF4T3ZlcmZsb3ciLCAiZ2V0TGFiZWxBbmRWYWx1ZSIsICJsYWJlbCIsICJnZXRMYWJlbEZvclZhbHVlIiwgIl9jbGlwIiwgImNsaXAiLCAiZWxlbWVudHMiLCAiYXJlYSIsICJjaGFydEFyZWEiLCAiZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AiLCAiZ2V0U3R5bGUiLCAicmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyIsICJyZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zIiwgImNvbnRleHQiLCAiX3Jlc29sdmVFbGVtZW50T3B0aW9ucyIsICJlbGVtZW50VHlwZSIsICJjYWNoZSIsICJjYWNoZUtleSIsICJzaGFyaW5nIiwgImRlZmluZWQiLCAiZGF0YXNldEVsZW1lbnRTY29wZUtleXMiLCAicHJlZml4ZXMiLCAibmFtZXMiLCAicmVzb2x2ZU5hbWVkT3B0aW9ucyIsICJmcmVlemUiLCAiX3Jlc29sdmVBbmltYXRpb25zIiwgInRyYW5zaXRpb24iLCAiZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyIsICJfY2FjaGVhYmxlIiwgImdldFNoYXJlZE9wdGlvbnMiLCAiaW5jbHVkZU9wdGlvbnMiLCAic2hhcmVkT3B0aW9ucyIsICJfYW5pbWF0aW9uc0Rpc2FibGVkIiwgIl9nZXRTaGFyZWRPcHRpb25zIiwgImZpcnN0T3B0cyIsICJwcmV2aW91c2x5U2hhcmVkT3B0aW9ucyIsICJ1cGRhdGVTaGFyZWRPcHRpb25zIiwgInVwZGF0ZUVsZW1lbnQiLCAiX3NldFN0eWxlIiwgInJlbW92ZUhvdmVyU3R5bGUiLCAic2V0SG92ZXJTdHlsZSIsICJfcmVtb3ZlRGF0YXNldEhvdmVyU3R5bGUiLCAiX3NldERhdGFzZXRIb3ZlclN0eWxlIiwgImFyZzEiLCAiYXJnMiIsICJudW1NZXRhIiwgIm51bURhdGEiLCAiX2luc2VydEVsZW1lbnRzIiwgIl9yZW1vdmVFbGVtZW50cyIsICJtb3ZlIiwgImFyciIsICJ1cGRhdGVFbGVtZW50cyIsICJyZW1vdmVkIiwgInNwbGljZSIsICJfc3luYyIsICJhcmdzIiwgIl9kYXRhQ2hhbmdlcyIsICJfb25EYXRhUHVzaCIsICJhcmd1bWVudHMiLCAiX29uRGF0YVBvcCIsICJfb25EYXRhU2hpZnQiLCAiX29uRGF0YVNwbGljZSIsICJuZXdDb3VudCIsICJfb25EYXRhVW5zaGlmdCIsICJnZXRSYXRpb0FuZE9mZnNldCIsICJyb3RhdGlvbiIsICJjaXJjdW1mZXJlbmNlIiwgImN1dG91dCIsICJyYXRpb1giLCAicmF0aW9ZIiwgIm9mZnNldFgiLCAib2Zmc2V0WSIsICJUQVUiLCAic3RhcnRBbmdsZSIsICJlbmRBbmdsZSIsICJzdGFydFgiLCAiTWF0aCIsICJjb3MiLCAic3RhcnRZIiwgInNpbiIsICJlbmRYIiwgImVuZFkiLCAiY2FsY01heCIsICJhbmdsZSIsICJhIiwgImIiLCAiX2FuZ2xlQmV0d2VlbiIsICJtYXgiLCAiY2FsY01pbiIsICJtaW4iLCAibWF4WCIsICJtYXhZIiwgIkhBTEZfUEkiLCAibWluWCIsICJQSSIsICJtaW5ZIiwgIkRvdWdobnV0Q29udHJvbGxlciIsICJEYXRhc2V0Q29udHJvbGxlciIsICJjb25zdHJ1Y3RvciIsICJjaGFydCIsICJkYXRhc2V0SW5kZXgiLCAiZW5hYmxlT3B0aW9uU2hhcmluZyIsICJpbm5lclJhZGl1cyIsICJ1bmRlZmluZWQiLCAib3V0ZXJSYWRpdXMiLCAibGlua1NjYWxlcyIsICJwYXJzZSIsICJzdGFydCIsICJjb3VudCIsICJkYXRhIiwgImdldERhdGFzZXQiLCAibWV0YSIsICJfY2FjaGVkTWV0YSIsICJfcGFyc2luZyIsICJfcGFyc2VkIiwgImdldHRlciIsICJpIiwgImlzT2JqZWN0IiwgImtleSIsICJyZXNvbHZlT2JqZWN0S2V5IiwgImlsZW4iLCAiX2dldFJvdGF0aW9uIiwgInRvUmFkaWFucyIsICJvcHRpb25zIiwgIl9nZXRDaXJjdW1mZXJlbmNlIiwgIl9nZXRSb3RhdGlvbkV4dGVudHMiLCAiZGF0YXNldHMiLCAibGVuZ3RoIiwgImlzRGF0YXNldFZpc2libGUiLCAiZ2V0RGF0YXNldE1ldGEiLCAidHlwZSIsICJfdHlwZSIsICJjb250cm9sbGVyIiwgInVwZGF0ZSIsICJtb2RlIiwgImNoYXJ0QXJlYSIsICJhcmNzIiwgInNwYWNpbmciLCAiZ2V0TWF4Qm9yZGVyV2lkdGgiLCAiZ2V0TWF4T2Zmc2V0IiwgIm1heFNpemUiLCAid2lkdGgiLCAiaGVpZ2h0IiwgInRvUGVyY2VudGFnZSIsICJjaGFydFdlaWdodCIsICJfZ2V0UmluZ1dlaWdodCIsICJpbmRleCIsICJtYXhXaWR0aCIsICJtYXhIZWlnaHQiLCAibWF4UmFkaXVzIiwgInRvRGltZW5zaW9uIiwgInJhZGl1cyIsICJyYWRpdXNMZW5ndGgiLCAiX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwiLCAidG90YWwiLCAiY2FsY3VsYXRlVG90YWwiLCAiX2dldFJpbmdXZWlnaHRPZmZzZXQiLCAidXBkYXRlRWxlbWVudHMiLCAiX2NpcmN1bWZlcmVuY2UiLCAicmVzZXQiLCAib3B0cyIsICJhbmltYXRpb24iLCAiYW5pbWF0ZVJvdGF0ZSIsICJnZXREYXRhVmlzaWJpbGl0eSIsICJoaWRkZW4iLCAiY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZSIsICJhbmltYXRpb25PcHRzIiwgImNlbnRlclgiLCAibGVmdCIsICJyaWdodCIsICJjZW50ZXJZIiwgInRvcCIsICJib3R0b20iLCAiYW5pbWF0ZVNjYWxlIiwgInNoYXJlZE9wdGlvbnMiLCAiaW5jbHVkZU9wdGlvbnMiLCAiX2dldFNoYXJlZE9wdGlvbnMiLCAiYXJjIiwgInByb3BlcnRpZXMiLCAieCIsICJ5IiwgInJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMiLCAiYWN0aXZlIiwgInVwZGF0ZUVsZW1lbnQiLCAibWV0YURhdGEiLCAidmFsdWUiLCAiaXNOYU4iLCAiYWJzIiwgImdldExhYmVsQW5kVmFsdWUiLCAibGFiZWxzIiwgImZvcm1hdE51bWJlciIsICJsb2NhbGUiLCAibGFiZWwiLCAiYm9yZGVyQWxpZ24iLCAiYm9yZGVyV2lkdGgiLCAiaG92ZXJCb3JkZXJXaWR0aCIsICJvZmZzZXQiLCAiaG92ZXJPZmZzZXQiLCAicmluZ1dlaWdodE9mZnNldCIsICJ2YWx1ZU9yRGVmYXVsdCIsICJ3ZWlnaHQiLCAiaWQiLCAiZGVmYXVsdHMiLCAiZGF0YXNldEVsZW1lbnRUeXBlIiwgImRhdGFFbGVtZW50VHlwZSIsICJhbmltYXRpb25zIiwgIm51bWJlcnMiLCAiaW5kZXhBeGlzIiwgImRlc2NyaXB0b3JzIiwgIl9zY3JpcHRhYmxlIiwgIm5hbWUiLCAiX2luZGV4YWJsZSIsICJzdGFydHNXaXRoIiwgIm92ZXJyaWRlcyIsICJhc3BlY3RSYXRpbyIsICJwbHVnaW5zIiwgImxlZ2VuZCIsICJnZW5lcmF0ZUxhYmVscyIsICJwb2ludFN0eWxlIiwgImNvbG9yIiwgIm1hcCIsICJzdHlsZSIsICJnZXRTdHlsZSIsICJ0ZXh0IiwgImZpbGxTdHlsZSIsICJiYWNrZ3JvdW5kQ29sb3IiLCAic3Ryb2tlU3R5bGUiLCAiYm9yZGVyQ29sb3IiLCAiZm9udENvbG9yIiwgImxpbmVXaWR0aCIsICJvbkNsaWNrIiwgImUiLCAibGVnZW5kSXRlbSIsICJ0b2dnbGVEYXRhVmlzaWJpbGl0eSIsICJhYnN0cmFjdCIsICJFcnJvciIsICJEYXRlQWRhcHRlckJhc2UiLCAiY29uc3RydWN0b3IiLCAib3B0aW9ucyIsICJvdmVycmlkZSIsICJtZW1iZXJzIiwgIk9iamVjdCIsICJhc3NpZ24iLCAicHJvdG90eXBlIiwgImluaXQiLCAiZm9ybWF0cyIsICJwYXJzZSIsICJmb3JtYXQiLCAiYWRkIiwgImRpZmYiLCAic3RhcnRPZiIsICJlbmRPZiIsICJfZGF0ZSIsICJiaW5hcnlTZWFyY2giLCAibWV0YXNldCIsICJheGlzIiwgInZhbHVlIiwgImludGVyc2VjdCIsICJjb250cm9sbGVyIiwgImRhdGEiLCAiX3NvcnRlZCIsICJpU2NhbGUiLCAiX2NhY2hlZE1ldGEiLCAibGVuZ3RoIiwgImxvb2t1cE1ldGhvZCIsICJfcmV2ZXJzZVBpeGVscyIsICJfcmxvb2t1cEJ5S2V5IiwgIl9sb29rdXBCeUtleSIsICJfc2hhcmVkT3B0aW9ucyIsICJlbCIsICJyYW5nZSIsICJnZXRSYW5nZSIsICJzdGFydCIsICJlbmQiLCAibG8iLCAiaGkiLCAiZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zIiwgImNoYXJ0IiwgInBvc2l0aW9uIiwgImhhbmRsZXIiLCAibWV0YXNldHMiLCAiZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcyIsICJpIiwgImlsZW4iLCAiaW5kZXgiLCAiaiIsICJlbGVtZW50IiwgInNraXAiLCAiZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzIiwgInVzZVgiLCAiaW5kZXhPZiIsICJ1c2VZIiwgInB0MSIsICJwdDIiLCAiZGVsdGFYIiwgIk1hdGgiLCAiYWJzIiwgIngiLCAiZGVsdGFZIiwgInkiLCAic3FydCIsICJwb3ciLCAiZ2V0SW50ZXJzZWN0SXRlbXMiLCAidXNlRmluYWxQb3NpdGlvbiIsICJpbmNsdWRlSW52aXNpYmxlIiwgIml0ZW1zIiwgImlzUG9pbnRJbkFyZWEiLCAiZXZhbHVhdGlvbkZ1bmMiLCAiZGF0YXNldEluZGV4IiwgIl9pc1BvaW50SW5BcmVhIiwgImNoYXJ0QXJlYSIsICJpblJhbmdlIiwgInB1c2giLCAiZ2V0TmVhcmVzdFJhZGlhbEl0ZW1zIiwgInN0YXJ0QW5nbGUiLCAiZW5kQW5nbGUiLCAiZ2V0UHJvcHMiLCAiYW5nbGUiLCAiZ2V0QW5nbGVGcm9tUG9pbnQiLCAiX2FuZ2xlQmV0d2VlbiIsICJnZXROZWFyZXN0Q2FydGVzaWFuSXRlbXMiLCAiZGlzdGFuY2VNZXRyaWMiLCAibWluRGlzdGFuY2UiLCAiTnVtYmVyIiwgIlBPU0lUSVZFX0lORklOSVRZIiwgImNlbnRlciIsICJnZXRDZW50ZXJQb2ludCIsICJwb2ludEluQXJlYSIsICJkaXN0YW5jZSIsICJnZXROZWFyZXN0SXRlbXMiLCAiZ2V0QXhpc0l0ZW1zIiwgInJhbmdlTWV0aG9kIiwgImludGVyc2VjdHNJdGVtIiwgIm1vZGVzIiwgImUiLCAiZ2V0UmVsYXRpdmVQb3NpdGlvbiIsICJlbGVtZW50cyIsICJmb3JFYWNoIiwgIm1ldGEiLCAiZGF0YXNldCIsICJnZXREYXRhc2V0TWV0YSIsICJwb2ludCIsICJuZWFyZXN0IiwgIlNUQVRJQ19QT1NJVElPTlMiLCAiZmlsdGVyQnlQb3NpdGlvbiIsICJhcnJheSIsICJmaWx0ZXIiLCAidiIsICJwb3MiLCAiZmlsdGVyRHluYW1pY1Bvc2l0aW9uQnlBeGlzIiwgImJveCIsICJzb3J0QnlXZWlnaHQiLCAicmV2ZXJzZSIsICJzb3J0IiwgImEiLCAiYiIsICJ2MCIsICJ2MSIsICJ3ZWlnaHQiLCAid3JhcEJveGVzIiwgImJveGVzIiwgImxheW91dEJveGVzIiwgInN0YWNrIiwgInN0YWNrV2VpZ2h0IiwgImhvcml6b250YWwiLCAiaXNIb3Jpem9udGFsIiwgImJ1aWxkU3RhY2tzIiwgImxheW91dHMiLCAic3RhY2tzIiwgIndyYXAiLCAiaW5jbHVkZXMiLCAiX3N0YWNrIiwgImNvdW50IiwgInBsYWNlZCIsICJzaXplIiwgInNldExheW91dERpbXMiLCAicGFyYW1zIiwgInZCb3hNYXhXaWR0aCIsICJoQm94TWF4SGVpZ2h0IiwgImxheW91dCIsICJmdWxsU2l6ZSIsICJmYWN0b3IiLCAid2lkdGgiLCAiYXZhaWxhYmxlV2lkdGgiLCAiaGVpZ2h0IiwgImF2YWlsYWJsZUhlaWdodCIsICJidWlsZExheW91dEJveGVzIiwgImxlZnQiLCAicmlnaHQiLCAidG9wIiwgImJvdHRvbSIsICJjZW50ZXJIb3Jpem9udGFsIiwgImNlbnRlclZlcnRpY2FsIiwgImxlZnRBbmRUb3AiLCAiY29uY2F0IiwgInJpZ2h0QW5kQm90dG9tIiwgInZlcnRpY2FsIiwgImdldENvbWJpbmVkTWF4IiwgIm1heFBhZGRpbmciLCAibWF4IiwgInVwZGF0ZU1heFBhZGRpbmciLCAiYm94UGFkZGluZyIsICJ1cGRhdGVEaW1zIiwgImlzT2JqZWN0IiwgImdldFBhZGRpbmciLCAibmV3V2lkdGgiLCAib3V0ZXJXaWR0aCIsICJuZXdIZWlnaHQiLCAib3V0ZXJIZWlnaHQiLCAid2lkdGhDaGFuZ2VkIiwgInciLCAiaGVpZ2h0Q2hhbmdlZCIsICJoIiwgInNhbWUiLCAib3RoZXIiLCAiaGFuZGxlTWF4UGFkZGluZyIsICJ1cGRhdGVQb3MiLCAiY2hhbmdlIiwgImdldE1hcmdpbnMiLCAibWFyZ2luRm9yUG9zaXRpb25zIiwgInBvc2l0aW9ucyIsICJtYXJnaW4iLCAiZml0Qm94ZXMiLCAicmVmaXRCb3hlcyIsICJyZWZpdCIsICJjaGFuZ2VkIiwgInVwZGF0ZSIsICJzZXRCb3hEaW1zIiwgInBsYWNlQm94ZXMiLCAidXNlclBhZGRpbmciLCAicGFkZGluZyIsICJkZWZpbmVkIiwgImFkZEJveCIsICJpdGVtIiwgIl9sYXllcnMiLCAieiIsICJkcmF3IiwgInJlbW92ZUJveCIsICJsYXlvdXRJdGVtIiwgInNwbGljZSIsICJjb25maWd1cmUiLCAibWluUGFkZGluZyIsICJ0b1BhZGRpbmciLCAidmVydGljYWxCb3hlcyIsICJob3Jpem9udGFsQm94ZXMiLCAiZWFjaCIsICJiZWZvcmVMYXlvdXQiLCAidmlzaWJsZVZlcnRpY2FsQm94Q291bnQiLCAicmVkdWNlIiwgInRvdGFsIiwgImRpc3BsYXkiLCAiZnJlZXplIiwgIkJhc2VQbGF0Zm9ybSIsICJhY3F1aXJlQ29udGV4dCIsICJjYW52YXMiLCAiYXNwZWN0UmF0aW8iLCAicmVsZWFzZUNvbnRleHQiLCAiY29udGV4dCIsICJhZGRFdmVudExpc3RlbmVyIiwgInR5cGUiLCAibGlzdGVuZXIiLCAicmVtb3ZlRXZlbnRMaXN0ZW5lciIsICJnZXREZXZpY2VQaXhlbFJhdGlvIiwgImdldE1heGltdW1TaXplIiwgImZsb29yIiwgImlzQXR0YWNoZWQiLCAidXBkYXRlQ29uZmlnIiwgImNvbmZpZyIsICJCYXNpY1BsYXRmb3JtIiwgImdldENvbnRleHQiLCAiYW5pbWF0aW9uIiwgIkVYUEFORE9fS0VZIiwgIkVWRU5UX1RZUEVTIiwgInRvdWNoc3RhcnQiLCAidG91Y2htb3ZlIiwgInRvdWNoZW5kIiwgInBvaW50ZXJlbnRlciIsICJwb2ludGVyZG93biIsICJwb2ludGVybW92ZSIsICJwb2ludGVydXAiLCAicG9pbnRlcmxlYXZlIiwgInBvaW50ZXJvdXQiLCAiaXNOdWxsT3JFbXB0eSIsICJpbml0Q2FudmFzIiwgInN0eWxlIiwgInJlbmRlckhlaWdodCIsICJnZXRBdHRyaWJ1dGUiLCAicmVuZGVyV2lkdGgiLCAiaW5pdGlhbCIsICJib3hTaXppbmciLCAiZGlzcGxheVdpZHRoIiwgInJlYWRVc2VkU2l6ZSIsICJ1bmRlZmluZWQiLCAiZGlzcGxheUhlaWdodCIsICJldmVudExpc3RlbmVyT3B0aW9ucyIsICJzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zIiwgInBhc3NpdmUiLCAiYWRkTGlzdGVuZXIiLCAibm9kZSIsICJyZW1vdmVMaXN0ZW5lciIsICJmcm9tTmF0aXZlRXZlbnQiLCAiZXZlbnQiLCAibmF0aXZlIiwgIm5vZGVMaXN0Q29udGFpbnMiLCAibm9kZUxpc3QiLCAiY29udGFpbnMiLCAiY3JlYXRlQXR0YWNoT2JzZXJ2ZXIiLCAib2JzZXJ2ZXIiLCAiTXV0YXRpb25PYnNlcnZlciIsICJlbnRyaWVzIiwgInRyaWdnZXIiLCAiZW50cnkiLCAiYWRkZWROb2RlcyIsICJyZW1vdmVkTm9kZXMiLCAib2JzZXJ2ZSIsICJkb2N1bWVudCIsICJjaGlsZExpc3QiLCAic3VidHJlZSIsICJjcmVhdGVEZXRhY2hPYnNlcnZlciIsICJkcnBMaXN0ZW5pbmdDaGFydHMiLCAiTWFwIiwgIm9sZERldmljZVBpeGVsUmF0aW8iLCAib25XaW5kb3dSZXNpemUiLCAiZHByIiwgIndpbmRvdyIsICJkZXZpY2VQaXhlbFJhdGlvIiwgInJlc2l6ZSIsICJjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyIsICJsaXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyIsICJzZXQiLCAidW5saXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyIsICJkZWxldGUiLCAiY3JlYXRlUmVzaXplT2JzZXJ2ZXIiLCAiY29udGFpbmVyIiwgIl9nZXRQYXJlbnROb2RlIiwgInRocm90dGxlZCIsICJjbGllbnRXaWR0aCIsICJSZXNpemVPYnNlcnZlciIsICJjb250ZW50UmVjdCIsICJyZWxlYXNlT2JzZXJ2ZXIiLCAiZGlzY29ubmVjdCIsICJjcmVhdGVQcm94eUFuZExpc3RlbiIsICJwcm94eSIsICJjdHgiLCAiRG9tUGxhdGZvcm0iLCAicHJvcCIsICJpc051bGxPclVuZGVmIiwgInJlbW92ZUF0dHJpYnV0ZSIsICJzZXRBdHRyaWJ1dGUiLCAia2V5cyIsICJrZXkiLCAicHJveGllcyIsICIkcHJveGllcyIsICJoYW5kbGVycyIsICJhdHRhY2giLCAiZGV0YWNoIiwgImlzQ29ubmVjdGVkIiwgIl9kZXRlY3RQbGF0Zm9ybSIsICJfaXNEb21TdXBwb3J0ZWQiLCAiT2Zmc2NyZWVuQ2FudmFzIiwgIkVsZW1lbnQiLCAiYWN0aXZlIiwgIiRhbmltYXRpb25zIiwgInRvb2x0aXBQb3NpdGlvbiIsICJoYXNWYWx1ZSIsICJpc051bWJlciIsICJwcm9wcyIsICJmaW5hbCIsICJhbmltcyIsICJyZXQiLCAiX3RvIiwgImRlZmF1bHRzIiwgImRlZmF1bHRSb3V0ZXMiLCAiYXV0b1NraXAiLCAic2NhbGUiLCAidGlja3MiLCAidGlja09wdHMiLCAiZGV0ZXJtaW5lZE1heFRpY2tzIiwgImRldGVybWluZU1heFRpY2tzIiwgInRpY2tzTGltaXQiLCAibWluIiwgIm1heFRpY2tzTGltaXQiLCAibWFqb3JJbmRpY2VzIiwgIm1ham9yIiwgImVuYWJsZWQiLCAiZ2V0TWFqb3JJbmRpY2VzIiwgIm51bU1ham9ySW5kaWNlcyIsICJmaXJzdCIsICJsYXN0IiwgIm5ld1RpY2tzIiwgInNraXBNYWpvcnMiLCAic3BhY2luZyIsICJjYWxjdWxhdGVTcGFjaW5nIiwgImF2Z01ham9yU3BhY2luZyIsICJyb3VuZCIsICJvZmZzZXQiLCAidGlja0xlbmd0aCIsICJfdGlja1NpemUiLCAibWF4U2NhbGUiLCAiX2xlbmd0aCIsICJtYXhDaGFydCIsICJfbWF4TGVuZ3RoIiwgImV2ZW5NYWpvclNwYWNpbmciLCAiZ2V0RXZlblNwYWNpbmciLCAiZmFjdG9ycyIsICJfZmFjdG9yaXplIiwgInJlc3VsdCIsICJuZXh0IiwgImNlaWwiLCAibWFqb3JTdGFydCIsICJtYWpvckVuZCIsICJ2YWx1ZU9yRGVmYXVsdCIsICJhcnIiLCAibGVuIiwgInJldmVyc2VBbGlnbiIsICJhbGlnbiIsICJvZmZzZXRGcm9tRWRnZSIsICJlZGdlIiwgImdldFRpY2tzTGltaXQiLCAidGlja3NMZW5ndGgiLCAic2FtcGxlIiwgIm51bUl0ZW1zIiwgImluY3JlbWVudCIsICJnZXRQaXhlbEZvckdyaWRMaW5lIiwgIm9mZnNldEdyaWRMaW5lcyIsICJ2YWxpZEluZGV4IiwgIl9zdGFydFBpeGVsIiwgIl9lbmRQaXhlbCIsICJlcHNpbG9uIiwgImxpbmVWYWx1ZSIsICJnZXRQaXhlbEZvclRpY2siLCAiZ2FyYmFnZUNvbGxlY3QiLCAiY2FjaGVzIiwgImNhY2hlIiwgImdjIiwgImdjTGVuIiwgImdldFRpY2tNYXJrTGVuZ3RoIiwgImRyYXdUaWNrcyIsICJnZXRUaXRsZUhlaWdodCIsICJmYWxsYmFjayIsICJmb250IiwgInRvRm9udCIsICJsaW5lcyIsICJpc0FycmF5IiwgInRleHQiLCAibGluZUhlaWdodCIsICJjcmVhdGVTY2FsZUNvbnRleHQiLCAicGFyZW50IiwgImNyZWF0ZUNvbnRleHQiLCAiY3JlYXRlVGlja0NvbnRleHQiLCAidGljayIsICJ0aXRsZUFsaWduIiwgIl90b0xlZnRSaWdodENlbnRlciIsICJ0aXRsZUFyZ3MiLCAic2NhbGVzIiwgInJvdGF0aW9uIiwgIm1heFdpZHRoIiwgInRpdGxlWCIsICJ0aXRsZVkiLCAiX2FsaWduU3RhcnRFbmQiLCAicG9zaXRpb25BeGlzSUQiLCAiZ2V0UGl4ZWxGb3JWYWx1ZSIsICJIQUxGX1BJIiwgIlNjYWxlIiwgImNmZyIsICJpZCIsICJfbWFyZ2lucyIsICJtYXhIZWlnaHQiLCAicGFkZGluZ1RvcCIsICJwYWRkaW5nQm90dG9tIiwgInBhZGRpbmdMZWZ0IiwgInBhZGRpbmdSaWdodCIsICJsYWJlbFJvdGF0aW9uIiwgIl9yYW5nZSIsICJfZ3JpZExpbmVJdGVtcyIsICJfbGFiZWxJdGVtcyIsICJfbGFiZWxTaXplcyIsICJfbG9uZ2VzdFRleHRDYWNoZSIsICJfdXNlck1heCIsICJfdXNlck1pbiIsICJfc3VnZ2VzdGVkTWF4IiwgIl9zdWdnZXN0ZWRNaW4iLCAiX3RpY2tzTGVuZ3RoIiwgIl9ib3JkZXJWYWx1ZSIsICJfY2FjaGUiLCAiX2RhdGFMaW1pdHNDYWNoZWQiLCAiJGNvbnRleHQiLCAic2V0Q29udGV4dCIsICJzdWdnZXN0ZWRNaW4iLCAic3VnZ2VzdGVkTWF4IiwgInJhdyIsICJnZXRVc2VyQm91bmRzIiwgImZpbml0ZU9yRGVmYXVsdCIsICJORUdBVElWRV9JTkZJTklUWSIsICJtaW5EZWZpbmVkIiwgImlzRmluaXRlIiwgIm1heERlZmluZWQiLCAiZ2V0TWluTWF4IiwgImNhblN0YWNrIiwgIm1ldGFzIiwgImdldE1hdGNoaW5nVmlzaWJsZU1ldGFzIiwgImdldFRpY2tzIiwgImdldExhYmVscyIsICJsYWJlbHMiLCAieExhYmVscyIsICJ5TGFiZWxzIiwgImdldExhYmVsSXRlbXMiLCAiX2NvbXB1dGVMYWJlbEl0ZW1zIiwgImJlZm9yZVVwZGF0ZSIsICJjYWxsIiwgIm1hcmdpbnMiLCAiYmVnaW5BdFplcm8iLCAiZ3JhY2UiLCAic2FtcGxlU2l6ZSIsICJiZWZvcmVTZXREaW1lbnNpb25zIiwgInNldERpbWVuc2lvbnMiLCAiYWZ0ZXJTZXREaW1lbnNpb25zIiwgImJlZm9yZURhdGFMaW1pdHMiLCAiZGV0ZXJtaW5lRGF0YUxpbWl0cyIsICJhZnRlckRhdGFMaW1pdHMiLCAiX2FkZEdyYWNlIiwgImJlZm9yZUJ1aWxkVGlja3MiLCAiYnVpbGRUaWNrcyIsICJhZnRlckJ1aWxkVGlja3MiLCAic2FtcGxpbmdFbmFibGVkIiwgIl9jb252ZXJ0VGlja3NUb0xhYmVscyIsICJiZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uIiwgImNhbGN1bGF0ZUxhYmVsUm90YXRpb24iLCAiYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uIiwgInNvdXJjZSIsICJhZnRlckF1dG9Ta2lwIiwgImJlZm9yZUZpdCIsICJmaXQiLCAiYWZ0ZXJGaXQiLCAiYWZ0ZXJVcGRhdGUiLCAicmV2ZXJzZVBpeGVscyIsICJzdGFydFBpeGVsIiwgImVuZFBpeGVsIiwgIl9hbGlnblRvUGl4ZWxzIiwgImFsaWduVG9QaXhlbHMiLCAiX2NhbGxIb29rcyIsICJuYW1lIiwgIm5vdGlmeVBsdWdpbnMiLCAiYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uIiwgImdlbmVyYXRlVGlja0xhYmVscyIsICJsYWJlbCIsICJjYWxsYmFjayIsICJhZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbiIsICJudW1UaWNrcyIsICJtaW5Sb3RhdGlvbiIsICJtYXhSb3RhdGlvbiIsICJ0aWNrV2lkdGgiLCAibWF4TGFiZWxEaWFnb25hbCIsICJfaXNWaXNpYmxlIiwgImxhYmVsU2l6ZXMiLCAiX2dldExhYmVsU2l6ZXMiLCAibWF4TGFiZWxXaWR0aCIsICJ3aWRlc3QiLCAibWF4TGFiZWxIZWlnaHQiLCAiaGlnaGVzdCIsICJfbGltaXRWYWx1ZSIsICJncmlkIiwgInRpdGxlIiwgInRvRGVncmVlcyIsICJhc2luIiwgIm1pblNpemUiLCAidGl0bGVPcHRzIiwgImdyaWRPcHRzIiwgInRpdGxlSGVpZ2h0IiwgInRpY2tQYWRkaW5nIiwgImFuZ2xlUmFkaWFucyIsICJ0b1JhZGlhbnMiLCAiY29zIiwgInNpbiIsICJsYWJlbEhlaWdodCIsICJtaXJyb3IiLCAibGFiZWxXaWR0aCIsICJfY2FsY3VsYXRlUGFkZGluZyIsICJfaGFuZGxlTWFyZ2lucyIsICJpc1JvdGF0ZWQiLCAibGFiZWxzQmVsb3dUaWNrcyIsICJvZmZzZXRMZWZ0IiwgIm9mZnNldFJpZ2h0IiwgImlzRnVsbFNpemUiLCAiX2NvbXB1dGVMYWJlbFNpemVzIiwgIndpZHRocyIsICJoZWlnaHRzIiwgIndpZGVzdExhYmVsU2l6ZSIsICJoaWdoZXN0TGFiZWxTaXplIiwgImpsZW4iLCAidGlja0ZvbnQiLCAiZm9udFN0cmluZyIsICJuZXN0ZWRMYWJlbCIsICJfcmVzb2x2ZVRpY2tGb250T3B0aW9ucyIsICJzdHJpbmciLCAiX21lYXN1cmVUZXh0IiwgInZhbHVlQXQiLCAiaWR4IiwgImdldExhYmVsRm9yVmFsdWUiLCAiTmFOIiwgImdldFZhbHVlRm9yUGl4ZWwiLCAicGl4ZWwiLCAiZ2V0UGl4ZWxGb3JEZWNpbWFsIiwgImRlY2ltYWwiLCAiX2ludDE2UmFuZ2UiLCAiX2FsaWduUGl4ZWwiLCAiZ2V0RGVjaW1hbEZvclBpeGVsIiwgImdldEJhc2VQaXhlbCIsICJnZXRCYXNlVmFsdWUiLCAib3B0aW9uVGlja3MiLCAicm90IiwgImF1dG9Ta2lwUGFkZGluZyIsICJfY29tcHV0ZUdyaWRMaW5lSXRlbXMiLCAiYm9yZGVyIiwgInRsIiwgImJvcmRlck9wdHMiLCAiYXhpc1dpZHRoIiwgImF4aXNIYWxmV2lkdGgiLCAiYWxpZ25Cb3JkZXJWYWx1ZSIsICJib3JkZXJWYWx1ZSIsICJhbGlnbmVkTGluZVZhbHVlIiwgInR4MSIsICJ0eTEiLCAidHgyIiwgInR5MiIsICJ4MSIsICJ5MSIsICJ4MiIsICJ5MiIsICJsaW1pdCIsICJzdGVwIiwgIm9wdHNBdEluZGV4IiwgIm9wdHNBdEluZGV4Qm9yZGVyIiwgImxpbmVXaWR0aCIsICJsaW5lQ29sb3IiLCAiY29sb3IiLCAiYm9yZGVyRGFzaCIsICJkYXNoIiwgImJvcmRlckRhc2hPZmZzZXQiLCAiZGFzaE9mZnNldCIsICJ0aWNrQ29sb3IiLCAidGlja0JvcmRlckRhc2giLCAidGlja0JvcmRlckRhc2hPZmZzZXQiLCAiY3Jvc3NBbGlnbiIsICJ0aWNrQW5kUGFkZGluZyIsICJoVGlja0FuZFBhZGRpbmciLCAidGV4dEFsaWduIiwgImxpbmVDb3VudCIsICJ0ZXh0T2Zmc2V0IiwgInRleHRCYXNlbGluZSIsICJfZ2V0WEF4aXNMYWJlbEFsaWdubWVudCIsICJfZ2V0WUF4aXNMYWJlbEFsaWdubWVudCIsICJsYWJlbE9mZnNldCIsICJoYWxmQ291bnQiLCAic3Ryb2tlQ29sb3IiLCAidGV4dFN0cm9rZUNvbG9yIiwgInN0cm9rZVdpZHRoIiwgInRleHRTdHJva2VXaWR0aCIsICJ0aWNrVGV4dEFsaWduIiwgInNob3dMYWJlbEJhY2tkcm9wIiwgImJhY2tkcm9wIiwgImxhYmVsUGFkZGluZyIsICJiYWNrZHJvcFBhZGRpbmciLCAiYmFja2Ryb3BDb2xvciIsICJ0cmFuc2xhdGlvbiIsICJfY29tcHV0ZUxhYmVsQXJlYSIsICJkcmF3QmFja2dyb3VuZCIsICJiYWNrZ3JvdW5kQ29sb3IiLCAic2F2ZSIsICJmaWxsU3R5bGUiLCAiZmlsbFJlY3QiLCAicmVzdG9yZSIsICJnZXRMaW5lV2lkdGhGb3JWYWx1ZSIsICJmaW5kSW5kZXgiLCAidCIsICJvcHRzIiwgImRyYXdHcmlkIiwgImRyYXdMaW5lIiwgInAxIiwgInAyIiwgInN0cm9rZVN0eWxlIiwgInNldExpbmVEYXNoIiwgImxpbmVEYXNoT2Zmc2V0IiwgImJlZ2luUGF0aCIsICJtb3ZlVG8iLCAibGluZVRvIiwgInN0cm9rZSIsICJkcmF3T25DaGFydEFyZWEiLCAiZHJhd0JvcmRlciIsICJsYXN0TGluZVdpZHRoIiwgImRyYXdMYWJlbHMiLCAiYXJlYSIsICJjbGlwQXJlYSIsICJyZW5kZXJUZXh0T3B0aW9ucyIsICJyZW5kZXJUZXh0IiwgInVuY2xpcEFyZWEiLCAiZHJhd1RpdGxlIiwgInR6IiwgImd6IiwgImJ6IiwgImF4aXNJRCIsICJfbWF4RGlnaXRzIiwgImZvbnRTaXplIiwgIlR5cGVkUmVnaXN0cnkiLCAic2NvcGUiLCAiY3JlYXRlIiwgImlzRm9yVHlwZSIsICJpc1Byb3RvdHlwZU9mIiwgInJlZ2lzdGVyIiwgInByb3RvIiwgImdldFByb3RvdHlwZU9mIiwgInBhcmVudFNjb3BlIiwgImlzSUNoYXJ0Q29tcG9uZW50IiwgInJlZ2lzdGVyRGVmYXVsdHMiLCAib3ZlcnJpZGVzIiwgImdldCIsICJ1bnJlZ2lzdGVyIiwgIml0ZW1EZWZhdWx0cyIsICJtZXJnZSIsICJyb3V0ZURlZmF1bHRzIiwgImRlc2NyaXB0b3JzIiwgImRlc2NyaWJlIiwgInJvdXRlcyIsICJwcm9wZXJ0eSIsICJwcm9wZXJ0eVBhcnRzIiwgInNwbGl0IiwgInNvdXJjZU5hbWUiLCAicG9wIiwgInNvdXJjZVNjb3BlIiwgImpvaW4iLCAicGFydHMiLCAidGFyZ2V0TmFtZSIsICJ0YXJnZXRTY29wZSIsICJyb3V0ZSIsICJSZWdpc3RyeSIsICJjb250cm9sbGVycyIsICJEYXRhc2V0Q29udHJvbGxlciIsICJwbHVnaW5zIiwgIl90eXBlZFJlZ2lzdHJpZXMiLCAiYXJncyIsICJfZWFjaCIsICJyZW1vdmUiLCAiYWRkQ29udHJvbGxlcnMiLCAiYWRkRWxlbWVudHMiLCAiYWRkUGx1Z2lucyIsICJhZGRTY2FsZXMiLCAiZ2V0Q29udHJvbGxlciIsICJfZ2V0IiwgImdldEVsZW1lbnQiLCAiZ2V0UGx1Z2luIiwgImdldFNjYWxlIiwgInJlbW92ZUNvbnRyb2xsZXJzIiwgInJlbW92ZUVsZW1lbnRzIiwgInJlbW92ZVBsdWdpbnMiLCAicmVtb3ZlU2NhbGVzIiwgIm1ldGhvZCIsICJ0eXBlZFJlZ2lzdHJ5IiwgImFyZyIsICJyZWciLCAiX2dldFJlZ2lzdHJ5Rm9yVHlwZSIsICJfZXhlYyIsICJpdGVtUmVnIiwgInJlZ2lzdHJ5IiwgImNvbXBvbmVudCIsICJjYW1lbE1ldGhvZCIsICJfY2FwaXRhbGl6ZSIsICJQbHVnaW5TZXJ2aWNlIiwgIl9pbml0IiwgIm5vdGlmeSIsICJob29rIiwgIl9jcmVhdGVEZXNjcmlwdG9ycyIsICJfbm90aWZ5IiwgIl9kZXNjcmlwdG9ycyIsICJkZXNjcmlwdG9yIiwgInBsdWdpbiIsICJjYWxsQ2FsbGJhY2siLCAiY2FuY2VsYWJsZSIsICJpbnZhbGlkYXRlIiwgIl9vbGRDYWNoZSIsICJfbm90aWZ5U3RhdGVDaGFuZ2VzIiwgImFsbCIsICJhbGxQbHVnaW5zIiwgImNyZWF0ZURlc2NyaXB0b3JzIiwgInByZXZpb3VzRGVzY3JpcHRvcnMiLCAic29tZSIsICJsb2NhbElkcyIsICJsb2NhbCIsICJnZXRPcHRzIiwgInBsdWdpbk9wdHMiLCAicGx1Z2luU2NvcGVLZXlzIiwgInNjb3BlcyIsICJnZXRPcHRpb25TY29wZXMiLCAiY3JlYXRlUmVzb2x2ZXIiLCAic2NyaXB0YWJsZSIsICJpbmRleGFibGUiLCAiYWxsS2V5cyIsICJnZXRJbmRleEF4aXMiLCAiZGF0YXNldERlZmF1bHRzIiwgImRhdGFzZXRzIiwgImRhdGFzZXRPcHRpb25zIiwgImluZGV4QXhpcyIsICJnZXRBeGlzRnJvbURlZmF1bHRTY2FsZUlEIiwgImdldERlZmF1bHRTY2FsZUlERnJvbUF4aXMiLCAiaWRNYXRjaGVzQXhpcyIsICJheGlzRnJvbVBvc2l0aW9uIiwgImRldGVybWluZUF4aXMiLCAic2NhbGVPcHRpb25zIiwgInRvTG93ZXJDYXNlIiwgImdldEF4aXNGcm9tRGF0YXNldCIsICJyZXRyaWV2ZUF4aXNGcm9tRGF0YXNldHMiLCAiYm91bmREcyIsICJkIiwgInhBeGlzSUQiLCAieUF4aXNJRCIsICJtZXJnZVNjYWxlQ29uZmlnIiwgImNoYXJ0RGVmYXVsdHMiLCAiY29uZmlnU2NhbGVzIiwgImNoYXJ0SW5kZXhBeGlzIiwgInNjYWxlQ29uZiIsICJjb25zb2xlIiwgImVycm9yIiwgIl9wcm94eSIsICJ3YXJuIiwgImRlZmF1bHRJZCIsICJkZWZhdWx0U2NhbGVPcHRpb25zIiwgIm1lcmdlSWYiLCAiZGVmYXVsdElEIiwgImluaXRPcHRpb25zIiwgImluaXREYXRhIiwgImluaXRDb25maWciLCAia2V5Q2FjaGUiLCAia2V5c0NhY2hlZCIsICJTZXQiLCAiY2FjaGVkS2V5cyIsICJjYWNoZUtleSIsICJnZW5lcmF0ZSIsICJhZGRJZkZvdW5kIiwgIm9iaiIsICJyZXNvbHZlT2JqZWN0S2V5IiwgIkNvbmZpZyIsICJfY29uZmlnIiwgIl9zY29wZUNhY2hlIiwgIl9yZXNvbHZlckNhY2hlIiwgInBsYXRmb3JtIiwgImNsZWFyQ2FjaGUiLCAiY2xlYXIiLCAiZGF0YXNldFNjb3BlS2V5cyIsICJkYXRhc2V0VHlwZSIsICJkYXRhc2V0QW5pbWF0aW9uU2NvcGVLZXlzIiwgInRyYW5zaXRpb24iLCAiZGF0YXNldEVsZW1lbnRTY29wZUtleXMiLCAiZWxlbWVudFR5cGUiLCAiYWRkaXRpb25hbE9wdGlvblNjb3BlcyIsICJfY2FjaGVkU2NvcGVzIiwgIm1haW5TY29wZSIsICJyZXNldENhY2hlIiwgImtleUxpc3RzIiwgImNhY2hlZCIsICJBcnJheSIsICJmcm9tIiwgImhhcyIsICJjaGFydE9wdGlvblNjb3BlcyIsICJyZXNvbHZlTmFtZWRPcHRpb25zIiwgIm5hbWVzIiwgInByZWZpeGVzIiwgIiRzaGFyZWQiLCAicmVzb2x2ZXIiLCAic3ViUHJlZml4ZXMiLCAiZ2V0UmVzb2x2ZXIiLCAibmVlZENvbnRleHQiLCAiaXNGdW5jdGlvbiIsICJzdWJSZXNvbHZlciIsICJfYXR0YWNoQ29udGV4dCIsICJkZXNjcmlwdG9yRGVmYXVsdHMiLCAicmVzb2x2ZXJDYWNoZSIsICJfY3JlYXRlUmVzb2x2ZXIiLCAicCIsICJoYXNGdW5jdGlvbiIsICJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwgImlzU2NyaXB0YWJsZSIsICJpc0luZGV4YWJsZSIsICJLTk9XTl9QT1NJVElPTlMiLCAicG9zaXRpb25Jc0hvcml6b250YWwiLCAiY29tcGFyZTJMZXZlbCIsICJsMSIsICJsMiIsICJvbkFuaW1hdGlvbnNDb21wbGV0ZSIsICJhbmltYXRpb25PcHRpb25zIiwgIm9uQ29tcGxldGUiLCAib25BbmltYXRpb25Qcm9ncmVzcyIsICJvblByb2dyZXNzIiwgImdldENhbnZhcyIsICJnZXRFbGVtZW50QnlJZCIsICJpbnN0YW5jZXMiLCAiZ2V0Q2hhcnQiLCAidmFsdWVzIiwgImMiLCAibW92ZU51bWVyaWNLZXlzIiwgIm1vdmUiLCAiaW50S2V5IiwgImRldGVybWluZUxhc3RFdmVudCIsICJsYXN0RXZlbnQiLCAiaW5DaGFydEFyZWEiLCAiaXNDbGljayIsICJnZXRTaXplRm9yQXJlYSIsICJmaWVsZCIsICJjbGlwIiwgImdldERhdGFzZXRBcmVhIiwgInhTY2FsZSIsICJ5U2NhbGUiLCAiQ2hhcnQiLCAiaW52YWxpZGF0ZVBsdWdpbnMiLCAidXNlckNvbmZpZyIsICJpbml0aWFsQ2FudmFzIiwgImV4aXN0aW5nQ2hhcnQiLCAidWlkIiwgIl9vcHRpb25zIiwgIl9hc3BlY3RSYXRpbyIsICJfbWV0YXNldHMiLCAiX3N0YWNrcyIsICJfYWN0aXZlIiwgIl9sYXN0RXZlbnQiLCAiX2xpc3RlbmVycyIsICJfcmVzcG9uc2l2ZUxpc3RlbmVycyIsICJfc29ydGVkTWV0YXNldHMiLCAiX3BsdWdpbnMiLCAiX2hpZGRlbkluZGljZXMiLCAiYXR0YWNoZWQiLCAiX2FuaW1hdGlvbnNEaXNhYmxlZCIsICJfZG9SZXNpemUiLCAiZGVib3VuY2UiLCAibW9kZSIsICJyZXNpemVEZWxheSIsICJfZGF0YUNoYW5nZXMiLCAiYW5pbWF0b3IiLCAibGlzdGVuIiwgIl9pbml0aWFsaXplIiwgIm1haW50YWluQXNwZWN0UmF0aW8iLCAicmVzcG9uc2l2ZSIsICJyZXRpbmFTY2FsZSIsICJiaW5kRXZlbnRzIiwgImNsZWFyQ2FudmFzIiwgInN0b3AiLCAicnVubmluZyIsICJfcmVzaXplIiwgIl9yZXNpemVCZWZvcmVEcmF3IiwgIm5ld1NpemUiLCAibmV3UmF0aW8iLCAib25SZXNpemUiLCAicmVuZGVyIiwgImVuc3VyZVNjYWxlc0hhdmVJRHMiLCAic2NhbGVzT3B0aW9ucyIsICJheGlzT3B0aW9ucyIsICJidWlsZE9yVXBkYXRlU2NhbGVzIiwgInNjYWxlT3B0cyIsICJ1cGRhdGVkIiwgIm1hcCIsICJpc1JhZGlhbCIsICJkcG9zaXRpb24iLCAiZHR5cGUiLCAic2NhbGVUeXBlIiwgInNjYWxlQ2xhc3MiLCAiaGFzVXBkYXRlZCIsICJfdXBkYXRlTWV0YXNldHMiLCAibnVtRGF0YSIsICJudW1NZXRhIiwgIl9kZXN0cm95RGF0YXNldE1ldGEiLCAic2xpY2UiLCAiX3JlbW92ZVVucmVmZXJlbmNlZE1ldGFzZXRzIiwgIl9kYXRhc2V0IiwgImJ1aWxkT3JVcGRhdGVDb250cm9sbGVycyIsICJuZXdDb250cm9sbGVycyIsICJvcmRlciIsICJ2aXNpYmxlIiwgImlzRGF0YXNldFZpc2libGUiLCAidXBkYXRlSW5kZXgiLCAibGlua1NjYWxlcyIsICJDb250cm9sbGVyQ2xhc3MiLCAiZGF0YXNldEVsZW1lbnRUeXBlIiwgImRhdGFFbGVtZW50VHlwZSIsICJfcmVzZXRFbGVtZW50cyIsICJyZXNldCIsICJhbmltc0Rpc2FibGVkIiwgIl91cGRhdGVTY2FsZXMiLCAiX2NoZWNrRXZlbnRCaW5kaW5ncyIsICJfdXBkYXRlSGlkZGVuSW5kaWNlcyIsICJidWlsZE9yVXBkYXRlRWxlbWVudHMiLCAiZ2V0TWF4T3ZlcmZsb3ciLCAiX21pblBhZGRpbmciLCAiYXV0b1BhZGRpbmciLCAiX3VwZGF0ZUxheW91dCIsICJfdXBkYXRlRGF0YXNldHMiLCAiX2V2ZW50SGFuZGxlciIsICJfdXBkYXRlSG92ZXJTdHlsZXMiLCAiZXhpc3RpbmdFdmVudHMiLCAibmV3RXZlbnRzIiwgImV2ZW50cyIsICJzZXRzRXF1YWwiLCAidW5iaW5kRXZlbnRzIiwgImNoYW5nZXMiLCAiX2dldFVuaWZvcm1EYXRhQ2hhbmdlcyIsICJkYXRhc2V0Q291bnQiLCAibWFrZVNldCIsICJjaGFuZ2VTZXQiLCAibm9BcmVhIiwgIl9pZHgiLCAiX3VwZGF0ZURhdGFzZXQiLCAiX3VwZGF0ZSIsICJsYXllcnMiLCAiX2RyYXdEYXRhc2V0cyIsICJfZ2V0U29ydGVkRGF0YXNldE1ldGFzIiwgImZpbHRlclZpc2libGUiLCAiX2RyYXdEYXRhc2V0IiwgIl9jbGlwIiwgInVzZUNsaXAiLCAiZGlzYWJsZWQiLCAiZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZSIsICJJbnRlcmFjdGlvbiIsICJoaWRkZW4iLCAiX3BhcnNlZCIsICJnZXRWaXNpYmxlRGF0YXNldENvdW50IiwgInNldERhdGFzZXRWaXNpYmlsaXR5IiwgInRvZ2dsZURhdGFWaXNpYmlsaXR5IiwgImdldERhdGFWaXNpYmlsaXR5IiwgIl91cGRhdGVWaXNpYmlsaXR5IiwgImRhdGFJbmRleCIsICJfcmVzb2x2ZUFuaW1hdGlvbnMiLCAiaGlkZSIsICJzaG93IiwgIl9kZXN0cm95IiwgIl9zdG9wIiwgImRlc3Ryb3kiLCAidG9CYXNlNjRJbWFnZSIsICJ0b0RhdGFVUkwiLCAiYmluZFVzZXJFdmVudHMiLCAiYmluZFJlc3BvbnNpdmVFdmVudHMiLCAibGlzdGVuZXJzIiwgIl9hZGQiLCAib2Zmc2V0WCIsICJvZmZzZXRZIiwgIl9yZW1vdmUiLCAiZGV0YWNoZWQiLCAidXBkYXRlSG92ZXJTdHlsZSIsICJwcmVmaXgiLCAiZ2V0QWN0aXZlRWxlbWVudHMiLCAic2V0QWN0aXZlRWxlbWVudHMiLCAiYWN0aXZlRWxlbWVudHMiLCAibGFzdEFjdGl2ZSIsICJfZWxlbWVudHNFcXVhbCIsICJpc1BsdWdpbkVuYWJsZWQiLCAicGx1Z2luSWQiLCAicmVwbGF5IiwgImhvdmVyT3B0aW9ucyIsICJob3ZlciIsICJkZWFjdGl2YXRlZCIsICJhY3RpdmF0ZWQiLCAiZXZlbnRGaWx0ZXIiLCAiX2hhbmRsZUV2ZW50IiwgIl9nZXRBY3RpdmVFbGVtZW50cyIsICJfaXNDbGlja0V2ZW50IiwgIm9uSG92ZXIiLCAib25DbGljayIsICJ2ZXJzaW9uIiwgImNsaXBBcmMiLCAicGl4ZWxNYXJnaW4iLCAib3V0ZXJSYWRpdXMiLCAiaW5uZXJSYWRpdXMiLCAiYW5nbGVNYXJnaW4iLCAiYXJjIiwgImNsb3NlUGF0aCIsICJ0b1JhZGl1c0Nvcm5lcnMiLCAiX3JlYWRWYWx1ZVRvUHJvcHMiLCAicGFyc2VCb3JkZXJSYWRpdXMiLCAiYW5nbGVEZWx0YSIsICJvIiwgImJvcmRlclJhZGl1cyIsICJoYWxmVGhpY2tuZXNzIiwgImlubmVyTGltaXQiLCAiY29tcHV0ZU91dGVyTGltaXQiLCAidmFsIiwgIm91dGVyQXJjTGltaXQiLCAib3V0ZXJTdGFydCIsICJvdXRlckVuZCIsICJpbm5lclN0YXJ0IiwgImlubmVyRW5kIiwgInJUaGV0YVRvWFkiLCAiciIsICJ0aGV0YSIsICJwYXRoQXJjIiwgImNpcmN1bGFyIiwgImlubmVyUiIsICJzcGFjaW5nT2Zmc2V0IiwgImFscGhhIiwgIm5vU3BhY2luZ0lubmVyUmFkaXVzIiwgIm5vU3BhY2luZ091dGVyUmFkaXVzIiwgImF2Tm9nU3BhY2luZ1JhZGl1cyIsICJhZGp1c3RlZEFuZ2xlIiwgImJldGEiLCAiUEkiLCAiYW5nbGVPZmZzZXQiLCAib3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzIiwgIm91dGVyRW5kQWRqdXN0ZWRSYWRpdXMiLCAib3V0ZXJTdGFydEFkanVzdGVkQW5nbGUiLCAib3V0ZXJFbmRBZGp1c3RlZEFuZ2xlIiwgImlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cyIsICJpbm5lckVuZEFkanVzdGVkUmFkaXVzIiwgImlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlIiwgImlubmVyRW5kQWRqdXN0ZWRBbmdsZSIsICJvdXRlck1pZEFkanVzdGVkQW5nbGUiLCAicENlbnRlciIsICJwNCIsICJpbm5lck1pZEFkanVzdGVkQW5nbGUiLCAicDgiLCAib3V0ZXJTdGFydFgiLCAib3V0ZXJTdGFydFkiLCAib3V0ZXJFbmRYIiwgIm91dGVyRW5kWSIsICJkcmF3QXJjIiwgImZ1bGxDaXJjbGVzIiwgImNpcmN1bWZlcmVuY2UiLCAiZmlsbCIsICJpc05hTiIsICJUQVUiLCAiYm9yZGVyV2lkdGgiLCAiYm9yZGVySm9pblN0eWxlIiwgImlubmVyIiwgImJvcmRlckFsaWduIiwgImxpbmVKb2luIiwgIkFyY0VsZW1lbnQiLCAiY2hhcnRYIiwgImNoYXJ0WSIsICJyQWRqdXN0IiwgIl9jaXJjdW1mZXJlbmNlIiwgImJldHdlZW5BbmdsZXMiLCAid2l0aGluUmFkaXVzIiwgIl9pc0JldHdlZW4iLCAiaGFsZkFuZ2xlIiwgImhhbGZSYWRpdXMiLCAidHJhbnNsYXRlIiwgImZpeCIsICJyYWRpdXNPZmZzZXQiLCAiYm9yZGVyQ29sb3IiLCAiX3NjcmlwdGFibGUiLCAiX2luZGV4YWJsZSIsICJnZXRCb3hTaXplIiwgImxhYmVsT3B0cyIsICJmb250U2l6ZSIsICJib3hIZWlnaHQiLCAiYm94V2lkdGgiLCAidXNlUG9pbnRTdHlsZSIsICJNYXRoIiwgIm1pbiIsICJwb2ludFN0eWxlV2lkdGgiLCAiaXRlbUhlaWdodCIsICJtYXgiLCAiaXRlbXNFcXVhbCIsICJhIiwgImIiLCAiZGF0YXNldEluZGV4IiwgImluZGV4IiwgIkxlZ2VuZCIsICJFbGVtZW50IiwgImNvbnN0cnVjdG9yIiwgImNvbmZpZyIsICJfYWRkZWQiLCAibGVnZW5kSGl0Qm94ZXMiLCAiX2hvdmVyZWRJdGVtIiwgImRvdWdobnV0TW9kZSIsICJjaGFydCIsICJvcHRpb25zIiwgImN0eCIsICJsZWdlbmRJdGVtcyIsICJ1bmRlZmluZWQiLCAiY29sdW1uU2l6ZXMiLCAibGluZVdpZHRocyIsICJtYXhIZWlnaHQiLCAibWF4V2lkdGgiLCAidG9wIiwgImJvdHRvbSIsICJsZWZ0IiwgInJpZ2h0IiwgImhlaWdodCIsICJ3aWR0aCIsICJfbWFyZ2lucyIsICJwb3NpdGlvbiIsICJ3ZWlnaHQiLCAiZnVsbFNpemUiLCAidXBkYXRlIiwgIm1hcmdpbnMiLCAic2V0RGltZW5zaW9ucyIsICJidWlsZExhYmVscyIsICJmaXQiLCAiaXNIb3Jpem9udGFsIiwgImxhYmVscyIsICJjYWxsIiwgImdlbmVyYXRlTGFiZWxzIiwgImZpbHRlciIsICJpdGVtIiwgImRhdGEiLCAic29ydCIsICJyZXZlcnNlIiwgImRpc3BsYXkiLCAibGFiZWxGb250IiwgInRvRm9udCIsICJmb250IiwgInNpemUiLCAidGl0bGVIZWlnaHQiLCAiX2NvbXB1dGVUaXRsZUhlaWdodCIsICJzdHJpbmciLCAiX2ZpdFJvd3MiLCAiX2ZpdENvbHMiLCAicGFkZGluZyIsICJoaXRib3hlcyIsICJsaW5lSGVpZ2h0IiwgInRvdGFsSGVpZ2h0IiwgInRleHRBbGlnbiIsICJ0ZXh0QmFzZWxpbmUiLCAicm93IiwgImZvckVhY2giLCAibGVnZW5kSXRlbSIsICJpIiwgIml0ZW1XaWR0aCIsICJtZWFzdXJlVGV4dCIsICJ0ZXh0IiwgImxlbmd0aCIsICJfaXRlbUhlaWdodCIsICJoZWlnaHRMaW1pdCIsICJ0b3RhbFdpZHRoIiwgImN1cnJlbnRDb2xXaWR0aCIsICJjdXJyZW50Q29sSGVpZ2h0IiwgImNvbCIsICJjYWxjdWxhdGVJdGVtU2l6ZSIsICJwdXNoIiwgImFkanVzdEhpdEJveGVzIiwgImFsaWduIiwgInJ0bCIsICJydGxIZWxwZXIiLCAiZ2V0UnRsQWRhcHRlciIsICJfYWxpZ25TdGFydEVuZCIsICJoaXRib3giLCAibGVmdEZvckx0ciIsICJ4IiwgImRyYXciLCAiY2xpcEFyZWEiLCAiX2RyYXciLCAidW5jbGlwQXJlYSIsICJvcHRzIiwgImRlZmF1bHRDb2xvciIsICJkZWZhdWx0cyIsICJjb2xvciIsICJoYWxmRm9udFNpemUiLCAiY3Vyc29yIiwgImRyYXdUaXRsZSIsICJsaW5lV2lkdGgiLCAiZHJhd0xlZ2VuZEJveCIsICJ5IiwgImlzTmFOIiwgInNhdmUiLCAidmFsdWVPckRlZmF1bHQiLCAiZmlsbFN0eWxlIiwgImxpbmVDYXAiLCAibGluZURhc2hPZmZzZXQiLCAibGluZUpvaW4iLCAic3Ryb2tlU3R5bGUiLCAic2V0TGluZURhc2giLCAibGluZURhc2giLCAiZHJhd09wdGlvbnMiLCAicmFkaXVzIiwgIlNRUlQyIiwgInBvaW50U3R5bGUiLCAicm90YXRpb24iLCAiYm9yZGVyV2lkdGgiLCAiY2VudGVyWCIsICJ4UGx1cyIsICJjZW50ZXJZIiwgImRyYXdQb2ludExlZ2VuZCIsICJ5Qm94VG9wIiwgInhCb3hMZWZ0IiwgImJvcmRlclJhZGl1cyIsICJ0b1RSQkxDb3JuZXJzIiwgImJlZ2luUGF0aCIsICJPYmplY3QiLCAidmFsdWVzIiwgInNvbWUiLCAidiIsICJhZGRSb3VuZGVkUmVjdFBhdGgiLCAidyIsICJoIiwgInJlY3QiLCAiZmlsbCIsICJzdHJva2UiLCAicmVzdG9yZSIsICJmaWxsVGV4dCIsICJyZW5kZXJUZXh0IiwgInN0cmlrZXRocm91Z2giLCAiaGlkZGVuIiwgImxpbmUiLCAib3ZlcnJpZGVUZXh0RGlyZWN0aW9uIiwgInRleHREaXJlY3Rpb24iLCAiZm9udENvbG9yIiwgInRleHRXaWR0aCIsICJzZXRXaWR0aCIsICJyZWFsWCIsICJfdGV4dFgiLCAiZm9udExpbmVIZWlnaHQiLCAiY2FsY3VsYXRlTGVnZW5kSXRlbUhlaWdodCIsICJyZXN0b3JlVGV4dERpcmVjdGlvbiIsICJ0aXRsZU9wdHMiLCAidGl0bGUiLCAidGl0bGVGb250IiwgInRpdGxlUGFkZGluZyIsICJ0b1BhZGRpbmciLCAidG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemUiLCAicmVkdWNlIiwgImFjYyIsICJfdG9MZWZ0UmlnaHRDZW50ZXIiLCAiX2dldExlZ2VuZEl0ZW1BdCIsICJoaXRCb3giLCAibGgiLCAiX2lzQmV0d2VlbiIsICJoYW5kbGVFdmVudCIsICJlIiwgImlzTGlzdGVuZWQiLCAidHlwZSIsICJob3ZlcmVkSXRlbSIsICJwcmV2aW91cyIsICJzYW1lSXRlbSIsICJvbkxlYXZlIiwgIm9uSG92ZXIiLCAib25DbGljayIsICJjYWxjdWxhdGVJdGVtV2lkdGgiLCAiY2FsY3VsYXRlSXRlbUhlaWdodCIsICJsZWdlbmRJdGVtVGV4dCIsICJsYWJlbEhlaWdodCIsICJpZCIsICJfZWxlbWVudCIsICJzdGFydCIsICJfYXJncyIsICJsZWdlbmQiLCAibGF5b3V0cyIsICJjb25maWd1cmUiLCAiYWRkQm94IiwgInN0b3AiLCAicmVtb3ZlQm94IiwgImJlZm9yZVVwZGF0ZSIsICJhZnRlclVwZGF0ZSIsICJhZnRlckV2ZW50IiwgImFyZ3MiLCAicmVwbGF5IiwgImV2ZW50IiwgImNpIiwgImlzRGF0YXNldFZpc2libGUiLCAiaGlkZSIsICJzaG93IiwgImRhdGFzZXRzIiwgInVzZUJvcmRlclJhZGl1cyIsICJfZ2V0U29ydGVkRGF0YXNldE1ldGFzIiwgIm1hcCIsICJtZXRhIiwgInN0eWxlIiwgImNvbnRyb2xsZXIiLCAiZ2V0U3R5bGUiLCAibGFiZWwiLCAiYmFja2dyb3VuZENvbG9yIiwgInZpc2libGUiLCAiYm9yZGVyQ2FwU3R5bGUiLCAiYm9yZGVyRGFzaCIsICJib3JkZXJEYXNoT2Zmc2V0IiwgImJvcmRlckpvaW5TdHlsZSIsICJib3JkZXJDb2xvciIsICJkZXNjcmlwdG9ycyIsICJfc2NyaXB0YWJsZSIsICJuYW1lIiwgInN0YXJ0c1dpdGgiLCAiaW5jbHVkZXMiLCAicG9zaXRpb25lcnMiLCAiYXZlcmFnZSIsICJpdGVtcyIsICJsZW5ndGgiLCAiaSIsICJsZW4iLCAieFNldCIsICJTZXQiLCAieSIsICJjb3VudCIsICJlbCIsICJlbGVtZW50IiwgImhhc1ZhbHVlIiwgInBvcyIsICJ0b29sdGlwUG9zaXRpb24iLCAiYWRkIiwgIngiLCAieEF2ZXJhZ2UiLCAicmVkdWNlIiwgImEiLCAiYiIsICJzaXplIiwgIm5lYXJlc3QiLCAiZXZlbnRQb3NpdGlvbiIsICJtaW5EaXN0YW5jZSIsICJOdW1iZXIiLCAiUE9TSVRJVkVfSU5GSU5JVFkiLCAibmVhcmVzdEVsZW1lbnQiLCAiY2VudGVyIiwgImdldENlbnRlclBvaW50IiwgImQiLCAiZGlzdGFuY2VCZXR3ZWVuUG9pbnRzIiwgInRwIiwgInB1c2hPckNvbmNhdCIsICJiYXNlIiwgInRvUHVzaCIsICJpc0FycmF5IiwgIkFycmF5IiwgInByb3RvdHlwZSIsICJwdXNoIiwgImFwcGx5IiwgInNwbGl0TmV3bGluZXMiLCAic3RyIiwgIlN0cmluZyIsICJpbmRleE9mIiwgInNwbGl0IiwgImNyZWF0ZVRvb2x0aXBJdGVtIiwgImNoYXJ0IiwgIml0ZW0iLCAiZGF0YXNldEluZGV4IiwgImluZGV4IiwgImNvbnRyb2xsZXIiLCAiZ2V0RGF0YXNldE1ldGEiLCAibGFiZWwiLCAidmFsdWUiLCAiZ2V0TGFiZWxBbmRWYWx1ZSIsICJwYXJzZWQiLCAiZ2V0UGFyc2VkIiwgInJhdyIsICJkYXRhIiwgImRhdGFzZXRzIiwgImZvcm1hdHRlZFZhbHVlIiwgImRhdGFzZXQiLCAiZ2V0RGF0YXNldCIsICJkYXRhSW5kZXgiLCAiZ2V0VG9vbHRpcFNpemUiLCAidG9vbHRpcCIsICJvcHRpb25zIiwgImN0eCIsICJib2R5IiwgImZvb3RlciIsICJ0aXRsZSIsICJib3hXaWR0aCIsICJib3hIZWlnaHQiLCAiYm9keUZvbnQiLCAidG9Gb250IiwgInRpdGxlRm9udCIsICJmb290ZXJGb250IiwgInRpdGxlTGluZUNvdW50IiwgImZvb3RlckxpbmVDb3VudCIsICJib2R5TGluZUl0ZW1Db3VudCIsICJwYWRkaW5nIiwgInRvUGFkZGluZyIsICJoZWlnaHQiLCAid2lkdGgiLCAiY29tYmluZWRCb2R5TGVuZ3RoIiwgImJvZHlJdGVtIiwgImJlZm9yZSIsICJsaW5lcyIsICJhZnRlciIsICJiZWZvcmVCb2R5IiwgImFmdGVyQm9keSIsICJsaW5lSGVpZ2h0IiwgInRpdGxlU3BhY2luZyIsICJ0aXRsZU1hcmdpbkJvdHRvbSIsICJib2R5TGluZUhlaWdodCIsICJkaXNwbGF5Q29sb3JzIiwgIk1hdGgiLCAibWF4IiwgImJvZHlTcGFjaW5nIiwgImZvb3Rlck1hcmdpblRvcCIsICJmb290ZXJTcGFjaW5nIiwgIndpZHRoUGFkZGluZyIsICJtYXhMaW5lV2lkdGgiLCAibGluZSIsICJtZWFzdXJlVGV4dCIsICJzYXZlIiwgImZvbnQiLCAic3RyaW5nIiwgImVhY2giLCAiY29uY2F0IiwgImJveFBhZGRpbmciLCAicmVzdG9yZSIsICJkZXRlcm1pbmVZQWxpZ24iLCAiZG9lc05vdEZpdFdpdGhBbGlnbiIsICJ4QWxpZ24iLCAiY2FyZXQiLCAiY2FyZXRTaXplIiwgImNhcmV0UGFkZGluZyIsICJkZXRlcm1pbmVYQWxpZ24iLCAieUFsaWduIiwgImNoYXJ0V2lkdGgiLCAiY2hhcnRBcmVhIiwgImxlZnQiLCAicmlnaHQiLCAiZGV0ZXJtaW5lQWxpZ25tZW50IiwgImFsaWduWCIsICJhbGlnblkiLCAicGFkZGluZ0FuZFNpemUiLCAiZ2V0QmFja2dyb3VuZFBvaW50IiwgImFsaWdubWVudCIsICJjb3JuZXJSYWRpdXMiLCAidG9wTGVmdCIsICJ0b3BSaWdodCIsICJib3R0b21MZWZ0IiwgImJvdHRvbVJpZ2h0IiwgInRvVFJCTENvcm5lcnMiLCAiX2xpbWl0VmFsdWUiLCAiZ2V0QWxpZ25lZFgiLCAiYWxpZ24iLCAiZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMiLCAiY2FsbGJhY2siLCAiY3JlYXRlVG9vbHRpcENvbnRleHQiLCAicGFyZW50IiwgInRvb2x0aXBJdGVtcyIsICJjcmVhdGVDb250ZXh0IiwgInR5cGUiLCAib3ZlcnJpZGVDYWxsYmFja3MiLCAiY2FsbGJhY2tzIiwgImNvbnRleHQiLCAib3ZlcnJpZGUiLCAiZGVmYXVsdENhbGxiYWNrcyIsICJiZWZvcmVUaXRsZSIsICJub29wIiwgImxhYmVscyIsICJsYWJlbENvdW50IiwgIm1vZGUiLCAiYWZ0ZXJUaXRsZSIsICJiZWZvcmVMYWJlbCIsICJ0b29sdGlwSXRlbSIsICJpc051bGxPclVuZGVmIiwgImxhYmVsQ29sb3IiLCAibWV0YSIsICJnZXRTdHlsZSIsICJib3JkZXJDb2xvciIsICJiYWNrZ3JvdW5kQ29sb3IiLCAiYm9yZGVyV2lkdGgiLCAiYm9yZGVyRGFzaCIsICJib3JkZXJEYXNoT2Zmc2V0IiwgImJvcmRlclJhZGl1cyIsICJsYWJlbFRleHRDb2xvciIsICJib2R5Q29sb3IiLCAibGFiZWxQb2ludFN0eWxlIiwgInBvaW50U3R5bGUiLCAicm90YXRpb24iLCAiYWZ0ZXJMYWJlbCIsICJiZWZvcmVGb290ZXIiLCAiYWZ0ZXJGb290ZXIiLCAiaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2siLCAibmFtZSIsICJhcmciLCAicmVzdWx0IiwgImNhbGwiLCAiVG9vbHRpcCIsICJFbGVtZW50IiwgImNvbnN0cnVjdG9yIiwgImNvbmZpZyIsICJvcGFjaXR5IiwgIl9hY3RpdmUiLCAiX2V2ZW50UG9zaXRpb24iLCAidW5kZWZpbmVkIiwgIl9zaXplIiwgIl9jYWNoZWRBbmltYXRpb25zIiwgIl90b29sdGlwSXRlbXMiLCAiJGFuaW1hdGlvbnMiLCAiJGNvbnRleHQiLCAiZGF0YVBvaW50cyIsICJjYXJldFgiLCAiY2FyZXRZIiwgImxhYmVsQ29sb3JzIiwgImxhYmVsUG9pbnRTdHlsZXMiLCAibGFiZWxUZXh0Q29sb3JzIiwgImluaXRpYWxpemUiLCAiX3Jlc29sdmVBbmltYXRpb25zIiwgImNhY2hlZCIsICJzZXRDb250ZXh0IiwgImdldENvbnRleHQiLCAib3B0cyIsICJlbmFibGVkIiwgImFuaW1hdGlvbiIsICJhbmltYXRpb25zIiwgIkFuaW1hdGlvbnMiLCAiX2NhY2hlYWJsZSIsICJPYmplY3QiLCAiZnJlZXplIiwgImdldFRpdGxlIiwgImdldEJlZm9yZUJvZHkiLCAiZ2V0Qm9keSIsICJib2R5SXRlbXMiLCAic2NvcGVkIiwgImdldEFmdGVyQm9keSIsICJnZXRGb290ZXIiLCAiX2NyZWF0ZUl0ZW1zIiwgImFjdGl2ZSIsICJmaWx0ZXIiLCAiYXJyYXkiLCAiaXRlbVNvcnQiLCAic29ydCIsICJ1cGRhdGUiLCAiY2hhbmdlZCIsICJyZXBsYXkiLCAicHJvcGVydGllcyIsICJwb3NpdGlvbiIsICJwb3NpdGlvbkFuZFNpemUiLCAiYXNzaWduIiwgImJhY2tncm91bmRQb2ludCIsICJleHRlcm5hbCIsICJkcmF3Q2FyZXQiLCAidG9vbHRpcFBvaW50IiwgImNhcmV0UG9zaXRpb24iLCAiZ2V0Q2FyZXRQb3NpdGlvbiIsICJsaW5lVG8iLCAieDEiLCAieTEiLCAieDIiLCAieTIiLCAieDMiLCAieTMiLCAicHRYIiwgInB0WSIsICJkcmF3VGl0bGUiLCAicHQiLCAicnRsSGVscGVyIiwgImdldFJ0bEFkYXB0ZXIiLCAicnRsIiwgInRpdGxlQWxpZ24iLCAidGV4dEFsaWduIiwgInRleHRCYXNlbGluZSIsICJmaWxsU3R5bGUiLCAidGl0bGVDb2xvciIsICJmaWxsVGV4dCIsICJfZHJhd0NvbG9yQm94IiwgImNvbG9yWCIsICJydGxDb2xvclgiLCAieU9mZlNldCIsICJjb2xvclkiLCAidXNlUG9pbnRTdHlsZSIsICJkcmF3T3B0aW9ucyIsICJyYWRpdXMiLCAibWluIiwgImNlbnRlclgiLCAibGVmdEZvckx0ciIsICJjZW50ZXJZIiwgInN0cm9rZVN0eWxlIiwgIm11bHRpS2V5QmFja2dyb3VuZCIsICJkcmF3UG9pbnQiLCAibGluZVdpZHRoIiwgImlzT2JqZWN0IiwgInZhbHVlcyIsICJzZXRMaW5lRGFzaCIsICJsaW5lRGFzaE9mZnNldCIsICJvdXRlclgiLCAiaW5uZXJYIiwgInhQbHVzIiwgInNvbWUiLCAidiIsICJiZWdpblBhdGgiLCAiYWRkUm91bmRlZFJlY3RQYXRoIiwgInciLCAiaCIsICJmaWxsIiwgInN0cm9rZSIsICJmaWxsUmVjdCIsICJzdHJva2VSZWN0IiwgImRyYXdCb2R5IiwgImJvZHlBbGlnbiIsICJ4TGluZVBhZGRpbmciLCAiZmlsbExpbmVPZlRleHQiLCAiYm9keUFsaWduRm9yQ2FsY3VsYXRpb24iLCAidGV4dENvbG9yIiwgImoiLCAiaWxlbiIsICJqbGVuIiwgImRyYXdGb290ZXIiLCAiZm9vdGVyQWxpZ24iLCAiZm9vdGVyQ29sb3IiLCAiZHJhd0JhY2tncm91bmQiLCAidG9vbHRpcFNpemUiLCAibW92ZVRvIiwgInF1YWRyYXRpY0N1cnZlVG8iLCAiY2xvc2VQYXRoIiwgIl91cGRhdGVBbmltYXRpb25UYXJnZXQiLCAiYW5pbXMiLCAiYW5pbVgiLCAiYW5pbVkiLCAicG9pbnQiLCAiX3RvIiwgIl93aWxsUmVuZGVyIiwgImRyYXciLCAiYWJzIiwgImhhc1Rvb2x0aXBDb250ZW50IiwgImdsb2JhbEFscGhhIiwgIm92ZXJyaWRlVGV4dERpcmVjdGlvbiIsICJ0ZXh0RGlyZWN0aW9uIiwgInRvcCIsICJyZXN0b3JlVGV4dERpcmVjdGlvbiIsICJnZXRBY3RpdmVFbGVtZW50cyIsICJzZXRBY3RpdmVFbGVtZW50cyIsICJhY3RpdmVFbGVtZW50cyIsICJsYXN0QWN0aXZlIiwgIm1hcCIsICJFcnJvciIsICJfZWxlbWVudHNFcXVhbCIsICJwb3NpdGlvbkNoYW5nZWQiLCAiX3Bvc2l0aW9uQ2hhbmdlZCIsICJfaWdub3JlUmVwbGF5RXZlbnRzIiwgImhhbmRsZUV2ZW50IiwgImUiLCAiaW5DaGFydEFyZWEiLCAiX2dldEFjdGl2ZUVsZW1lbnRzIiwgImdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUiLCAicmV2ZXJzZSIsICJpZCIsICJfZWxlbWVudCIsICJhZnRlckluaXQiLCAiX2FyZ3MiLCAiYmVmb3JlVXBkYXRlIiwgInJlc2V0IiwgImFmdGVyRHJhdyIsICJhcmdzIiwgIm5vdGlmeVBsdWdpbnMiLCAiY2FuY2VsYWJsZSIsICJhZnRlckV2ZW50IiwgInVzZUZpbmFsUG9zaXRpb24iLCAiZXZlbnQiLCAiZGVmYXVsdHMiLCAid2VpZ2h0IiwgImR1cmF0aW9uIiwgImVhc2luZyIsICJudW1iZXJzIiwgImRlZmF1bHRSb3V0ZXMiLCAiZGVzY3JpcHRvcnMiLCAiX3NjcmlwdGFibGUiLCAiX2luZGV4YWJsZSIsICJfZmFsbGJhY2siLCAiYWRkaXRpb25hbE9wdGlvblNjb3BlcyIsICJnZW5lcmF0ZVRpY2tzIiwgImdlbmVyYXRpb25PcHRpb25zIiwgImRhdGFSYW5nZSIsICJ0aWNrcyIsICJNSU5fU1BBQ0lORyIsICJib3VuZHMiLCAic3RlcCIsICJtaW4iLCAibWF4IiwgInByZWNpc2lvbiIsICJjb3VudCIsICJtYXhUaWNrcyIsICJtYXhEaWdpdHMiLCAiaW5jbHVkZUJvdW5kcyIsICJ1bml0IiwgIm1heFNwYWNlcyIsICJybWluIiwgInJtYXgiLCAibWluRGVmaW5lZCIsICJpc051bGxPclVuZGVmIiwgIm1heERlZmluZWQiLCAiY291bnREZWZpbmVkIiwgIm1pblNwYWNpbmciLCAic3BhY2luZyIsICJuaWNlTnVtIiwgImZhY3RvciIsICJuaWNlTWluIiwgIm5pY2VNYXgiLCAibnVtU3BhY2VzIiwgInZhbHVlIiwgIk1hdGgiLCAiY2VpbCIsICJmbG9vciIsICJwb3ciLCAiYWxtb3N0V2hvbGUiLCAicm91bmQiLCAiYWxtb3N0RXF1YWxzIiwgImRlY2ltYWxQbGFjZXMiLCAiX2RlY2ltYWxQbGFjZXMiLCAiaiIsICJwdXNoIiwgInJlbGF0aXZlTGFiZWxTaXplIiwgInRpY2tWYWx1ZSIsICJsZW5ndGgiLCAiaG9yaXpvbnRhbCIsICJtaW5Sb3RhdGlvbiIsICJyYWQiLCAidG9SYWRpYW5zIiwgInJhdGlvIiwgInNpbiIsICJjb3MiLCAiTGluZWFyU2NhbGVCYXNlIiwgIlNjYWxlIiwgImNvbnN0cnVjdG9yIiwgImNmZyIsICJzdGFydCIsICJ1bmRlZmluZWQiLCAiZW5kIiwgIl9zdGFydFZhbHVlIiwgIl9lbmRWYWx1ZSIsICJfdmFsdWVSYW5nZSIsICJwYXJzZSIsICJyYXciLCAiaW5kZXgiLCAiTnVtYmVyIiwgImlzRmluaXRlIiwgImhhbmRsZVRpY2tSYW5nZU9wdGlvbnMiLCAiYmVnaW5BdFplcm8iLCAib3B0aW9ucyIsICJnZXRVc2VyQm91bmRzIiwgInNldE1pbiIsICJ2IiwgInNldE1heCIsICJtaW5TaWduIiwgInNpZ24iLCAibWF4U2lnbiIsICJvZmZzZXQiLCAiYWJzIiwgImdldFRpY2tMaW1pdCIsICJ0aWNrT3B0cyIsICJtYXhUaWNrc0xpbWl0IiwgInN0ZXBTaXplIiwgImNvbnNvbGUiLCAid2FybiIsICJpZCIsICJjb21wdXRlVGlja0xpbWl0IiwgIlBPU0lUSVZFX0lORklOSVRZIiwgImJ1aWxkVGlja3MiLCAib3B0cyIsICJudW1lcmljR2VuZXJhdG9yT3B0aW9ucyIsICJfbWF4RGlnaXRzIiwgImlzSG9yaXpvbnRhbCIsICJfcmFuZ2UiLCAiX3NldE1pbkFuZE1heEJ5S2V5IiwgInJldmVyc2UiLCAiY29uZmlndXJlIiwgImdldExhYmVsRm9yVmFsdWUiLCAiZm9ybWF0TnVtYmVyIiwgImNoYXJ0IiwgImxvY2FsZSIsICJmb3JtYXQiLCAiTGluZWFyU2NhbGUiLCAiZGV0ZXJtaW5lRGF0YUxpbWl0cyIsICJnZXRNaW5NYXgiLCAid2lkdGgiLCAiaGVpZ2h0IiwgInRpY2tGb250IiwgIl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zIiwgImxpbmVIZWlnaHQiLCAiZ2V0UGl4ZWxGb3JWYWx1ZSIsICJOYU4iLCAiZ2V0UGl4ZWxGb3JEZWNpbWFsIiwgImdldFZhbHVlRm9yUGl4ZWwiLCAicGl4ZWwiLCAiZ2V0RGVjaW1hbEZvclBpeGVsIiwgImRlZmF1bHRzIiwgImNhbGxiYWNrIiwgIlRpY2tzIiwgImZvcm1hdHRlcnMiLCAibnVtZXJpYyIsICJsb2cxMEZsb29yIiwgImxvZzEwIiwgImNoYW5nZUV4cG9uZW50IiwgIm0iLCAiaXNNYWpvciIsICJ0aWNrVmFsIiwgInJlbWFpbiIsICJzdGVwcyIsICJyYW5nZUV4cCIsICJyYW5nZVN0ZXAiLCAic3RhcnRFeHAiLCAicmFuZ2UiLCAiZmluaXRlT3JEZWZhdWx0IiwgIm1pbkV4cCIsICJleHAiLCAiYmFzZSIsICJzaWduaWZpY2FuZCIsICJtYWpvciIsICJsYXN0VGljayIsICJMb2dhcml0aG1pY1NjYWxlIiwgInByb3RvdHlwZSIsICJhcHBseSIsICJfemVybyIsICJfc3VnZ2VzdGVkTWluIiwgIl91c2VyTWluIiwgIl91c2VyTWF4IiwgImlzTmFOIiwgImRlY2ltYWwiLCAibG9nYXJpdGhtaWMiLCAiZW5hYmxlZCIsICJnZXRUaWNrQmFja2Ryb3BIZWlnaHQiLCAiZGlzcGxheSIsICJwYWRkaW5nIiwgInRvUGFkZGluZyIsICJiYWNrZHJvcFBhZGRpbmciLCAidmFsdWVPckRlZmF1bHQiLCAiZm9udCIsICJzaXplIiwgIm1lYXN1cmVMYWJlbFNpemUiLCAiY3R4IiwgImxhYmVsIiwgImlzQXJyYXkiLCAidyIsICJfbG9uZ2VzdFRleHQiLCAic3RyaW5nIiwgImgiLCAiZGV0ZXJtaW5lTGltaXRzIiwgImFuZ2xlIiwgInBvcyIsICJmaXRXaXRoUG9pbnRMYWJlbHMiLCAic2NhbGUiLCAib3JpZyIsICJsIiwgImxlZnQiLCAiX3BhZGRpbmciLCAiciIsICJyaWdodCIsICJ0IiwgInRvcCIsICJiIiwgImJvdHRvbSIsICJsaW1pdHMiLCAiT2JqZWN0IiwgImFzc2lnbiIsICJsYWJlbFNpemVzIiwgInZhbHVlQ291bnQiLCAiX3BvaW50TGFiZWxzIiwgInBvaW50TGFiZWxPcHRzIiwgInBvaW50TGFiZWxzIiwgImFkZGl0aW9uYWxBbmdsZSIsICJjZW50ZXJQb2ludExhYmVscyIsICJQSSIsICJpIiwgInNldENvbnRleHQiLCAiZ2V0UG9pbnRMYWJlbENvbnRleHQiLCAicG9pbnRQb3NpdGlvbiIsICJnZXRQb2ludFBvc2l0aW9uIiwgImRyYXdpbmdBcmVhIiwgInBsRm9udCIsICJ0b0ZvbnQiLCAidGV4dFNpemUiLCAiYW5nbGVSYWRpYW5zIiwgIl9ub3JtYWxpemVBbmdsZSIsICJnZXRJbmRleEFuZ2xlIiwgInRvRGVncmVlcyIsICJoTGltaXRzIiwgIngiLCAidkxpbWl0cyIsICJ5IiwgInVwZGF0ZUxpbWl0cyIsICJzZXRDZW50ZXJQb2ludCIsICJfcG9pbnRMYWJlbEl0ZW1zIiwgImJ1aWxkUG9pbnRMYWJlbEl0ZW1zIiwgImNyZWF0ZVBvaW50TGFiZWxJdGVtIiwgIml0ZW1PcHRzIiwgIm91dGVyRGlzdGFuY2UiLCAiZXh0cmEiLCAicG9pbnRMYWJlbFBvc2l0aW9uIiwgIkhBTEZfUEkiLCAieUZvckFuZ2xlIiwgInRleHRBbGlnbiIsICJnZXRUZXh0QWxpZ25Gb3JBbmdsZSIsICJsZWZ0Rm9yVGV4dEFsaWduIiwgInZpc2libGUiLCAiaXNOb3RPdmVybGFwcGVkIiwgIml0ZW0iLCAiYXJlYSIsICJhcGV4ZXNJbkFyZWEiLCAiX2lzUG9pbnRJbkFyZWEiLCAiaXRlbXMiLCAiYWxpZ24iLCAiZHJhd1BvaW50TGFiZWxCb3giLCAiYmFja2Ryb3BDb2xvciIsICJib3JkZXJSYWRpdXMiLCAidG9UUkJMQ29ybmVycyIsICJmaWxsU3R5bGUiLCAiYmFja2Ryb3BMZWZ0IiwgImJhY2tkcm9wVG9wIiwgImJhY2tkcm9wV2lkdGgiLCAiYmFja2Ryb3BIZWlnaHQiLCAidmFsdWVzIiwgInNvbWUiLCAiYmVnaW5QYXRoIiwgImFkZFJvdW5kZWRSZWN0UGF0aCIsICJyYWRpdXMiLCAiZmlsbCIsICJmaWxsUmVjdCIsICJkcmF3UG9pbnRMYWJlbHMiLCAibGFiZWxDb3VudCIsICJvcHRzQXRJbmRleCIsICJyZW5kZXJUZXh0IiwgImNvbG9yIiwgInRleHRCYXNlbGluZSIsICJwYXRoUmFkaXVzTGluZSIsICJjaXJjdWxhciIsICJhcmMiLCAieENlbnRlciIsICJ5Q2VudGVyIiwgIlRBVSIsICJtb3ZlVG8iLCAibGluZVRvIiwgImRyYXdSYWRpdXNMaW5lIiwgImdyaWRMaW5lT3B0cyIsICJib3JkZXJPcHRzIiwgImxpbmVXaWR0aCIsICJzYXZlIiwgInN0cm9rZVN0eWxlIiwgInNldExpbmVEYXNoIiwgImRhc2giLCAibGluZURhc2hPZmZzZXQiLCAiZGFzaE9mZnNldCIsICJjbG9zZVBhdGgiLCAic3Ryb2tlIiwgInJlc3RvcmUiLCAiY3JlYXRlUG9pbnRMYWJlbENvbnRleHQiLCAicGFyZW50IiwgImNyZWF0ZUNvbnRleHQiLCAidHlwZSIsICJSYWRpYWxMaW5lYXJTY2FsZSIsICJzZXREaW1lbnNpb25zIiwgIm1heFdpZHRoIiwgIm1heEhlaWdodCIsICJnZW5lcmF0ZVRpY2tMYWJlbHMiLCAiY2FsbCIsICJnZXRMYWJlbHMiLCAibWFwIiwgImNhbGxDYWxsYmFjayIsICJmaWx0ZXIiLCAiZ2V0RGF0YVZpc2liaWxpdHkiLCAiZml0IiwgImxlZnRNb3ZlbWVudCIsICJyaWdodE1vdmVtZW50IiwgInRvcE1vdmVtZW50IiwgImJvdHRvbU1vdmVtZW50IiwgImFuZ2xlTXVsdGlwbGllciIsICJzdGFydEFuZ2xlIiwgImdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlIiwgInNjYWxpbmdGYWN0b3IiLCAiZ2V0VmFsdWVGb3JEaXN0YW5jZUZyb21DZW50ZXIiLCAiZGlzdGFuY2UiLCAic2NhbGVkRGlzdGFuY2UiLCAicG9pbnRMYWJlbCIsICJnZXRDb250ZXh0IiwgImRpc3RhbmNlRnJvbUNlbnRlciIsICJnZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUiLCAiZ2V0QmFzZVBvc2l0aW9uIiwgImdldEJhc2VWYWx1ZSIsICJnZXRQb2ludExhYmVsUG9zaXRpb24iLCAiZHJhd0JhY2tncm91bmQiLCAiYmFja2dyb3VuZENvbG9yIiwgImdyaWQiLCAiZHJhd0dyaWQiLCAiYW5nbGVMaW5lcyIsICJib3JkZXIiLCAicG9zaXRpb24iLCAiZm9yRWFjaCIsICJ0aWNrIiwgImNvbnRleHQiLCAib3B0c0F0SW5kZXhCb3JkZXIiLCAiYm9yZGVyRGFzaCIsICJib3JkZXJEYXNoT2Zmc2V0IiwgImRyYXdCb3JkZXIiLCAiZHJhd0xhYmVscyIsICJ0cmFuc2xhdGUiLCAicm90YXRlIiwgInNob3dMYWJlbEJhY2tkcm9wIiwgIm1lYXN1cmVUZXh0IiwgInN0cm9rZUNvbG9yIiwgInRleHRTdHJva2VDb2xvciIsICJzdHJva2VXaWR0aCIsICJ0ZXh0U3Ryb2tlV2lkdGgiLCAiZHJhd1RpdGxlIiwgImFuaW1hdGUiLCAiZGVmYXVsdFJvdXRlcyIsICJkZXNjcmlwdG9ycyIsICJfZmFsbGJhY2siLCAiSU5URVJWQUxTIiwgIm1pbGxpc2Vjb25kIiwgImNvbW1vbiIsICJzZWNvbmQiLCAibWludXRlIiwgImhvdXIiLCAiZGF5IiwgIndlZWsiLCAibW9udGgiLCAicXVhcnRlciIsICJ5ZWFyIiwgIlVOSVRTIiwgImtleXMiLCAic29ydGVyIiwgImEiLCAiaW5wdXQiLCAiYWRhcHRlciIsICJfYWRhcHRlciIsICJwYXJzZXIiLCAiaXNvV2Vla2RheSIsICJfcGFyc2VPcHRzIiwgImlzTnVtYmVyIiwgInN0YXJ0T2YiLCAiZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyIsICJtaW5Vbml0IiwgImNhcGFjaXR5IiwgImlsZW4iLCAiaW5kZXhPZiIsICJpbnRlcnZhbCIsICJNQVhfU0FGRV9JTlRFR0VSIiwgImRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nIiwgIm51bVRpY2tzIiwgImRpZmYiLCAiZGV0ZXJtaW5lTWFqb3JVbml0IiwgImFkZFRpY2siLCAidGltZSIsICJ0aW1lc3RhbXBzIiwgImxvIiwgImhpIiwgIl9sb29rdXAiLCAidGltZXN0YW1wIiwgInNldE1ham9yVGlja3MiLCAibWFqb3JVbml0IiwgImZpcnN0IiwgImxhc3QiLCAiYWRkIiwgInRpY2tzRnJvbVRpbWVzdGFtcHMiLCAiVGltZVNjYWxlIiwgInByb3BzIiwgIl9jYWNoZSIsICJkYXRhIiwgImxhYmVscyIsICJhbGwiLCAiX3VuaXQiLCAiX21ham9yVW5pdCIsICJfb2Zmc2V0cyIsICJfbm9ybWFsaXplZCIsICJpbml0IiwgInNjYWxlT3B0cyIsICJhZGFwdGVycyIsICJfZGF0ZSIsICJkYXRlIiwgIm1lcmdlSWYiLCAiZGlzcGxheUZvcm1hdHMiLCAiZm9ybWF0cyIsICJub3JtYWxpemVkIiwgImJlZm9yZUxheW91dCIsICJfYXBwbHlCb3VuZHMiLCAiX2dldExhYmVsQm91bmRzIiwgInNvdXJjZSIsICJEYXRlIiwgIm5vdyIsICJlbmRPZiIsICJhcnIiLCAiZ2V0TGFiZWxUaW1lc3RhbXBzIiwgIk5FR0FUSVZFX0lORklOSVRZIiwgInRpbWVPcHRzIiwgIl9nZW5lcmF0ZSIsICJfZmlsdGVyQmV0d2VlbiIsICJhdXRvU2tpcCIsICJfZ2V0TGFiZWxDYXBhY2l0eSIsICJpbml0T2Zmc2V0cyIsICJhZnRlckF1dG9Ta2lwIiwgIm9mZnNldEFmdGVyQXV0b3NraXAiLCAiZ2V0RGVjaW1hbEZvclZhbHVlIiwgImxpbWl0IiwgIl9saW1pdFZhbHVlIiwgIm1pbm9yIiwgIndlZWtkYXkiLCAiaGFzV2Vla2RheSIsICJFcnJvciIsICJnZXREYXRhVGltZXN0YW1wcyIsICJzb3J0IiwgInRvb2x0aXBGb3JtYXQiLCAiZGF0ZXRpbWUiLCAiZm10IiwgIl90aWNrRm9ybWF0RnVuY3Rpb24iLCAiZm9ybWF0dGVyIiwgIm1pbm9yRm9ybWF0IiwgIm1ham9yRm9ybWF0IiwgIm9mZnNldHMiLCAiX2dldExhYmVsU2l6ZSIsICJ0aWNrc09wdHMiLCAidGlja0xhYmVsV2lkdGgiLCAibWF4Um90YXRpb24iLCAiY29zUm90YXRpb24iLCAic2luUm90YXRpb24iLCAidGlja0ZvbnRTaXplIiwgImV4YW1wbGVUaW1lIiwgImV4YW1wbGVMYWJlbCIsICJtZXRhcyIsICJnZXRNYXRjaGluZ1Zpc2libGVNZXRhcyIsICJjb250cm9sbGVyIiwgImdldEFsbFBhcnNlZFZhbHVlcyIsICJjb25jYXQiLCAibm9ybWFsaXplIiwgIl9hcnJheVVuaXF1ZSIsICJpbnRlcnBvbGF0ZSIsICJ0YWJsZSIsICJ2YWwiLCAicHJldlNvdXJjZSIsICJuZXh0U291cmNlIiwgInByZXZUYXJnZXQiLCAibmV4dFRhcmdldCIsICJfbG9va3VwQnlLZXkiLCAic3BhbiIsICJUaW1lU2VyaWVzU2NhbGUiLCAiX3RhYmxlIiwgIl9taW5Qb3MiLCAiX3RhYmxlUmFuZ2UiLCAiX2dldFRpbWVzdGFtcHNGb3JUYWJsZSIsICJidWlsZExvb2t1cFRhYmxlIiwgInByZXYiLCAiY3VyciIsICJuZXh0IiwgImluY2x1ZGVzIiwgInNwbGljZSIsICJyb3VuZCIsICJsaW0iLCAibCIsICJwMmIiLCAibjJiIiwgImxpbSIsICJyb3VuZCIsICJiMm4iLCAibjJwIiwgIm1hcCQxIiwgImhleCIsICJoMSIsICJoMiIsICJlcSIsICJpc1Nob3J0IiwgImhleFBhcnNlIiwgImFscGhhIiwgImhleFN0cmluZyIsICJIVUVfUkUiLCAiaHNsMnJnYm4iLCAicyIsICJsIiwgIm4iLCAiaHN2MnJnYm4iLCAiaHdiMnJnYm4iLCAiaHVlVmFsdWUiLCAicmdiMmhzbCIsICJjYWxsbiIsICJoc2wycmdiIiwgImh3YjJyZ2IiLCAiaHN2MnJnYiIsICJodWUiLCAiaHVlUGFyc2UiLCAicDJiIiwgInJvdGF0ZSIsICJoc2xTdHJpbmciLCAibWFwIiwgIm5hbWVzJDEiLCAidW5wYWNrIiwgIm5hbWVzIiwgIm5hbWVQYXJzZSIsICJSR0JfUkUiLCAicmdiUGFyc2UiLCAicmdiU3RyaW5nIiwgInRvIiwgImZyb20iLCAiaW50ZXJwb2xhdGUiLCAibW9kSFNMIiwgImNsb25lIiwgImZyb21PYmplY3QiLCAiZnVuY3Rpb25QYXJzZSIsICJDb2xvciIsICJjb2xvciIsICJ1aWQiLCAiaWQiLCAiaXNOdWxsT3JVbmRlZiIsICJ2YWx1ZSIsICJpc0FycmF5IiwgIkFycmF5IiwgInR5cGUiLCAiT2JqZWN0IiwgInByb3RvdHlwZSIsICJ0b1N0cmluZyIsICJjYWxsIiwgInNsaWNlIiwgImlzT2JqZWN0IiwgImlzTnVtYmVyRmluaXRlIiwgIk51bWJlciIsICJpc0Zpbml0ZSIsICJmaW5pdGVPckRlZmF1bHQiLCAiZGVmYXVsdFZhbHVlIiwgInZhbHVlT3JEZWZhdWx0IiwgInRvRGltZW5zaW9uIiwgInZhbHVlIiwgImRpbWVuc2lvbiIsICJlbmRzV2l0aCIsICJwYXJzZUZsb2F0IiwgImNhbGxiYWNrIiwgImZuIiwgImFyZ3MiLCAidGhpc0FyZyIsICJjYWxsIiwgImFwcGx5IiwgImVhY2giLCAibG9vcGFibGUiLCAicmV2ZXJzZSIsICJpIiwgImxlbiIsICJrZXlzIiwgImlzQXJyYXkiLCAibGVuZ3RoIiwgImlzT2JqZWN0IiwgIk9iamVjdCIsICJjbG9uZSIsICJzb3VyY2UiLCAiaXNBcnJheSIsICJtYXAiLCAiaXNPYmplY3QiLCAidGFyZ2V0IiwgIk9iamVjdCIsICJjcmVhdGUiLCAia2V5cyIsICJrbGVuIiwgImxlbmd0aCIsICJrIiwgImlzVmFsaWRLZXkiLCAia2V5IiwgImluZGV4T2YiLCAiX21lcmdlciIsICJvcHRpb25zIiwgInR2YWwiLCAic3ZhbCIsICJtZXJnZSIsICJzb3VyY2VzIiwgImlsZW4iLCAibWVyZ2VyIiwgImN1cnJlbnQiLCAiaSIsICJtZXJnZUlmIiwgIl9tZXJnZXJJZiIsICJwcm90b3R5cGUiLCAiaGFzT3duUHJvcGVydHkiLCAiY2FsbCIsICJQSSIsICJNYXRoIiwgIlRBVSIsICJQSVRBVSIsICJJTkZJTklUWSIsICJOdW1iZXIiLCAiUE9TSVRJVkVfSU5GSU5JVFkiLCAiUkFEX1BFUl9ERUciLCAiSEFMRl9QSSIsICJRVUFSVEVSX1BJIiwgIlRXT19USElSRFNfUEkiLCAibG9nMTAiLCAic2lnbiIsICJhbG1vc3RFcXVhbHMiLCAieCIsICJ5IiwgImVwc2lsb24iLCAiYWJzIiwgIm5pY2VOdW0iLCAicmFuZ2UiLCAicm91bmRlZFJhbmdlIiwgInJvdW5kIiwgIm5pY2VSYW5nZSIsICJwb3ciLCAiZmxvb3IiLCAiZnJhY3Rpb24iLCAibmljZUZyYWN0aW9uIiwgIl9mYWN0b3JpemUiLCAidmFsdWUiLCAicmVzdWx0IiwgInNxcnQiLCAiaSIsICJwdXNoIiwgInNvcnQiLCAiYSIsICJiIiwgInBvcCIsICJpc051bWJlciIsICJuIiwgImlzTmFOIiwgInBhcnNlRmxvYXQiLCAiaXNGaW5pdGUiLCAiYWxtb3N0V2hvbGUiLCAicm91bmRlZCIsICJfc2V0TWluQW5kTWF4QnlLZXkiLCAiYXJyYXkiLCAidGFyZ2V0IiwgInByb3BlcnR5IiwgImlsZW4iLCAibGVuZ3RoIiwgIm1pbiIsICJtYXgiLCAidG9SYWRpYW5zIiwgImRlZ3JlZXMiLCAidG9EZWdyZWVzIiwgInJhZGlhbnMiLCAiX2RlY2ltYWxQbGFjZXMiLCAiaXNGaW5pdGVOdW1iZXIiLCAiZSIsICJwIiwgIl9ub3JtYWxpemVBbmdsZSIsICJhIiwgIlRBVSIsICJfbGltaXRWYWx1ZSIsICJ2YWx1ZSIsICJtaW4iLCAibWF4IiwgIk1hdGgiLCAiX2ludDE2UmFuZ2UiLCAiX2xvb2t1cCIsICJ0YWJsZSIsICJ2YWx1ZSIsICJjbXAiLCAiaW5kZXgiLCAiaGkiLCAibGVuZ3RoIiwgImxvIiwgIm1pZCIsICJfbG9va3VwQnlLZXkiLCAia2V5IiwgImxhc3QiLCAidGkiLCAiX2ZpbHRlckJldHdlZW4iLCAidmFsdWVzIiwgIm1pbiIsICJtYXgiLCAic3RhcnQiLCAiZW5kIiwgImxlbmd0aCIsICJzbGljZSIsICJfYXJyYXlVbmlxdWUiLCAiaXRlbXMiLCAic2V0IiwgIlNldCIsICJzaXplIiwgImxlbmd0aCIsICJBcnJheSIsICJmcm9tIiwgInJlcXVlc3RBbmltRnJhbWUiLCAid2luZG93IiwgImNhbGxiYWNrIiwgInJlcXVlc3RBbmltYXRpb25GcmFtZSIsICJfdG9MZWZ0UmlnaHRDZW50ZXIiLCAiYWxpZ24iLCAiX2FsaWduU3RhcnRFbmQiLCAic3RhcnQiLCAiZW5kIiwgImlzUGF0dGVybk9yR3JhZGllbnQiLCAidmFsdWUiLCAidHlwZSIsICJ0b1N0cmluZyIsICJnZXRIb3ZlckNvbG9yIiwgInZhbHVlIiwgImlzUGF0dGVybk9yR3JhZGllbnQiLCAiQ29sb3IiLCAic2F0dXJhdGUiLCAiZGFya2VuIiwgImhleFN0cmluZyIsICJudW1iZXJzIiwgImNvbG9ycyIsICJhcHBseUFuaW1hdGlvbnNEZWZhdWx0cyIsICJkZWZhdWx0cyIsICJzZXQiLCAiZGVsYXkiLCAidW5kZWZpbmVkIiwgImR1cmF0aW9uIiwgImVhc2luZyIsICJmbiIsICJmcm9tIiwgImxvb3AiLCAidG8iLCAidHlwZSIsICJkZXNjcmliZSIsICJfZmFsbGJhY2siLCAiX2luZGV4YWJsZSIsICJfc2NyaXB0YWJsZSIsICJuYW1lIiwgInByb3BlcnRpZXMiLCAiYWN0aXZlIiwgImFuaW1hdGlvbiIsICJyZXNpemUiLCAic2hvdyIsICJhbmltYXRpb25zIiwgInZpc2libGUiLCAiaGlkZSIsICJ2IiwgImFwcGx5TGF5b3V0c0RlZmF1bHRzIiwgImF1dG9QYWRkaW5nIiwgInBhZGRpbmciLCAidG9wIiwgInJpZ2h0IiwgImJvdHRvbSIsICJsZWZ0IiwgImludGxDYWNoZSIsICJNYXAiLCAiZ2V0TnVtYmVyRm9ybWF0IiwgImxvY2FsZSIsICJvcHRpb25zIiwgImNhY2hlS2V5IiwgIkpTT04iLCAic3RyaW5naWZ5IiwgImZvcm1hdHRlciIsICJnZXQiLCAiSW50bCIsICJOdW1iZXJGb3JtYXQiLCAiZm9ybWF0TnVtYmVyIiwgIm51bSIsICJmb3JtYXQiLCAiZm9ybWF0dGVycyIsICJ2YWx1ZXMiLCAiaXNBcnJheSIsICJudW1lcmljIiwgInRpY2tWYWx1ZSIsICJpbmRleCIsICJ0aWNrcyIsICJjaGFydCIsICJub3RhdGlvbiIsICJkZWx0YSIsICJsZW5ndGgiLCAibWF4VGljayIsICJNYXRoIiwgIm1heCIsICJhYnMiLCAiY2FsY3VsYXRlRGVsdGEiLCAibG9nRGVsdGEiLCAibG9nMTAiLCAibnVtRGVjaW1hbCIsICJpc05hTiIsICJtaW4iLCAiZmxvb3IiLCAibWluaW11bUZyYWN0aW9uRGlnaXRzIiwgIm1heGltdW1GcmFjdGlvbkRpZ2l0cyIsICJPYmplY3QiLCAiYXNzaWduIiwgImxvZ2FyaXRobWljIiwgInJlbWFpbiIsICJzaWduaWZpY2FuZCIsICJwb3ciLCAiaW5jbHVkZXMiLCAiY2FsbCIsICJUaWNrcyIsICJhcHBseVNjYWxlRGVmYXVsdHMiLCAiZGlzcGxheSIsICJvZmZzZXQiLCAicmV2ZXJzZSIsICJiZWdpbkF0WmVybyIsICJib3VuZHMiLCAiY2xpcCIsICJncmFjZSIsICJncmlkIiwgImxpbmVXaWR0aCIsICJkcmF3T25DaGFydEFyZWEiLCAiZHJhd1RpY2tzIiwgInRpY2tMZW5ndGgiLCAidGlja1dpZHRoIiwgIl9jdHgiLCAidGlja0NvbG9yIiwgImNvbG9yIiwgImJvcmRlciIsICJkYXNoIiwgImRhc2hPZmZzZXQiLCAid2lkdGgiLCAidGl0bGUiLCAidGV4dCIsICJtaW5Sb3RhdGlvbiIsICJtYXhSb3RhdGlvbiIsICJtaXJyb3IiLCAidGV4dFN0cm9rZVdpZHRoIiwgInRleHRTdHJva2VDb2xvciIsICJhdXRvU2tpcCIsICJhdXRvU2tpcFBhZGRpbmciLCAibGFiZWxPZmZzZXQiLCAiY2FsbGJhY2siLCAibWlub3IiLCAibWFqb3IiLCAiYWxpZ24iLCAiY3Jvc3NBbGlnbiIsICJzaG93TGFiZWxCYWNrZHJvcCIsICJiYWNrZHJvcENvbG9yIiwgImJhY2tkcm9wUGFkZGluZyIsICJyb3V0ZSIsICJzdGFydHNXaXRoIiwgIm92ZXJyaWRlcyIsICJjcmVhdGUiLCAiZGVzY3JpcHRvcnMiLCAiZ2V0U2NvcGUiLCAibm9kZSIsICJrZXkiLCAia2V5cyIsICJzcGxpdCIsICJpIiwgIm4iLCAiayIsICJyb290IiwgInNjb3BlIiwgIm1lcmdlIiwgIkRlZmF1bHRzIiwgImNvbnN0cnVjdG9yIiwgIl9kZXNjcmlwdG9ycyIsICJfYXBwbGllcnMiLCAiYmFja2dyb3VuZENvbG9yIiwgImJvcmRlckNvbG9yIiwgImRhdGFzZXRzIiwgImRldmljZVBpeGVsUmF0aW8iLCAiY29udGV4dCIsICJwbGF0Zm9ybSIsICJnZXREZXZpY2VQaXhlbFJhdGlvIiwgImVsZW1lbnRzIiwgImV2ZW50cyIsICJmb250IiwgImZhbWlseSIsICJzaXplIiwgInN0eWxlIiwgImxpbmVIZWlnaHQiLCAid2VpZ2h0IiwgImhvdmVyIiwgImhvdmVyQmFja2dyb3VuZENvbG9yIiwgImN0eCIsICJob3ZlckJvcmRlckNvbG9yIiwgImhvdmVyQ29sb3IiLCAiaW5kZXhBeGlzIiwgImludGVyYWN0aW9uIiwgIm1vZGUiLCAiaW50ZXJzZWN0IiwgImluY2x1ZGVJbnZpc2libGUiLCAibWFpbnRhaW5Bc3BlY3RSYXRpbyIsICJvbkhvdmVyIiwgIm9uQ2xpY2siLCAicGFyc2luZyIsICJwbHVnaW5zIiwgInJlc3BvbnNpdmUiLCAic2NhbGUiLCAic2NhbGVzIiwgInNob3dMaW5lIiwgImRyYXdBY3RpdmVFbGVtZW50c09uVG9wIiwgImFwcGx5IiwgIm92ZXJyaWRlIiwgInRhcmdldFNjb3BlIiwgInRhcmdldE5hbWUiLCAic2NvcGVPYmplY3QiLCAidGFyZ2V0U2NvcGVPYmplY3QiLCAicHJpdmF0ZU5hbWUiLCAiZGVmaW5lUHJvcGVydGllcyIsICJ3cml0YWJsZSIsICJlbnVtZXJhYmxlIiwgImxvY2FsIiwgInRhcmdldCIsICJpc09iamVjdCIsICJ2YWx1ZU9yRGVmYXVsdCIsICJhcHBsaWVycyIsICJmb3JFYWNoIiwgInRvRm9udFN0cmluZyIsICJpc051bGxPclVuZGVmIiwgIl9tZWFzdXJlVGV4dCIsICJkYXRhIiwgImdjIiwgImxvbmdlc3QiLCAic3RyaW5nIiwgInRleHRXaWR0aCIsICJtZWFzdXJlVGV4dCIsICJwdXNoIiwgIl9sb25nZXN0VGV4dCIsICJhcnJheU9mVGhpbmdzIiwgImNhY2hlIiwgImdhcmJhZ2VDb2xsZWN0IiwgInNhdmUiLCAiaWxlbiIsICJqIiwgImpsZW4iLCAidGhpbmciLCAibmVzdGVkVGhpbmciLCAicmVzdG9yZSIsICJnY0xlbiIsICJzcGxpY2UiLCAiX2FsaWduUGl4ZWwiLCAicGl4ZWwiLCAiY3VycmVudERldmljZVBpeGVsUmF0aW8iLCAiaGFsZldpZHRoIiwgInJvdW5kIiwgIl9pc1BvaW50SW5BcmVhIiwgInBvaW50IiwgImFyZWEiLCAibWFyZ2luIiwgIngiLCAibGVmdCIsICJyaWdodCIsICJ5IiwgInRvcCIsICJib3R0b20iLCAiY2xpcEFyZWEiLCAiY3R4IiwgInNhdmUiLCAiYmVnaW5QYXRoIiwgInJlY3QiLCAiY2xpcCIsICJ1bmNsaXBBcmVhIiwgInJlc3RvcmUiLCAic2V0UmVuZGVyT3B0cyIsICJjdHgiLCAib3B0cyIsICJ0cmFuc2xhdGlvbiIsICJ0cmFuc2xhdGUiLCAiaXNOdWxsT3JVbmRlZiIsICJyb3RhdGlvbiIsICJyb3RhdGUiLCAiY29sb3IiLCAiZmlsbFN0eWxlIiwgInRleHRBbGlnbiIsICJ0ZXh0QmFzZWxpbmUiLCAiZGVjb3JhdGVUZXh0IiwgIngiLCAieSIsICJsaW5lIiwgInN0cmlrZXRocm91Z2giLCAidW5kZXJsaW5lIiwgIm1ldHJpY3MiLCAibWVhc3VyZVRleHQiLCAibGVmdCIsICJhY3R1YWxCb3VuZGluZ0JveExlZnQiLCAicmlnaHQiLCAiYWN0dWFsQm91bmRpbmdCb3hSaWdodCIsICJ0b3AiLCAiYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQiLCAiYm90dG9tIiwgImFjdHVhbEJvdW5kaW5nQm94RGVzY2VudCIsICJ5RGVjb3JhdGlvbiIsICJzdHJva2VTdHlsZSIsICJiZWdpblBhdGgiLCAibGluZVdpZHRoIiwgImRlY29yYXRpb25XaWR0aCIsICJtb3ZlVG8iLCAibGluZVRvIiwgInN0cm9rZSIsICJkcmF3QmFja2Ryb3AiLCAib2xkQ29sb3IiLCAiZmlsbFJlY3QiLCAid2lkdGgiLCAiaGVpZ2h0IiwgInJlbmRlclRleHQiLCAidGV4dCIsICJmb250IiwgImxpbmVzIiwgImlzQXJyYXkiLCAic3Ryb2tlV2lkdGgiLCAic3Ryb2tlQ29sb3IiLCAiaSIsICJzYXZlIiwgInN0cmluZyIsICJsZW5ndGgiLCAiYmFja2Ryb3AiLCAic3Ryb2tlVGV4dCIsICJtYXhXaWR0aCIsICJmaWxsVGV4dCIsICJOdW1iZXIiLCAibGluZUhlaWdodCIsICJyZXN0b3JlIiwgImFkZFJvdW5kZWRSZWN0UGF0aCIsICJyZWN0IiwgInciLCAiaCIsICJyYWRpdXMiLCAiYXJjIiwgInRvcExlZnQiLCAiUEkiLCAiYm90dG9tTGVmdCIsICJIQUxGX1BJIiwgImJvdHRvbVJpZ2h0IiwgInRvcFJpZ2h0IiwgIkxJTkVfSEVJR0hUIiwgIkZPTlRfU1RZTEUiLCAidG9MaW5lSGVpZ2h0IiwgInZhbHVlIiwgInNpemUiLCAibWF0Y2hlcyIsICJtYXRjaCIsICJudW1iZXJPclplcm8iLCAidiIsICJfcmVhZFZhbHVlVG9Qcm9wcyIsICJwcm9wcyIsICJyZXQiLCAib2JqUHJvcHMiLCAiaXNPYmplY3QiLCAia2V5cyIsICJPYmplY3QiLCAicmVhZCIsICJwcm9wIiwgInZhbHVlT3JEZWZhdWx0IiwgInRvVFJCTCIsICJ0b1RSQkxDb3JuZXJzIiwgInRvUGFkZGluZyIsICJvYmoiLCAidG9Gb250IiwgIm9wdGlvbnMiLCAiZmFsbGJhY2siLCAiZGVmYXVsdHMiLCAicGFyc2VJbnQiLCAic3R5bGUiLCAiY29uc29sZSIsICJ3YXJuIiwgInVuZGVmaW5lZCIsICJmYW1pbHkiLCAid2VpZ2h0IiwgInRvRm9udFN0cmluZyIsICJfYWRkR3JhY2UiLCAibWlubWF4IiwgImdyYWNlIiwgImJlZ2luQXRaZXJvIiwgIm1pbiIsICJtYXgiLCAiY2hhbmdlIiwgInRvRGltZW5zaW9uIiwgImtlZXBaZXJvIiwgInZhbHVlIiwgImFkZCIsICJNYXRoIiwgImFicyIsICJjcmVhdGVDb250ZXh0IiwgInBhcmVudENvbnRleHQiLCAiY29udGV4dCIsICJPYmplY3QiLCAiYXNzaWduIiwgImNyZWF0ZSIsICJFUFNJTE9OIiwgIk51bWJlciIsICJfaXNEb21TdXBwb3J0ZWQiLCAid2luZG93IiwgImRvY3VtZW50IiwgInN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMiLCAicGFzc2l2ZVN1cHBvcnRlZCIsICJvcHRpb25zIiwgInBhc3NpdmUiLCAiX2lzRG9tU3VwcG9ydGVkIiwgIndpbmRvdyIsICJhZGRFdmVudExpc3RlbmVyIiwgInJlbW92ZUV2ZW50TGlzdGVuZXIiLCAiZSIsICJhYnN0cmFjdCIsICJFcnJvciIsICJEYXRlQWRhcHRlckJhc2UiLCAiY29uc3RydWN0b3IiLCAib3B0aW9ucyIsICJvdmVycmlkZSIsICJtZW1iZXJzIiwgIk9iamVjdCIsICJhc3NpZ24iLCAicHJvdG90eXBlIiwgImluaXQiLCAiZm9ybWF0cyIsICJwYXJzZSIsICJmb3JtYXQiLCAiYWRkIiwgImRpZmYiLCAic3RhcnRPZiIsICJlbmRPZiIsICJhZGFwdGVycyIsICJfZGF0ZSIsICJFbGVtZW50IiwgIngiLCAieSIsICJhY3RpdmUiLCAib3B0aW9ucyIsICIkYW5pbWF0aW9ucyIsICJ0b29sdGlwUG9zaXRpb24iLCAidXNlRmluYWxQb3NpdGlvbiIsICJnZXRQcm9wcyIsICJoYXNWYWx1ZSIsICJpc051bWJlciIsICJwcm9wcyIsICJmaW5hbCIsICJhbmltcyIsICJyZXQiLCAiZm9yRWFjaCIsICJwcm9wIiwgIl90byIsICJkZWZhdWx0cyIsICJkZWZhdWx0Um91dGVzIiwgImF1dG9Ta2lwIiwgInNjYWxlIiwgInRpY2tzIiwgInRpY2tPcHRzIiwgImRldGVybWluZWRNYXhUaWNrcyIsICJkZXRlcm1pbmVNYXhUaWNrcyIsICJ0aWNrc0xpbWl0IiwgIk1hdGgiLCAibWluIiwgIm1heFRpY2tzTGltaXQiLCAibWFqb3JJbmRpY2VzIiwgIm1ham9yIiwgImVuYWJsZWQiLCAiZ2V0TWFqb3JJbmRpY2VzIiwgIm51bU1ham9ySW5kaWNlcyIsICJsZW5ndGgiLCAiZmlyc3QiLCAibGFzdCIsICJuZXdUaWNrcyIsICJza2lwTWFqb3JzIiwgInNwYWNpbmciLCAiY2FsY3VsYXRlU3BhY2luZyIsICJpIiwgImlsZW4iLCAiYXZnTWFqb3JTcGFjaW5nIiwgInJvdW5kIiwgInNraXAiLCAiaXNOdWxsT3JVbmRlZiIsICJvZmZzZXQiLCAidGlja0xlbmd0aCIsICJfdGlja1NpemUiLCAibWF4U2NhbGUiLCAiX2xlbmd0aCIsICJtYXhDaGFydCIsICJfbWF4TGVuZ3RoIiwgImZsb29yIiwgImV2ZW5NYWpvclNwYWNpbmciLCAiZ2V0RXZlblNwYWNpbmciLCAibWF4IiwgImZhY3RvcnMiLCAiX2ZhY3Rvcml6ZSIsICJmYWN0b3IiLCAicmVzdWx0IiwgInB1c2giLCAiY291bnQiLCAibmV4dCIsICJjZWlsIiwgIm1ham9yU3RhcnQiLCAibWFqb3JFbmQiLCAic3RhcnQiLCAidmFsdWVPckRlZmF1bHQiLCAiZW5kIiwgImFyciIsICJsZW4iLCAiZGlmZiIsICJyZXZlcnNlQWxpZ24iLCAiYWxpZ24iLCAib2Zmc2V0RnJvbUVkZ2UiLCAiZWRnZSIsICJnZXRUaWNrc0xpbWl0IiwgInRpY2tzTGVuZ3RoIiwgInNhbXBsZSIsICJudW1JdGVtcyIsICJpbmNyZW1lbnQiLCAiZ2V0UGl4ZWxGb3JHcmlkTGluZSIsICJpbmRleCIsICJvZmZzZXRHcmlkTGluZXMiLCAidmFsaWRJbmRleCIsICJfc3RhcnRQaXhlbCIsICJfZW5kUGl4ZWwiLCAiZXBzaWxvbiIsICJsaW5lVmFsdWUiLCAiZ2V0UGl4ZWxGb3JUaWNrIiwgImdhcmJhZ2VDb2xsZWN0IiwgImNhY2hlcyIsICJlYWNoIiwgImNhY2hlIiwgImdjIiwgImdjTGVuIiwgImRhdGEiLCAic3BsaWNlIiwgImdldFRpY2tNYXJrTGVuZ3RoIiwgImRyYXdUaWNrcyIsICJnZXRUaXRsZUhlaWdodCIsICJmYWxsYmFjayIsICJkaXNwbGF5IiwgImZvbnQiLCAidG9Gb250IiwgInBhZGRpbmciLCAidG9QYWRkaW5nIiwgImxpbmVzIiwgImlzQXJyYXkiLCAidGV4dCIsICJsaW5lSGVpZ2h0IiwgImhlaWdodCIsICJjcmVhdGVTY2FsZUNvbnRleHQiLCAicGFyZW50IiwgImNyZWF0ZUNvbnRleHQiLCAidHlwZSIsICJjcmVhdGVUaWNrQ29udGV4dCIsICJ0aWNrIiwgInRpdGxlQWxpZ24iLCAicG9zaXRpb24iLCAicmV2ZXJzZSIsICJfdG9MZWZ0UmlnaHRDZW50ZXIiLCAidGl0bGVBcmdzIiwgInRvcCIsICJsZWZ0IiwgImJvdHRvbSIsICJyaWdodCIsICJjaGFydCIsICJjaGFydEFyZWEiLCAic2NhbGVzIiwgInJvdGF0aW9uIiwgIm1heFdpZHRoIiwgInRpdGxlWCIsICJ0aXRsZVkiLCAid2lkdGgiLCAiaXNIb3Jpem9udGFsIiwgIl9hbGlnblN0YXJ0RW5kIiwgImlzT2JqZWN0IiwgInBvc2l0aW9uQXhpc0lEIiwgIk9iamVjdCIsICJrZXlzIiwgInZhbHVlIiwgImdldFBpeGVsRm9yVmFsdWUiLCAiSEFMRl9QSSIsICJTY2FsZSIsICJjb25zdHJ1Y3RvciIsICJjZmciLCAiaWQiLCAidW5kZWZpbmVkIiwgImN0eCIsICJfbWFyZ2lucyIsICJtYXhIZWlnaHQiLCAicGFkZGluZ1RvcCIsICJwYWRkaW5nQm90dG9tIiwgInBhZGRpbmdMZWZ0IiwgInBhZGRpbmdSaWdodCIsICJheGlzIiwgImxhYmVsUm90YXRpb24iLCAiX3JhbmdlIiwgIl9ncmlkTGluZUl0ZW1zIiwgIl9sYWJlbEl0ZW1zIiwgIl9sYWJlbFNpemVzIiwgIl9sb25nZXN0VGV4dENhY2hlIiwgIl9yZXZlcnNlUGl4ZWxzIiwgIl91c2VyTWF4IiwgIl91c2VyTWluIiwgIl9zdWdnZXN0ZWRNYXgiLCAiX3N1Z2dlc3RlZE1pbiIsICJfdGlja3NMZW5ndGgiLCAiX2JvcmRlclZhbHVlIiwgIl9jYWNoZSIsICJfZGF0YUxpbWl0c0NhY2hlZCIsICIkY29udGV4dCIsICJpbml0IiwgInNldENvbnRleHQiLCAiZ2V0Q29udGV4dCIsICJwYXJzZSIsICJzdWdnZXN0ZWRNaW4iLCAic3VnZ2VzdGVkTWF4IiwgInJhdyIsICJnZXRVc2VyQm91bmRzIiwgImZpbml0ZU9yRGVmYXVsdCIsICJOdW1iZXIiLCAiUE9TSVRJVkVfSU5GSU5JVFkiLCAiTkVHQVRJVkVfSU5GSU5JVFkiLCAibWluRGVmaW5lZCIsICJpc0Zpbml0ZSIsICJtYXhEZWZpbmVkIiwgImdldE1pbk1heCIsICJjYW5TdGFjayIsICJyYW5nZSIsICJtZXRhcyIsICJnZXRNYXRjaGluZ1Zpc2libGVNZXRhcyIsICJjb250cm9sbGVyIiwgImdldFBhZGRpbmciLCAiZ2V0VGlja3MiLCAiZ2V0TGFiZWxzIiwgImxhYmVscyIsICJ4TGFiZWxzIiwgInlMYWJlbHMiLCAiZ2V0TGFiZWxJdGVtcyIsICJpdGVtcyIsICJfY29tcHV0ZUxhYmVsSXRlbXMiLCAiYmVmb3JlTGF5b3V0IiwgImJlZm9yZVVwZGF0ZSIsICJjYWxsIiwgInVwZGF0ZSIsICJtYXJnaW5zIiwgImJlZ2luQXRaZXJvIiwgImdyYWNlIiwgInNhbXBsZVNpemUiLCAiYXNzaWduIiwgImJlZm9yZVNldERpbWVuc2lvbnMiLCAic2V0RGltZW5zaW9ucyIsICJhZnRlclNldERpbWVuc2lvbnMiLCAiYmVmb3JlRGF0YUxpbWl0cyIsICJkZXRlcm1pbmVEYXRhTGltaXRzIiwgImFmdGVyRGF0YUxpbWl0cyIsICJfYWRkR3JhY2UiLCAiYmVmb3JlQnVpbGRUaWNrcyIsICJidWlsZFRpY2tzIiwgImFmdGVyQnVpbGRUaWNrcyIsICJzYW1wbGluZ0VuYWJsZWQiLCAiX2NvbnZlcnRUaWNrc1RvTGFiZWxzIiwgImNvbmZpZ3VyZSIsICJiZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uIiwgImNhbGN1bGF0ZUxhYmVsUm90YXRpb24iLCAiYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uIiwgInNvdXJjZSIsICJhZnRlckF1dG9Ta2lwIiwgImJlZm9yZUZpdCIsICJmaXQiLCAiYWZ0ZXJGaXQiLCAiYWZ0ZXJVcGRhdGUiLCAicmV2ZXJzZVBpeGVscyIsICJzdGFydFBpeGVsIiwgImVuZFBpeGVsIiwgIl9hbGlnblRvUGl4ZWxzIiwgImFsaWduVG9QaXhlbHMiLCAiX2NhbGxIb29rcyIsICJuYW1lIiwgIm5vdGlmeVBsdWdpbnMiLCAiYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uIiwgImdlbmVyYXRlVGlja0xhYmVscyIsICJsYWJlbCIsICJjYWxsYmFjayIsICJhZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbiIsICJudW1UaWNrcyIsICJtaW5Sb3RhdGlvbiIsICJtYXhSb3RhdGlvbiIsICJ0aWNrV2lkdGgiLCAibWF4TGFiZWxEaWFnb25hbCIsICJfaXNWaXNpYmxlIiwgImxhYmVsU2l6ZXMiLCAiX2dldExhYmVsU2l6ZXMiLCAibWF4TGFiZWxXaWR0aCIsICJ3aWRlc3QiLCAibWF4TGFiZWxIZWlnaHQiLCAiaGlnaGVzdCIsICJfbGltaXRWYWx1ZSIsICJncmlkIiwgInRpdGxlIiwgInNxcnQiLCAidG9EZWdyZWVzIiwgImFzaW4iLCAibWluU2l6ZSIsICJ0aXRsZU9wdHMiLCAiZ3JpZE9wdHMiLCAidGl0bGVIZWlnaHQiLCAidGlja1BhZGRpbmciLCAiYW5nbGVSYWRpYW5zIiwgInRvUmFkaWFucyIsICJjb3MiLCAic2luIiwgImxhYmVsSGVpZ2h0IiwgIm1pcnJvciIsICJsYWJlbFdpZHRoIiwgIl9jYWxjdWxhdGVQYWRkaW5nIiwgIl9oYW5kbGVNYXJnaW5zIiwgImlzUm90YXRlZCIsICJsYWJlbHNCZWxvd1RpY2tzIiwgIm9mZnNldExlZnQiLCAib2Zmc2V0UmlnaHQiLCAiaXNGdWxsU2l6ZSIsICJmdWxsU2l6ZSIsICJfY29tcHV0ZUxhYmVsU2l6ZXMiLCAid2lkdGhzIiwgImhlaWdodHMiLCAid2lkZXN0TGFiZWxTaXplIiwgImhpZ2hlc3RMYWJlbFNpemUiLCAiaiIsICJqbGVuIiwgInRpY2tGb250IiwgImZvbnRTdHJpbmciLCAibmVzdGVkTGFiZWwiLCAiX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMiLCAic3RyaW5nIiwgIl9tZWFzdXJlVGV4dCIsICJpbmRleE9mIiwgInZhbHVlQXQiLCAiaWR4IiwgImdldExhYmVsRm9yVmFsdWUiLCAiTmFOIiwgImdldFZhbHVlRm9yUGl4ZWwiLCAicGl4ZWwiLCAiZ2V0UGl4ZWxGb3JEZWNpbWFsIiwgImRlY2ltYWwiLCAiX2ludDE2UmFuZ2UiLCAiX2FsaWduUGl4ZWwiLCAiZ2V0RGVjaW1hbEZvclBpeGVsIiwgImdldEJhc2VQaXhlbCIsICJnZXRCYXNlVmFsdWUiLCAib3B0aW9uVGlja3MiLCAicm90IiwgImFicyIsICJhdXRvU2tpcFBhZGRpbmciLCAidyIsICJoIiwgIl9jb21wdXRlR3JpZExpbmVJdGVtcyIsICJib3JkZXIiLCAidGwiLCAiYm9yZGVyT3B0cyIsICJheGlzV2lkdGgiLCAiYXhpc0hhbGZXaWR0aCIsICJhbGlnbkJvcmRlclZhbHVlIiwgImJvcmRlclZhbHVlIiwgImFsaWduZWRMaW5lVmFsdWUiLCAidHgxIiwgInR5MSIsICJ0eDIiLCAidHkyIiwgIngxIiwgInkxIiwgIngyIiwgInkyIiwgImxpbWl0IiwgInN0ZXAiLCAiY29udGV4dCIsICJvcHRzQXRJbmRleCIsICJvcHRzQXRJbmRleEJvcmRlciIsICJsaW5lV2lkdGgiLCAibGluZUNvbG9yIiwgImNvbG9yIiwgImJvcmRlckRhc2giLCAiZGFzaCIsICJib3JkZXJEYXNoT2Zmc2V0IiwgImRhc2hPZmZzZXQiLCAidGlja0NvbG9yIiwgInRpY2tCb3JkZXJEYXNoIiwgInRpY2tCb3JkZXJEYXNoT2Zmc2V0IiwgImNyb3NzQWxpZ24iLCAidGlja0FuZFBhZGRpbmciLCAiaFRpY2tBbmRQYWRkaW5nIiwgInRleHRBbGlnbiIsICJsaW5lQ291bnQiLCAidGV4dE9mZnNldCIsICJ0ZXh0QmFzZWxpbmUiLCAiX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQiLCAiX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQiLCAibGFiZWxPZmZzZXQiLCAiaGFsZkNvdW50IiwgInN0cm9rZUNvbG9yIiwgInRleHRTdHJva2VDb2xvciIsICJzdHJva2VXaWR0aCIsICJ0ZXh0U3Ryb2tlV2lkdGgiLCAidGlja1RleHRBbGlnbiIsICJzaG93TGFiZWxCYWNrZHJvcCIsICJiYWNrZHJvcCIsICJsYWJlbFBhZGRpbmciLCAiYmFja2Ryb3BQYWRkaW5nIiwgImJhY2tkcm9wQ29sb3IiLCAidHJhbnNsYXRpb24iLCAiX2NvbXB1dGVMYWJlbEFyZWEiLCAiZHJhd0JhY2tncm91bmQiLCAiYmFja2dyb3VuZENvbG9yIiwgInNhdmUiLCAiZmlsbFN0eWxlIiwgImZpbGxSZWN0IiwgInJlc3RvcmUiLCAiZ2V0TGluZVdpZHRoRm9yVmFsdWUiLCAiZmluZEluZGV4IiwgInQiLCAib3B0cyIsICJkcmF3R3JpZCIsICJkcmF3TGluZSIsICJwMSIsICJwMiIsICJzdHlsZSIsICJzdHJva2VTdHlsZSIsICJzZXRMaW5lRGFzaCIsICJsaW5lRGFzaE9mZnNldCIsICJiZWdpblBhdGgiLCAibW92ZVRvIiwgImxpbmVUbyIsICJzdHJva2UiLCAiaXRlbSIsICJkcmF3T25DaGFydEFyZWEiLCAiZHJhd0JvcmRlciIsICJsYXN0TGluZVdpZHRoIiwgImRyYXdMYWJlbHMiLCAiYXJlYSIsICJjbGlwQXJlYSIsICJyZW5kZXJUZXh0T3B0aW9ucyIsICJyZW5kZXJUZXh0IiwgInVuY2xpcEFyZWEiLCAiZHJhd1RpdGxlIiwgImRyYXciLCAiX2xheWVycyIsICJ0eiIsICJ6IiwgImd6IiwgImJ6IiwgInByb3RvdHlwZSIsICJnZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzIiwgImF4aXNJRCIsICJtZXRhIiwgIl9tYXhEaWdpdHMiLCAiZm9udFNpemUiLCAiZ2VuZXJhdGVUaWNrcyIsICJnZW5lcmF0aW9uT3B0aW9ucyIsICJkYXRhUmFuZ2UiLCAidGlja3MiLCAiTUlOX1NQQUNJTkciLCAiYm91bmRzIiwgInN0ZXAiLCAibWluIiwgIm1heCIsICJwcmVjaXNpb24iLCAiY291bnQiLCAibWF4VGlja3MiLCAibWF4RGlnaXRzIiwgImluY2x1ZGVCb3VuZHMiLCAidW5pdCIsICJtYXhTcGFjZXMiLCAicm1pbiIsICJybWF4IiwgIm1pbkRlZmluZWQiLCAiaXNOdWxsT3JVbmRlZiIsICJtYXhEZWZpbmVkIiwgImNvdW50RGVmaW5lZCIsICJtaW5TcGFjaW5nIiwgInNwYWNpbmciLCAibmljZU51bSIsICJmYWN0b3IiLCAibmljZU1pbiIsICJuaWNlTWF4IiwgIm51bVNwYWNlcyIsICJ2YWx1ZSIsICJNYXRoIiwgImNlaWwiLCAiZmxvb3IiLCAicG93IiwgImFsbW9zdFdob2xlIiwgInJvdW5kIiwgImFsbW9zdEVxdWFscyIsICJkZWNpbWFsUGxhY2VzIiwgIl9kZWNpbWFsUGxhY2VzIiwgImoiLCAicHVzaCIsICJyZWxhdGl2ZUxhYmVsU2l6ZSIsICJ0aWNrVmFsdWUiLCAibGVuZ3RoIiwgImhvcml6b250YWwiLCAibWluUm90YXRpb24iLCAicmFkIiwgInRvUmFkaWFucyIsICJyYXRpbyIsICJzaW4iLCAiY29zIiwgIkxpbmVhclNjYWxlQmFzZSIsICJTY2FsZSIsICJjb25zdHJ1Y3RvciIsICJjZmciLCAic3RhcnQiLCAidW5kZWZpbmVkIiwgImVuZCIsICJfc3RhcnRWYWx1ZSIsICJfZW5kVmFsdWUiLCAiX3ZhbHVlUmFuZ2UiLCAicGFyc2UiLCAicmF3IiwgImluZGV4IiwgIk51bWJlciIsICJpc0Zpbml0ZSIsICJoYW5kbGVUaWNrUmFuZ2VPcHRpb25zIiwgImJlZ2luQXRaZXJvIiwgIm9wdGlvbnMiLCAiZ2V0VXNlckJvdW5kcyIsICJzZXRNaW4iLCAidiIsICJzZXRNYXgiLCAibWluU2lnbiIsICJzaWduIiwgIm1heFNpZ24iLCAib2Zmc2V0IiwgImFicyIsICJnZXRUaWNrTGltaXQiLCAidGlja09wdHMiLCAibWF4VGlja3NMaW1pdCIsICJzdGVwU2l6ZSIsICJjb25zb2xlIiwgIndhcm4iLCAiaWQiLCAiY29tcHV0ZVRpY2tMaW1pdCIsICJQT1NJVElWRV9JTkZJTklUWSIsICJidWlsZFRpY2tzIiwgIm9wdHMiLCAibnVtZXJpY0dlbmVyYXRvck9wdGlvbnMiLCAiX21heERpZ2l0cyIsICJpc0hvcml6b250YWwiLCAiX3JhbmdlIiwgIl9zZXRNaW5BbmRNYXhCeUtleSIsICJyZXZlcnNlIiwgImNvbmZpZ3VyZSIsICJnZXRMYWJlbEZvclZhbHVlIiwgImZvcm1hdE51bWJlciIsICJjaGFydCIsICJsb2NhbGUiLCAiZm9ybWF0IiwgIkxpbmVhclNjYWxlIiwgImRldGVybWluZURhdGFMaW1pdHMiLCAiZ2V0TWluTWF4IiwgIndpZHRoIiwgImhlaWdodCIsICJ0aWNrRm9udCIsICJfcmVzb2x2ZVRpY2tGb250T3B0aW9ucyIsICJsaW5lSGVpZ2h0IiwgImdldFBpeGVsRm9yVmFsdWUiLCAiTmFOIiwgImdldFBpeGVsRm9yRGVjaW1hbCIsICJnZXRWYWx1ZUZvclBpeGVsIiwgInBpeGVsIiwgImdldERlY2ltYWxGb3JQaXhlbCIsICJkZWZhdWx0cyIsICJjYWxsYmFjayIsICJUaWNrcyIsICJmb3JtYXR0ZXJzIiwgIm51bWVyaWMiLCAibG9nMTBGbG9vciIsICJsb2cxMCIsICJjaGFuZ2VFeHBvbmVudCIsICJtIiwgImlzTWFqb3IiLCAidGlja1ZhbCIsICJyZW1haW4iLCAic3RlcHMiLCAicmFuZ2VFeHAiLCAicmFuZ2VTdGVwIiwgInN0YXJ0RXhwIiwgInJhbmdlIiwgImZpbml0ZU9yRGVmYXVsdCIsICJtaW5FeHAiLCAiZXhwIiwgImJhc2UiLCAic2lnbmlmaWNhbmQiLCAibWFqb3IiLCAibGFzdFRpY2siLCAiTG9nYXJpdGhtaWNTY2FsZSIsICJwcm90b3R5cGUiLCAiYXBwbHkiLCAiX3plcm8iLCAiX3N1Z2dlc3RlZE1pbiIsICJfdXNlck1pbiIsICJfdXNlck1heCIsICJpc05hTiIsICJkZWNpbWFsIiwgImxvZ2FyaXRobWljIiwgImVuYWJsZWQiLCAiZ2V0VGlja0JhY2tkcm9wSGVpZ2h0IiwgImRpc3BsYXkiLCAicGFkZGluZyIsICJ0b1BhZGRpbmciLCAiYmFja2Ryb3BQYWRkaW5nIiwgInZhbHVlT3JEZWZhdWx0IiwgImZvbnQiLCAic2l6ZSIsICJtZWFzdXJlTGFiZWxTaXplIiwgImN0eCIsICJsYWJlbCIsICJpc0FycmF5IiwgInciLCAiX2xvbmdlc3RUZXh0IiwgInN0cmluZyIsICJoIiwgImRldGVybWluZUxpbWl0cyIsICJhbmdsZSIsICJwb3MiLCAiZml0V2l0aFBvaW50TGFiZWxzIiwgInNjYWxlIiwgIm9yaWciLCAibCIsICJsZWZ0IiwgIl9wYWRkaW5nIiwgInIiLCAicmlnaHQiLCAidCIsICJ0b3AiLCAiYiIsICJib3R0b20iLCAibGltaXRzIiwgIk9iamVjdCIsICJhc3NpZ24iLCAibGFiZWxTaXplcyIsICJ2YWx1ZUNvdW50IiwgIl9wb2ludExhYmVscyIsICJwb2ludExhYmVsT3B0cyIsICJwb2ludExhYmVscyIsICJhZGRpdGlvbmFsQW5nbGUiLCAiY2VudGVyUG9pbnRMYWJlbHMiLCAiUEkiLCAiaSIsICJzZXRDb250ZXh0IiwgImdldFBvaW50TGFiZWxDb250ZXh0IiwgInBvaW50UG9zaXRpb24iLCAiZ2V0UG9pbnRQb3NpdGlvbiIsICJkcmF3aW5nQXJlYSIsICJwbEZvbnQiLCAidG9Gb250IiwgInRleHRTaXplIiwgImFuZ2xlUmFkaWFucyIsICJfbm9ybWFsaXplQW5nbGUiLCAiZ2V0SW5kZXhBbmdsZSIsICJ0b0RlZ3JlZXMiLCAiaExpbWl0cyIsICJ4IiwgInZMaW1pdHMiLCAieSIsICJ1cGRhdGVMaW1pdHMiLCAic2V0Q2VudGVyUG9pbnQiLCAiX3BvaW50TGFiZWxJdGVtcyIsICJidWlsZFBvaW50TGFiZWxJdGVtcyIsICJjcmVhdGVQb2ludExhYmVsSXRlbSIsICJpdGVtT3B0cyIsICJvdXRlckRpc3RhbmNlIiwgImV4dHJhIiwgInBvaW50TGFiZWxQb3NpdGlvbiIsICJIQUxGX1BJIiwgInlGb3JBbmdsZSIsICJ0ZXh0QWxpZ24iLCAiZ2V0VGV4dEFsaWduRm9yQW5nbGUiLCAibGVmdEZvclRleHRBbGlnbiIsICJ2aXNpYmxlIiwgImlzTm90T3ZlcmxhcHBlZCIsICJpdGVtIiwgImFyZWEiLCAiYXBleGVzSW5BcmVhIiwgIl9pc1BvaW50SW5BcmVhIiwgIml0ZW1zIiwgImFsaWduIiwgImRyYXdQb2ludExhYmVsQm94IiwgImJhY2tkcm9wQ29sb3IiLCAiYm9yZGVyUmFkaXVzIiwgInRvVFJCTENvcm5lcnMiLCAiZmlsbFN0eWxlIiwgImJhY2tkcm9wTGVmdCIsICJiYWNrZHJvcFRvcCIsICJiYWNrZHJvcFdpZHRoIiwgImJhY2tkcm9wSGVpZ2h0IiwgInZhbHVlcyIsICJzb21lIiwgImJlZ2luUGF0aCIsICJhZGRSb3VuZGVkUmVjdFBhdGgiLCAicmFkaXVzIiwgImZpbGwiLCAiZmlsbFJlY3QiLCAiZHJhd1BvaW50TGFiZWxzIiwgImxhYmVsQ291bnQiLCAib3B0c0F0SW5kZXgiLCAicmVuZGVyVGV4dCIsICJjb2xvciIsICJ0ZXh0QmFzZWxpbmUiLCAicGF0aFJhZGl1c0xpbmUiLCAiY2lyY3VsYXIiLCAiYXJjIiwgInhDZW50ZXIiLCAieUNlbnRlciIsICJUQVUiLCAibW92ZVRvIiwgImxpbmVUbyIsICJkcmF3UmFkaXVzTGluZSIsICJncmlkTGluZU9wdHMiLCAiYm9yZGVyT3B0cyIsICJsaW5lV2lkdGgiLCAic2F2ZSIsICJzdHJva2VTdHlsZSIsICJzZXRMaW5lRGFzaCIsICJkYXNoIiwgImxpbmVEYXNoT2Zmc2V0IiwgImRhc2hPZmZzZXQiLCAiY2xvc2VQYXRoIiwgInN0cm9rZSIsICJyZXN0b3JlIiwgImNyZWF0ZVBvaW50TGFiZWxDb250ZXh0IiwgInBhcmVudCIsICJjcmVhdGVDb250ZXh0IiwgInR5cGUiLCAiUmFkaWFsTGluZWFyU2NhbGUiLCAic2V0RGltZW5zaW9ucyIsICJtYXhXaWR0aCIsICJtYXhIZWlnaHQiLCAiZ2VuZXJhdGVUaWNrTGFiZWxzIiwgImNhbGwiLCAiZ2V0TGFiZWxzIiwgIm1hcCIsICJjYWxsQ2FsbGJhY2siLCAiZmlsdGVyIiwgImdldERhdGFWaXNpYmlsaXR5IiwgImZpdCIsICJsZWZ0TW92ZW1lbnQiLCAicmlnaHRNb3ZlbWVudCIsICJ0b3BNb3ZlbWVudCIsICJib3R0b21Nb3ZlbWVudCIsICJhbmdsZU11bHRpcGxpZXIiLCAic3RhcnRBbmdsZSIsICJnZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSIsICJzY2FsaW5nRmFjdG9yIiwgImdldFZhbHVlRm9yRGlzdGFuY2VGcm9tQ2VudGVyIiwgImRpc3RhbmNlIiwgInNjYWxlZERpc3RhbmNlIiwgInBvaW50TGFiZWwiLCAiZ2V0Q29udGV4dCIsICJkaXN0YW5jZUZyb21DZW50ZXIiLCAiZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlIiwgImdldEJhc2VQb3NpdGlvbiIsICJnZXRCYXNlVmFsdWUiLCAiZ2V0UG9pbnRMYWJlbFBvc2l0aW9uIiwgImRyYXdCYWNrZ3JvdW5kIiwgImJhY2tncm91bmRDb2xvciIsICJncmlkIiwgImRyYXdHcmlkIiwgImFuZ2xlTGluZXMiLCAiYm9yZGVyIiwgInBvc2l0aW9uIiwgImZvckVhY2giLCAidGljayIsICJjb250ZXh0IiwgIm9wdHNBdEluZGV4Qm9yZGVyIiwgImJvcmRlckRhc2giLCAiYm9yZGVyRGFzaE9mZnNldCIsICJkcmF3Qm9yZGVyIiwgImRyYXdMYWJlbHMiLCAidHJhbnNsYXRlIiwgInJvdGF0ZSIsICJzaG93TGFiZWxCYWNrZHJvcCIsICJtZWFzdXJlVGV4dCIsICJzdHJva2VDb2xvciIsICJ0ZXh0U3Ryb2tlQ29sb3IiLCAic3Ryb2tlV2lkdGgiLCAidGV4dFN0cm9rZVdpZHRoIiwgImRyYXdUaXRsZSIsICJhbmltYXRlIiwgImRlZmF1bHRSb3V0ZXMiLCAiZGVzY3JpcHRvcnMiLCAiX2ZhbGxiYWNrIiwgIklOVEVSVkFMUyIsICJtaWxsaXNlY29uZCIsICJjb21tb24iLCAic2Vjb25kIiwgIm1pbnV0ZSIsICJob3VyIiwgImRheSIsICJ3ZWVrIiwgIm1vbnRoIiwgInF1YXJ0ZXIiLCAieWVhciIsICJVTklUUyIsICJrZXlzIiwgInNvcnRlciIsICJhIiwgImlucHV0IiwgImFkYXB0ZXIiLCAiX2FkYXB0ZXIiLCAicGFyc2VyIiwgImlzb1dlZWtkYXkiLCAiX3BhcnNlT3B0cyIsICJpc051bWJlciIsICJzdGFydE9mIiwgImRldGVybWluZVVuaXRGb3JBdXRvVGlja3MiLCAibWluVW5pdCIsICJjYXBhY2l0eSIsICJpbGVuIiwgImluZGV4T2YiLCAiaW50ZXJ2YWwiLCAiTUFYX1NBRkVfSU5URUdFUiIsICJkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyIsICJudW1UaWNrcyIsICJkaWZmIiwgImRldGVybWluZU1ham9yVW5pdCIsICJhZGRUaWNrIiwgInRpbWUiLCAidGltZXN0YW1wcyIsICJsbyIsICJoaSIsICJfbG9va3VwIiwgInRpbWVzdGFtcCIsICJzZXRNYWpvclRpY2tzIiwgIm1ham9yVW5pdCIsICJmaXJzdCIsICJsYXN0IiwgImFkZCIsICJ0aWNrc0Zyb21UaW1lc3RhbXBzIiwgIlRpbWVTY2FsZSIsICJwcm9wcyIsICJfY2FjaGUiLCAiZGF0YSIsICJsYWJlbHMiLCAiYWxsIiwgIl91bml0IiwgIl9tYWpvclVuaXQiLCAiX29mZnNldHMiLCAiX25vcm1hbGl6ZWQiLCAiaW5pdCIsICJzY2FsZU9wdHMiLCAiYWRhcHRlcnMiLCAiX2RhdGUiLCAiZGF0ZSIsICJtZXJnZUlmIiwgImRpc3BsYXlGb3JtYXRzIiwgImZvcm1hdHMiLCAibm9ybWFsaXplZCIsICJiZWZvcmVMYXlvdXQiLCAiX2FwcGx5Qm91bmRzIiwgIl9nZXRMYWJlbEJvdW5kcyIsICJzb3VyY2UiLCAiRGF0ZSIsICJub3ciLCAiZW5kT2YiLCAiYXJyIiwgImdldExhYmVsVGltZXN0YW1wcyIsICJORUdBVElWRV9JTkZJTklUWSIsICJ0aW1lT3B0cyIsICJfZ2VuZXJhdGUiLCAiX2ZpbHRlckJldHdlZW4iLCAiYXV0b1NraXAiLCAiX2dldExhYmVsQ2FwYWNpdHkiLCAiaW5pdE9mZnNldHMiLCAiYWZ0ZXJBdXRvU2tpcCIsICJvZmZzZXRBZnRlckF1dG9za2lwIiwgImdldERlY2ltYWxGb3JWYWx1ZSIsICJsaW1pdCIsICJfbGltaXRWYWx1ZSIsICJtaW5vciIsICJ3ZWVrZGF5IiwgImhhc1dlZWtkYXkiLCAiRXJyb3IiLCAiZ2V0RGF0YVRpbWVzdGFtcHMiLCAic29ydCIsICJ0b29sdGlwRm9ybWF0IiwgImRhdGV0aW1lIiwgImZtdCIsICJfdGlja0Zvcm1hdEZ1bmN0aW9uIiwgImZvcm1hdHRlciIsICJtaW5vckZvcm1hdCIsICJtYWpvckZvcm1hdCIsICJvZmZzZXRzIiwgIl9nZXRMYWJlbFNpemUiLCAidGlja3NPcHRzIiwgInRpY2tMYWJlbFdpZHRoIiwgIm1heFJvdGF0aW9uIiwgImNvc1JvdGF0aW9uIiwgInNpblJvdGF0aW9uIiwgInRpY2tGb250U2l6ZSIsICJleGFtcGxlVGltZSIsICJleGFtcGxlTGFiZWwiLCAibWV0YXMiLCAiZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMiLCAiY29udHJvbGxlciIsICJnZXRBbGxQYXJzZWRWYWx1ZXMiLCAiY29uY2F0IiwgIm5vcm1hbGl6ZSIsICJfYXJyYXlVbmlxdWUiLCAiaW50ZXJwb2xhdGUiLCAidGFibGUiLCAidmFsIiwgInByZXZTb3VyY2UiLCAibmV4dFNvdXJjZSIsICJwcmV2VGFyZ2V0IiwgIm5leHRUYXJnZXQiLCAiX2xvb2t1cEJ5S2V5IiwgInNwYW4iLCAiVGltZVNlcmllc1NjYWxlIiwgIl90YWJsZSIsICJfbWluUG9zIiwgIl90YWJsZVJhbmdlIiwgIl9nZXRUaW1lc3RhbXBzRm9yVGFibGUiLCAiYnVpbGRMb29rdXBUYWJsZSIsICJwcmV2IiwgImN1cnIiLCAibmV4dCIsICJpbmNsdWRlcyIsICJzcGxpY2UiLCAicyIsICJzaW5nbGV0b24iLCAib2Zmc2V0IiwgInMiLCAiZGVmYXVsdFpvbmUiLCAib2Zmc2V0IiwgImlzTnVtYmVyIiwgIm4iLCAiaXNOdW1iZXIiLCAibiIsICJvZmZzZXQiLCAic2lnbiIsICJzIiwgIm4iLCAiZm9ybWF0T2Zmc2V0IiwgInBhcnNlIiwgInMiLCAibWF0Y2giLCAib2Zmc2V0IiwgImNsb25lIiwgImlzTnVtYmVyIiwgImwiLCAibiIsICJzIiwgImVxIiwgIklOVkFMSUQiLCAicyIsICJlIiwgInMiLCAiSU5WQUxJRCIsICJjbG9uZSIsICJvZmZzZXQiLCAib3JkZXJlZFVuaXRzIiwgInJvdW5kIiwgImlzTnVtYmVyIiwgImFkYXB0ZXJzIiwgImNoYXJ0Il0KfQo=
